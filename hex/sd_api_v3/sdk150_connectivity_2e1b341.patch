diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/serialization/common/ser_config.h nRF5_SDK_15.0.0_a53641a/components/serialization/common/ser_config.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/serialization/common/ser_config.h   2018-04-16 15:37:15.966258400 +0200
+++ nRF5_SDK_15.0.0_a53641a/components/serialization/common/ser_config.h    2018-04-24 08:48:28.675148200 +0200
@@ -99,7 +99,7 @@
 
 /** UART transmission parameters */
 #define SER_PHY_UART_FLOW_CTRL          NRF_UART_HWFC_ENABLED
-#define SER_PHY_UART_PARITY             NRF_UART_PARITY_INCLUDED
+#define SER_PHY_UART_PARITY             NRF_UART_PARITY_EXCLUDED
 #define SER_PHY_UART_BAUDRATE_VAL       1000000
 
 #define SER_PHY_UART_BAUDRATE CONCAT_2(NRF_UART_BAUDRATE_,SER_PHY_UART_BAUDRATE_VAL)
@@ -110,6 +110,8 @@
 
 #define SER_MAX_CONNECTIONS 8
 
+#define HCI_LINK_CONTROL
+
 #ifndef SER_MAX_ADV_DATA
 #define SER_MAX_ADV_DATA 256
 #endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/serialization/common/transport/ser_phy/config/ser_phy_config_conn.h nRF5_SDK_15.0.0_a53641a/components/serialization/common/transport/ser_phy/config/ser_phy_config_conn.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/serialization/common/transport/ser_phy/config/ser_phy_config_conn.h 2018-04-16 15:37:16.689330700 +0200
+++ nRF5_SDK_15.0.0_a53641a/components/serialization/common/transport/ser_phy/config/ser_phy_config_conn.h  2018-04-24 08:48:28.685148400 +0200
@@ -69,10 +69,10 @@
 /* UART configuration */
 #define UART_IRQ_PRIORITY                       APP_IRQ_PRIORITY_LOWEST
 
-#define SER_PHY_UART_RX                         SER_CON_RX_PIN
-#define SER_PHY_UART_TX                         SER_CON_TX_PIN
-#define SER_PHY_UART_CTS                        SER_CON_CTS_PIN
-#define SER_PHY_UART_RTS                        SER_CON_RTS_PIN
+#define SER_PHY_UART_RX                         RX_PIN_NUMBER
+#define SER_PHY_UART_TX                         TX_PIN_NUMBER
+#define SER_PHY_UART_CTS                        CTS_PIN_NUMBER
+#define SER_PHY_UART_RTS                        RTS_PIN_NUMBER
 
 
 #ifdef __cplusplus
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/serialization/common/transport/ser_phy/ser_phy_hci.c nRF5_SDK_15.0.0_a53641a/components/serialization/common/transport/ser_phy/ser_phy_hci.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/serialization/common/transport/ser_phy/ser_phy_hci.c    2018-04-16 15:37:16.454307200 +0200
+++ nRF5_SDK_15.0.0_a53641a/components/serialization/common/transport/ser_phy/ser_phy_hci.c 2018-04-24 08:48:28.685148400 +0200
@@ -67,6 +67,8 @@
                                  (SER_HAL_TRANSPORT_MAX_PKT_SIZE + PKT_HDR_SIZE + PKT_CRC_SIZE))
 #define BAUD_TIME_us            (1000000uL / SER_PHY_UART_BAUDRATE_VAL)
 
+#define PKT_TYPE_RESET 5
+
 #define TX_EVT_QUEUE_SIZE            16
 #define RX_EVT_QUEUE_SIZE            16
 #define PKT_TYPE_VENDOR_SPECIFIC     14                                                /**< Packet type vendor specific. */
@@ -798,7 +800,7 @@
 
         if (packet_type == PKT_TYPE_RESET)
         {
-            NVIC_SystemReset();
+            // NVIC_SystemReset();
         }
         else if (packet_type == PKT_TYPE_ACK )
         {
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/serialization/common/transport/ser_phy/ser_phy_hci_slip_cdc.c nRF5_SDK_15.0.0_a53641a/components/serialization/common/transport/ser_phy/ser_phy_hci_slip_cdc.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/serialization/common/transport/ser_phy/ser_phy_hci_slip_cdc.c   2018-04-16 15:37:16.512313000 +0200
+++ nRF5_SDK_15.0.0_a53641a/components/serialization/common/transport/ser_phy/ser_phy_hci_slip_cdc.c    2018-04-24 08:48:28.695148600 +0200
@@ -67,10 +67,10 @@
 static void cdc_acm_user_ev_handler(app_usbd_class_inst_t const * p_inst,
                                     app_usbd_cdc_acm_user_event_t event);
 
-#define CDC_ACM_COMM_INTERFACE  0
+#define CDC_ACM_COMM_INTERFACE  1
 #define CDC_ACM_COMM_EPIN       NRF_DRV_USBD_EPIN2
 
-#define CDC_ACM_DATA_INTERFACE  1
+#define CDC_ACM_DATA_INTERFACE  2
 #define CDC_ACM_DATA_EPIN       NRF_DRV_USBD_EPIN1
 #define CDC_ACM_DATA_EPOUT      NRF_DRV_USBD_EPOUT1
 
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble.c 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble.c  2018-04-24 08:48:28.715149000 +0200
@@ -0,0 +1,1621 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_ble.h"
+
+typedef struct _CMOCK_sd_ble_enable_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_enable_params_t* Expected_p_ble_enable_params;
+  uint32_t* Expected_p_app_ram_base;
+  int Expected_p_ble_enable_params_Depth;
+  int Expected_p_app_ram_base_Depth;
+  int ReturnThruPtr_p_ble_enable_params_Used;
+  ble_enable_params_t* ReturnThruPtr_p_ble_enable_params_Val;
+  int ReturnThruPtr_p_ble_enable_params_Size;
+  int ReturnThruPtr_p_app_ram_base_Used;
+  uint32_t* ReturnThruPtr_p_app_ram_base_Val;
+  int ReturnThruPtr_p_app_ram_base_Size;
+  int IgnoreArg_p_ble_enable_params;
+  int IgnoreArg_p_app_ram_base;
+
+} CMOCK_sd_ble_enable_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_evt_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t* Expected_p_dest;
+  uint16_t* Expected_p_len;
+  int Expected_p_dest_Depth;
+  int Expected_p_len_Depth;
+  int ReturnThruPtr_p_dest_Used;
+  uint8_t* ReturnThruPtr_p_dest_Val;
+  int ReturnThruPtr_p_dest_Size;
+  int ReturnThruPtr_p_len_Used;
+  uint16_t* ReturnThruPtr_p_len_Val;
+  int ReturnThruPtr_p_len_Size;
+  int IgnoreArg_p_dest;
+  int IgnoreArg_p_len;
+
+} CMOCK_sd_ble_evt_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint8_t* Expected_p_count;
+  int Expected_p_count_Depth;
+  int ReturnThruPtr_p_count_Used;
+  uint8_t* ReturnThruPtr_p_count_Val;
+  int ReturnThruPtr_p_count_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_count;
+
+} CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_uuid128_t const* Expected_p_vs_uuid;
+  uint8_t* Expected_p_uuid_type;
+  int Expected_p_vs_uuid_Depth;
+  int Expected_p_uuid_type_Depth;
+  int ReturnThruPtr_p_vs_uuid_Used;
+  ble_uuid128_t const* ReturnThruPtr_p_vs_uuid_Val;
+  int ReturnThruPtr_p_vs_uuid_Size;
+  int ReturnThruPtr_p_uuid_type_Used;
+  uint8_t* ReturnThruPtr_p_uuid_type_Val;
+  int ReturnThruPtr_p_uuid_type_Size;
+  int IgnoreArg_p_vs_uuid;
+  int IgnoreArg_p_uuid_type;
+
+} CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_uuid_decode_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t Expected_uuid_le_len;
+  uint8_t const* Expected_p_uuid_le;
+  ble_uuid_t* Expected_p_uuid;
+  int Expected_p_uuid_le_Depth;
+  int Expected_p_uuid_Depth;
+  int ReturnThruPtr_p_uuid_le_Used;
+  uint8_t const* ReturnThruPtr_p_uuid_le_Val;
+  int ReturnThruPtr_p_uuid_le_Size;
+  int ReturnThruPtr_p_uuid_Used;
+  ble_uuid_t* ReturnThruPtr_p_uuid_Val;
+  int ReturnThruPtr_p_uuid_Size;
+  int IgnoreArg_uuid_le_len;
+  int IgnoreArg_p_uuid_le;
+  int IgnoreArg_p_uuid;
+
+} CMOCK_sd_ble_uuid_decode_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_uuid_encode_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_uuid_t const* Expected_p_uuid;
+  uint8_t* Expected_p_uuid_le_len;
+  uint8_t* Expected_p_uuid_le;
+  int Expected_p_uuid_Depth;
+  int Expected_p_uuid_le_len_Depth;
+  int Expected_p_uuid_le_Depth;
+  int ReturnThruPtr_p_uuid_Used;
+  ble_uuid_t const* ReturnThruPtr_p_uuid_Val;
+  int ReturnThruPtr_p_uuid_Size;
+  int ReturnThruPtr_p_uuid_le_len_Used;
+  uint8_t* ReturnThruPtr_p_uuid_le_len_Val;
+  int ReturnThruPtr_p_uuid_le_len_Size;
+  int ReturnThruPtr_p_uuid_le_Used;
+  uint8_t* ReturnThruPtr_p_uuid_le_Val;
+  int ReturnThruPtr_p_uuid_le_Size;
+  int IgnoreArg_p_uuid;
+  int IgnoreArg_p_uuid_le_len;
+  int IgnoreArg_p_uuid_le;
+
+} CMOCK_sd_ble_uuid_encode_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_version_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_version_t* Expected_p_version;
+  int Expected_p_version_Depth;
+  int ReturnThruPtr_p_version_Used;
+  ble_version_t* ReturnThruPtr_p_version_Val;
+  int ReturnThruPtr_p_version_Size;
+  int IgnoreArg_p_version;
+
+} CMOCK_sd_ble_version_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_user_mem_block_t const* Expected_p_block;
+  int Expected_p_block_Depth;
+  int ReturnThruPtr_p_block_Used;
+  ble_user_mem_block_t const* ReturnThruPtr_p_block_Val;
+  int ReturnThruPtr_p_block_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_block;
+
+} CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_opt_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t Expected_opt_id;
+  ble_opt_t const* Expected_p_opt;
+  int Expected_p_opt_Depth;
+  int ReturnThruPtr_p_opt_Used;
+  ble_opt_t const* ReturnThruPtr_p_opt_Val;
+  int ReturnThruPtr_p_opt_Size;
+  int IgnoreArg_opt_id;
+  int IgnoreArg_p_opt;
+
+} CMOCK_sd_ble_opt_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_opt_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t Expected_opt_id;
+  ble_opt_t* Expected_p_opt;
+  int Expected_p_opt_Depth;
+  int ReturnThruPtr_p_opt_Used;
+  ble_opt_t* ReturnThruPtr_p_opt_Val;
+  int ReturnThruPtr_p_opt_Size;
+  int IgnoreArg_opt_id;
+  int IgnoreArg_p_opt;
+
+} CMOCK_sd_ble_opt_get_CALL_INSTANCE;
+
+static struct mock_bleInstance
+{
+  int sd_ble_enable_IgnoreBool;
+  uint32_t sd_ble_enable_FinalReturn;
+  CMOCK_sd_ble_enable_CALLBACK sd_ble_enable_CallbackFunctionPointer;
+  int sd_ble_enable_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_enable_CallInstance;
+  int sd_ble_evt_get_IgnoreBool;
+  uint32_t sd_ble_evt_get_FinalReturn;
+  CMOCK_sd_ble_evt_get_CALLBACK sd_ble_evt_get_CallbackFunctionPointer;
+  int sd_ble_evt_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_evt_get_CallInstance;
+  int sd_ble_tx_packet_count_get_IgnoreBool;
+  uint32_t sd_ble_tx_packet_count_get_FinalReturn;
+  CMOCK_sd_ble_tx_packet_count_get_CALLBACK sd_ble_tx_packet_count_get_CallbackFunctionPointer;
+  int sd_ble_tx_packet_count_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_tx_packet_count_get_CallInstance;
+  int sd_ble_uuid_vs_add_IgnoreBool;
+  uint32_t sd_ble_uuid_vs_add_FinalReturn;
+  CMOCK_sd_ble_uuid_vs_add_CALLBACK sd_ble_uuid_vs_add_CallbackFunctionPointer;
+  int sd_ble_uuid_vs_add_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_uuid_vs_add_CallInstance;
+  int sd_ble_uuid_decode_IgnoreBool;
+  uint32_t sd_ble_uuid_decode_FinalReturn;
+  CMOCK_sd_ble_uuid_decode_CALLBACK sd_ble_uuid_decode_CallbackFunctionPointer;
+  int sd_ble_uuid_decode_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_uuid_decode_CallInstance;
+  int sd_ble_uuid_encode_IgnoreBool;
+  uint32_t sd_ble_uuid_encode_FinalReturn;
+  CMOCK_sd_ble_uuid_encode_CALLBACK sd_ble_uuid_encode_CallbackFunctionPointer;
+  int sd_ble_uuid_encode_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_uuid_encode_CallInstance;
+  int sd_ble_version_get_IgnoreBool;
+  uint32_t sd_ble_version_get_FinalReturn;
+  CMOCK_sd_ble_version_get_CALLBACK sd_ble_version_get_CallbackFunctionPointer;
+  int sd_ble_version_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_version_get_CallInstance;
+  int sd_ble_user_mem_reply_IgnoreBool;
+  uint32_t sd_ble_user_mem_reply_FinalReturn;
+  CMOCK_sd_ble_user_mem_reply_CALLBACK sd_ble_user_mem_reply_CallbackFunctionPointer;
+  int sd_ble_user_mem_reply_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_user_mem_reply_CallInstance;
+  int sd_ble_opt_set_IgnoreBool;
+  uint32_t sd_ble_opt_set_FinalReturn;
+  CMOCK_sd_ble_opt_set_CALLBACK sd_ble_opt_set_CallbackFunctionPointer;
+  int sd_ble_opt_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_opt_set_CallInstance;
+  int sd_ble_opt_get_IgnoreBool;
+  uint32_t sd_ble_opt_get_FinalReturn;
+  CMOCK_sd_ble_opt_get_CALLBACK sd_ble_opt_get_CallbackFunctionPointer;
+  int sd_ble_opt_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_opt_get_CallInstance;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_ble_Verify(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_enable_CallInstance, cmock_line, "Function 'sd_ble_enable' called less times than expected.");
+  if (Mock.sd_ble_enable_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_enable_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_evt_get_CallInstance, cmock_line, "Function 'sd_ble_evt_get' called less times than expected.");
+  if (Mock.sd_ble_evt_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_evt_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_tx_packet_count_get_CallInstance, cmock_line, "Function 'sd_ble_tx_packet_count_get' called less times than expected.");
+  if (Mock.sd_ble_tx_packet_count_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_tx_packet_count_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_uuid_vs_add_CallInstance, cmock_line, "Function 'sd_ble_uuid_vs_add' called less times than expected.");
+  if (Mock.sd_ble_uuid_vs_add_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_uuid_vs_add_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_uuid_decode_CallInstance, cmock_line, "Function 'sd_ble_uuid_decode' called less times than expected.");
+  if (Mock.sd_ble_uuid_decode_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_uuid_decode_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_uuid_encode_CallInstance, cmock_line, "Function 'sd_ble_uuid_encode' called less times than expected.");
+  if (Mock.sd_ble_uuid_encode_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_uuid_encode_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_version_get_CallInstance, cmock_line, "Function 'sd_ble_version_get' called less times than expected.");
+  if (Mock.sd_ble_version_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_version_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_user_mem_reply_CallInstance, cmock_line, "Function 'sd_ble_user_mem_reply' called less times than expected.");
+  if (Mock.sd_ble_user_mem_reply_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_user_mem_reply_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_opt_set_CallInstance, cmock_line, "Function 'sd_ble_opt_set' called less times than expected.");
+  if (Mock.sd_ble_opt_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_opt_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_opt_get_CallInstance, cmock_line, "Function 'sd_ble_opt_get' called less times than expected.");
+  if (Mock.sd_ble_opt_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_opt_get_CallInstance = CMOCK_GUTS_NONE;
+}
+
+void mock_ble_Init(void)
+{
+  mock_ble_Destroy();
+}
+
+void mock_ble_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  Mock.sd_ble_enable_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_enable_CallbackCalls = 0;
+  Mock.sd_ble_evt_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_evt_get_CallbackCalls = 0;
+  Mock.sd_ble_tx_packet_count_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_tx_packet_count_get_CallbackCalls = 0;
+  Mock.sd_ble_uuid_vs_add_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_uuid_vs_add_CallbackCalls = 0;
+  Mock.sd_ble_uuid_decode_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_uuid_decode_CallbackCalls = 0;
+  Mock.sd_ble_uuid_encode_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_uuid_encode_CallbackCalls = 0;
+  Mock.sd_ble_version_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_version_get_CallbackCalls = 0;
+  Mock.sd_ble_user_mem_reply_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_user_mem_reply_CallbackCalls = 0;
+  Mock.sd_ble_opt_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_opt_set_CallbackCalls = 0;
+  Mock.sd_ble_opt_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_opt_get_CallbackCalls = 0;
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+uint32_t sd_ble_enable(ble_enable_params_t* p_ble_enable_params, uint32_t* p_app_ram_base)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_enable_CallInstance);
+  Mock.sd_ble_enable_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_enable_CallInstance);
+  if (Mock.sd_ble_enable_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_enable_FinalReturn;
+    Mock.sd_ble_enable_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_enable_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_enable_CallbackFunctionPointer(p_ble_enable_params, p_app_ram_base, Mock.sd_ble_enable_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_enable' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_enable' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_enable' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_ble_enable_params)
+  {
+    if (cmock_call_instance->Expected_p_ble_enable_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_ble_enable_params, cmock_line, "Expected NULL. Function 'sd_ble_enable' called with unexpected value for argument 'p_ble_enable_params'."); }
+    else if (cmock_call_instance->Expected_p_ble_enable_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_ble_enable_params, p_ble_enable_params, cmock_line, "Function 'sd_ble_enable' called with unexpected value for argument 'p_ble_enable_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_ble_enable_params), (void*)(p_ble_enable_params), sizeof(ble_enable_params_t), cmock_call_instance->Expected_p_ble_enable_params_Depth, cmock_line, "Function 'sd_ble_enable' called with unexpected value for argument 'p_ble_enable_params'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_app_ram_base)
+  {
+    if (cmock_call_instance->Expected_p_app_ram_base == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_app_ram_base, cmock_line, "Expected NULL. Function 'sd_ble_enable' called with unexpected value for argument 'p_app_ram_base'."); }
+    else if (cmock_call_instance->Expected_p_app_ram_base_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_app_ram_base, p_app_ram_base, cmock_line, "Function 'sd_ble_enable' called with unexpected value for argument 'p_app_ram_base'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_p_app_ram_base, p_app_ram_base, cmock_call_instance->Expected_p_app_ram_base_Depth, cmock_line, "Function 'sd_ble_enable' called with unexpected value for argument 'p_app_ram_base'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_ble_enable_params_Used)
+  {
+    memcpy((void*)p_ble_enable_params, (void*)cmock_call_instance->ReturnThruPtr_p_ble_enable_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_ble_enable_params_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_app_ram_base_Used)
+  {
+    memcpy((void*)p_app_ram_base, (void*)cmock_call_instance->ReturnThruPtr_p_app_ram_base_Val,
+      cmock_call_instance->ReturnThruPtr_p_app_ram_base_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_enable(CMOCK_sd_ble_enable_CALL_INSTANCE* cmock_call_instance, ble_enable_params_t* p_ble_enable_params, int p_ble_enable_params_Depth, uint32_t* p_app_ram_base, int p_app_ram_base_Depth)
+{
+  cmock_call_instance->Expected_p_ble_enable_params = p_ble_enable_params;
+  cmock_call_instance->Expected_p_ble_enable_params_Depth = p_ble_enable_params_Depth;
+  cmock_call_instance->IgnoreArg_p_ble_enable_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_ble_enable_params_Used = 0;
+  cmock_call_instance->Expected_p_app_ram_base = p_app_ram_base;
+  cmock_call_instance->Expected_p_app_ram_base_Depth = p_app_ram_base_Depth;
+  cmock_call_instance->IgnoreArg_p_app_ram_base = 0;
+  cmock_call_instance->ReturnThruPtr_p_app_ram_base_Used = 0;
+}
+
+void sd_ble_enable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_enable_CALL_INSTANCE));
+  CMOCK_sd_ble_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_enable_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_enable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_enable_IgnoreBool = (int)1;
+}
+
+void sd_ble_enable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_enable_params_t* p_ble_enable_params, uint32_t* p_app_ram_base, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_enable_CALL_INSTANCE));
+  CMOCK_sd_ble_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_enable_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_enable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_enable(cmock_call_instance, p_ble_enable_params, 0, p_app_ram_base, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_enable_StubWithCallback(CMOCK_sd_ble_enable_CALLBACK Callback)
+{
+  Mock.sd_ble_enable_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_enable_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_enable_params_t* p_ble_enable_params, int p_ble_enable_params_Depth, uint32_t* p_app_ram_base, int p_app_ram_base_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_enable_CALL_INSTANCE));
+  CMOCK_sd_ble_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_enable_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_enable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_enable(cmock_call_instance, p_ble_enable_params, p_ble_enable_params_Depth, p_app_ram_base, p_app_ram_base_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_enable_CMockReturnMemThruPtr_p_ble_enable_params(UNITY_LINE_TYPE cmock_line, ble_enable_params_t* p_ble_enable_params, int cmock_size)
+{
+  CMOCK_sd_ble_enable_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_enable_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_ble_enable_params ReturnThruPtr called before Expect on 'sd_ble_enable'.");
+  cmock_call_instance->ReturnThruPtr_p_ble_enable_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_ble_enable_params_Val = p_ble_enable_params;
+  cmock_call_instance->ReturnThruPtr_p_ble_enable_params_Size = cmock_size;
+}
+
+void sd_ble_enable_CMockReturnMemThruPtr_p_app_ram_base(UNITY_LINE_TYPE cmock_line, uint32_t* p_app_ram_base, int cmock_size)
+{
+  CMOCK_sd_ble_enable_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_enable_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_app_ram_base ReturnThruPtr called before Expect on 'sd_ble_enable'.");
+  cmock_call_instance->ReturnThruPtr_p_app_ram_base_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_app_ram_base_Val = p_app_ram_base;
+  cmock_call_instance->ReturnThruPtr_p_app_ram_base_Size = cmock_size;
+}
+
+void sd_ble_enable_CMockIgnoreArg_p_ble_enable_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_enable_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_enable_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_ble_enable_params IgnoreArg called before Expect on 'sd_ble_enable'.");
+  cmock_call_instance->IgnoreArg_p_ble_enable_params = 1;
+}
+
+void sd_ble_enable_CMockIgnoreArg_p_app_ram_base(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_enable_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_enable_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_app_ram_base IgnoreArg called before Expect on 'sd_ble_enable'.");
+  cmock_call_instance->IgnoreArg_p_app_ram_base = 1;
+}
+
+uint32_t sd_ble_evt_get(uint8_t* p_dest, uint16_t* p_len)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_evt_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_evt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_evt_get_CallInstance);
+  Mock.sd_ble_evt_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_evt_get_CallInstance);
+  if (Mock.sd_ble_evt_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_evt_get_FinalReturn;
+    Mock.sd_ble_evt_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_evt_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_evt_get_CallbackFunctionPointer(p_dest, p_len, Mock.sd_ble_evt_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_evt_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_evt_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_evt_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_dest)
+  {
+    if (cmock_call_instance->Expected_p_dest == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_dest, cmock_line, "Expected NULL. Function 'sd_ble_evt_get' called with unexpected value for argument 'p_dest'."); }
+    else if (cmock_call_instance->Expected_p_dest_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_dest, p_dest, cmock_line, "Function 'sd_ble_evt_get' called with unexpected value for argument 'p_dest'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_dest, p_dest, cmock_call_instance->Expected_p_dest_Depth, cmock_line, "Function 'sd_ble_evt_get' called with unexpected value for argument 'p_dest'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_len)
+  {
+    if (cmock_call_instance->Expected_p_len == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_len, cmock_line, "Expected NULL. Function 'sd_ble_evt_get' called with unexpected value for argument 'p_len'."); }
+    else if (cmock_call_instance->Expected_p_len_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_len, p_len, cmock_line, "Function 'sd_ble_evt_get' called with unexpected value for argument 'p_len'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_p_len, p_len, cmock_call_instance->Expected_p_len_Depth, cmock_line, "Function 'sd_ble_evt_get' called with unexpected value for argument 'p_len'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_dest_Used)
+  {
+    memcpy((void*)p_dest, (void*)cmock_call_instance->ReturnThruPtr_p_dest_Val,
+      cmock_call_instance->ReturnThruPtr_p_dest_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_len_Used)
+  {
+    memcpy((void*)p_len, (void*)cmock_call_instance->ReturnThruPtr_p_len_Val,
+      cmock_call_instance->ReturnThruPtr_p_len_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_evt_get(CMOCK_sd_ble_evt_get_CALL_INSTANCE* cmock_call_instance, uint8_t* p_dest, int p_dest_Depth, uint16_t* p_len, int p_len_Depth)
+{
+  cmock_call_instance->Expected_p_dest = p_dest;
+  cmock_call_instance->Expected_p_dest_Depth = p_dest_Depth;
+  cmock_call_instance->IgnoreArg_p_dest = 0;
+  cmock_call_instance->ReturnThruPtr_p_dest_Used = 0;
+  cmock_call_instance->Expected_p_len = p_len;
+  cmock_call_instance->Expected_p_len_Depth = p_len_Depth;
+  cmock_call_instance->IgnoreArg_p_len = 0;
+  cmock_call_instance->ReturnThruPtr_p_len_Used = 0;
+}
+
+void sd_ble_evt_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_evt_get_CALL_INSTANCE));
+  CMOCK_sd_ble_evt_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_evt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_evt_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_evt_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_evt_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_evt_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_dest, uint16_t* p_len, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_evt_get_CALL_INSTANCE));
+  CMOCK_sd_ble_evt_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_evt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_evt_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_evt_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_evt_get(cmock_call_instance, p_dest, 0, p_len, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_evt_get_StubWithCallback(CMOCK_sd_ble_evt_get_CALLBACK Callback)
+{
+  Mock.sd_ble_evt_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_evt_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_dest, int p_dest_Depth, uint16_t* p_len, int p_len_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_evt_get_CALL_INSTANCE));
+  CMOCK_sd_ble_evt_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_evt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_evt_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_evt_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_evt_get(cmock_call_instance, p_dest, p_dest_Depth, p_len, p_len_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_evt_get_CMockReturnMemThruPtr_p_dest(UNITY_LINE_TYPE cmock_line, uint8_t* p_dest, int cmock_size)
+{
+  CMOCK_sd_ble_evt_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_evt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_evt_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_dest ReturnThruPtr called before Expect on 'sd_ble_evt_get'.");
+  cmock_call_instance->ReturnThruPtr_p_dest_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_dest_Val = p_dest;
+  cmock_call_instance->ReturnThruPtr_p_dest_Size = cmock_size;
+}
+
+void sd_ble_evt_get_CMockReturnMemThruPtr_p_len(UNITY_LINE_TYPE cmock_line, uint16_t* p_len, int cmock_size)
+{
+  CMOCK_sd_ble_evt_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_evt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_evt_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_len ReturnThruPtr called before Expect on 'sd_ble_evt_get'.");
+  cmock_call_instance->ReturnThruPtr_p_len_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_len_Val = p_len;
+  cmock_call_instance->ReturnThruPtr_p_len_Size = cmock_size;
+}
+
+void sd_ble_evt_get_CMockIgnoreArg_p_dest(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_evt_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_evt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_evt_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_dest IgnoreArg called before Expect on 'sd_ble_evt_get'.");
+  cmock_call_instance->IgnoreArg_p_dest = 1;
+}
+
+void sd_ble_evt_get_CMockIgnoreArg_p_len(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_evt_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_evt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_evt_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_len IgnoreArg called before Expect on 'sd_ble_evt_get'.");
+  cmock_call_instance->IgnoreArg_p_len = 1;
+}
+
+uint32_t sd_ble_tx_packet_count_get(uint16_t conn_handle, uint8_t* p_count)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_tx_packet_count_get_CallInstance);
+  Mock.sd_ble_tx_packet_count_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_tx_packet_count_get_CallInstance);
+  if (Mock.sd_ble_tx_packet_count_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_tx_packet_count_get_FinalReturn;
+    Mock.sd_ble_tx_packet_count_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_tx_packet_count_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_tx_packet_count_get_CallbackFunctionPointer(conn_handle, p_count, Mock.sd_ble_tx_packet_count_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_tx_packet_count_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_tx_packet_count_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_tx_packet_count_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_tx_packet_count_get' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_count)
+  {
+    if (cmock_call_instance->Expected_p_count == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_count, cmock_line, "Expected NULL. Function 'sd_ble_tx_packet_count_get' called with unexpected value for argument 'p_count'."); }
+    else if (cmock_call_instance->Expected_p_count_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_count, p_count, cmock_line, "Function 'sd_ble_tx_packet_count_get' called with unexpected value for argument 'p_count'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_count, p_count, cmock_call_instance->Expected_p_count_Depth, cmock_line, "Function 'sd_ble_tx_packet_count_get' called with unexpected value for argument 'p_count'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_count_Used)
+  {
+    memcpy((void*)p_count, (void*)cmock_call_instance->ReturnThruPtr_p_count_Val,
+      cmock_call_instance->ReturnThruPtr_p_count_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_tx_packet_count_get(CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint8_t* p_count, int p_count_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_count = p_count;
+  cmock_call_instance->Expected_p_count_Depth = p_count_Depth;
+  cmock_call_instance->IgnoreArg_p_count = 0;
+  cmock_call_instance->ReturnThruPtr_p_count_Used = 0;
+}
+
+void sd_ble_tx_packet_count_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE));
+  CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_tx_packet_count_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_tx_packet_count_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_tx_packet_count_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_tx_packet_count_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t* p_count, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE));
+  CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_tx_packet_count_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_tx_packet_count_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_tx_packet_count_get(cmock_call_instance, conn_handle, p_count, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_tx_packet_count_get_StubWithCallback(CMOCK_sd_ble_tx_packet_count_get_CALLBACK Callback)
+{
+  Mock.sd_ble_tx_packet_count_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_tx_packet_count_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t* p_count, int p_count_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE));
+  CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_tx_packet_count_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_tx_packet_count_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_tx_packet_count_get(cmock_call_instance, conn_handle, p_count, p_count_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_tx_packet_count_get_CMockReturnMemThruPtr_p_count(UNITY_LINE_TYPE cmock_line, uint8_t* p_count, int cmock_size)
+{
+  CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_tx_packet_count_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_count ReturnThruPtr called before Expect on 'sd_ble_tx_packet_count_get'.");
+  cmock_call_instance->ReturnThruPtr_p_count_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_count_Val = p_count;
+  cmock_call_instance->ReturnThruPtr_p_count_Size = cmock_size;
+}
+
+void sd_ble_tx_packet_count_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_tx_packet_count_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_tx_packet_count_get'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_tx_packet_count_get_CMockIgnoreArg_p_count(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_tx_packet_count_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_tx_packet_count_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_count IgnoreArg called before Expect on 'sd_ble_tx_packet_count_get'.");
+  cmock_call_instance->IgnoreArg_p_count = 1;
+}
+
+uint32_t sd_ble_uuid_vs_add(ble_uuid128_t const* p_vs_uuid, uint8_t* p_uuid_type)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_uuid_vs_add_CallInstance);
+  Mock.sd_ble_uuid_vs_add_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_uuid_vs_add_CallInstance);
+  if (Mock.sd_ble_uuid_vs_add_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_uuid_vs_add_FinalReturn;
+    Mock.sd_ble_uuid_vs_add_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_uuid_vs_add_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_uuid_vs_add_CallbackFunctionPointer(p_vs_uuid, p_uuid_type, Mock.sd_ble_uuid_vs_add_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_uuid_vs_add' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_uuid_vs_add' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_uuid_vs_add' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_vs_uuid)
+  {
+    if (cmock_call_instance->Expected_p_vs_uuid == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_vs_uuid, cmock_line, "Expected NULL. Function 'sd_ble_uuid_vs_add' called with unexpected value for argument 'p_vs_uuid'."); }
+    else if (cmock_call_instance->Expected_p_vs_uuid_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_vs_uuid, p_vs_uuid, cmock_line, "Function 'sd_ble_uuid_vs_add' called with unexpected value for argument 'p_vs_uuid'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_vs_uuid), (void*)(p_vs_uuid), sizeof(ble_uuid128_t), cmock_call_instance->Expected_p_vs_uuid_Depth, cmock_line, "Function 'sd_ble_uuid_vs_add' called with unexpected value for argument 'p_vs_uuid'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_uuid_type)
+  {
+    if (cmock_call_instance->Expected_p_uuid_type == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_uuid_type, cmock_line, "Expected NULL. Function 'sd_ble_uuid_vs_add' called with unexpected value for argument 'p_uuid_type'."); }
+    else if (cmock_call_instance->Expected_p_uuid_type_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_uuid_type, p_uuid_type, cmock_line, "Function 'sd_ble_uuid_vs_add' called with unexpected value for argument 'p_uuid_type'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_uuid_type, p_uuid_type, cmock_call_instance->Expected_p_uuid_type_Depth, cmock_line, "Function 'sd_ble_uuid_vs_add' called with unexpected value for argument 'p_uuid_type'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_vs_uuid_Used)
+  {
+    memcpy((void*)p_vs_uuid, (void*)cmock_call_instance->ReturnThruPtr_p_vs_uuid_Val,
+      cmock_call_instance->ReturnThruPtr_p_vs_uuid_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_uuid_type_Used)
+  {
+    memcpy((void*)p_uuid_type, (void*)cmock_call_instance->ReturnThruPtr_p_uuid_type_Val,
+      cmock_call_instance->ReturnThruPtr_p_uuid_type_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_uuid_vs_add(CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE* cmock_call_instance, ble_uuid128_t const* p_vs_uuid, int p_vs_uuid_Depth, uint8_t* p_uuid_type, int p_uuid_type_Depth)
+{
+  cmock_call_instance->Expected_p_vs_uuid = p_vs_uuid;
+  cmock_call_instance->Expected_p_vs_uuid_Depth = p_vs_uuid_Depth;
+  cmock_call_instance->IgnoreArg_p_vs_uuid = 0;
+  cmock_call_instance->ReturnThruPtr_p_vs_uuid_Used = 0;
+  cmock_call_instance->Expected_p_uuid_type = p_uuid_type;
+  cmock_call_instance->Expected_p_uuid_type_Depth = p_uuid_type_Depth;
+  cmock_call_instance->IgnoreArg_p_uuid_type = 0;
+  cmock_call_instance->ReturnThruPtr_p_uuid_type_Used = 0;
+}
+
+void sd_ble_uuid_vs_add_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE));
+  CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_uuid_vs_add_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_uuid_vs_add_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_uuid_vs_add_IgnoreBool = (int)1;
+}
+
+void sd_ble_uuid_vs_add_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_uuid128_t const* p_vs_uuid, uint8_t* p_uuid_type, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE));
+  CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_uuid_vs_add_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_uuid_vs_add_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_uuid_vs_add(cmock_call_instance, p_vs_uuid, 0, p_uuid_type, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_uuid_vs_add_StubWithCallback(CMOCK_sd_ble_uuid_vs_add_CALLBACK Callback)
+{
+  Mock.sd_ble_uuid_vs_add_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_uuid_vs_add_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_uuid128_t const* p_vs_uuid, int p_vs_uuid_Depth, uint8_t* p_uuid_type, int p_uuid_type_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE));
+  CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_uuid_vs_add_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_uuid_vs_add_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_uuid_vs_add(cmock_call_instance, p_vs_uuid, p_vs_uuid_Depth, p_uuid_type, p_uuid_type_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_uuid_vs_add_CMockReturnMemThruPtr_p_vs_uuid(UNITY_LINE_TYPE cmock_line, ble_uuid128_t const* p_vs_uuid, int cmock_size)
+{
+  CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_uuid_vs_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_vs_uuid ReturnThruPtr called before Expect on 'sd_ble_uuid_vs_add'.");
+  cmock_call_instance->ReturnThruPtr_p_vs_uuid_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_vs_uuid_Val = p_vs_uuid;
+  cmock_call_instance->ReturnThruPtr_p_vs_uuid_Size = cmock_size;
+}
+
+void sd_ble_uuid_vs_add_CMockReturnMemThruPtr_p_uuid_type(UNITY_LINE_TYPE cmock_line, uint8_t* p_uuid_type, int cmock_size)
+{
+  CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_uuid_vs_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid_type ReturnThruPtr called before Expect on 'sd_ble_uuid_vs_add'.");
+  cmock_call_instance->ReturnThruPtr_p_uuid_type_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_uuid_type_Val = p_uuid_type;
+  cmock_call_instance->ReturnThruPtr_p_uuid_type_Size = cmock_size;
+}
+
+void sd_ble_uuid_vs_add_CMockIgnoreArg_p_vs_uuid(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_uuid_vs_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_vs_uuid IgnoreArg called before Expect on 'sd_ble_uuid_vs_add'.");
+  cmock_call_instance->IgnoreArg_p_vs_uuid = 1;
+}
+
+void sd_ble_uuid_vs_add_CMockIgnoreArg_p_uuid_type(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_uuid_vs_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_uuid_vs_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid_type IgnoreArg called before Expect on 'sd_ble_uuid_vs_add'.");
+  cmock_call_instance->IgnoreArg_p_uuid_type = 1;
+}
+
+uint32_t sd_ble_uuid_decode(uint8_t uuid_le_len, uint8_t const* p_uuid_le, ble_uuid_t* p_uuid)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_uuid_decode_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_uuid_decode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_uuid_decode_CallInstance);
+  Mock.sd_ble_uuid_decode_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_uuid_decode_CallInstance);
+  if (Mock.sd_ble_uuid_decode_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_uuid_decode_FinalReturn;
+    Mock.sd_ble_uuid_decode_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_uuid_decode_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_uuid_decode_CallbackFunctionPointer(uuid_le_len, p_uuid_le, p_uuid, Mock.sd_ble_uuid_decode_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_uuid_decode' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_uuid_decode' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_uuid_decode' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_uuid_le_len)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_uuid_le_len, uuid_le_len, cmock_line, "Function 'sd_ble_uuid_decode' called with unexpected value for argument 'uuid_le_len'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_uuid_le)
+  {
+    if (cmock_call_instance->Expected_p_uuid_le == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_uuid_le, cmock_line, "Expected NULL. Function 'sd_ble_uuid_decode' called with unexpected value for argument 'p_uuid_le'."); }
+    else if (cmock_call_instance->Expected_p_uuid_le_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_uuid_le, p_uuid_le, cmock_line, "Function 'sd_ble_uuid_decode' called with unexpected value for argument 'p_uuid_le'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_uuid_le, p_uuid_le, cmock_call_instance->Expected_p_uuid_le_Depth, cmock_line, "Function 'sd_ble_uuid_decode' called with unexpected value for argument 'p_uuid_le'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_uuid)
+  {
+    if (cmock_call_instance->Expected_p_uuid == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_uuid, cmock_line, "Expected NULL. Function 'sd_ble_uuid_decode' called with unexpected value for argument 'p_uuid'."); }
+    else if (cmock_call_instance->Expected_p_uuid_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_uuid, p_uuid, cmock_line, "Function 'sd_ble_uuid_decode' called with unexpected value for argument 'p_uuid'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_uuid), (void*)(p_uuid), sizeof(ble_uuid_t), cmock_call_instance->Expected_p_uuid_Depth, cmock_line, "Function 'sd_ble_uuid_decode' called with unexpected value for argument 'p_uuid'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_uuid_le_Used)
+  {
+    memcpy((void*)p_uuid_le, (void*)cmock_call_instance->ReturnThruPtr_p_uuid_le_Val,
+      cmock_call_instance->ReturnThruPtr_p_uuid_le_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_uuid_Used)
+  {
+    memcpy((void*)p_uuid, (void*)cmock_call_instance->ReturnThruPtr_p_uuid_Val,
+      cmock_call_instance->ReturnThruPtr_p_uuid_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_uuid_decode(CMOCK_sd_ble_uuid_decode_CALL_INSTANCE* cmock_call_instance, uint8_t uuid_le_len, uint8_t const* p_uuid_le, int p_uuid_le_Depth, ble_uuid_t* p_uuid, int p_uuid_Depth)
+{
+  cmock_call_instance->Expected_uuid_le_len = uuid_le_len;
+  cmock_call_instance->IgnoreArg_uuid_le_len = 0;
+  cmock_call_instance->Expected_p_uuid_le = p_uuid_le;
+  cmock_call_instance->Expected_p_uuid_le_Depth = p_uuid_le_Depth;
+  cmock_call_instance->IgnoreArg_p_uuid_le = 0;
+  cmock_call_instance->ReturnThruPtr_p_uuid_le_Used = 0;
+  cmock_call_instance->Expected_p_uuid = p_uuid;
+  cmock_call_instance->Expected_p_uuid_Depth = p_uuid_Depth;
+  cmock_call_instance->IgnoreArg_p_uuid = 0;
+  cmock_call_instance->ReturnThruPtr_p_uuid_Used = 0;
+}
+
+void sd_ble_uuid_decode_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_uuid_decode_CALL_INSTANCE));
+  CMOCK_sd_ble_uuid_decode_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_uuid_decode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_uuid_decode_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_uuid_decode_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_uuid_decode_IgnoreBool = (int)1;
+}
+
+void sd_ble_uuid_decode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t uuid_le_len, uint8_t const* p_uuid_le, ble_uuid_t* p_uuid, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_uuid_decode_CALL_INSTANCE));
+  CMOCK_sd_ble_uuid_decode_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_uuid_decode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_uuid_decode_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_uuid_decode_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_uuid_decode(cmock_call_instance, uuid_le_len, p_uuid_le, 0, p_uuid, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_uuid_decode_StubWithCallback(CMOCK_sd_ble_uuid_decode_CALLBACK Callback)
+{
+  Mock.sd_ble_uuid_decode_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_uuid_decode_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t uuid_le_len, uint8_t const* p_uuid_le, int p_uuid_le_Depth, ble_uuid_t* p_uuid, int p_uuid_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_uuid_decode_CALL_INSTANCE));
+  CMOCK_sd_ble_uuid_decode_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_uuid_decode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_uuid_decode_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_uuid_decode_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_uuid_decode(cmock_call_instance, uuid_le_len, p_uuid_le, p_uuid_le_Depth, p_uuid, p_uuid_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_uuid_decode_CMockReturnMemThruPtr_p_uuid_le(UNITY_LINE_TYPE cmock_line, uint8_t const* p_uuid_le, int cmock_size)
+{
+  CMOCK_sd_ble_uuid_decode_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_uuid_decode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_uuid_decode_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid_le ReturnThruPtr called before Expect on 'sd_ble_uuid_decode'.");
+  cmock_call_instance->ReturnThruPtr_p_uuid_le_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_uuid_le_Val = p_uuid_le;
+  cmock_call_instance->ReturnThruPtr_p_uuid_le_Size = cmock_size;
+}
+
+void sd_ble_uuid_decode_CMockReturnMemThruPtr_p_uuid(UNITY_LINE_TYPE cmock_line, ble_uuid_t* p_uuid, int cmock_size)
+{
+  CMOCK_sd_ble_uuid_decode_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_uuid_decode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_uuid_decode_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid ReturnThruPtr called before Expect on 'sd_ble_uuid_decode'.");
+  cmock_call_instance->ReturnThruPtr_p_uuid_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_uuid_Val = p_uuid;
+  cmock_call_instance->ReturnThruPtr_p_uuid_Size = cmock_size;
+}
+
+void sd_ble_uuid_decode_CMockIgnoreArg_uuid_le_len(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_uuid_decode_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_uuid_decode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_uuid_decode_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "uuid_le_len IgnoreArg called before Expect on 'sd_ble_uuid_decode'.");
+  cmock_call_instance->IgnoreArg_uuid_le_len = 1;
+}
+
+void sd_ble_uuid_decode_CMockIgnoreArg_p_uuid_le(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_uuid_decode_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_uuid_decode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_uuid_decode_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid_le IgnoreArg called before Expect on 'sd_ble_uuid_decode'.");
+  cmock_call_instance->IgnoreArg_p_uuid_le = 1;
+}
+
+void sd_ble_uuid_decode_CMockIgnoreArg_p_uuid(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_uuid_decode_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_uuid_decode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_uuid_decode_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid IgnoreArg called before Expect on 'sd_ble_uuid_decode'.");
+  cmock_call_instance->IgnoreArg_p_uuid = 1;
+}
+
+uint32_t sd_ble_uuid_encode(ble_uuid_t const* p_uuid, uint8_t* p_uuid_le_len, uint8_t* p_uuid_le)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_uuid_encode_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_uuid_encode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_uuid_encode_CallInstance);
+  Mock.sd_ble_uuid_encode_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_uuid_encode_CallInstance);
+  if (Mock.sd_ble_uuid_encode_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_uuid_encode_FinalReturn;
+    Mock.sd_ble_uuid_encode_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_uuid_encode_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_uuid_encode_CallbackFunctionPointer(p_uuid, p_uuid_le_len, p_uuid_le, Mock.sd_ble_uuid_encode_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_uuid_encode' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_uuid_encode' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_uuid_encode' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_uuid)
+  {
+    if (cmock_call_instance->Expected_p_uuid == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_uuid, cmock_line, "Expected NULL. Function 'sd_ble_uuid_encode' called with unexpected value for argument 'p_uuid'."); }
+    else if (cmock_call_instance->Expected_p_uuid_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_uuid, p_uuid, cmock_line, "Function 'sd_ble_uuid_encode' called with unexpected value for argument 'p_uuid'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_uuid), (void*)(p_uuid), sizeof(ble_uuid_t), cmock_call_instance->Expected_p_uuid_Depth, cmock_line, "Function 'sd_ble_uuid_encode' called with unexpected value for argument 'p_uuid'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_uuid_le_len)
+  {
+    if (cmock_call_instance->Expected_p_uuid_le_len == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_uuid_le_len, cmock_line, "Expected NULL. Function 'sd_ble_uuid_encode' called with unexpected value for argument 'p_uuid_le_len'."); }
+    else if (cmock_call_instance->Expected_p_uuid_le_len_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_uuid_le_len, p_uuid_le_len, cmock_line, "Function 'sd_ble_uuid_encode' called with unexpected value for argument 'p_uuid_le_len'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_uuid_le_len, p_uuid_le_len, cmock_call_instance->Expected_p_uuid_le_len_Depth, cmock_line, "Function 'sd_ble_uuid_encode' called with unexpected value for argument 'p_uuid_le_len'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_uuid_le)
+  {
+    if (cmock_call_instance->Expected_p_uuid_le == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_uuid_le, cmock_line, "Expected NULL. Function 'sd_ble_uuid_encode' called with unexpected value for argument 'p_uuid_le'."); }
+    else if (cmock_call_instance->Expected_p_uuid_le_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_uuid_le, p_uuid_le, cmock_line, "Function 'sd_ble_uuid_encode' called with unexpected value for argument 'p_uuid_le'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_uuid_le, p_uuid_le, cmock_call_instance->Expected_p_uuid_le_Depth, cmock_line, "Function 'sd_ble_uuid_encode' called with unexpected value for argument 'p_uuid_le'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_uuid_Used)
+  {
+    memcpy((void*)p_uuid, (void*)cmock_call_instance->ReturnThruPtr_p_uuid_Val,
+      cmock_call_instance->ReturnThruPtr_p_uuid_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_uuid_le_len_Used)
+  {
+    memcpy((void*)p_uuid_le_len, (void*)cmock_call_instance->ReturnThruPtr_p_uuid_le_len_Val,
+      cmock_call_instance->ReturnThruPtr_p_uuid_le_len_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_uuid_le_Used)
+  {
+    memcpy((void*)p_uuid_le, (void*)cmock_call_instance->ReturnThruPtr_p_uuid_le_Val,
+      cmock_call_instance->ReturnThruPtr_p_uuid_le_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_uuid_encode(CMOCK_sd_ble_uuid_encode_CALL_INSTANCE* cmock_call_instance, ble_uuid_t const* p_uuid, int p_uuid_Depth, uint8_t* p_uuid_le_len, int p_uuid_le_len_Depth, uint8_t* p_uuid_le, int p_uuid_le_Depth)
+{
+  cmock_call_instance->Expected_p_uuid = p_uuid;
+  cmock_call_instance->Expected_p_uuid_Depth = p_uuid_Depth;
+  cmock_call_instance->IgnoreArg_p_uuid = 0;
+  cmock_call_instance->ReturnThruPtr_p_uuid_Used = 0;
+  cmock_call_instance->Expected_p_uuid_le_len = p_uuid_le_len;
+  cmock_call_instance->Expected_p_uuid_le_len_Depth = p_uuid_le_len_Depth;
+  cmock_call_instance->IgnoreArg_p_uuid_le_len = 0;
+  cmock_call_instance->ReturnThruPtr_p_uuid_le_len_Used = 0;
+  cmock_call_instance->Expected_p_uuid_le = p_uuid_le;
+  cmock_call_instance->Expected_p_uuid_le_Depth = p_uuid_le_Depth;
+  cmock_call_instance->IgnoreArg_p_uuid_le = 0;
+  cmock_call_instance->ReturnThruPtr_p_uuid_le_Used = 0;
+}
+
+void sd_ble_uuid_encode_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_uuid_encode_CALL_INSTANCE));
+  CMOCK_sd_ble_uuid_encode_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_uuid_encode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_uuid_encode_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_uuid_encode_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_uuid_encode_IgnoreBool = (int)1;
+}
+
+void sd_ble_uuid_encode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_uuid_t const* p_uuid, uint8_t* p_uuid_le_len, uint8_t* p_uuid_le, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_uuid_encode_CALL_INSTANCE));
+  CMOCK_sd_ble_uuid_encode_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_uuid_encode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_uuid_encode_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_uuid_encode_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_uuid_encode(cmock_call_instance, p_uuid, 0, p_uuid_le_len, 0, p_uuid_le, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_uuid_encode_StubWithCallback(CMOCK_sd_ble_uuid_encode_CALLBACK Callback)
+{
+  Mock.sd_ble_uuid_encode_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_uuid_encode_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_uuid_t const* p_uuid, int p_uuid_Depth, uint8_t* p_uuid_le_len, int p_uuid_le_len_Depth, uint8_t* p_uuid_le, int p_uuid_le_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_uuid_encode_CALL_INSTANCE));
+  CMOCK_sd_ble_uuid_encode_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_uuid_encode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_uuid_encode_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_uuid_encode_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_uuid_encode(cmock_call_instance, p_uuid, p_uuid_Depth, p_uuid_le_len, p_uuid_le_len_Depth, p_uuid_le, p_uuid_le_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_uuid_encode_CMockReturnMemThruPtr_p_uuid(UNITY_LINE_TYPE cmock_line, ble_uuid_t const* p_uuid, int cmock_size)
+{
+  CMOCK_sd_ble_uuid_encode_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_uuid_encode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_uuid_encode_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid ReturnThruPtr called before Expect on 'sd_ble_uuid_encode'.");
+  cmock_call_instance->ReturnThruPtr_p_uuid_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_uuid_Val = p_uuid;
+  cmock_call_instance->ReturnThruPtr_p_uuid_Size = cmock_size;
+}
+
+void sd_ble_uuid_encode_CMockReturnMemThruPtr_p_uuid_le_len(UNITY_LINE_TYPE cmock_line, uint8_t* p_uuid_le_len, int cmock_size)
+{
+  CMOCK_sd_ble_uuid_encode_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_uuid_encode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_uuid_encode_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid_le_len ReturnThruPtr called before Expect on 'sd_ble_uuid_encode'.");
+  cmock_call_instance->ReturnThruPtr_p_uuid_le_len_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_uuid_le_len_Val = p_uuid_le_len;
+  cmock_call_instance->ReturnThruPtr_p_uuid_le_len_Size = cmock_size;
+}
+
+void sd_ble_uuid_encode_CMockReturnMemThruPtr_p_uuid_le(UNITY_LINE_TYPE cmock_line, uint8_t* p_uuid_le, int cmock_size)
+{
+  CMOCK_sd_ble_uuid_encode_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_uuid_encode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_uuid_encode_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid_le ReturnThruPtr called before Expect on 'sd_ble_uuid_encode'.");
+  cmock_call_instance->ReturnThruPtr_p_uuid_le_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_uuid_le_Val = p_uuid_le;
+  cmock_call_instance->ReturnThruPtr_p_uuid_le_Size = cmock_size;
+}
+
+void sd_ble_uuid_encode_CMockIgnoreArg_p_uuid(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_uuid_encode_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_uuid_encode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_uuid_encode_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid IgnoreArg called before Expect on 'sd_ble_uuid_encode'.");
+  cmock_call_instance->IgnoreArg_p_uuid = 1;
+}
+
+void sd_ble_uuid_encode_CMockIgnoreArg_p_uuid_le_len(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_uuid_encode_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_uuid_encode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_uuid_encode_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid_le_len IgnoreArg called before Expect on 'sd_ble_uuid_encode'.");
+  cmock_call_instance->IgnoreArg_p_uuid_le_len = 1;
+}
+
+void sd_ble_uuid_encode_CMockIgnoreArg_p_uuid_le(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_uuid_encode_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_uuid_encode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_uuid_encode_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid_le IgnoreArg called before Expect on 'sd_ble_uuid_encode'.");
+  cmock_call_instance->IgnoreArg_p_uuid_le = 1;
+}
+
+uint32_t sd_ble_version_get(ble_version_t* p_version)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_version_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_version_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_version_get_CallInstance);
+  Mock.sd_ble_version_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_version_get_CallInstance);
+  if (Mock.sd_ble_version_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_version_get_FinalReturn;
+    Mock.sd_ble_version_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_version_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_version_get_CallbackFunctionPointer(p_version, Mock.sd_ble_version_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_version_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_version_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_version_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_version)
+  {
+    if (cmock_call_instance->Expected_p_version == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_version, cmock_line, "Expected NULL. Function 'sd_ble_version_get' called with unexpected value for argument 'p_version'."); }
+    else if (cmock_call_instance->Expected_p_version_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_version, p_version, cmock_line, "Function 'sd_ble_version_get' called with unexpected value for argument 'p_version'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_version), (void*)(p_version), sizeof(ble_version_t), cmock_call_instance->Expected_p_version_Depth, cmock_line, "Function 'sd_ble_version_get' called with unexpected value for argument 'p_version'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_version_Used)
+  {
+    memcpy((void*)p_version, (void*)cmock_call_instance->ReturnThruPtr_p_version_Val,
+      cmock_call_instance->ReturnThruPtr_p_version_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_version_get(CMOCK_sd_ble_version_get_CALL_INSTANCE* cmock_call_instance, ble_version_t* p_version, int p_version_Depth)
+{
+  cmock_call_instance->Expected_p_version = p_version;
+  cmock_call_instance->Expected_p_version_Depth = p_version_Depth;
+  cmock_call_instance->IgnoreArg_p_version = 0;
+  cmock_call_instance->ReturnThruPtr_p_version_Used = 0;
+}
+
+void sd_ble_version_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_version_get_CALL_INSTANCE));
+  CMOCK_sd_ble_version_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_version_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_version_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_version_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_version_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_version_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_version_t* p_version, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_version_get_CALL_INSTANCE));
+  CMOCK_sd_ble_version_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_version_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_version_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_version_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_version_get(cmock_call_instance, p_version, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_version_get_StubWithCallback(CMOCK_sd_ble_version_get_CALLBACK Callback)
+{
+  Mock.sd_ble_version_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_version_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_version_t* p_version, int p_version_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_version_get_CALL_INSTANCE));
+  CMOCK_sd_ble_version_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_version_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_version_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_version_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_version_get(cmock_call_instance, p_version, p_version_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_version_get_CMockReturnMemThruPtr_p_version(UNITY_LINE_TYPE cmock_line, ble_version_t* p_version, int cmock_size)
+{
+  CMOCK_sd_ble_version_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_version_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_version_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_version ReturnThruPtr called before Expect on 'sd_ble_version_get'.");
+  cmock_call_instance->ReturnThruPtr_p_version_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_version_Val = p_version;
+  cmock_call_instance->ReturnThruPtr_p_version_Size = cmock_size;
+}
+
+void sd_ble_version_get_CMockIgnoreArg_p_version(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_version_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_version_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_version_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_version IgnoreArg called before Expect on 'sd_ble_version_get'.");
+  cmock_call_instance->IgnoreArg_p_version = 1;
+}
+
+uint32_t sd_ble_user_mem_reply(uint16_t conn_handle, ble_user_mem_block_t const* p_block)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_user_mem_reply_CallInstance);
+  Mock.sd_ble_user_mem_reply_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_user_mem_reply_CallInstance);
+  if (Mock.sd_ble_user_mem_reply_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_user_mem_reply_FinalReturn;
+    Mock.sd_ble_user_mem_reply_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_user_mem_reply_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_user_mem_reply_CallbackFunctionPointer(conn_handle, p_block, Mock.sd_ble_user_mem_reply_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_user_mem_reply' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_user_mem_reply' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_user_mem_reply' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_user_mem_reply' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_block)
+  {
+    if (cmock_call_instance->Expected_p_block == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_block, cmock_line, "Expected NULL. Function 'sd_ble_user_mem_reply' called with unexpected value for argument 'p_block'."); }
+    else if (cmock_call_instance->Expected_p_block_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_block, p_block, cmock_line, "Function 'sd_ble_user_mem_reply' called with unexpected value for argument 'p_block'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_block), (void*)(p_block), sizeof(ble_user_mem_block_t), cmock_call_instance->Expected_p_block_Depth, cmock_line, "Function 'sd_ble_user_mem_reply' called with unexpected value for argument 'p_block'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_block_Used)
+  {
+    memcpy((void*)p_block, (void*)cmock_call_instance->ReturnThruPtr_p_block_Val,
+      cmock_call_instance->ReturnThruPtr_p_block_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_user_mem_reply(CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_user_mem_block_t const* p_block, int p_block_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_block = p_block;
+  cmock_call_instance->Expected_p_block_Depth = p_block_Depth;
+  cmock_call_instance->IgnoreArg_p_block = 0;
+  cmock_call_instance->ReturnThruPtr_p_block_Used = 0;
+}
+
+void sd_ble_user_mem_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_user_mem_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_user_mem_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_user_mem_reply_IgnoreBool = (int)1;
+}
+
+void sd_ble_user_mem_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_user_mem_block_t const* p_block, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_user_mem_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_user_mem_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_user_mem_reply(cmock_call_instance, conn_handle, p_block, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_user_mem_reply_StubWithCallback(CMOCK_sd_ble_user_mem_reply_CALLBACK Callback)
+{
+  Mock.sd_ble_user_mem_reply_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_user_mem_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_user_mem_block_t const* p_block, int p_block_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_user_mem_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_user_mem_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_user_mem_reply(cmock_call_instance, conn_handle, p_block, p_block_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_user_mem_reply_CMockReturnMemThruPtr_p_block(UNITY_LINE_TYPE cmock_line, ble_user_mem_block_t const* p_block, int cmock_size)
+{
+  CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_user_mem_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_block ReturnThruPtr called before Expect on 'sd_ble_user_mem_reply'.");
+  cmock_call_instance->ReturnThruPtr_p_block_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_block_Val = p_block;
+  cmock_call_instance->ReturnThruPtr_p_block_Size = cmock_size;
+}
+
+void sd_ble_user_mem_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_user_mem_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_user_mem_reply'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_user_mem_reply_CMockIgnoreArg_p_block(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_user_mem_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_user_mem_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_block IgnoreArg called before Expect on 'sd_ble_user_mem_reply'.");
+  cmock_call_instance->IgnoreArg_p_block = 1;
+}
+
+uint32_t sd_ble_opt_set(uint32_t opt_id, ble_opt_t const* p_opt)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_opt_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_opt_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_opt_set_CallInstance);
+  Mock.sd_ble_opt_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_opt_set_CallInstance);
+  if (Mock.sd_ble_opt_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_opt_set_FinalReturn;
+    Mock.sd_ble_opt_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_opt_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_opt_set_CallbackFunctionPointer(opt_id, p_opt, Mock.sd_ble_opt_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_opt_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_opt_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_opt_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_opt_id)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_opt_id, opt_id, cmock_line, "Function 'sd_ble_opt_set' called with unexpected value for argument 'opt_id'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_opt)
+  {
+    if (cmock_call_instance->Expected_p_opt == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_opt, cmock_line, "Expected NULL. Function 'sd_ble_opt_set' called with unexpected value for argument 'p_opt'."); }
+    else if (cmock_call_instance->Expected_p_opt_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_opt, p_opt, cmock_line, "Function 'sd_ble_opt_set' called with unexpected value for argument 'p_opt'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_opt), (void*)(p_opt), sizeof(ble_opt_t), cmock_call_instance->Expected_p_opt_Depth, cmock_line, "Function 'sd_ble_opt_set' called with unexpected value for argument 'p_opt'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_opt_Used)
+  {
+    memcpy((void*)p_opt, (void*)cmock_call_instance->ReturnThruPtr_p_opt_Val,
+      cmock_call_instance->ReturnThruPtr_p_opt_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_opt_set(CMOCK_sd_ble_opt_set_CALL_INSTANCE* cmock_call_instance, uint32_t opt_id, ble_opt_t const* p_opt, int p_opt_Depth)
+{
+  cmock_call_instance->Expected_opt_id = opt_id;
+  cmock_call_instance->IgnoreArg_opt_id = 0;
+  cmock_call_instance->Expected_p_opt = p_opt;
+  cmock_call_instance->Expected_p_opt_Depth = p_opt_Depth;
+  cmock_call_instance->IgnoreArg_p_opt = 0;
+  cmock_call_instance->ReturnThruPtr_p_opt_Used = 0;
+}
+
+void sd_ble_opt_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_opt_set_CALL_INSTANCE));
+  CMOCK_sd_ble_opt_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_opt_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_opt_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_opt_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_opt_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_opt_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t opt_id, ble_opt_t const* p_opt, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_opt_set_CALL_INSTANCE));
+  CMOCK_sd_ble_opt_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_opt_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_opt_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_opt_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_opt_set(cmock_call_instance, opt_id, p_opt, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_opt_set_StubWithCallback(CMOCK_sd_ble_opt_set_CALLBACK Callback)
+{
+  Mock.sd_ble_opt_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_opt_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t opt_id, ble_opt_t const* p_opt, int p_opt_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_opt_set_CALL_INSTANCE));
+  CMOCK_sd_ble_opt_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_opt_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_opt_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_opt_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_opt_set(cmock_call_instance, opt_id, p_opt, p_opt_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_opt_set_CMockReturnMemThruPtr_p_opt(UNITY_LINE_TYPE cmock_line, ble_opt_t const* p_opt, int cmock_size)
+{
+  CMOCK_sd_ble_opt_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_opt_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_opt_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_opt ReturnThruPtr called before Expect on 'sd_ble_opt_set'.");
+  cmock_call_instance->ReturnThruPtr_p_opt_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_opt_Val = p_opt;
+  cmock_call_instance->ReturnThruPtr_p_opt_Size = cmock_size;
+}
+
+void sd_ble_opt_set_CMockIgnoreArg_opt_id(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_opt_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_opt_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_opt_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "opt_id IgnoreArg called before Expect on 'sd_ble_opt_set'.");
+  cmock_call_instance->IgnoreArg_opt_id = 1;
+}
+
+void sd_ble_opt_set_CMockIgnoreArg_p_opt(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_opt_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_opt_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_opt_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_opt IgnoreArg called before Expect on 'sd_ble_opt_set'.");
+  cmock_call_instance->IgnoreArg_p_opt = 1;
+}
+
+uint32_t sd_ble_opt_get(uint32_t opt_id, ble_opt_t* p_opt)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_opt_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_opt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_opt_get_CallInstance);
+  Mock.sd_ble_opt_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_opt_get_CallInstance);
+  if (Mock.sd_ble_opt_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_opt_get_FinalReturn;
+    Mock.sd_ble_opt_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_opt_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_opt_get_CallbackFunctionPointer(opt_id, p_opt, Mock.sd_ble_opt_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_opt_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_opt_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_opt_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_opt_id)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_opt_id, opt_id, cmock_line, "Function 'sd_ble_opt_get' called with unexpected value for argument 'opt_id'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_opt)
+  {
+    if (cmock_call_instance->Expected_p_opt == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_opt, cmock_line, "Expected NULL. Function 'sd_ble_opt_get' called with unexpected value for argument 'p_opt'."); }
+    else if (cmock_call_instance->Expected_p_opt_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_opt, p_opt, cmock_line, "Function 'sd_ble_opt_get' called with unexpected value for argument 'p_opt'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_opt), (void*)(p_opt), sizeof(ble_opt_t), cmock_call_instance->Expected_p_opt_Depth, cmock_line, "Function 'sd_ble_opt_get' called with unexpected value for argument 'p_opt'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_opt_Used)
+  {
+    memcpy((void*)p_opt, (void*)cmock_call_instance->ReturnThruPtr_p_opt_Val,
+      cmock_call_instance->ReturnThruPtr_p_opt_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_opt_get(CMOCK_sd_ble_opt_get_CALL_INSTANCE* cmock_call_instance, uint32_t opt_id, ble_opt_t* p_opt, int p_opt_Depth)
+{
+  cmock_call_instance->Expected_opt_id = opt_id;
+  cmock_call_instance->IgnoreArg_opt_id = 0;
+  cmock_call_instance->Expected_p_opt = p_opt;
+  cmock_call_instance->Expected_p_opt_Depth = p_opt_Depth;
+  cmock_call_instance->IgnoreArg_p_opt = 0;
+  cmock_call_instance->ReturnThruPtr_p_opt_Used = 0;
+}
+
+void sd_ble_opt_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_opt_get_CALL_INSTANCE));
+  CMOCK_sd_ble_opt_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_opt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_opt_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_opt_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_opt_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_opt_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t opt_id, ble_opt_t* p_opt, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_opt_get_CALL_INSTANCE));
+  CMOCK_sd_ble_opt_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_opt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_opt_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_opt_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_opt_get(cmock_call_instance, opt_id, p_opt, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_opt_get_StubWithCallback(CMOCK_sd_ble_opt_get_CALLBACK Callback)
+{
+  Mock.sd_ble_opt_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_opt_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t opt_id, ble_opt_t* p_opt, int p_opt_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_opt_get_CALL_INSTANCE));
+  CMOCK_sd_ble_opt_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_opt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_opt_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_opt_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_opt_get(cmock_call_instance, opt_id, p_opt, p_opt_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_opt_get_CMockReturnMemThruPtr_p_opt(UNITY_LINE_TYPE cmock_line, ble_opt_t* p_opt, int cmock_size)
+{
+  CMOCK_sd_ble_opt_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_opt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_opt_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_opt ReturnThruPtr called before Expect on 'sd_ble_opt_get'.");
+  cmock_call_instance->ReturnThruPtr_p_opt_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_opt_Val = p_opt;
+  cmock_call_instance->ReturnThruPtr_p_opt_Size = cmock_size;
+}
+
+void sd_ble_opt_get_CMockIgnoreArg_opt_id(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_opt_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_opt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_opt_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "opt_id IgnoreArg called before Expect on 'sd_ble_opt_get'.");
+  cmock_call_instance->IgnoreArg_opt_id = 1;
+}
+
+void sd_ble_opt_get_CMockIgnoreArg_p_opt(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_opt_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_opt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_opt_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_opt IgnoreArg called before Expect on 'sd_ble_opt_get'.");
+  cmock_call_instance->IgnoreArg_p_opt = 1;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble.h 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble.h  2018-04-24 08:48:28.725149200 +0200
@@ -0,0 +1,212 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_BLE_H
+#define _MOCK_BLE_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <ble.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_ble_Init(void);
+void mock_ble_Destroy(void);
+void mock_ble_Verify(void);
+
+
+
+
+#define sd_ble_enable_IgnoreAndReturn(cmock_retval) sd_ble_enable_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_enable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_enable_ExpectAndReturn(p_ble_enable_params, p_app_ram_base, cmock_retval) sd_ble_enable_CMockExpectAndReturn(__LINE__, p_ble_enable_params, p_app_ram_base, cmock_retval)
+void sd_ble_enable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_enable_params_t* p_ble_enable_params, uint32_t* p_app_ram_base, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_enable_CALLBACK)(ble_enable_params_t* p_ble_enable_params, uint32_t* p_app_ram_base, int cmock_num_calls);
+void sd_ble_enable_StubWithCallback(CMOCK_sd_ble_enable_CALLBACK Callback);
+#define sd_ble_enable_ExpectWithArrayAndReturn(p_ble_enable_params, p_ble_enable_params_Depth, p_app_ram_base, p_app_ram_base_Depth, cmock_retval) sd_ble_enable_CMockExpectWithArrayAndReturn(__LINE__, p_ble_enable_params, p_ble_enable_params_Depth, p_app_ram_base, p_app_ram_base_Depth, cmock_retval)
+void sd_ble_enable_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_enable_params_t* p_ble_enable_params, int p_ble_enable_params_Depth, uint32_t* p_app_ram_base, int p_app_ram_base_Depth, uint32_t cmock_to_return);
+#define sd_ble_enable_ReturnThruPtr_p_ble_enable_params(p_ble_enable_params) sd_ble_enable_CMockReturnMemThruPtr_p_ble_enable_params(__LINE__, p_ble_enable_params, sizeof(*p_ble_enable_params))
+#define sd_ble_enable_ReturnArrayThruPtr_p_ble_enable_params(p_ble_enable_params, cmock_len) sd_ble_enable_CMockReturnMemThruPtr_p_ble_enable_params(__LINE__, p_ble_enable_params, cmock_len * sizeof(*p_ble_enable_params))
+#define sd_ble_enable_ReturnMemThruPtr_p_ble_enable_params(p_ble_enable_params, cmock_size) sd_ble_enable_CMockReturnMemThruPtr_p_ble_enable_params(__LINE__, p_ble_enable_params, cmock_size)
+void sd_ble_enable_CMockReturnMemThruPtr_p_ble_enable_params(UNITY_LINE_TYPE cmock_line, ble_enable_params_t* p_ble_enable_params, int cmock_size);
+#define sd_ble_enable_ReturnThruPtr_p_app_ram_base(p_app_ram_base) sd_ble_enable_CMockReturnMemThruPtr_p_app_ram_base(__LINE__, p_app_ram_base, sizeof(*p_app_ram_base))
+#define sd_ble_enable_ReturnArrayThruPtr_p_app_ram_base(p_app_ram_base, cmock_len) sd_ble_enable_CMockReturnMemThruPtr_p_app_ram_base(__LINE__, p_app_ram_base, cmock_len * sizeof(*p_app_ram_base))
+#define sd_ble_enable_ReturnMemThruPtr_p_app_ram_base(p_app_ram_base, cmock_size) sd_ble_enable_CMockReturnMemThruPtr_p_app_ram_base(__LINE__, p_app_ram_base, cmock_size)
+void sd_ble_enable_CMockReturnMemThruPtr_p_app_ram_base(UNITY_LINE_TYPE cmock_line, uint32_t* p_app_ram_base, int cmock_size);
+#define sd_ble_enable_IgnoreArg_p_ble_enable_params() sd_ble_enable_CMockIgnoreArg_p_ble_enable_params(__LINE__)
+void sd_ble_enable_CMockIgnoreArg_p_ble_enable_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_enable_IgnoreArg_p_app_ram_base() sd_ble_enable_CMockIgnoreArg_p_app_ram_base(__LINE__)
+void sd_ble_enable_CMockIgnoreArg_p_app_ram_base(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_evt_get_IgnoreAndReturn(cmock_retval) sd_ble_evt_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_evt_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_evt_get_ExpectAndReturn(p_dest, p_len, cmock_retval) sd_ble_evt_get_CMockExpectAndReturn(__LINE__, p_dest, p_len, cmock_retval)
+void sd_ble_evt_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_dest, uint16_t* p_len, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_evt_get_CALLBACK)(uint8_t* p_dest, uint16_t* p_len, int cmock_num_calls);
+void sd_ble_evt_get_StubWithCallback(CMOCK_sd_ble_evt_get_CALLBACK Callback);
+#define sd_ble_evt_get_ExpectWithArrayAndReturn(p_dest, p_dest_Depth, p_len, p_len_Depth, cmock_retval) sd_ble_evt_get_CMockExpectWithArrayAndReturn(__LINE__, p_dest, p_dest_Depth, p_len, p_len_Depth, cmock_retval)
+void sd_ble_evt_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_dest, int p_dest_Depth, uint16_t* p_len, int p_len_Depth, uint32_t cmock_to_return);
+#define sd_ble_evt_get_ReturnThruPtr_p_dest(p_dest) sd_ble_evt_get_CMockReturnMemThruPtr_p_dest(__LINE__, p_dest, sizeof(*p_dest))
+#define sd_ble_evt_get_ReturnArrayThruPtr_p_dest(p_dest, cmock_len) sd_ble_evt_get_CMockReturnMemThruPtr_p_dest(__LINE__, p_dest, cmock_len * sizeof(*p_dest))
+#define sd_ble_evt_get_ReturnMemThruPtr_p_dest(p_dest, cmock_size) sd_ble_evt_get_CMockReturnMemThruPtr_p_dest(__LINE__, p_dest, cmock_size)
+void sd_ble_evt_get_CMockReturnMemThruPtr_p_dest(UNITY_LINE_TYPE cmock_line, uint8_t* p_dest, int cmock_size);
+#define sd_ble_evt_get_ReturnThruPtr_p_len(p_len) sd_ble_evt_get_CMockReturnMemThruPtr_p_len(__LINE__, p_len, sizeof(*p_len))
+#define sd_ble_evt_get_ReturnArrayThruPtr_p_len(p_len, cmock_len) sd_ble_evt_get_CMockReturnMemThruPtr_p_len(__LINE__, p_len, cmock_len * sizeof(*p_len))
+#define sd_ble_evt_get_ReturnMemThruPtr_p_len(p_len, cmock_size) sd_ble_evt_get_CMockReturnMemThruPtr_p_len(__LINE__, p_len, cmock_size)
+void sd_ble_evt_get_CMockReturnMemThruPtr_p_len(UNITY_LINE_TYPE cmock_line, uint16_t* p_len, int cmock_size);
+#define sd_ble_evt_get_IgnoreArg_p_dest() sd_ble_evt_get_CMockIgnoreArg_p_dest(__LINE__)
+void sd_ble_evt_get_CMockIgnoreArg_p_dest(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_evt_get_IgnoreArg_p_len() sd_ble_evt_get_CMockIgnoreArg_p_len(__LINE__)
+void sd_ble_evt_get_CMockIgnoreArg_p_len(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_tx_packet_count_get_IgnoreAndReturn(cmock_retval) sd_ble_tx_packet_count_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_tx_packet_count_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_tx_packet_count_get_ExpectAndReturn(conn_handle, p_count, cmock_retval) sd_ble_tx_packet_count_get_CMockExpectAndReturn(__LINE__, conn_handle, p_count, cmock_retval)
+void sd_ble_tx_packet_count_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t* p_count, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_tx_packet_count_get_CALLBACK)(uint16_t conn_handle, uint8_t* p_count, int cmock_num_calls);
+void sd_ble_tx_packet_count_get_StubWithCallback(CMOCK_sd_ble_tx_packet_count_get_CALLBACK Callback);
+#define sd_ble_tx_packet_count_get_ExpectWithArrayAndReturn(conn_handle, p_count, p_count_Depth, cmock_retval) sd_ble_tx_packet_count_get_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_count, p_count_Depth, cmock_retval)
+void sd_ble_tx_packet_count_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t* p_count, int p_count_Depth, uint32_t cmock_to_return);
+#define sd_ble_tx_packet_count_get_ReturnThruPtr_p_count(p_count) sd_ble_tx_packet_count_get_CMockReturnMemThruPtr_p_count(__LINE__, p_count, sizeof(*p_count))
+#define sd_ble_tx_packet_count_get_ReturnArrayThruPtr_p_count(p_count, cmock_len) sd_ble_tx_packet_count_get_CMockReturnMemThruPtr_p_count(__LINE__, p_count, cmock_len * sizeof(*p_count))
+#define sd_ble_tx_packet_count_get_ReturnMemThruPtr_p_count(p_count, cmock_size) sd_ble_tx_packet_count_get_CMockReturnMemThruPtr_p_count(__LINE__, p_count, cmock_size)
+void sd_ble_tx_packet_count_get_CMockReturnMemThruPtr_p_count(UNITY_LINE_TYPE cmock_line, uint8_t* p_count, int cmock_size);
+#define sd_ble_tx_packet_count_get_IgnoreArg_conn_handle() sd_ble_tx_packet_count_get_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_tx_packet_count_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_tx_packet_count_get_IgnoreArg_p_count() sd_ble_tx_packet_count_get_CMockIgnoreArg_p_count(__LINE__)
+void sd_ble_tx_packet_count_get_CMockIgnoreArg_p_count(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_uuid_vs_add_IgnoreAndReturn(cmock_retval) sd_ble_uuid_vs_add_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_uuid_vs_add_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_uuid_vs_add_ExpectAndReturn(p_vs_uuid, p_uuid_type, cmock_retval) sd_ble_uuid_vs_add_CMockExpectAndReturn(__LINE__, p_vs_uuid, p_uuid_type, cmock_retval)
+void sd_ble_uuid_vs_add_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_uuid128_t const* p_vs_uuid, uint8_t* p_uuid_type, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_uuid_vs_add_CALLBACK)(ble_uuid128_t const* p_vs_uuid, uint8_t* p_uuid_type, int cmock_num_calls);
+void sd_ble_uuid_vs_add_StubWithCallback(CMOCK_sd_ble_uuid_vs_add_CALLBACK Callback);
+#define sd_ble_uuid_vs_add_ExpectWithArrayAndReturn(p_vs_uuid, p_vs_uuid_Depth, p_uuid_type, p_uuid_type_Depth, cmock_retval) sd_ble_uuid_vs_add_CMockExpectWithArrayAndReturn(__LINE__, p_vs_uuid, p_vs_uuid_Depth, p_uuid_type, p_uuid_type_Depth, cmock_retval)
+void sd_ble_uuid_vs_add_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_uuid128_t const* p_vs_uuid, int p_vs_uuid_Depth, uint8_t* p_uuid_type, int p_uuid_type_Depth, uint32_t cmock_to_return);
+#define sd_ble_uuid_vs_add_ReturnThruPtr_p_vs_uuid(p_vs_uuid) sd_ble_uuid_vs_add_CMockReturnMemThruPtr_p_vs_uuid(__LINE__, p_vs_uuid, sizeof(*p_vs_uuid))
+#define sd_ble_uuid_vs_add_ReturnArrayThruPtr_p_vs_uuid(p_vs_uuid, cmock_len) sd_ble_uuid_vs_add_CMockReturnMemThruPtr_p_vs_uuid(__LINE__, p_vs_uuid, cmock_len * sizeof(*p_vs_uuid))
+#define sd_ble_uuid_vs_add_ReturnMemThruPtr_p_vs_uuid(p_vs_uuid, cmock_size) sd_ble_uuid_vs_add_CMockReturnMemThruPtr_p_vs_uuid(__LINE__, p_vs_uuid, cmock_size)
+void sd_ble_uuid_vs_add_CMockReturnMemThruPtr_p_vs_uuid(UNITY_LINE_TYPE cmock_line, ble_uuid128_t const* p_vs_uuid, int cmock_size);
+#define sd_ble_uuid_vs_add_ReturnThruPtr_p_uuid_type(p_uuid_type) sd_ble_uuid_vs_add_CMockReturnMemThruPtr_p_uuid_type(__LINE__, p_uuid_type, sizeof(*p_uuid_type))
+#define sd_ble_uuid_vs_add_ReturnArrayThruPtr_p_uuid_type(p_uuid_type, cmock_len) sd_ble_uuid_vs_add_CMockReturnMemThruPtr_p_uuid_type(__LINE__, p_uuid_type, cmock_len * sizeof(*p_uuid_type))
+#define sd_ble_uuid_vs_add_ReturnMemThruPtr_p_uuid_type(p_uuid_type, cmock_size) sd_ble_uuid_vs_add_CMockReturnMemThruPtr_p_uuid_type(__LINE__, p_uuid_type, cmock_size)
+void sd_ble_uuid_vs_add_CMockReturnMemThruPtr_p_uuid_type(UNITY_LINE_TYPE cmock_line, uint8_t* p_uuid_type, int cmock_size);
+#define sd_ble_uuid_vs_add_IgnoreArg_p_vs_uuid() sd_ble_uuid_vs_add_CMockIgnoreArg_p_vs_uuid(__LINE__)
+void sd_ble_uuid_vs_add_CMockIgnoreArg_p_vs_uuid(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_uuid_vs_add_IgnoreArg_p_uuid_type() sd_ble_uuid_vs_add_CMockIgnoreArg_p_uuid_type(__LINE__)
+void sd_ble_uuid_vs_add_CMockIgnoreArg_p_uuid_type(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_uuid_decode_IgnoreAndReturn(cmock_retval) sd_ble_uuid_decode_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_uuid_decode_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_uuid_decode_ExpectAndReturn(uuid_le_len, p_uuid_le, p_uuid, cmock_retval) sd_ble_uuid_decode_CMockExpectAndReturn(__LINE__, uuid_le_len, p_uuid_le, p_uuid, cmock_retval)
+void sd_ble_uuid_decode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t uuid_le_len, uint8_t const* p_uuid_le, ble_uuid_t* p_uuid, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_uuid_decode_CALLBACK)(uint8_t uuid_le_len, uint8_t const* p_uuid_le, ble_uuid_t* p_uuid, int cmock_num_calls);
+void sd_ble_uuid_decode_StubWithCallback(CMOCK_sd_ble_uuid_decode_CALLBACK Callback);
+#define sd_ble_uuid_decode_ExpectWithArrayAndReturn(uuid_le_len, p_uuid_le, p_uuid_le_Depth, p_uuid, p_uuid_Depth, cmock_retval) sd_ble_uuid_decode_CMockExpectWithArrayAndReturn(__LINE__, uuid_le_len, p_uuid_le, p_uuid_le_Depth, p_uuid, p_uuid_Depth, cmock_retval)
+void sd_ble_uuid_decode_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t uuid_le_len, uint8_t const* p_uuid_le, int p_uuid_le_Depth, ble_uuid_t* p_uuid, int p_uuid_Depth, uint32_t cmock_to_return);
+#define sd_ble_uuid_decode_ReturnThruPtr_p_uuid_le(p_uuid_le) sd_ble_uuid_decode_CMockReturnMemThruPtr_p_uuid_le(__LINE__, p_uuid_le, sizeof(*p_uuid_le))
+#define sd_ble_uuid_decode_ReturnArrayThruPtr_p_uuid_le(p_uuid_le, cmock_len) sd_ble_uuid_decode_CMockReturnMemThruPtr_p_uuid_le(__LINE__, p_uuid_le, cmock_len * sizeof(*p_uuid_le))
+#define sd_ble_uuid_decode_ReturnMemThruPtr_p_uuid_le(p_uuid_le, cmock_size) sd_ble_uuid_decode_CMockReturnMemThruPtr_p_uuid_le(__LINE__, p_uuid_le, cmock_size)
+void sd_ble_uuid_decode_CMockReturnMemThruPtr_p_uuid_le(UNITY_LINE_TYPE cmock_line, uint8_t const* p_uuid_le, int cmock_size);
+#define sd_ble_uuid_decode_ReturnThruPtr_p_uuid(p_uuid) sd_ble_uuid_decode_CMockReturnMemThruPtr_p_uuid(__LINE__, p_uuid, sizeof(*p_uuid))
+#define sd_ble_uuid_decode_ReturnArrayThruPtr_p_uuid(p_uuid, cmock_len) sd_ble_uuid_decode_CMockReturnMemThruPtr_p_uuid(__LINE__, p_uuid, cmock_len * sizeof(*p_uuid))
+#define sd_ble_uuid_decode_ReturnMemThruPtr_p_uuid(p_uuid, cmock_size) sd_ble_uuid_decode_CMockReturnMemThruPtr_p_uuid(__LINE__, p_uuid, cmock_size)
+void sd_ble_uuid_decode_CMockReturnMemThruPtr_p_uuid(UNITY_LINE_TYPE cmock_line, ble_uuid_t* p_uuid, int cmock_size);
+#define sd_ble_uuid_decode_IgnoreArg_uuid_le_len() sd_ble_uuid_decode_CMockIgnoreArg_uuid_le_len(__LINE__)
+void sd_ble_uuid_decode_CMockIgnoreArg_uuid_le_len(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_uuid_decode_IgnoreArg_p_uuid_le() sd_ble_uuid_decode_CMockIgnoreArg_p_uuid_le(__LINE__)
+void sd_ble_uuid_decode_CMockIgnoreArg_p_uuid_le(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_uuid_decode_IgnoreArg_p_uuid() sd_ble_uuid_decode_CMockIgnoreArg_p_uuid(__LINE__)
+void sd_ble_uuid_decode_CMockIgnoreArg_p_uuid(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_uuid_encode_IgnoreAndReturn(cmock_retval) sd_ble_uuid_encode_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_uuid_encode_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_uuid_encode_ExpectAndReturn(p_uuid, p_uuid_le_len, p_uuid_le, cmock_retval) sd_ble_uuid_encode_CMockExpectAndReturn(__LINE__, p_uuid, p_uuid_le_len, p_uuid_le, cmock_retval)
+void sd_ble_uuid_encode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_uuid_t const* p_uuid, uint8_t* p_uuid_le_len, uint8_t* p_uuid_le, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_uuid_encode_CALLBACK)(ble_uuid_t const* p_uuid, uint8_t* p_uuid_le_len, uint8_t* p_uuid_le, int cmock_num_calls);
+void sd_ble_uuid_encode_StubWithCallback(CMOCK_sd_ble_uuid_encode_CALLBACK Callback);
+#define sd_ble_uuid_encode_ExpectWithArrayAndReturn(p_uuid, p_uuid_Depth, p_uuid_le_len, p_uuid_le_len_Depth, p_uuid_le, p_uuid_le_Depth, cmock_retval) sd_ble_uuid_encode_CMockExpectWithArrayAndReturn(__LINE__, p_uuid, p_uuid_Depth, p_uuid_le_len, p_uuid_le_len_Depth, p_uuid_le, p_uuid_le_Depth, cmock_retval)
+void sd_ble_uuid_encode_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_uuid_t const* p_uuid, int p_uuid_Depth, uint8_t* p_uuid_le_len, int p_uuid_le_len_Depth, uint8_t* p_uuid_le, int p_uuid_le_Depth, uint32_t cmock_to_return);
+#define sd_ble_uuid_encode_ReturnThruPtr_p_uuid(p_uuid) sd_ble_uuid_encode_CMockReturnMemThruPtr_p_uuid(__LINE__, p_uuid, sizeof(*p_uuid))
+#define sd_ble_uuid_encode_ReturnArrayThruPtr_p_uuid(p_uuid, cmock_len) sd_ble_uuid_encode_CMockReturnMemThruPtr_p_uuid(__LINE__, p_uuid, cmock_len * sizeof(*p_uuid))
+#define sd_ble_uuid_encode_ReturnMemThruPtr_p_uuid(p_uuid, cmock_size) sd_ble_uuid_encode_CMockReturnMemThruPtr_p_uuid(__LINE__, p_uuid, cmock_size)
+void sd_ble_uuid_encode_CMockReturnMemThruPtr_p_uuid(UNITY_LINE_TYPE cmock_line, ble_uuid_t const* p_uuid, int cmock_size);
+#define sd_ble_uuid_encode_ReturnThruPtr_p_uuid_le_len(p_uuid_le_len) sd_ble_uuid_encode_CMockReturnMemThruPtr_p_uuid_le_len(__LINE__, p_uuid_le_len, sizeof(*p_uuid_le_len))
+#define sd_ble_uuid_encode_ReturnArrayThruPtr_p_uuid_le_len(p_uuid_le_len, cmock_len) sd_ble_uuid_encode_CMockReturnMemThruPtr_p_uuid_le_len(__LINE__, p_uuid_le_len, cmock_len * sizeof(*p_uuid_le_len))
+#define sd_ble_uuid_encode_ReturnMemThruPtr_p_uuid_le_len(p_uuid_le_len, cmock_size) sd_ble_uuid_encode_CMockReturnMemThruPtr_p_uuid_le_len(__LINE__, p_uuid_le_len, cmock_size)
+void sd_ble_uuid_encode_CMockReturnMemThruPtr_p_uuid_le_len(UNITY_LINE_TYPE cmock_line, uint8_t* p_uuid_le_len, int cmock_size);
+#define sd_ble_uuid_encode_ReturnThruPtr_p_uuid_le(p_uuid_le) sd_ble_uuid_encode_CMockReturnMemThruPtr_p_uuid_le(__LINE__, p_uuid_le, sizeof(*p_uuid_le))
+#define sd_ble_uuid_encode_ReturnArrayThruPtr_p_uuid_le(p_uuid_le, cmock_len) sd_ble_uuid_encode_CMockReturnMemThruPtr_p_uuid_le(__LINE__, p_uuid_le, cmock_len * sizeof(*p_uuid_le))
+#define sd_ble_uuid_encode_ReturnMemThruPtr_p_uuid_le(p_uuid_le, cmock_size) sd_ble_uuid_encode_CMockReturnMemThruPtr_p_uuid_le(__LINE__, p_uuid_le, cmock_size)
+void sd_ble_uuid_encode_CMockReturnMemThruPtr_p_uuid_le(UNITY_LINE_TYPE cmock_line, uint8_t* p_uuid_le, int cmock_size);
+#define sd_ble_uuid_encode_IgnoreArg_p_uuid() sd_ble_uuid_encode_CMockIgnoreArg_p_uuid(__LINE__)
+void sd_ble_uuid_encode_CMockIgnoreArg_p_uuid(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_uuid_encode_IgnoreArg_p_uuid_le_len() sd_ble_uuid_encode_CMockIgnoreArg_p_uuid_le_len(__LINE__)
+void sd_ble_uuid_encode_CMockIgnoreArg_p_uuid_le_len(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_uuid_encode_IgnoreArg_p_uuid_le() sd_ble_uuid_encode_CMockIgnoreArg_p_uuid_le(__LINE__)
+void sd_ble_uuid_encode_CMockIgnoreArg_p_uuid_le(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_version_get_IgnoreAndReturn(cmock_retval) sd_ble_version_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_version_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_version_get_ExpectAndReturn(p_version, cmock_retval) sd_ble_version_get_CMockExpectAndReturn(__LINE__, p_version, cmock_retval)
+void sd_ble_version_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_version_t* p_version, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_version_get_CALLBACK)(ble_version_t* p_version, int cmock_num_calls);
+void sd_ble_version_get_StubWithCallback(CMOCK_sd_ble_version_get_CALLBACK Callback);
+#define sd_ble_version_get_ExpectWithArrayAndReturn(p_version, p_version_Depth, cmock_retval) sd_ble_version_get_CMockExpectWithArrayAndReturn(__LINE__, p_version, p_version_Depth, cmock_retval)
+void sd_ble_version_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_version_t* p_version, int p_version_Depth, uint32_t cmock_to_return);
+#define sd_ble_version_get_ReturnThruPtr_p_version(p_version) sd_ble_version_get_CMockReturnMemThruPtr_p_version(__LINE__, p_version, sizeof(*p_version))
+#define sd_ble_version_get_ReturnArrayThruPtr_p_version(p_version, cmock_len) sd_ble_version_get_CMockReturnMemThruPtr_p_version(__LINE__, p_version, cmock_len * sizeof(*p_version))
+#define sd_ble_version_get_ReturnMemThruPtr_p_version(p_version, cmock_size) sd_ble_version_get_CMockReturnMemThruPtr_p_version(__LINE__, p_version, cmock_size)
+void sd_ble_version_get_CMockReturnMemThruPtr_p_version(UNITY_LINE_TYPE cmock_line, ble_version_t* p_version, int cmock_size);
+#define sd_ble_version_get_IgnoreArg_p_version() sd_ble_version_get_CMockIgnoreArg_p_version(__LINE__)
+void sd_ble_version_get_CMockIgnoreArg_p_version(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_user_mem_reply_IgnoreAndReturn(cmock_retval) sd_ble_user_mem_reply_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_user_mem_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_user_mem_reply_ExpectAndReturn(conn_handle, p_block, cmock_retval) sd_ble_user_mem_reply_CMockExpectAndReturn(__LINE__, conn_handle, p_block, cmock_retval)
+void sd_ble_user_mem_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_user_mem_block_t const* p_block, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_user_mem_reply_CALLBACK)(uint16_t conn_handle, ble_user_mem_block_t const* p_block, int cmock_num_calls);
+void sd_ble_user_mem_reply_StubWithCallback(CMOCK_sd_ble_user_mem_reply_CALLBACK Callback);
+#define sd_ble_user_mem_reply_ExpectWithArrayAndReturn(conn_handle, p_block, p_block_Depth, cmock_retval) sd_ble_user_mem_reply_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_block, p_block_Depth, cmock_retval)
+void sd_ble_user_mem_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_user_mem_block_t const* p_block, int p_block_Depth, uint32_t cmock_to_return);
+#define sd_ble_user_mem_reply_ReturnThruPtr_p_block(p_block) sd_ble_user_mem_reply_CMockReturnMemThruPtr_p_block(__LINE__, p_block, sizeof(*p_block))
+#define sd_ble_user_mem_reply_ReturnArrayThruPtr_p_block(p_block, cmock_len) sd_ble_user_mem_reply_CMockReturnMemThruPtr_p_block(__LINE__, p_block, cmock_len * sizeof(*p_block))
+#define sd_ble_user_mem_reply_ReturnMemThruPtr_p_block(p_block, cmock_size) sd_ble_user_mem_reply_CMockReturnMemThruPtr_p_block(__LINE__, p_block, cmock_size)
+void sd_ble_user_mem_reply_CMockReturnMemThruPtr_p_block(UNITY_LINE_TYPE cmock_line, ble_user_mem_block_t const* p_block, int cmock_size);
+#define sd_ble_user_mem_reply_IgnoreArg_conn_handle() sd_ble_user_mem_reply_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_user_mem_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_user_mem_reply_IgnoreArg_p_block() sd_ble_user_mem_reply_CMockIgnoreArg_p_block(__LINE__)
+void sd_ble_user_mem_reply_CMockIgnoreArg_p_block(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_opt_set_IgnoreAndReturn(cmock_retval) sd_ble_opt_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_opt_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_opt_set_ExpectAndReturn(opt_id, p_opt, cmock_retval) sd_ble_opt_set_CMockExpectAndReturn(__LINE__, opt_id, p_opt, cmock_retval)
+void sd_ble_opt_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t opt_id, ble_opt_t const* p_opt, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_opt_set_CALLBACK)(uint32_t opt_id, ble_opt_t const* p_opt, int cmock_num_calls);
+void sd_ble_opt_set_StubWithCallback(CMOCK_sd_ble_opt_set_CALLBACK Callback);
+#define sd_ble_opt_set_ExpectWithArrayAndReturn(opt_id, p_opt, p_opt_Depth, cmock_retval) sd_ble_opt_set_CMockExpectWithArrayAndReturn(__LINE__, opt_id, p_opt, p_opt_Depth, cmock_retval)
+void sd_ble_opt_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t opt_id, ble_opt_t const* p_opt, int p_opt_Depth, uint32_t cmock_to_return);
+#define sd_ble_opt_set_ReturnThruPtr_p_opt(p_opt) sd_ble_opt_set_CMockReturnMemThruPtr_p_opt(__LINE__, p_opt, sizeof(*p_opt))
+#define sd_ble_opt_set_ReturnArrayThruPtr_p_opt(p_opt, cmock_len) sd_ble_opt_set_CMockReturnMemThruPtr_p_opt(__LINE__, p_opt, cmock_len * sizeof(*p_opt))
+#define sd_ble_opt_set_ReturnMemThruPtr_p_opt(p_opt, cmock_size) sd_ble_opt_set_CMockReturnMemThruPtr_p_opt(__LINE__, p_opt, cmock_size)
+void sd_ble_opt_set_CMockReturnMemThruPtr_p_opt(UNITY_LINE_TYPE cmock_line, ble_opt_t const* p_opt, int cmock_size);
+#define sd_ble_opt_set_IgnoreArg_opt_id() sd_ble_opt_set_CMockIgnoreArg_opt_id(__LINE__)
+void sd_ble_opt_set_CMockIgnoreArg_opt_id(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_opt_set_IgnoreArg_p_opt() sd_ble_opt_set_CMockIgnoreArg_p_opt(__LINE__)
+void sd_ble_opt_set_CMockIgnoreArg_p_opt(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_opt_get_IgnoreAndReturn(cmock_retval) sd_ble_opt_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_opt_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_opt_get_ExpectAndReturn(opt_id, p_opt, cmock_retval) sd_ble_opt_get_CMockExpectAndReturn(__LINE__, opt_id, p_opt, cmock_retval)
+void sd_ble_opt_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t opt_id, ble_opt_t* p_opt, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_opt_get_CALLBACK)(uint32_t opt_id, ble_opt_t* p_opt, int cmock_num_calls);
+void sd_ble_opt_get_StubWithCallback(CMOCK_sd_ble_opt_get_CALLBACK Callback);
+#define sd_ble_opt_get_ExpectWithArrayAndReturn(opt_id, p_opt, p_opt_Depth, cmock_retval) sd_ble_opt_get_CMockExpectWithArrayAndReturn(__LINE__, opt_id, p_opt, p_opt_Depth, cmock_retval)
+void sd_ble_opt_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t opt_id, ble_opt_t* p_opt, int p_opt_Depth, uint32_t cmock_to_return);
+#define sd_ble_opt_get_ReturnThruPtr_p_opt(p_opt) sd_ble_opt_get_CMockReturnMemThruPtr_p_opt(__LINE__, p_opt, sizeof(*p_opt))
+#define sd_ble_opt_get_ReturnArrayThruPtr_p_opt(p_opt, cmock_len) sd_ble_opt_get_CMockReturnMemThruPtr_p_opt(__LINE__, p_opt, cmock_len * sizeof(*p_opt))
+#define sd_ble_opt_get_ReturnMemThruPtr_p_opt(p_opt, cmock_size) sd_ble_opt_get_CMockReturnMemThruPtr_p_opt(__LINE__, p_opt, cmock_size)
+void sd_ble_opt_get_CMockReturnMemThruPtr_p_opt(UNITY_LINE_TYPE cmock_line, ble_opt_t* p_opt, int cmock_size);
+#define sd_ble_opt_get_IgnoreArg_opt_id() sd_ble_opt_get_CMockIgnoreArg_opt_id(__LINE__)
+void sd_ble_opt_get_CMockIgnoreArg_opt_id(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_opt_get_IgnoreArg_p_opt() sd_ble_opt_get_CMockIgnoreArg_p_opt(__LINE__)
+void sd_ble_opt_get_CMockIgnoreArg_p_opt(UNITY_LINE_TYPE cmock_line);
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_err.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_err.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_err.c 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_err.c  2018-04-24 08:48:28.725149200 +0200
@@ -0,0 +1,36 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_ble_err.h"
+
+static struct mock_ble_errInstance
+{
+  unsigned char placeHolder;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_ble_err_Verify(void)
+{
+}
+
+void mock_ble_err_Init(void)
+{
+  mock_ble_err_Destroy();
+}
+
+void mock_ble_err_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_err.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_err.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_err.h 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_err.h  2018-04-24 08:48:28.726149300 +0200
@@ -0,0 +1,26 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_BLE_ERR_H
+#define _MOCK_BLE_ERR_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <ble_err.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_ble_err_Init(void);
+void mock_ble_err_Destroy(void);
+void mock_ble_err_Verify(void);
+
+
+
+
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_gap.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_gap.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_gap.c 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_gap.c  2018-04-24 08:48:28.758150100 +0200
@@ -0,0 +1,4883 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_ble_gap.h"
+
+typedef struct _CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_addr_t const* Expected_p_addr;
+  int Expected_p_addr_Depth;
+  int ReturnThruPtr_p_addr_Used;
+  ble_gap_addr_t const* ReturnThruPtr_p_addr_Val;
+  int ReturnThruPtr_p_addr_Size;
+  int IgnoreArg_p_addr;
+
+} CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_addr_t* Expected_p_addr;
+  int Expected_p_addr_Depth;
+  int ReturnThruPtr_p_addr_Used;
+  ble_gap_addr_t* ReturnThruPtr_p_addr_Val;
+  int ReturnThruPtr_p_addr_Size;
+  int IgnoreArg_p_addr;
+
+} CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_addr_t const* const* Expected_pp_wl_addrs;
+  uint8_t Expected_len;
+  int Expected_pp_wl_addrs_Depth;
+  int ReturnThruPtr_pp_wl_addrs_Used;
+  ble_gap_addr_t const* const* ReturnThruPtr_pp_wl_addrs_Val;
+  int ReturnThruPtr_pp_wl_addrs_Size;
+  int IgnoreArg_pp_wl_addrs;
+  int IgnoreArg_len;
+
+} CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_id_key_t const* const* Expected_pp_id_keys;
+  ble_gap_irk_t const* const* Expected_pp_local_irks;
+  uint8_t Expected_len;
+  int Expected_pp_id_keys_Depth;
+  int Expected_pp_local_irks_Depth;
+  int ReturnThruPtr_pp_id_keys_Used;
+  ble_gap_id_key_t const* const* ReturnThruPtr_pp_id_keys_Val;
+  int ReturnThruPtr_pp_id_keys_Size;
+  int ReturnThruPtr_pp_local_irks_Used;
+  ble_gap_irk_t const* const* ReturnThruPtr_pp_local_irks_Val;
+  int ReturnThruPtr_pp_local_irks_Size;
+  int IgnoreArg_pp_id_keys;
+  int IgnoreArg_pp_local_irks;
+  int IgnoreArg_len;
+
+} CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_privacy_params_t const* Expected_p_privacy_params;
+  int Expected_p_privacy_params_Depth;
+  int ReturnThruPtr_p_privacy_params_Used;
+  ble_gap_privacy_params_t const* ReturnThruPtr_p_privacy_params_Val;
+  int ReturnThruPtr_p_privacy_params_Size;
+  int IgnoreArg_p_privacy_params;
+
+} CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_privacy_params_t* Expected_p_privacy_params;
+  int Expected_p_privacy_params_Depth;
+  int ReturnThruPtr_p_privacy_params_Used;
+  ble_gap_privacy_params_t* ReturnThruPtr_p_privacy_params_Val;
+  int ReturnThruPtr_p_privacy_params_Size;
+  int IgnoreArg_p_privacy_params;
+
+} CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t const* Expected_p_data;
+  uint8_t Expected_dlen;
+  uint8_t const* Expected_p_sr_data;
+  uint8_t Expected_srdlen;
+  int Expected_p_data_Depth;
+  int Expected_p_sr_data_Depth;
+  int ReturnThruPtr_p_data_Used;
+  uint8_t const* ReturnThruPtr_p_data_Val;
+  int ReturnThruPtr_p_data_Size;
+  int ReturnThruPtr_p_sr_data_Used;
+  uint8_t const* ReturnThruPtr_p_sr_data_Val;
+  int ReturnThruPtr_p_sr_data_Size;
+  int IgnoreArg_p_data;
+  int IgnoreArg_dlen;
+  int IgnoreArg_p_sr_data;
+  int IgnoreArg_srdlen;
+
+} CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_adv_params_t const* Expected_p_adv_params;
+  int Expected_p_adv_params_Depth;
+  int ReturnThruPtr_p_adv_params_Used;
+  ble_gap_adv_params_t const* ReturnThruPtr_p_adv_params_Val;
+  int ReturnThruPtr_p_adv_params_Size;
+  int IgnoreArg_p_adv_params;
+
+} CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+
+} CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gap_conn_params_t const* Expected_p_conn_params;
+  int Expected_p_conn_params_Depth;
+  int ReturnThruPtr_p_conn_params_Used;
+  ble_gap_conn_params_t const* ReturnThruPtr_p_conn_params_Val;
+  int ReturnThruPtr_p_conn_params_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_conn_params;
+
+} CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint8_t Expected_hci_status_code;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_hci_status_code;
+
+} CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  int8_t Expected_tx_power;
+  int IgnoreArg_tx_power;
+
+} CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_appearance;
+  int IgnoreArg_appearance;
+
+} CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t* Expected_p_appearance;
+  int Expected_p_appearance_Depth;
+  int ReturnThruPtr_p_appearance_Used;
+  uint16_t* ReturnThruPtr_p_appearance_Val;
+  int ReturnThruPtr_p_appearance_Size;
+  int IgnoreArg_p_appearance;
+
+} CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_conn_params_t const* Expected_p_conn_params;
+  int Expected_p_conn_params_Depth;
+  int ReturnThruPtr_p_conn_params_Used;
+  ble_gap_conn_params_t const* ReturnThruPtr_p_conn_params_Val;
+  int ReturnThruPtr_p_conn_params_Size;
+  int IgnoreArg_p_conn_params;
+
+} CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_conn_params_t* Expected_p_conn_params;
+  int Expected_p_conn_params_Depth;
+  int ReturnThruPtr_p_conn_params_Used;
+  ble_gap_conn_params_t* ReturnThruPtr_p_conn_params_Val;
+  int ReturnThruPtr_p_conn_params_Size;
+  int IgnoreArg_p_conn_params;
+
+} CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_conn_sec_mode_t const* Expected_p_write_perm;
+  uint8_t const* Expected_p_dev_name;
+  uint16_t Expected_len;
+  int Expected_p_write_perm_Depth;
+  int Expected_p_dev_name_Depth;
+  int ReturnThruPtr_p_write_perm_Used;
+  ble_gap_conn_sec_mode_t const* ReturnThruPtr_p_write_perm_Val;
+  int ReturnThruPtr_p_write_perm_Size;
+  int ReturnThruPtr_p_dev_name_Used;
+  uint8_t const* ReturnThruPtr_p_dev_name_Val;
+  int ReturnThruPtr_p_dev_name_Size;
+  int IgnoreArg_p_write_perm;
+  int IgnoreArg_p_dev_name;
+  int IgnoreArg_len;
+
+} CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t* Expected_p_dev_name;
+  uint16_t* Expected_p_len;
+  int Expected_p_dev_name_Depth;
+  int Expected_p_len_Depth;
+  int ReturnThruPtr_p_dev_name_Used;
+  uint8_t* ReturnThruPtr_p_dev_name_Val;
+  int ReturnThruPtr_p_dev_name_Size;
+  int ReturnThruPtr_p_len_Used;
+  uint16_t* ReturnThruPtr_p_len_Val;
+  int ReturnThruPtr_p_len_Size;
+  int IgnoreArg_p_dev_name;
+  int IgnoreArg_p_len;
+
+} CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gap_sec_params_t const* Expected_p_sec_params;
+  int Expected_p_sec_params_Depth;
+  int ReturnThruPtr_p_sec_params_Used;
+  ble_gap_sec_params_t const* ReturnThruPtr_p_sec_params_Val;
+  int ReturnThruPtr_p_sec_params_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_sec_params;
+
+} CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint8_t Expected_sec_status;
+  ble_gap_sec_params_t const* Expected_p_sec_params;
+  ble_gap_sec_keyset_t const* Expected_p_sec_keyset;
+  int Expected_p_sec_params_Depth;
+  int Expected_p_sec_keyset_Depth;
+  int ReturnThruPtr_p_sec_params_Used;
+  ble_gap_sec_params_t const* ReturnThruPtr_p_sec_params_Val;
+  int ReturnThruPtr_p_sec_params_Size;
+  int ReturnThruPtr_p_sec_keyset_Used;
+  ble_gap_sec_keyset_t const* ReturnThruPtr_p_sec_keyset_Val;
+  int ReturnThruPtr_p_sec_keyset_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_sec_status;
+  int IgnoreArg_p_sec_params;
+  int IgnoreArg_p_sec_keyset;
+
+} CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint8_t Expected_key_type;
+  uint8_t const* Expected_p_key;
+  int Expected_p_key_Depth;
+  int ReturnThruPtr_p_key_Used;
+  uint8_t const* ReturnThruPtr_p_key_Val;
+  int ReturnThruPtr_p_key_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_key_type;
+  int IgnoreArg_p_key;
+
+} CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gap_lesc_dhkey_t const* Expected_p_dhkey;
+  int Expected_p_dhkey_Depth;
+  int ReturnThruPtr_p_dhkey_Used;
+  ble_gap_lesc_dhkey_t const* ReturnThruPtr_p_dhkey_Val;
+  int ReturnThruPtr_p_dhkey_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_dhkey;
+
+} CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint8_t Expected_kp_not;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_kp_not;
+
+} CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gap_lesc_p256_pk_t const* Expected_p_pk_own;
+  ble_gap_lesc_oob_data_t* Expected_p_oobd_own;
+  int Expected_p_pk_own_Depth;
+  int Expected_p_oobd_own_Depth;
+  int ReturnThruPtr_p_pk_own_Used;
+  ble_gap_lesc_p256_pk_t const* ReturnThruPtr_p_pk_own_Val;
+  int ReturnThruPtr_p_pk_own_Size;
+  int ReturnThruPtr_p_oobd_own_Used;
+  ble_gap_lesc_oob_data_t* ReturnThruPtr_p_oobd_own_Val;
+  int ReturnThruPtr_p_oobd_own_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_pk_own;
+  int IgnoreArg_p_oobd_own;
+
+} CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gap_lesc_oob_data_t const* Expected_p_oobd_own;
+  ble_gap_lesc_oob_data_t const* Expected_p_oobd_peer;
+  int Expected_p_oobd_own_Depth;
+  int Expected_p_oobd_peer_Depth;
+  int ReturnThruPtr_p_oobd_own_Used;
+  ble_gap_lesc_oob_data_t const* ReturnThruPtr_p_oobd_own_Val;
+  int ReturnThruPtr_p_oobd_own_Size;
+  int ReturnThruPtr_p_oobd_peer_Used;
+  ble_gap_lesc_oob_data_t const* ReturnThruPtr_p_oobd_peer_Val;
+  int ReturnThruPtr_p_oobd_peer_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_oobd_own;
+  int IgnoreArg_p_oobd_peer;
+
+} CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gap_master_id_t const* Expected_p_master_id;
+  ble_gap_enc_info_t const* Expected_p_enc_info;
+  int Expected_p_master_id_Depth;
+  int Expected_p_enc_info_Depth;
+  int ReturnThruPtr_p_master_id_Used;
+  ble_gap_master_id_t const* ReturnThruPtr_p_master_id_Val;
+  int ReturnThruPtr_p_master_id_Size;
+  int ReturnThruPtr_p_enc_info_Used;
+  ble_gap_enc_info_t const* ReturnThruPtr_p_enc_info_Val;
+  int ReturnThruPtr_p_enc_info_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_master_id;
+  int IgnoreArg_p_enc_info;
+
+} CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gap_enc_info_t const* Expected_p_enc_info;
+  ble_gap_irk_t const* Expected_p_id_info;
+  ble_gap_sign_info_t const* Expected_p_sign_info;
+  int Expected_p_enc_info_Depth;
+  int Expected_p_id_info_Depth;
+  int Expected_p_sign_info_Depth;
+  int ReturnThruPtr_p_enc_info_Used;
+  ble_gap_enc_info_t const* ReturnThruPtr_p_enc_info_Val;
+  int ReturnThruPtr_p_enc_info_Size;
+  int ReturnThruPtr_p_id_info_Used;
+  ble_gap_irk_t const* ReturnThruPtr_p_id_info_Val;
+  int ReturnThruPtr_p_id_info_Size;
+  int ReturnThruPtr_p_sign_info_Used;
+  ble_gap_sign_info_t const* ReturnThruPtr_p_sign_info_Val;
+  int ReturnThruPtr_p_sign_info_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_enc_info;
+  int IgnoreArg_p_id_info;
+  int IgnoreArg_p_sign_info;
+
+} CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gap_conn_sec_t* Expected_p_conn_sec;
+  int Expected_p_conn_sec_Depth;
+  int ReturnThruPtr_p_conn_sec_Used;
+  ble_gap_conn_sec_t* ReturnThruPtr_p_conn_sec_Val;
+  int ReturnThruPtr_p_conn_sec_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_conn_sec;
+
+} CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint8_t Expected_threshold_dbm;
+  uint8_t Expected_skip_count;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_threshold_dbm;
+  int IgnoreArg_skip_count;
+
+} CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  int IgnoreArg_conn_handle;
+
+} CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  int8_t* Expected_p_rssi;
+  int Expected_p_rssi_Depth;
+  int ReturnThruPtr_p_rssi_Used;
+  int8_t* ReturnThruPtr_p_rssi_Val;
+  int ReturnThruPtr_p_rssi_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_rssi;
+
+} CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_scan_params_t const* Expected_p_scan_params;
+  int Expected_p_scan_params_Depth;
+  int ReturnThruPtr_p_scan_params_Used;
+  ble_gap_scan_params_t const* ReturnThruPtr_p_scan_params_Val;
+  int ReturnThruPtr_p_scan_params_Size;
+  int IgnoreArg_p_scan_params;
+
+} CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+
+} CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_connect_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_addr_t const* Expected_p_peer_addr;
+  ble_gap_scan_params_t const* Expected_p_scan_params;
+  ble_gap_conn_params_t const* Expected_p_conn_params;
+  int Expected_p_peer_addr_Depth;
+  int Expected_p_scan_params_Depth;
+  int Expected_p_conn_params_Depth;
+  int ReturnThruPtr_p_peer_addr_Used;
+  ble_gap_addr_t const* ReturnThruPtr_p_peer_addr_Val;
+  int ReturnThruPtr_p_peer_addr_Size;
+  int ReturnThruPtr_p_scan_params_Used;
+  ble_gap_scan_params_t const* ReturnThruPtr_p_scan_params_Val;
+  int ReturnThruPtr_p_scan_params_Size;
+  int ReturnThruPtr_p_conn_params_Used;
+  ble_gap_conn_params_t const* ReturnThruPtr_p_conn_params_Val;
+  int ReturnThruPtr_p_conn_params_Size;
+  int IgnoreArg_p_peer_addr;
+  int IgnoreArg_p_scan_params;
+  int IgnoreArg_p_conn_params;
+
+} CMOCK_sd_ble_gap_connect_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+
+} CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE;
+
+static struct mock_ble_gapInstance
+{
+  int sd_ble_gap_addr_set_IgnoreBool;
+  uint32_t sd_ble_gap_addr_set_FinalReturn;
+  CMOCK_sd_ble_gap_addr_set_CALLBACK sd_ble_gap_addr_set_CallbackFunctionPointer;
+  int sd_ble_gap_addr_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_addr_set_CallInstance;
+  int sd_ble_gap_addr_get_IgnoreBool;
+  uint32_t sd_ble_gap_addr_get_FinalReturn;
+  CMOCK_sd_ble_gap_addr_get_CALLBACK sd_ble_gap_addr_get_CallbackFunctionPointer;
+  int sd_ble_gap_addr_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_addr_get_CallInstance;
+  int sd_ble_gap_whitelist_set_IgnoreBool;
+  uint32_t sd_ble_gap_whitelist_set_FinalReturn;
+  CMOCK_sd_ble_gap_whitelist_set_CALLBACK sd_ble_gap_whitelist_set_CallbackFunctionPointer;
+  int sd_ble_gap_whitelist_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_whitelist_set_CallInstance;
+  int sd_ble_gap_device_identities_set_IgnoreBool;
+  uint32_t sd_ble_gap_device_identities_set_FinalReturn;
+  CMOCK_sd_ble_gap_device_identities_set_CALLBACK sd_ble_gap_device_identities_set_CallbackFunctionPointer;
+  int sd_ble_gap_device_identities_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_device_identities_set_CallInstance;
+  int sd_ble_gap_privacy_set_IgnoreBool;
+  uint32_t sd_ble_gap_privacy_set_FinalReturn;
+  CMOCK_sd_ble_gap_privacy_set_CALLBACK sd_ble_gap_privacy_set_CallbackFunctionPointer;
+  int sd_ble_gap_privacy_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_privacy_set_CallInstance;
+  int sd_ble_gap_privacy_get_IgnoreBool;
+  uint32_t sd_ble_gap_privacy_get_FinalReturn;
+  CMOCK_sd_ble_gap_privacy_get_CALLBACK sd_ble_gap_privacy_get_CallbackFunctionPointer;
+  int sd_ble_gap_privacy_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_privacy_get_CallInstance;
+  int sd_ble_gap_adv_data_set_IgnoreBool;
+  uint32_t sd_ble_gap_adv_data_set_FinalReturn;
+  CMOCK_sd_ble_gap_adv_data_set_CALLBACK sd_ble_gap_adv_data_set_CallbackFunctionPointer;
+  int sd_ble_gap_adv_data_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_adv_data_set_CallInstance;
+  int sd_ble_gap_adv_start_IgnoreBool;
+  uint32_t sd_ble_gap_adv_start_FinalReturn;
+  CMOCK_sd_ble_gap_adv_start_CALLBACK sd_ble_gap_adv_start_CallbackFunctionPointer;
+  int sd_ble_gap_adv_start_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_adv_start_CallInstance;
+  int sd_ble_gap_adv_stop_IgnoreBool;
+  uint32_t sd_ble_gap_adv_stop_FinalReturn;
+  CMOCK_sd_ble_gap_adv_stop_CALLBACK sd_ble_gap_adv_stop_CallbackFunctionPointer;
+  int sd_ble_gap_adv_stop_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_adv_stop_CallInstance;
+  int sd_ble_gap_conn_param_update_IgnoreBool;
+  uint32_t sd_ble_gap_conn_param_update_FinalReturn;
+  CMOCK_sd_ble_gap_conn_param_update_CALLBACK sd_ble_gap_conn_param_update_CallbackFunctionPointer;
+  int sd_ble_gap_conn_param_update_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_conn_param_update_CallInstance;
+  int sd_ble_gap_disconnect_IgnoreBool;
+  uint32_t sd_ble_gap_disconnect_FinalReturn;
+  CMOCK_sd_ble_gap_disconnect_CALLBACK sd_ble_gap_disconnect_CallbackFunctionPointer;
+  int sd_ble_gap_disconnect_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_disconnect_CallInstance;
+  int sd_ble_gap_tx_power_set_IgnoreBool;
+  uint32_t sd_ble_gap_tx_power_set_FinalReturn;
+  CMOCK_sd_ble_gap_tx_power_set_CALLBACK sd_ble_gap_tx_power_set_CallbackFunctionPointer;
+  int sd_ble_gap_tx_power_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_tx_power_set_CallInstance;
+  int sd_ble_gap_appearance_set_IgnoreBool;
+  uint32_t sd_ble_gap_appearance_set_FinalReturn;
+  CMOCK_sd_ble_gap_appearance_set_CALLBACK sd_ble_gap_appearance_set_CallbackFunctionPointer;
+  int sd_ble_gap_appearance_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_appearance_set_CallInstance;
+  int sd_ble_gap_appearance_get_IgnoreBool;
+  uint32_t sd_ble_gap_appearance_get_FinalReturn;
+  CMOCK_sd_ble_gap_appearance_get_CALLBACK sd_ble_gap_appearance_get_CallbackFunctionPointer;
+  int sd_ble_gap_appearance_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_appearance_get_CallInstance;
+  int sd_ble_gap_ppcp_set_IgnoreBool;
+  uint32_t sd_ble_gap_ppcp_set_FinalReturn;
+  CMOCK_sd_ble_gap_ppcp_set_CALLBACK sd_ble_gap_ppcp_set_CallbackFunctionPointer;
+  int sd_ble_gap_ppcp_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_ppcp_set_CallInstance;
+  int sd_ble_gap_ppcp_get_IgnoreBool;
+  uint32_t sd_ble_gap_ppcp_get_FinalReturn;
+  CMOCK_sd_ble_gap_ppcp_get_CALLBACK sd_ble_gap_ppcp_get_CallbackFunctionPointer;
+  int sd_ble_gap_ppcp_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_ppcp_get_CallInstance;
+  int sd_ble_gap_device_name_set_IgnoreBool;
+  uint32_t sd_ble_gap_device_name_set_FinalReturn;
+  CMOCK_sd_ble_gap_device_name_set_CALLBACK sd_ble_gap_device_name_set_CallbackFunctionPointer;
+  int sd_ble_gap_device_name_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_device_name_set_CallInstance;
+  int sd_ble_gap_device_name_get_IgnoreBool;
+  uint32_t sd_ble_gap_device_name_get_FinalReturn;
+  CMOCK_sd_ble_gap_device_name_get_CALLBACK sd_ble_gap_device_name_get_CallbackFunctionPointer;
+  int sd_ble_gap_device_name_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_device_name_get_CallInstance;
+  int sd_ble_gap_authenticate_IgnoreBool;
+  uint32_t sd_ble_gap_authenticate_FinalReturn;
+  CMOCK_sd_ble_gap_authenticate_CALLBACK sd_ble_gap_authenticate_CallbackFunctionPointer;
+  int sd_ble_gap_authenticate_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_authenticate_CallInstance;
+  int sd_ble_gap_sec_params_reply_IgnoreBool;
+  uint32_t sd_ble_gap_sec_params_reply_FinalReturn;
+  CMOCK_sd_ble_gap_sec_params_reply_CALLBACK sd_ble_gap_sec_params_reply_CallbackFunctionPointer;
+  int sd_ble_gap_sec_params_reply_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_sec_params_reply_CallInstance;
+  int sd_ble_gap_auth_key_reply_IgnoreBool;
+  uint32_t sd_ble_gap_auth_key_reply_FinalReturn;
+  CMOCK_sd_ble_gap_auth_key_reply_CALLBACK sd_ble_gap_auth_key_reply_CallbackFunctionPointer;
+  int sd_ble_gap_auth_key_reply_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_auth_key_reply_CallInstance;
+  int sd_ble_gap_lesc_dhkey_reply_IgnoreBool;
+  uint32_t sd_ble_gap_lesc_dhkey_reply_FinalReturn;
+  CMOCK_sd_ble_gap_lesc_dhkey_reply_CALLBACK sd_ble_gap_lesc_dhkey_reply_CallbackFunctionPointer;
+  int sd_ble_gap_lesc_dhkey_reply_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_lesc_dhkey_reply_CallInstance;
+  int sd_ble_gap_keypress_notify_IgnoreBool;
+  uint32_t sd_ble_gap_keypress_notify_FinalReturn;
+  CMOCK_sd_ble_gap_keypress_notify_CALLBACK sd_ble_gap_keypress_notify_CallbackFunctionPointer;
+  int sd_ble_gap_keypress_notify_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_keypress_notify_CallInstance;
+  int sd_ble_gap_lesc_oob_data_get_IgnoreBool;
+  uint32_t sd_ble_gap_lesc_oob_data_get_FinalReturn;
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALLBACK sd_ble_gap_lesc_oob_data_get_CallbackFunctionPointer;
+  int sd_ble_gap_lesc_oob_data_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_lesc_oob_data_get_CallInstance;
+  int sd_ble_gap_lesc_oob_data_set_IgnoreBool;
+  uint32_t sd_ble_gap_lesc_oob_data_set_FinalReturn;
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALLBACK sd_ble_gap_lesc_oob_data_set_CallbackFunctionPointer;
+  int sd_ble_gap_lesc_oob_data_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_lesc_oob_data_set_CallInstance;
+  int sd_ble_gap_encrypt_IgnoreBool;
+  uint32_t sd_ble_gap_encrypt_FinalReturn;
+  CMOCK_sd_ble_gap_encrypt_CALLBACK sd_ble_gap_encrypt_CallbackFunctionPointer;
+  int sd_ble_gap_encrypt_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_encrypt_CallInstance;
+  int sd_ble_gap_sec_info_reply_IgnoreBool;
+  uint32_t sd_ble_gap_sec_info_reply_FinalReturn;
+  CMOCK_sd_ble_gap_sec_info_reply_CALLBACK sd_ble_gap_sec_info_reply_CallbackFunctionPointer;
+  int sd_ble_gap_sec_info_reply_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_sec_info_reply_CallInstance;
+  int sd_ble_gap_conn_sec_get_IgnoreBool;
+  uint32_t sd_ble_gap_conn_sec_get_FinalReturn;
+  CMOCK_sd_ble_gap_conn_sec_get_CALLBACK sd_ble_gap_conn_sec_get_CallbackFunctionPointer;
+  int sd_ble_gap_conn_sec_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_conn_sec_get_CallInstance;
+  int sd_ble_gap_rssi_start_IgnoreBool;
+  uint32_t sd_ble_gap_rssi_start_FinalReturn;
+  CMOCK_sd_ble_gap_rssi_start_CALLBACK sd_ble_gap_rssi_start_CallbackFunctionPointer;
+  int sd_ble_gap_rssi_start_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_rssi_start_CallInstance;
+  int sd_ble_gap_rssi_stop_IgnoreBool;
+  uint32_t sd_ble_gap_rssi_stop_FinalReturn;
+  CMOCK_sd_ble_gap_rssi_stop_CALLBACK sd_ble_gap_rssi_stop_CallbackFunctionPointer;
+  int sd_ble_gap_rssi_stop_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_rssi_stop_CallInstance;
+  int sd_ble_gap_rssi_get_IgnoreBool;
+  uint32_t sd_ble_gap_rssi_get_FinalReturn;
+  CMOCK_sd_ble_gap_rssi_get_CALLBACK sd_ble_gap_rssi_get_CallbackFunctionPointer;
+  int sd_ble_gap_rssi_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_rssi_get_CallInstance;
+  int sd_ble_gap_scan_start_IgnoreBool;
+  uint32_t sd_ble_gap_scan_start_FinalReturn;
+  CMOCK_sd_ble_gap_scan_start_CALLBACK sd_ble_gap_scan_start_CallbackFunctionPointer;
+  int sd_ble_gap_scan_start_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_scan_start_CallInstance;
+  int sd_ble_gap_scan_stop_IgnoreBool;
+  uint32_t sd_ble_gap_scan_stop_FinalReturn;
+  CMOCK_sd_ble_gap_scan_stop_CALLBACK sd_ble_gap_scan_stop_CallbackFunctionPointer;
+  int sd_ble_gap_scan_stop_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_scan_stop_CallInstance;
+  int sd_ble_gap_connect_IgnoreBool;
+  uint32_t sd_ble_gap_connect_FinalReturn;
+  CMOCK_sd_ble_gap_connect_CALLBACK sd_ble_gap_connect_CallbackFunctionPointer;
+  int sd_ble_gap_connect_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_connect_CallInstance;
+  int sd_ble_gap_connect_cancel_IgnoreBool;
+  uint32_t sd_ble_gap_connect_cancel_FinalReturn;
+  CMOCK_sd_ble_gap_connect_cancel_CALLBACK sd_ble_gap_connect_cancel_CallbackFunctionPointer;
+  int sd_ble_gap_connect_cancel_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_connect_cancel_CallInstance;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_ble_gap_Verify(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_addr_set_CallInstance, cmock_line, "Function 'sd_ble_gap_addr_set' called less times than expected.");
+  if (Mock.sd_ble_gap_addr_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_addr_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_addr_get_CallInstance, cmock_line, "Function 'sd_ble_gap_addr_get' called less times than expected.");
+  if (Mock.sd_ble_gap_addr_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_addr_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_whitelist_set_CallInstance, cmock_line, "Function 'sd_ble_gap_whitelist_set' called less times than expected.");
+  if (Mock.sd_ble_gap_whitelist_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_whitelist_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_device_identities_set_CallInstance, cmock_line, "Function 'sd_ble_gap_device_identities_set' called less times than expected.");
+  if (Mock.sd_ble_gap_device_identities_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_device_identities_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_privacy_set_CallInstance, cmock_line, "Function 'sd_ble_gap_privacy_set' called less times than expected.");
+  if (Mock.sd_ble_gap_privacy_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_privacy_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_privacy_get_CallInstance, cmock_line, "Function 'sd_ble_gap_privacy_get' called less times than expected.");
+  if (Mock.sd_ble_gap_privacy_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_privacy_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_adv_data_set_CallInstance, cmock_line, "Function 'sd_ble_gap_adv_data_set' called less times than expected.");
+  if (Mock.sd_ble_gap_adv_data_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_adv_data_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_adv_start_CallInstance, cmock_line, "Function 'sd_ble_gap_adv_start' called less times than expected.");
+  if (Mock.sd_ble_gap_adv_start_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_adv_start_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_adv_stop_CallInstance, cmock_line, "Function 'sd_ble_gap_adv_stop' called less times than expected.");
+  if (Mock.sd_ble_gap_adv_stop_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_adv_stop_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_conn_param_update_CallInstance, cmock_line, "Function 'sd_ble_gap_conn_param_update' called less times than expected.");
+  if (Mock.sd_ble_gap_conn_param_update_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_conn_param_update_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_disconnect_CallInstance, cmock_line, "Function 'sd_ble_gap_disconnect' called less times than expected.");
+  if (Mock.sd_ble_gap_disconnect_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_disconnect_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_tx_power_set_CallInstance, cmock_line, "Function 'sd_ble_gap_tx_power_set' called less times than expected.");
+  if (Mock.sd_ble_gap_tx_power_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_tx_power_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_appearance_set_CallInstance, cmock_line, "Function 'sd_ble_gap_appearance_set' called less times than expected.");
+  if (Mock.sd_ble_gap_appearance_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_appearance_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_appearance_get_CallInstance, cmock_line, "Function 'sd_ble_gap_appearance_get' called less times than expected.");
+  if (Mock.sd_ble_gap_appearance_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_appearance_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_ppcp_set_CallInstance, cmock_line, "Function 'sd_ble_gap_ppcp_set' called less times than expected.");
+  if (Mock.sd_ble_gap_ppcp_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_ppcp_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_ppcp_get_CallInstance, cmock_line, "Function 'sd_ble_gap_ppcp_get' called less times than expected.");
+  if (Mock.sd_ble_gap_ppcp_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_ppcp_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_device_name_set_CallInstance, cmock_line, "Function 'sd_ble_gap_device_name_set' called less times than expected.");
+  if (Mock.sd_ble_gap_device_name_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_device_name_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_device_name_get_CallInstance, cmock_line, "Function 'sd_ble_gap_device_name_get' called less times than expected.");
+  if (Mock.sd_ble_gap_device_name_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_device_name_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_authenticate_CallInstance, cmock_line, "Function 'sd_ble_gap_authenticate' called less times than expected.");
+  if (Mock.sd_ble_gap_authenticate_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_authenticate_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_sec_params_reply_CallInstance, cmock_line, "Function 'sd_ble_gap_sec_params_reply' called less times than expected.");
+  if (Mock.sd_ble_gap_sec_params_reply_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_sec_params_reply_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_auth_key_reply_CallInstance, cmock_line, "Function 'sd_ble_gap_auth_key_reply' called less times than expected.");
+  if (Mock.sd_ble_gap_auth_key_reply_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_auth_key_reply_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance, cmock_line, "Function 'sd_ble_gap_lesc_dhkey_reply' called less times than expected.");
+  if (Mock.sd_ble_gap_lesc_dhkey_reply_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_keypress_notify_CallInstance, cmock_line, "Function 'sd_ble_gap_keypress_notify' called less times than expected.");
+  if (Mock.sd_ble_gap_keypress_notify_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_keypress_notify_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_lesc_oob_data_get_CallInstance, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called less times than expected.");
+  if (Mock.sd_ble_gap_lesc_oob_data_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_lesc_oob_data_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_lesc_oob_data_set_CallInstance, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called less times than expected.");
+  if (Mock.sd_ble_gap_lesc_oob_data_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_lesc_oob_data_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_encrypt_CallInstance, cmock_line, "Function 'sd_ble_gap_encrypt' called less times than expected.");
+  if (Mock.sd_ble_gap_encrypt_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_encrypt_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_sec_info_reply_CallInstance, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called less times than expected.");
+  if (Mock.sd_ble_gap_sec_info_reply_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_sec_info_reply_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_conn_sec_get_CallInstance, cmock_line, "Function 'sd_ble_gap_conn_sec_get' called less times than expected.");
+  if (Mock.sd_ble_gap_conn_sec_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_conn_sec_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_rssi_start_CallInstance, cmock_line, "Function 'sd_ble_gap_rssi_start' called less times than expected.");
+  if (Mock.sd_ble_gap_rssi_start_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_rssi_start_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_rssi_stop_CallInstance, cmock_line, "Function 'sd_ble_gap_rssi_stop' called less times than expected.");
+  if (Mock.sd_ble_gap_rssi_stop_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_rssi_stop_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_rssi_get_CallInstance, cmock_line, "Function 'sd_ble_gap_rssi_get' called less times than expected.");
+  if (Mock.sd_ble_gap_rssi_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_rssi_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_scan_start_CallInstance, cmock_line, "Function 'sd_ble_gap_scan_start' called less times than expected.");
+  if (Mock.sd_ble_gap_scan_start_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_scan_start_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_scan_stop_CallInstance, cmock_line, "Function 'sd_ble_gap_scan_stop' called less times than expected.");
+  if (Mock.sd_ble_gap_scan_stop_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_scan_stop_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_connect_CallInstance, cmock_line, "Function 'sd_ble_gap_connect' called less times than expected.");
+  if (Mock.sd_ble_gap_connect_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_connect_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_connect_cancel_CallInstance, cmock_line, "Function 'sd_ble_gap_connect_cancel' called less times than expected.");
+  if (Mock.sd_ble_gap_connect_cancel_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_connect_cancel_CallInstance = CMOCK_GUTS_NONE;
+}
+
+void mock_ble_gap_Init(void)
+{
+  mock_ble_gap_Destroy();
+}
+
+void mock_ble_gap_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  Mock.sd_ble_gap_addr_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_addr_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_addr_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_addr_get_CallbackCalls = 0;
+  Mock.sd_ble_gap_whitelist_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_whitelist_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_device_identities_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_device_identities_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_privacy_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_privacy_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_privacy_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_privacy_get_CallbackCalls = 0;
+  Mock.sd_ble_gap_adv_data_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_adv_data_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_adv_start_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_adv_start_CallbackCalls = 0;
+  Mock.sd_ble_gap_adv_stop_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_adv_stop_CallbackCalls = 0;
+  Mock.sd_ble_gap_conn_param_update_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_conn_param_update_CallbackCalls = 0;
+  Mock.sd_ble_gap_disconnect_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_disconnect_CallbackCalls = 0;
+  Mock.sd_ble_gap_tx_power_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_tx_power_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_appearance_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_appearance_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_appearance_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_appearance_get_CallbackCalls = 0;
+  Mock.sd_ble_gap_ppcp_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_ppcp_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_ppcp_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_ppcp_get_CallbackCalls = 0;
+  Mock.sd_ble_gap_device_name_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_device_name_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_device_name_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_device_name_get_CallbackCalls = 0;
+  Mock.sd_ble_gap_authenticate_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_authenticate_CallbackCalls = 0;
+  Mock.sd_ble_gap_sec_params_reply_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_sec_params_reply_CallbackCalls = 0;
+  Mock.sd_ble_gap_auth_key_reply_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_auth_key_reply_CallbackCalls = 0;
+  Mock.sd_ble_gap_lesc_dhkey_reply_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_lesc_dhkey_reply_CallbackCalls = 0;
+  Mock.sd_ble_gap_keypress_notify_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_keypress_notify_CallbackCalls = 0;
+  Mock.sd_ble_gap_lesc_oob_data_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_lesc_oob_data_get_CallbackCalls = 0;
+  Mock.sd_ble_gap_lesc_oob_data_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_lesc_oob_data_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_encrypt_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_encrypt_CallbackCalls = 0;
+  Mock.sd_ble_gap_sec_info_reply_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_sec_info_reply_CallbackCalls = 0;
+  Mock.sd_ble_gap_conn_sec_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_conn_sec_get_CallbackCalls = 0;
+  Mock.sd_ble_gap_rssi_start_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_rssi_start_CallbackCalls = 0;
+  Mock.sd_ble_gap_rssi_stop_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_rssi_stop_CallbackCalls = 0;
+  Mock.sd_ble_gap_rssi_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_rssi_get_CallbackCalls = 0;
+  Mock.sd_ble_gap_scan_start_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_scan_start_CallbackCalls = 0;
+  Mock.sd_ble_gap_scan_stop_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_scan_stop_CallbackCalls = 0;
+  Mock.sd_ble_gap_connect_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_connect_CallbackCalls = 0;
+  Mock.sd_ble_gap_connect_cancel_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_connect_cancel_CallbackCalls = 0;
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+uint32_t sd_ble_gap_addr_set(ble_gap_addr_t const* p_addr)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_addr_set_CallInstance);
+  Mock.sd_ble_gap_addr_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_addr_set_CallInstance);
+  if (Mock.sd_ble_gap_addr_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_addr_set_FinalReturn;
+    Mock.sd_ble_gap_addr_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_addr_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_addr_set_CallbackFunctionPointer(p_addr, Mock.sd_ble_gap_addr_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_addr_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_addr_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_addr_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_addr)
+  {
+    if (cmock_call_instance->Expected_p_addr == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_addr, cmock_line, "Expected NULL. Function 'sd_ble_gap_addr_set' called with unexpected value for argument 'p_addr'."); }
+    else if (cmock_call_instance->Expected_p_addr_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_addr, p_addr, cmock_line, "Function 'sd_ble_gap_addr_set' called with unexpected value for argument 'p_addr'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_addr), (void*)(p_addr), sizeof(ble_gap_addr_t), cmock_call_instance->Expected_p_addr_Depth, cmock_line, "Function 'sd_ble_gap_addr_set' called with unexpected value for argument 'p_addr'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_addr_Used)
+  {
+    memcpy((void*)p_addr, (void*)cmock_call_instance->ReturnThruPtr_p_addr_Val,
+      cmock_call_instance->ReturnThruPtr_p_addr_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_addr_set(CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE* cmock_call_instance, ble_gap_addr_t const* p_addr, int p_addr_Depth)
+{
+  cmock_call_instance->Expected_p_addr = p_addr;
+  cmock_call_instance->Expected_p_addr_Depth = p_addr_Depth;
+  cmock_call_instance->IgnoreArg_p_addr = 0;
+  cmock_call_instance->ReturnThruPtr_p_addr_Used = 0;
+}
+
+void sd_ble_gap_addr_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_addr_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_addr_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_addr_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_addr_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_addr, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_addr_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_addr_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_addr_set(cmock_call_instance, p_addr, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_addr_set_StubWithCallback(CMOCK_sd_ble_gap_addr_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_addr_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_addr_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_addr, int p_addr_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_addr_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_addr_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_addr_set(cmock_call_instance, p_addr, p_addr_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_addr_set_CMockReturnMemThruPtr_p_addr(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_addr, int cmock_size)
+{
+  CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_addr_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_addr ReturnThruPtr called before Expect on 'sd_ble_gap_addr_set'.");
+  cmock_call_instance->ReturnThruPtr_p_addr_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_addr_Val = p_addr;
+  cmock_call_instance->ReturnThruPtr_p_addr_Size = cmock_size;
+}
+
+void sd_ble_gap_addr_set_CMockIgnoreArg_p_addr(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_addr_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_addr IgnoreArg called before Expect on 'sd_ble_gap_addr_set'.");
+  cmock_call_instance->IgnoreArg_p_addr = 1;
+}
+
+uint32_t sd_ble_gap_addr_get(ble_gap_addr_t* p_addr)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_addr_get_CallInstance);
+  Mock.sd_ble_gap_addr_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_addr_get_CallInstance);
+  if (Mock.sd_ble_gap_addr_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_addr_get_FinalReturn;
+    Mock.sd_ble_gap_addr_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_addr_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_addr_get_CallbackFunctionPointer(p_addr, Mock.sd_ble_gap_addr_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_addr_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_addr_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_addr_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_addr)
+  {
+    if (cmock_call_instance->Expected_p_addr == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_addr, cmock_line, "Expected NULL. Function 'sd_ble_gap_addr_get' called with unexpected value for argument 'p_addr'."); }
+    else if (cmock_call_instance->Expected_p_addr_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_addr, p_addr, cmock_line, "Function 'sd_ble_gap_addr_get' called with unexpected value for argument 'p_addr'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_addr), (void*)(p_addr), sizeof(ble_gap_addr_t), cmock_call_instance->Expected_p_addr_Depth, cmock_line, "Function 'sd_ble_gap_addr_get' called with unexpected value for argument 'p_addr'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_addr_Used)
+  {
+    memcpy((void*)p_addr, (void*)cmock_call_instance->ReturnThruPtr_p_addr_Val,
+      cmock_call_instance->ReturnThruPtr_p_addr_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_addr_get(CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE* cmock_call_instance, ble_gap_addr_t* p_addr, int p_addr_Depth)
+{
+  cmock_call_instance->Expected_p_addr = p_addr;
+  cmock_call_instance->Expected_p_addr_Depth = p_addr_Depth;
+  cmock_call_instance->IgnoreArg_p_addr = 0;
+  cmock_call_instance->ReturnThruPtr_p_addr_Used = 0;
+}
+
+void sd_ble_gap_addr_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_addr_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_addr_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_addr_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_addr_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t* p_addr, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_addr_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_addr_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_addr_get(cmock_call_instance, p_addr, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_addr_get_StubWithCallback(CMOCK_sd_ble_gap_addr_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_addr_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_addr_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t* p_addr, int p_addr_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_addr_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_addr_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_addr_get(cmock_call_instance, p_addr, p_addr_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_addr_get_CMockReturnMemThruPtr_p_addr(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t* p_addr, int cmock_size)
+{
+  CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_addr_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_addr ReturnThruPtr called before Expect on 'sd_ble_gap_addr_get'.");
+  cmock_call_instance->ReturnThruPtr_p_addr_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_addr_Val = p_addr;
+  cmock_call_instance->ReturnThruPtr_p_addr_Size = cmock_size;
+}
+
+void sd_ble_gap_addr_get_CMockIgnoreArg_p_addr(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_addr_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_addr IgnoreArg called before Expect on 'sd_ble_gap_addr_get'.");
+  cmock_call_instance->IgnoreArg_p_addr = 1;
+}
+
+uint32_t sd_ble_gap_whitelist_set(ble_gap_addr_t const* const* pp_wl_addrs, uint8_t len)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_whitelist_set_CallInstance);
+  Mock.sd_ble_gap_whitelist_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_whitelist_set_CallInstance);
+  if (Mock.sd_ble_gap_whitelist_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_whitelist_set_FinalReturn;
+    Mock.sd_ble_gap_whitelist_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_whitelist_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_whitelist_set_CallbackFunctionPointer(pp_wl_addrs, len, Mock.sd_ble_gap_whitelist_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_whitelist_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_whitelist_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_whitelist_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_pp_wl_addrs)
+  {
+    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pp_wl_addrs, pp_wl_addrs, cmock_line, "Function 'sd_ble_gap_whitelist_set' called with unexpected value for argument 'pp_wl_addrs'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_len)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_len, len, cmock_line, "Function 'sd_ble_gap_whitelist_set' called with unexpected value for argument 'len'.");
+  }
+  if (cmock_call_instance->ReturnThruPtr_pp_wl_addrs_Used)
+  {
+    memcpy((void*)pp_wl_addrs, (void*)cmock_call_instance->ReturnThruPtr_pp_wl_addrs_Val,
+      cmock_call_instance->ReturnThruPtr_pp_wl_addrs_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_whitelist_set(CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE* cmock_call_instance, ble_gap_addr_t const* const* pp_wl_addrs, int pp_wl_addrs_Depth, uint8_t len)
+{
+  cmock_call_instance->Expected_pp_wl_addrs = pp_wl_addrs;
+  cmock_call_instance->Expected_pp_wl_addrs_Depth = pp_wl_addrs_Depth;
+  cmock_call_instance->IgnoreArg_pp_wl_addrs = 0;
+  cmock_call_instance->ReturnThruPtr_pp_wl_addrs_Used = 0;
+  cmock_call_instance->Expected_len = len;
+  cmock_call_instance->IgnoreArg_len = 0;
+}
+
+void sd_ble_gap_whitelist_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_whitelist_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_whitelist_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_whitelist_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_whitelist_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* const* pp_wl_addrs, uint8_t len, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_whitelist_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_whitelist_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_whitelist_set(cmock_call_instance, pp_wl_addrs, 0, len);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_whitelist_set_StubWithCallback(CMOCK_sd_ble_gap_whitelist_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_whitelist_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_whitelist_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* const* pp_wl_addrs, int pp_wl_addrs_Depth, uint8_t len, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_whitelist_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_whitelist_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_whitelist_set(cmock_call_instance, pp_wl_addrs, pp_wl_addrs_Depth, len);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_whitelist_set_CMockReturnMemThruPtr_pp_wl_addrs(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* const* pp_wl_addrs, int cmock_size)
+{
+  CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_whitelist_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "pp_wl_addrs ReturnThruPtr called before Expect on 'sd_ble_gap_whitelist_set'.");
+  cmock_call_instance->ReturnThruPtr_pp_wl_addrs_Used = 1;
+  cmock_call_instance->ReturnThruPtr_pp_wl_addrs_Val = pp_wl_addrs;
+  cmock_call_instance->ReturnThruPtr_pp_wl_addrs_Size = cmock_size;
+}
+
+void sd_ble_gap_whitelist_set_CMockIgnoreArg_pp_wl_addrs(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_whitelist_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "pp_wl_addrs IgnoreArg called before Expect on 'sd_ble_gap_whitelist_set'.");
+  cmock_call_instance->IgnoreArg_pp_wl_addrs = 1;
+}
+
+void sd_ble_gap_whitelist_set_CMockIgnoreArg_len(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_whitelist_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "len IgnoreArg called before Expect on 'sd_ble_gap_whitelist_set'.");
+  cmock_call_instance->IgnoreArg_len = 1;
+}
+
+uint32_t sd_ble_gap_device_identities_set(ble_gap_id_key_t const* const* pp_id_keys, ble_gap_irk_t const* const* pp_local_irks, uint8_t len)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_device_identities_set_CallInstance);
+  Mock.sd_ble_gap_device_identities_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_device_identities_set_CallInstance);
+  if (Mock.sd_ble_gap_device_identities_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_device_identities_set_FinalReturn;
+    Mock.sd_ble_gap_device_identities_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_device_identities_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_device_identities_set_CallbackFunctionPointer(pp_id_keys, pp_local_irks, len, Mock.sd_ble_gap_device_identities_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_device_identities_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_device_identities_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_device_identities_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_pp_id_keys)
+  {
+    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pp_id_keys, pp_id_keys, cmock_line, "Function 'sd_ble_gap_device_identities_set' called with unexpected value for argument 'pp_id_keys'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_pp_local_irks)
+  {
+    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pp_local_irks, pp_local_irks, cmock_line, "Function 'sd_ble_gap_device_identities_set' called with unexpected value for argument 'pp_local_irks'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_len)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_len, len, cmock_line, "Function 'sd_ble_gap_device_identities_set' called with unexpected value for argument 'len'.");
+  }
+  if (cmock_call_instance->ReturnThruPtr_pp_id_keys_Used)
+  {
+    memcpy((void*)pp_id_keys, (void*)cmock_call_instance->ReturnThruPtr_pp_id_keys_Val,
+      cmock_call_instance->ReturnThruPtr_pp_id_keys_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_pp_local_irks_Used)
+  {
+    memcpy((void*)pp_local_irks, (void*)cmock_call_instance->ReturnThruPtr_pp_local_irks_Val,
+      cmock_call_instance->ReturnThruPtr_pp_local_irks_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_device_identities_set(CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance, ble_gap_id_key_t const* const* pp_id_keys, int pp_id_keys_Depth, ble_gap_irk_t const* const* pp_local_irks, int pp_local_irks_Depth, uint8_t len)
+{
+  cmock_call_instance->Expected_pp_id_keys = pp_id_keys;
+  cmock_call_instance->Expected_pp_id_keys_Depth = pp_id_keys_Depth;
+  cmock_call_instance->IgnoreArg_pp_id_keys = 0;
+  cmock_call_instance->ReturnThruPtr_pp_id_keys_Used = 0;
+  cmock_call_instance->Expected_pp_local_irks = pp_local_irks;
+  cmock_call_instance->Expected_pp_local_irks_Depth = pp_local_irks_Depth;
+  cmock_call_instance->IgnoreArg_pp_local_irks = 0;
+  cmock_call_instance->ReturnThruPtr_pp_local_irks_Used = 0;
+  cmock_call_instance->Expected_len = len;
+  cmock_call_instance->IgnoreArg_len = 0;
+}
+
+void sd_ble_gap_device_identities_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_identities_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_identities_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_device_identities_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_device_identities_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_id_key_t const* const* pp_id_keys, ble_gap_irk_t const* const* pp_local_irks, uint8_t len, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_identities_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_identities_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_device_identities_set(cmock_call_instance, pp_id_keys, 0, pp_local_irks, 0, len);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_device_identities_set_StubWithCallback(CMOCK_sd_ble_gap_device_identities_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_device_identities_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_device_identities_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_id_key_t const* const* pp_id_keys, int pp_id_keys_Depth, ble_gap_irk_t const* const* pp_local_irks, int pp_local_irks_Depth, uint8_t len, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_identities_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_identities_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_device_identities_set(cmock_call_instance, pp_id_keys, pp_id_keys_Depth, pp_local_irks, pp_local_irks_Depth, len);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_id_keys(UNITY_LINE_TYPE cmock_line, ble_gap_id_key_t const* const* pp_id_keys, int cmock_size)
+{
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_identities_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "pp_id_keys ReturnThruPtr called before Expect on 'sd_ble_gap_device_identities_set'.");
+  cmock_call_instance->ReturnThruPtr_pp_id_keys_Used = 1;
+  cmock_call_instance->ReturnThruPtr_pp_id_keys_Val = pp_id_keys;
+  cmock_call_instance->ReturnThruPtr_pp_id_keys_Size = cmock_size;
+}
+
+void sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_local_irks(UNITY_LINE_TYPE cmock_line, ble_gap_irk_t const* const* pp_local_irks, int cmock_size)
+{
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_identities_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "pp_local_irks ReturnThruPtr called before Expect on 'sd_ble_gap_device_identities_set'.");
+  cmock_call_instance->ReturnThruPtr_pp_local_irks_Used = 1;
+  cmock_call_instance->ReturnThruPtr_pp_local_irks_Val = pp_local_irks;
+  cmock_call_instance->ReturnThruPtr_pp_local_irks_Size = cmock_size;
+}
+
+void sd_ble_gap_device_identities_set_CMockIgnoreArg_pp_id_keys(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_identities_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "pp_id_keys IgnoreArg called before Expect on 'sd_ble_gap_device_identities_set'.");
+  cmock_call_instance->IgnoreArg_pp_id_keys = 1;
+}
+
+void sd_ble_gap_device_identities_set_CMockIgnoreArg_pp_local_irks(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_identities_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "pp_local_irks IgnoreArg called before Expect on 'sd_ble_gap_device_identities_set'.");
+  cmock_call_instance->IgnoreArg_pp_local_irks = 1;
+}
+
+void sd_ble_gap_device_identities_set_CMockIgnoreArg_len(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_identities_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "len IgnoreArg called before Expect on 'sd_ble_gap_device_identities_set'.");
+  cmock_call_instance->IgnoreArg_len = 1;
+}
+
+uint32_t sd_ble_gap_privacy_set(ble_gap_privacy_params_t const* p_privacy_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_privacy_set_CallInstance);
+  Mock.sd_ble_gap_privacy_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_privacy_set_CallInstance);
+  if (Mock.sd_ble_gap_privacy_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_privacy_set_FinalReturn;
+    Mock.sd_ble_gap_privacy_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_privacy_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_privacy_set_CallbackFunctionPointer(p_privacy_params, Mock.sd_ble_gap_privacy_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_privacy_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_privacy_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_privacy_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_privacy_params)
+  {
+    if (cmock_call_instance->Expected_p_privacy_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_privacy_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_privacy_set' called with unexpected value for argument 'p_privacy_params'."); }
+    else if (cmock_call_instance->Expected_p_privacy_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_privacy_params, p_privacy_params, cmock_line, "Function 'sd_ble_gap_privacy_set' called with unexpected value for argument 'p_privacy_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_privacy_params), (void*)(p_privacy_params), sizeof(ble_gap_privacy_params_t), cmock_call_instance->Expected_p_privacy_params_Depth, cmock_line, "Function 'sd_ble_gap_privacy_set' called with unexpected value for argument 'p_privacy_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_privacy_params_Used)
+  {
+    memcpy((void*)p_privacy_params, (void*)cmock_call_instance->ReturnThruPtr_p_privacy_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_privacy_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_privacy_set(CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE* cmock_call_instance, ble_gap_privacy_params_t const* p_privacy_params, int p_privacy_params_Depth)
+{
+  cmock_call_instance->Expected_p_privacy_params = p_privacy_params;
+  cmock_call_instance->Expected_p_privacy_params_Depth = p_privacy_params_Depth;
+  cmock_call_instance->IgnoreArg_p_privacy_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_privacy_params_Used = 0;
+}
+
+void sd_ble_gap_privacy_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_privacy_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_privacy_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_privacy_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_privacy_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t const* p_privacy_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_privacy_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_privacy_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_privacy_set(cmock_call_instance, p_privacy_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_privacy_set_StubWithCallback(CMOCK_sd_ble_gap_privacy_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_privacy_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_privacy_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t const* p_privacy_params, int p_privacy_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_privacy_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_privacy_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_privacy_set(cmock_call_instance, p_privacy_params, p_privacy_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_privacy_set_CMockReturnMemThruPtr_p_privacy_params(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t const* p_privacy_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_privacy_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_privacy_params ReturnThruPtr called before Expect on 'sd_ble_gap_privacy_set'.");
+  cmock_call_instance->ReturnThruPtr_p_privacy_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_privacy_params_Val = p_privacy_params;
+  cmock_call_instance->ReturnThruPtr_p_privacy_params_Size = cmock_size;
+}
+
+void sd_ble_gap_privacy_set_CMockIgnoreArg_p_privacy_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_privacy_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_privacy_params IgnoreArg called before Expect on 'sd_ble_gap_privacy_set'.");
+  cmock_call_instance->IgnoreArg_p_privacy_params = 1;
+}
+
+uint32_t sd_ble_gap_privacy_get(ble_gap_privacy_params_t* p_privacy_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_privacy_get_CallInstance);
+  Mock.sd_ble_gap_privacy_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_privacy_get_CallInstance);
+  if (Mock.sd_ble_gap_privacy_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_privacy_get_FinalReturn;
+    Mock.sd_ble_gap_privacy_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_privacy_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_privacy_get_CallbackFunctionPointer(p_privacy_params, Mock.sd_ble_gap_privacy_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_privacy_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_privacy_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_privacy_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_privacy_params)
+  {
+    if (cmock_call_instance->Expected_p_privacy_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_privacy_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_privacy_get' called with unexpected value for argument 'p_privacy_params'."); }
+    else if (cmock_call_instance->Expected_p_privacy_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_privacy_params, p_privacy_params, cmock_line, "Function 'sd_ble_gap_privacy_get' called with unexpected value for argument 'p_privacy_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_privacy_params), (void*)(p_privacy_params), sizeof(ble_gap_privacy_params_t), cmock_call_instance->Expected_p_privacy_params_Depth, cmock_line, "Function 'sd_ble_gap_privacy_get' called with unexpected value for argument 'p_privacy_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_privacy_params_Used)
+  {
+    memcpy((void*)p_privacy_params, (void*)cmock_call_instance->ReturnThruPtr_p_privacy_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_privacy_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_privacy_get(CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE* cmock_call_instance, ble_gap_privacy_params_t* p_privacy_params, int p_privacy_params_Depth)
+{
+  cmock_call_instance->Expected_p_privacy_params = p_privacy_params;
+  cmock_call_instance->Expected_p_privacy_params_Depth = p_privacy_params_Depth;
+  cmock_call_instance->IgnoreArg_p_privacy_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_privacy_params_Used = 0;
+}
+
+void sd_ble_gap_privacy_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_privacy_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_privacy_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_privacy_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_privacy_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t* p_privacy_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_privacy_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_privacy_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_privacy_get(cmock_call_instance, p_privacy_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_privacy_get_StubWithCallback(CMOCK_sd_ble_gap_privacy_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_privacy_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_privacy_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t* p_privacy_params, int p_privacy_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_privacy_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_privacy_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_privacy_get(cmock_call_instance, p_privacy_params, p_privacy_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_privacy_get_CMockReturnMemThruPtr_p_privacy_params(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t* p_privacy_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_privacy_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_privacy_params ReturnThruPtr called before Expect on 'sd_ble_gap_privacy_get'.");
+  cmock_call_instance->ReturnThruPtr_p_privacy_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_privacy_params_Val = p_privacy_params;
+  cmock_call_instance->ReturnThruPtr_p_privacy_params_Size = cmock_size;
+}
+
+void sd_ble_gap_privacy_get_CMockIgnoreArg_p_privacy_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_privacy_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_privacy_params IgnoreArg called before Expect on 'sd_ble_gap_privacy_get'.");
+  cmock_call_instance->IgnoreArg_p_privacy_params = 1;
+}
+
+uint32_t sd_ble_gap_adv_data_set(uint8_t const* p_data, uint8_t dlen, uint8_t const* p_sr_data, uint8_t srdlen)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_adv_data_set_CallInstance);
+  Mock.sd_ble_gap_adv_data_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_adv_data_set_CallInstance);
+  if (Mock.sd_ble_gap_adv_data_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_adv_data_set_FinalReturn;
+    Mock.sd_ble_gap_adv_data_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_adv_data_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_adv_data_set_CallbackFunctionPointer(p_data, dlen, p_sr_data, srdlen, Mock.sd_ble_gap_adv_data_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_adv_data_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_adv_data_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_adv_data_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_data)
+  {
+    if (cmock_call_instance->Expected_p_data == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_data, cmock_line, "Expected NULL. Function 'sd_ble_gap_adv_data_set' called with unexpected value for argument 'p_data'."); }
+    else if (cmock_call_instance->Expected_p_data_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_data, p_data, cmock_line, "Function 'sd_ble_gap_adv_data_set' called with unexpected value for argument 'p_data'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_data, p_data, cmock_call_instance->Expected_p_data_Depth, cmock_line, "Function 'sd_ble_gap_adv_data_set' called with unexpected value for argument 'p_data'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_dlen)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_dlen, dlen, cmock_line, "Function 'sd_ble_gap_adv_data_set' called with unexpected value for argument 'dlen'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_sr_data)
+  {
+    if (cmock_call_instance->Expected_p_sr_data == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_sr_data, cmock_line, "Expected NULL. Function 'sd_ble_gap_adv_data_set' called with unexpected value for argument 'p_sr_data'."); }
+    else if (cmock_call_instance->Expected_p_sr_data_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_sr_data, p_sr_data, cmock_line, "Function 'sd_ble_gap_adv_data_set' called with unexpected value for argument 'p_sr_data'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_sr_data, p_sr_data, cmock_call_instance->Expected_p_sr_data_Depth, cmock_line, "Function 'sd_ble_gap_adv_data_set' called with unexpected value for argument 'p_sr_data'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_srdlen)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_srdlen, srdlen, cmock_line, "Function 'sd_ble_gap_adv_data_set' called with unexpected value for argument 'srdlen'.");
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_data_Used)
+  {
+    memcpy((void*)p_data, (void*)cmock_call_instance->ReturnThruPtr_p_data_Val,
+      cmock_call_instance->ReturnThruPtr_p_data_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_sr_data_Used)
+  {
+    memcpy((void*)p_sr_data, (void*)cmock_call_instance->ReturnThruPtr_p_sr_data_Val,
+      cmock_call_instance->ReturnThruPtr_p_sr_data_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_adv_data_set(CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance, uint8_t const* p_data, int p_data_Depth, uint8_t dlen, uint8_t const* p_sr_data, int p_sr_data_Depth, uint8_t srdlen)
+{
+  cmock_call_instance->Expected_p_data = p_data;
+  cmock_call_instance->Expected_p_data_Depth = p_data_Depth;
+  cmock_call_instance->IgnoreArg_p_data = 0;
+  cmock_call_instance->ReturnThruPtr_p_data_Used = 0;
+  cmock_call_instance->Expected_dlen = dlen;
+  cmock_call_instance->IgnoreArg_dlen = 0;
+  cmock_call_instance->Expected_p_sr_data = p_sr_data;
+  cmock_call_instance->Expected_p_sr_data_Depth = p_sr_data_Depth;
+  cmock_call_instance->IgnoreArg_p_sr_data = 0;
+  cmock_call_instance->ReturnThruPtr_p_sr_data_Used = 0;
+  cmock_call_instance->Expected_srdlen = srdlen;
+  cmock_call_instance->IgnoreArg_srdlen = 0;
+}
+
+void sd_ble_gap_adv_data_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_adv_data_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_adv_data_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_adv_data_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_adv_data_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t const* p_data, uint8_t dlen, uint8_t const* p_sr_data, uint8_t srdlen, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_adv_data_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_adv_data_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_adv_data_set(cmock_call_instance, p_data, 0, dlen, p_sr_data, 0, srdlen);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_adv_data_set_StubWithCallback(CMOCK_sd_ble_gap_adv_data_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_adv_data_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_adv_data_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t const* p_data, int p_data_Depth, uint8_t dlen, uint8_t const* p_sr_data, int p_sr_data_Depth, uint8_t srdlen, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_adv_data_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_adv_data_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_adv_data_set(cmock_call_instance, p_data, p_data_Depth, dlen, p_sr_data, p_sr_data_Depth, srdlen);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_data(UNITY_LINE_TYPE cmock_line, uint8_t const* p_data, int cmock_size)
+{
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_adv_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_data ReturnThruPtr called before Expect on 'sd_ble_gap_adv_data_set'.");
+  cmock_call_instance->ReturnThruPtr_p_data_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_data_Val = p_data;
+  cmock_call_instance->ReturnThruPtr_p_data_Size = cmock_size;
+}
+
+void sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_sr_data(UNITY_LINE_TYPE cmock_line, uint8_t const* p_sr_data, int cmock_size)
+{
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_adv_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sr_data ReturnThruPtr called before Expect on 'sd_ble_gap_adv_data_set'.");
+  cmock_call_instance->ReturnThruPtr_p_sr_data_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_sr_data_Val = p_sr_data;
+  cmock_call_instance->ReturnThruPtr_p_sr_data_Size = cmock_size;
+}
+
+void sd_ble_gap_adv_data_set_CMockIgnoreArg_p_data(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_adv_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_data IgnoreArg called before Expect on 'sd_ble_gap_adv_data_set'.");
+  cmock_call_instance->IgnoreArg_p_data = 1;
+}
+
+void sd_ble_gap_adv_data_set_CMockIgnoreArg_dlen(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_adv_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "dlen IgnoreArg called before Expect on 'sd_ble_gap_adv_data_set'.");
+  cmock_call_instance->IgnoreArg_dlen = 1;
+}
+
+void sd_ble_gap_adv_data_set_CMockIgnoreArg_p_sr_data(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_adv_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sr_data IgnoreArg called before Expect on 'sd_ble_gap_adv_data_set'.");
+  cmock_call_instance->IgnoreArg_p_sr_data = 1;
+}
+
+void sd_ble_gap_adv_data_set_CMockIgnoreArg_srdlen(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_adv_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "srdlen IgnoreArg called before Expect on 'sd_ble_gap_adv_data_set'.");
+  cmock_call_instance->IgnoreArg_srdlen = 1;
+}
+
+uint32_t sd_ble_gap_adv_start(ble_gap_adv_params_t const* p_adv_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_adv_start_CallInstance);
+  Mock.sd_ble_gap_adv_start_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_adv_start_CallInstance);
+  if (Mock.sd_ble_gap_adv_start_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_adv_start_FinalReturn;
+    Mock.sd_ble_gap_adv_start_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_adv_start_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_adv_start_CallbackFunctionPointer(p_adv_params, Mock.sd_ble_gap_adv_start_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_adv_start' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_adv_start' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_adv_start' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_adv_params)
+  {
+    if (cmock_call_instance->Expected_p_adv_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_adv_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_adv_start' called with unexpected value for argument 'p_adv_params'."); }
+    else if (cmock_call_instance->Expected_p_adv_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_adv_params, p_adv_params, cmock_line, "Function 'sd_ble_gap_adv_start' called with unexpected value for argument 'p_adv_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_adv_params), (void*)(p_adv_params), sizeof(ble_gap_adv_params_t), cmock_call_instance->Expected_p_adv_params_Depth, cmock_line, "Function 'sd_ble_gap_adv_start' called with unexpected value for argument 'p_adv_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_adv_params_Used)
+  {
+    memcpy((void*)p_adv_params, (void*)cmock_call_instance->ReturnThruPtr_p_adv_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_adv_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_adv_start(CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE* cmock_call_instance, ble_gap_adv_params_t const* p_adv_params, int p_adv_params_Depth)
+{
+  cmock_call_instance->Expected_p_adv_params = p_adv_params;
+  cmock_call_instance->Expected_p_adv_params_Depth = p_adv_params_Depth;
+  cmock_call_instance->IgnoreArg_p_adv_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_adv_params_Used = 0;
+}
+
+void sd_ble_gap_adv_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_adv_start_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_adv_start_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_adv_start_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_adv_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_adv_params_t const* p_adv_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_adv_start_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_adv_start_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_adv_start(cmock_call_instance, p_adv_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_adv_start_StubWithCallback(CMOCK_sd_ble_gap_adv_start_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_adv_start_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_adv_start_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_adv_params_t const* p_adv_params, int p_adv_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_adv_start_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_adv_start_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_adv_start(cmock_call_instance, p_adv_params, p_adv_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_adv_start_CMockReturnMemThruPtr_p_adv_params(UNITY_LINE_TYPE cmock_line, ble_gap_adv_params_t const* p_adv_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_adv_start_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_adv_params ReturnThruPtr called before Expect on 'sd_ble_gap_adv_start'.");
+  cmock_call_instance->ReturnThruPtr_p_adv_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_adv_params_Val = p_adv_params;
+  cmock_call_instance->ReturnThruPtr_p_adv_params_Size = cmock_size;
+}
+
+void sd_ble_gap_adv_start_CMockIgnoreArg_p_adv_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_adv_start_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_adv_params IgnoreArg called before Expect on 'sd_ble_gap_adv_start'.");
+  cmock_call_instance->IgnoreArg_p_adv_params = 1;
+}
+
+uint32_t sd_ble_gap_adv_stop(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_adv_stop_CallInstance);
+  Mock.sd_ble_gap_adv_stop_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_adv_stop_CallInstance);
+  if (Mock.sd_ble_gap_adv_stop_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_adv_stop_FinalReturn;
+    Mock.sd_ble_gap_adv_stop_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_adv_stop_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_adv_stop_CallbackFunctionPointer(Mock.sd_ble_gap_adv_stop_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_adv_stop' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_adv_stop' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_adv_stop' called later than expected.");
+  return cmock_call_instance->ReturnVal;
+}
+
+void sd_ble_gap_adv_stop_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_adv_stop_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_adv_stop_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_adv_stop_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_adv_stop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_adv_stop_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_adv_stop_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_adv_stop_StubWithCallback(CMOCK_sd_ble_gap_adv_stop_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_adv_stop_CallbackFunctionPointer = Callback;
+}
+
+uint32_t sd_ble_gap_conn_param_update(uint16_t conn_handle, ble_gap_conn_params_t const* p_conn_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_conn_param_update_CallInstance);
+  Mock.sd_ble_gap_conn_param_update_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_conn_param_update_CallInstance);
+  if (Mock.sd_ble_gap_conn_param_update_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_conn_param_update_FinalReturn;
+    Mock.sd_ble_gap_conn_param_update_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_conn_param_update_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_conn_param_update_CallbackFunctionPointer(conn_handle, p_conn_params, Mock.sd_ble_gap_conn_param_update_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_conn_param_update' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_conn_param_update' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_conn_param_update' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_conn_param_update' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_conn_params)
+  {
+    if (cmock_call_instance->Expected_p_conn_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_conn_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_conn_param_update' called with unexpected value for argument 'p_conn_params'."); }
+    else if (cmock_call_instance->Expected_p_conn_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_conn_params, p_conn_params, cmock_line, "Function 'sd_ble_gap_conn_param_update' called with unexpected value for argument 'p_conn_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_conn_params), (void*)(p_conn_params), sizeof(ble_gap_conn_params_t), cmock_call_instance->Expected_p_conn_params_Depth, cmock_line, "Function 'sd_ble_gap_conn_param_update' called with unexpected value for argument 'p_conn_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_conn_params_Used)
+  {
+    memcpy((void*)p_conn_params, (void*)cmock_call_instance->ReturnThruPtr_p_conn_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_conn_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_conn_param_update(CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_conn_params = p_conn_params;
+  cmock_call_instance->Expected_p_conn_params_Depth = p_conn_params_Depth;
+  cmock_call_instance->IgnoreArg_p_conn_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Used = 0;
+}
+
+void sd_ble_gap_conn_param_update_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_conn_param_update_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_conn_param_update_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_conn_param_update_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_conn_param_update_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_conn_params_t const* p_conn_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_conn_param_update_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_conn_param_update_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_conn_param_update(cmock_call_instance, conn_handle, p_conn_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_conn_param_update_StubWithCallback(CMOCK_sd_ble_gap_conn_param_update_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_conn_param_update_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_conn_param_update_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_conn_param_update_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_conn_param_update_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_conn_param_update(cmock_call_instance, conn_handle, p_conn_params, p_conn_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_conn_param_update_CMockReturnMemThruPtr_p_conn_params(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_conn_param_update_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_params ReturnThruPtr called before Expect on 'sd_ble_gap_conn_param_update'.");
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Val = p_conn_params;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Size = cmock_size;
+}
+
+void sd_ble_gap_conn_param_update_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_conn_param_update_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_conn_param_update'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_conn_param_update_CMockIgnoreArg_p_conn_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_conn_param_update_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_params IgnoreArg called before Expect on 'sd_ble_gap_conn_param_update'.");
+  cmock_call_instance->IgnoreArg_p_conn_params = 1;
+}
+
+uint32_t sd_ble_gap_disconnect(uint16_t conn_handle, uint8_t hci_status_code)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_disconnect_CallInstance);
+  Mock.sd_ble_gap_disconnect_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_disconnect_CallInstance);
+  if (Mock.sd_ble_gap_disconnect_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_disconnect_FinalReturn;
+    Mock.sd_ble_gap_disconnect_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_disconnect_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_disconnect_CallbackFunctionPointer(conn_handle, hci_status_code, Mock.sd_ble_gap_disconnect_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_disconnect' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_disconnect' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_disconnect' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_disconnect' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_hci_status_code)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_hci_status_code, hci_status_code, cmock_line, "Function 'sd_ble_gap_disconnect' called with unexpected value for argument 'hci_status_code'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_disconnect(CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint8_t hci_status_code)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_hci_status_code = hci_status_code;
+  cmock_call_instance->IgnoreArg_hci_status_code = 0;
+}
+
+void sd_ble_gap_disconnect_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_disconnect_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_disconnect_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_disconnect_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_disconnect_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t hci_status_code, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_disconnect_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_disconnect_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_disconnect(cmock_call_instance, conn_handle, hci_status_code);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_disconnect_StubWithCallback(CMOCK_sd_ble_gap_disconnect_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_disconnect_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_disconnect_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_disconnect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_disconnect'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_disconnect_CMockIgnoreArg_hci_status_code(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_disconnect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "hci_status_code IgnoreArg called before Expect on 'sd_ble_gap_disconnect'.");
+  cmock_call_instance->IgnoreArg_hci_status_code = 1;
+}
+
+uint32_t sd_ble_gap_tx_power_set(int8_t tx_power)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_tx_power_set_CallInstance);
+  Mock.sd_ble_gap_tx_power_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_tx_power_set_CallInstance);
+  if (Mock.sd_ble_gap_tx_power_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_tx_power_set_FinalReturn;
+    Mock.sd_ble_gap_tx_power_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_tx_power_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_tx_power_set_CallbackFunctionPointer(tx_power, Mock.sd_ble_gap_tx_power_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_tx_power_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_tx_power_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_tx_power_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_tx_power)
+  {
+    UNITY_TEST_ASSERT_EQUAL_INT8(cmock_call_instance->Expected_tx_power, tx_power, cmock_line, "Function 'sd_ble_gap_tx_power_set' called with unexpected value for argument 'tx_power'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_tx_power_set(CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE* cmock_call_instance, int8_t tx_power)
+{
+  cmock_call_instance->Expected_tx_power = tx_power;
+  cmock_call_instance->IgnoreArg_tx_power = 0;
+}
+
+void sd_ble_gap_tx_power_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_tx_power_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_tx_power_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_tx_power_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_tx_power_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int8_t tx_power, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_tx_power_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_tx_power_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_tx_power_set(cmock_call_instance, tx_power);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_tx_power_set_StubWithCallback(CMOCK_sd_ble_gap_tx_power_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_tx_power_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_tx_power_set_CMockIgnoreArg_tx_power(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_tx_power_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "tx_power IgnoreArg called before Expect on 'sd_ble_gap_tx_power_set'.");
+  cmock_call_instance->IgnoreArg_tx_power = 1;
+}
+
+uint32_t sd_ble_gap_appearance_set(uint16_t appearance)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_appearance_set_CallInstance);
+  Mock.sd_ble_gap_appearance_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_appearance_set_CallInstance);
+  if (Mock.sd_ble_gap_appearance_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_appearance_set_FinalReturn;
+    Mock.sd_ble_gap_appearance_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_appearance_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_appearance_set_CallbackFunctionPointer(appearance, Mock.sd_ble_gap_appearance_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_appearance_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_appearance_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_appearance_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_appearance)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_appearance, appearance, cmock_line, "Function 'sd_ble_gap_appearance_set' called with unexpected value for argument 'appearance'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_appearance_set(CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE* cmock_call_instance, uint16_t appearance)
+{
+  cmock_call_instance->Expected_appearance = appearance;
+  cmock_call_instance->IgnoreArg_appearance = 0;
+}
+
+void sd_ble_gap_appearance_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_appearance_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_appearance_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_appearance_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_appearance_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t appearance, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_appearance_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_appearance_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_appearance_set(cmock_call_instance, appearance);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_appearance_set_StubWithCallback(CMOCK_sd_ble_gap_appearance_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_appearance_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_appearance_set_CMockIgnoreArg_appearance(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_appearance_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "appearance IgnoreArg called before Expect on 'sd_ble_gap_appearance_set'.");
+  cmock_call_instance->IgnoreArg_appearance = 1;
+}
+
+uint32_t sd_ble_gap_appearance_get(uint16_t* p_appearance)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_appearance_get_CallInstance);
+  Mock.sd_ble_gap_appearance_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_appearance_get_CallInstance);
+  if (Mock.sd_ble_gap_appearance_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_appearance_get_FinalReturn;
+    Mock.sd_ble_gap_appearance_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_appearance_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_appearance_get_CallbackFunctionPointer(p_appearance, Mock.sd_ble_gap_appearance_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_appearance_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_appearance_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_appearance_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_appearance)
+  {
+    if (cmock_call_instance->Expected_p_appearance == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_appearance, cmock_line, "Expected NULL. Function 'sd_ble_gap_appearance_get' called with unexpected value for argument 'p_appearance'."); }
+    else if (cmock_call_instance->Expected_p_appearance_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_appearance, p_appearance, cmock_line, "Function 'sd_ble_gap_appearance_get' called with unexpected value for argument 'p_appearance'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_p_appearance, p_appearance, cmock_call_instance->Expected_p_appearance_Depth, cmock_line, "Function 'sd_ble_gap_appearance_get' called with unexpected value for argument 'p_appearance'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_appearance_Used)
+  {
+    memcpy((void*)p_appearance, (void*)cmock_call_instance->ReturnThruPtr_p_appearance_Val,
+      cmock_call_instance->ReturnThruPtr_p_appearance_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_appearance_get(CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE* cmock_call_instance, uint16_t* p_appearance, int p_appearance_Depth)
+{
+  cmock_call_instance->Expected_p_appearance = p_appearance;
+  cmock_call_instance->Expected_p_appearance_Depth = p_appearance_Depth;
+  cmock_call_instance->IgnoreArg_p_appearance = 0;
+  cmock_call_instance->ReturnThruPtr_p_appearance_Used = 0;
+}
+
+void sd_ble_gap_appearance_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_appearance_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_appearance_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_appearance_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_appearance_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t* p_appearance, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_appearance_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_appearance_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_appearance_get(cmock_call_instance, p_appearance, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_appearance_get_StubWithCallback(CMOCK_sd_ble_gap_appearance_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_appearance_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_appearance_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t* p_appearance, int p_appearance_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_appearance_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_appearance_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_appearance_get(cmock_call_instance, p_appearance, p_appearance_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_appearance_get_CMockReturnMemThruPtr_p_appearance(UNITY_LINE_TYPE cmock_line, uint16_t* p_appearance, int cmock_size)
+{
+  CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_appearance_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_appearance ReturnThruPtr called before Expect on 'sd_ble_gap_appearance_get'.");
+  cmock_call_instance->ReturnThruPtr_p_appearance_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_appearance_Val = p_appearance;
+  cmock_call_instance->ReturnThruPtr_p_appearance_Size = cmock_size;
+}
+
+void sd_ble_gap_appearance_get_CMockIgnoreArg_p_appearance(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_appearance_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_appearance IgnoreArg called before Expect on 'sd_ble_gap_appearance_get'.");
+  cmock_call_instance->IgnoreArg_p_appearance = 1;
+}
+
+uint32_t sd_ble_gap_ppcp_set(ble_gap_conn_params_t const* p_conn_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_ppcp_set_CallInstance);
+  Mock.sd_ble_gap_ppcp_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_ppcp_set_CallInstance);
+  if (Mock.sd_ble_gap_ppcp_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_ppcp_set_FinalReturn;
+    Mock.sd_ble_gap_ppcp_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_ppcp_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_ppcp_set_CallbackFunctionPointer(p_conn_params, Mock.sd_ble_gap_ppcp_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_ppcp_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_ppcp_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_ppcp_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_conn_params)
+  {
+    if (cmock_call_instance->Expected_p_conn_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_conn_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_ppcp_set' called with unexpected value for argument 'p_conn_params'."); }
+    else if (cmock_call_instance->Expected_p_conn_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_conn_params, p_conn_params, cmock_line, "Function 'sd_ble_gap_ppcp_set' called with unexpected value for argument 'p_conn_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_conn_params), (void*)(p_conn_params), sizeof(ble_gap_conn_params_t), cmock_call_instance->Expected_p_conn_params_Depth, cmock_line, "Function 'sd_ble_gap_ppcp_set' called with unexpected value for argument 'p_conn_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_conn_params_Used)
+  {
+    memcpy((void*)p_conn_params, (void*)cmock_call_instance->ReturnThruPtr_p_conn_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_conn_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_ppcp_set(CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE* cmock_call_instance, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth)
+{
+  cmock_call_instance->Expected_p_conn_params = p_conn_params;
+  cmock_call_instance->Expected_p_conn_params_Depth = p_conn_params_Depth;
+  cmock_call_instance->IgnoreArg_p_conn_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Used = 0;
+}
+
+void sd_ble_gap_ppcp_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_ppcp_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_ppcp_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_ppcp_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_ppcp_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_ppcp_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_ppcp_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_ppcp_set(cmock_call_instance, p_conn_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_ppcp_set_StubWithCallback(CMOCK_sd_ble_gap_ppcp_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_ppcp_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_ppcp_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_ppcp_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_ppcp_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_ppcp_set(cmock_call_instance, p_conn_params, p_conn_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_ppcp_set_CMockReturnMemThruPtr_p_conn_params(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_ppcp_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_params ReturnThruPtr called before Expect on 'sd_ble_gap_ppcp_set'.");
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Val = p_conn_params;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Size = cmock_size;
+}
+
+void sd_ble_gap_ppcp_set_CMockIgnoreArg_p_conn_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_ppcp_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_params IgnoreArg called before Expect on 'sd_ble_gap_ppcp_set'.");
+  cmock_call_instance->IgnoreArg_p_conn_params = 1;
+}
+
+uint32_t sd_ble_gap_ppcp_get(ble_gap_conn_params_t* p_conn_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_ppcp_get_CallInstance);
+  Mock.sd_ble_gap_ppcp_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_ppcp_get_CallInstance);
+  if (Mock.sd_ble_gap_ppcp_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_ppcp_get_FinalReturn;
+    Mock.sd_ble_gap_ppcp_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_ppcp_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_ppcp_get_CallbackFunctionPointer(p_conn_params, Mock.sd_ble_gap_ppcp_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_ppcp_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_ppcp_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_ppcp_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_conn_params)
+  {
+    if (cmock_call_instance->Expected_p_conn_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_conn_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_ppcp_get' called with unexpected value for argument 'p_conn_params'."); }
+    else if (cmock_call_instance->Expected_p_conn_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_conn_params, p_conn_params, cmock_line, "Function 'sd_ble_gap_ppcp_get' called with unexpected value for argument 'p_conn_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_conn_params), (void*)(p_conn_params), sizeof(ble_gap_conn_params_t), cmock_call_instance->Expected_p_conn_params_Depth, cmock_line, "Function 'sd_ble_gap_ppcp_get' called with unexpected value for argument 'p_conn_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_conn_params_Used)
+  {
+    memcpy((void*)p_conn_params, (void*)cmock_call_instance->ReturnThruPtr_p_conn_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_conn_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_ppcp_get(CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE* cmock_call_instance, ble_gap_conn_params_t* p_conn_params, int p_conn_params_Depth)
+{
+  cmock_call_instance->Expected_p_conn_params = p_conn_params;
+  cmock_call_instance->Expected_p_conn_params_Depth = p_conn_params_Depth;
+  cmock_call_instance->IgnoreArg_p_conn_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Used = 0;
+}
+
+void sd_ble_gap_ppcp_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_ppcp_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_ppcp_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_ppcp_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_ppcp_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t* p_conn_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_ppcp_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_ppcp_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_ppcp_get(cmock_call_instance, p_conn_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_ppcp_get_StubWithCallback(CMOCK_sd_ble_gap_ppcp_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_ppcp_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_ppcp_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t* p_conn_params, int p_conn_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_ppcp_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_ppcp_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_ppcp_get(cmock_call_instance, p_conn_params, p_conn_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_ppcp_get_CMockReturnMemThruPtr_p_conn_params(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t* p_conn_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_ppcp_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_params ReturnThruPtr called before Expect on 'sd_ble_gap_ppcp_get'.");
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Val = p_conn_params;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Size = cmock_size;
+}
+
+void sd_ble_gap_ppcp_get_CMockIgnoreArg_p_conn_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_ppcp_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_params IgnoreArg called before Expect on 'sd_ble_gap_ppcp_get'.");
+  cmock_call_instance->IgnoreArg_p_conn_params = 1;
+}
+
+uint32_t sd_ble_gap_device_name_set(ble_gap_conn_sec_mode_t const* p_write_perm, uint8_t const* p_dev_name, uint16_t len)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_device_name_set_CallInstance);
+  Mock.sd_ble_gap_device_name_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_device_name_set_CallInstance);
+  if (Mock.sd_ble_gap_device_name_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_device_name_set_FinalReturn;
+    Mock.sd_ble_gap_device_name_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_device_name_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_device_name_set_CallbackFunctionPointer(p_write_perm, p_dev_name, len, Mock.sd_ble_gap_device_name_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_device_name_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_device_name_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_device_name_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_write_perm)
+  {
+    if (cmock_call_instance->Expected_p_write_perm == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_write_perm, cmock_line, "Expected NULL. Function 'sd_ble_gap_device_name_set' called with unexpected value for argument 'p_write_perm'."); }
+    else if (cmock_call_instance->Expected_p_write_perm_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_write_perm, p_write_perm, cmock_line, "Function 'sd_ble_gap_device_name_set' called with unexpected value for argument 'p_write_perm'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_write_perm), (void*)(p_write_perm), sizeof(ble_gap_conn_sec_mode_t), cmock_call_instance->Expected_p_write_perm_Depth, cmock_line, "Function 'sd_ble_gap_device_name_set' called with unexpected value for argument 'p_write_perm'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_dev_name)
+  {
+    if (cmock_call_instance->Expected_p_dev_name == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_dev_name, cmock_line, "Expected NULL. Function 'sd_ble_gap_device_name_set' called with unexpected value for argument 'p_dev_name'."); }
+    else if (cmock_call_instance->Expected_p_dev_name_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_dev_name, p_dev_name, cmock_line, "Function 'sd_ble_gap_device_name_set' called with unexpected value for argument 'p_dev_name'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_dev_name, p_dev_name, cmock_call_instance->Expected_p_dev_name_Depth, cmock_line, "Function 'sd_ble_gap_device_name_set' called with unexpected value for argument 'p_dev_name'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_len)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_len, len, cmock_line, "Function 'sd_ble_gap_device_name_set' called with unexpected value for argument 'len'.");
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_write_perm_Used)
+  {
+    memcpy((void*)p_write_perm, (void*)cmock_call_instance->ReturnThruPtr_p_write_perm_Val,
+      cmock_call_instance->ReturnThruPtr_p_write_perm_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_dev_name_Used)
+  {
+    memcpy((void*)p_dev_name, (void*)cmock_call_instance->ReturnThruPtr_p_dev_name_Val,
+      cmock_call_instance->ReturnThruPtr_p_dev_name_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_device_name_set(CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance, ble_gap_conn_sec_mode_t const* p_write_perm, int p_write_perm_Depth, uint8_t const* p_dev_name, int p_dev_name_Depth, uint16_t len)
+{
+  cmock_call_instance->Expected_p_write_perm = p_write_perm;
+  cmock_call_instance->Expected_p_write_perm_Depth = p_write_perm_Depth;
+  cmock_call_instance->IgnoreArg_p_write_perm = 0;
+  cmock_call_instance->ReturnThruPtr_p_write_perm_Used = 0;
+  cmock_call_instance->Expected_p_dev_name = p_dev_name;
+  cmock_call_instance->Expected_p_dev_name_Depth = p_dev_name_Depth;
+  cmock_call_instance->IgnoreArg_p_dev_name = 0;
+  cmock_call_instance->ReturnThruPtr_p_dev_name_Used = 0;
+  cmock_call_instance->Expected_len = len;
+  cmock_call_instance->IgnoreArg_len = 0;
+}
+
+void sd_ble_gap_device_name_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_name_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_name_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_device_name_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_device_name_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_sec_mode_t const* p_write_perm, uint8_t const* p_dev_name, uint16_t len, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_name_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_name_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_device_name_set(cmock_call_instance, p_write_perm, 0, p_dev_name, 0, len);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_device_name_set_StubWithCallback(CMOCK_sd_ble_gap_device_name_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_device_name_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_device_name_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_sec_mode_t const* p_write_perm, int p_write_perm_Depth, uint8_t const* p_dev_name, int p_dev_name_Depth, uint16_t len, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_name_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_name_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_device_name_set(cmock_call_instance, p_write_perm, p_write_perm_Depth, p_dev_name, p_dev_name_Depth, len);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_write_perm(UNITY_LINE_TYPE cmock_line, ble_gap_conn_sec_mode_t const* p_write_perm, int cmock_size)
+{
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_write_perm ReturnThruPtr called before Expect on 'sd_ble_gap_device_name_set'.");
+  cmock_call_instance->ReturnThruPtr_p_write_perm_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_write_perm_Val = p_write_perm;
+  cmock_call_instance->ReturnThruPtr_p_write_perm_Size = cmock_size;
+}
+
+void sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_dev_name(UNITY_LINE_TYPE cmock_line, uint8_t const* p_dev_name, int cmock_size)
+{
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_dev_name ReturnThruPtr called before Expect on 'sd_ble_gap_device_name_set'.");
+  cmock_call_instance->ReturnThruPtr_p_dev_name_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_dev_name_Val = p_dev_name;
+  cmock_call_instance->ReturnThruPtr_p_dev_name_Size = cmock_size;
+}
+
+void sd_ble_gap_device_name_set_CMockIgnoreArg_p_write_perm(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_write_perm IgnoreArg called before Expect on 'sd_ble_gap_device_name_set'.");
+  cmock_call_instance->IgnoreArg_p_write_perm = 1;
+}
+
+void sd_ble_gap_device_name_set_CMockIgnoreArg_p_dev_name(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_dev_name IgnoreArg called before Expect on 'sd_ble_gap_device_name_set'.");
+  cmock_call_instance->IgnoreArg_p_dev_name = 1;
+}
+
+void sd_ble_gap_device_name_set_CMockIgnoreArg_len(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "len IgnoreArg called before Expect on 'sd_ble_gap_device_name_set'.");
+  cmock_call_instance->IgnoreArg_len = 1;
+}
+
+uint32_t sd_ble_gap_device_name_get(uint8_t* p_dev_name, uint16_t* p_len)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_device_name_get_CallInstance);
+  Mock.sd_ble_gap_device_name_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_device_name_get_CallInstance);
+  if (Mock.sd_ble_gap_device_name_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_device_name_get_FinalReturn;
+    Mock.sd_ble_gap_device_name_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_device_name_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_device_name_get_CallbackFunctionPointer(p_dev_name, p_len, Mock.sd_ble_gap_device_name_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_device_name_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_device_name_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_device_name_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_dev_name)
+  {
+    if (cmock_call_instance->Expected_p_dev_name == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_dev_name, cmock_line, "Expected NULL. Function 'sd_ble_gap_device_name_get' called with unexpected value for argument 'p_dev_name'."); }
+    else if (cmock_call_instance->Expected_p_dev_name_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_dev_name, p_dev_name, cmock_line, "Function 'sd_ble_gap_device_name_get' called with unexpected value for argument 'p_dev_name'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_dev_name, p_dev_name, cmock_call_instance->Expected_p_dev_name_Depth, cmock_line, "Function 'sd_ble_gap_device_name_get' called with unexpected value for argument 'p_dev_name'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_len)
+  {
+    if (cmock_call_instance->Expected_p_len == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_len, cmock_line, "Expected NULL. Function 'sd_ble_gap_device_name_get' called with unexpected value for argument 'p_len'."); }
+    else if (cmock_call_instance->Expected_p_len_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_len, p_len, cmock_line, "Function 'sd_ble_gap_device_name_get' called with unexpected value for argument 'p_len'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_p_len, p_len, cmock_call_instance->Expected_p_len_Depth, cmock_line, "Function 'sd_ble_gap_device_name_get' called with unexpected value for argument 'p_len'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_dev_name_Used)
+  {
+    memcpy((void*)p_dev_name, (void*)cmock_call_instance->ReturnThruPtr_p_dev_name_Val,
+      cmock_call_instance->ReturnThruPtr_p_dev_name_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_len_Used)
+  {
+    memcpy((void*)p_len, (void*)cmock_call_instance->ReturnThruPtr_p_len_Val,
+      cmock_call_instance->ReturnThruPtr_p_len_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_device_name_get(CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance, uint8_t* p_dev_name, int p_dev_name_Depth, uint16_t* p_len, int p_len_Depth)
+{
+  cmock_call_instance->Expected_p_dev_name = p_dev_name;
+  cmock_call_instance->Expected_p_dev_name_Depth = p_dev_name_Depth;
+  cmock_call_instance->IgnoreArg_p_dev_name = 0;
+  cmock_call_instance->ReturnThruPtr_p_dev_name_Used = 0;
+  cmock_call_instance->Expected_p_len = p_len;
+  cmock_call_instance->Expected_p_len_Depth = p_len_Depth;
+  cmock_call_instance->IgnoreArg_p_len = 0;
+  cmock_call_instance->ReturnThruPtr_p_len_Used = 0;
+}
+
+void sd_ble_gap_device_name_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_name_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_name_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_device_name_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_device_name_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_dev_name, uint16_t* p_len, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_name_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_name_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_device_name_get(cmock_call_instance, p_dev_name, 0, p_len, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_device_name_get_StubWithCallback(CMOCK_sd_ble_gap_device_name_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_device_name_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_device_name_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_dev_name, int p_dev_name_Depth, uint16_t* p_len, int p_len_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_name_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_name_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_device_name_get(cmock_call_instance, p_dev_name, p_dev_name_Depth, p_len, p_len_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_dev_name(UNITY_LINE_TYPE cmock_line, uint8_t* p_dev_name, int cmock_size)
+{
+  CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_dev_name ReturnThruPtr called before Expect on 'sd_ble_gap_device_name_get'.");
+  cmock_call_instance->ReturnThruPtr_p_dev_name_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_dev_name_Val = p_dev_name;
+  cmock_call_instance->ReturnThruPtr_p_dev_name_Size = cmock_size;
+}
+
+void sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_len(UNITY_LINE_TYPE cmock_line, uint16_t* p_len, int cmock_size)
+{
+  CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_len ReturnThruPtr called before Expect on 'sd_ble_gap_device_name_get'.");
+  cmock_call_instance->ReturnThruPtr_p_len_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_len_Val = p_len;
+  cmock_call_instance->ReturnThruPtr_p_len_Size = cmock_size;
+}
+
+void sd_ble_gap_device_name_get_CMockIgnoreArg_p_dev_name(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_dev_name IgnoreArg called before Expect on 'sd_ble_gap_device_name_get'.");
+  cmock_call_instance->IgnoreArg_p_dev_name = 1;
+}
+
+void sd_ble_gap_device_name_get_CMockIgnoreArg_p_len(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_len IgnoreArg called before Expect on 'sd_ble_gap_device_name_get'.");
+  cmock_call_instance->IgnoreArg_p_len = 1;
+}
+
+uint32_t sd_ble_gap_authenticate(uint16_t conn_handle, ble_gap_sec_params_t const* p_sec_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_authenticate_CallInstance);
+  Mock.sd_ble_gap_authenticate_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_authenticate_CallInstance);
+  if (Mock.sd_ble_gap_authenticate_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_authenticate_FinalReturn;
+    Mock.sd_ble_gap_authenticate_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_authenticate_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_authenticate_CallbackFunctionPointer(conn_handle, p_sec_params, Mock.sd_ble_gap_authenticate_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_authenticate' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_authenticate' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_authenticate' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_authenticate' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_sec_params)
+  {
+    if (cmock_call_instance->Expected_p_sec_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_sec_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_authenticate' called with unexpected value for argument 'p_sec_params'."); }
+    else if (cmock_call_instance->Expected_p_sec_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_sec_params, p_sec_params, cmock_line, "Function 'sd_ble_gap_authenticate' called with unexpected value for argument 'p_sec_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_sec_params), (void*)(p_sec_params), sizeof(ble_gap_sec_params_t), cmock_call_instance->Expected_p_sec_params_Depth, cmock_line, "Function 'sd_ble_gap_authenticate' called with unexpected value for argument 'p_sec_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_sec_params_Used)
+  {
+    memcpy((void*)p_sec_params, (void*)cmock_call_instance->ReturnThruPtr_p_sec_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_sec_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_authenticate(CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gap_sec_params_t const* p_sec_params, int p_sec_params_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_sec_params = p_sec_params;
+  cmock_call_instance->Expected_p_sec_params_Depth = p_sec_params_Depth;
+  cmock_call_instance->IgnoreArg_p_sec_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_sec_params_Used = 0;
+}
+
+void sd_ble_gap_authenticate_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_authenticate_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_authenticate_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_authenticate_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_authenticate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_sec_params_t const* p_sec_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_authenticate_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_authenticate_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_authenticate(cmock_call_instance, conn_handle, p_sec_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_authenticate_StubWithCallback(CMOCK_sd_ble_gap_authenticate_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_authenticate_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_authenticate_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_sec_params_t const* p_sec_params, int p_sec_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_authenticate_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_authenticate_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_authenticate(cmock_call_instance, conn_handle, p_sec_params, p_sec_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_authenticate_CMockReturnMemThruPtr_p_sec_params(UNITY_LINE_TYPE cmock_line, ble_gap_sec_params_t const* p_sec_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_authenticate_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sec_params ReturnThruPtr called before Expect on 'sd_ble_gap_authenticate'.");
+  cmock_call_instance->ReturnThruPtr_p_sec_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_sec_params_Val = p_sec_params;
+  cmock_call_instance->ReturnThruPtr_p_sec_params_Size = cmock_size;
+}
+
+void sd_ble_gap_authenticate_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_authenticate_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_authenticate'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_authenticate_CMockIgnoreArg_p_sec_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_authenticate_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sec_params IgnoreArg called before Expect on 'sd_ble_gap_authenticate'.");
+  cmock_call_instance->IgnoreArg_p_sec_params = 1;
+}
+
+uint32_t sd_ble_gap_sec_params_reply(uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const* p_sec_params, ble_gap_sec_keyset_t const* p_sec_keyset)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_sec_params_reply_CallInstance);
+  Mock.sd_ble_gap_sec_params_reply_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_sec_params_reply_CallInstance);
+  if (Mock.sd_ble_gap_sec_params_reply_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_sec_params_reply_FinalReturn;
+    Mock.sd_ble_gap_sec_params_reply_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_sec_params_reply_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_sec_params_reply_CallbackFunctionPointer(conn_handle, sec_status, p_sec_params, p_sec_keyset, Mock.sd_ble_gap_sec_params_reply_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_sec_params_reply' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_sec_params_reply' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_sec_params_reply' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_sec_params_reply' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_sec_status)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_sec_status, sec_status, cmock_line, "Function 'sd_ble_gap_sec_params_reply' called with unexpected value for argument 'sec_status'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_sec_params)
+  {
+    if (cmock_call_instance->Expected_p_sec_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_sec_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_sec_params_reply' called with unexpected value for argument 'p_sec_params'."); }
+    else if (cmock_call_instance->Expected_p_sec_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_sec_params, p_sec_params, cmock_line, "Function 'sd_ble_gap_sec_params_reply' called with unexpected value for argument 'p_sec_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_sec_params), (void*)(p_sec_params), sizeof(ble_gap_sec_params_t), cmock_call_instance->Expected_p_sec_params_Depth, cmock_line, "Function 'sd_ble_gap_sec_params_reply' called with unexpected value for argument 'p_sec_params'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_sec_keyset)
+  {
+    if (cmock_call_instance->Expected_p_sec_keyset == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_sec_keyset, cmock_line, "Expected NULL. Function 'sd_ble_gap_sec_params_reply' called with unexpected value for argument 'p_sec_keyset'."); }
+    else if (cmock_call_instance->Expected_p_sec_keyset_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_sec_keyset, p_sec_keyset, cmock_line, "Function 'sd_ble_gap_sec_params_reply' called with unexpected value for argument 'p_sec_keyset'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_sec_keyset), (void*)(p_sec_keyset), sizeof(ble_gap_sec_keyset_t), cmock_call_instance->Expected_p_sec_keyset_Depth, cmock_line, "Function 'sd_ble_gap_sec_params_reply' called with unexpected value for argument 'p_sec_keyset'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_sec_params_Used)
+  {
+    memcpy((void*)p_sec_params, (void*)cmock_call_instance->ReturnThruPtr_p_sec_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_sec_params_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_sec_keyset_Used)
+  {
+    memcpy((void*)p_sec_keyset, (void*)cmock_call_instance->ReturnThruPtr_p_sec_keyset_Val,
+      cmock_call_instance->ReturnThruPtr_p_sec_keyset_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_sec_params_reply(CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const* p_sec_params, int p_sec_params_Depth, ble_gap_sec_keyset_t const* p_sec_keyset, int p_sec_keyset_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_sec_status = sec_status;
+  cmock_call_instance->IgnoreArg_sec_status = 0;
+  cmock_call_instance->Expected_p_sec_params = p_sec_params;
+  cmock_call_instance->Expected_p_sec_params_Depth = p_sec_params_Depth;
+  cmock_call_instance->IgnoreArg_p_sec_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_sec_params_Used = 0;
+  cmock_call_instance->Expected_p_sec_keyset = p_sec_keyset;
+  cmock_call_instance->Expected_p_sec_keyset_Depth = p_sec_keyset_Depth;
+  cmock_call_instance->IgnoreArg_p_sec_keyset = 0;
+  cmock_call_instance->ReturnThruPtr_p_sec_keyset_Used = 0;
+}
+
+void sd_ble_gap_sec_params_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_sec_params_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_sec_params_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_sec_params_reply_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_sec_params_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const* p_sec_params, ble_gap_sec_keyset_t const* p_sec_keyset, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_sec_params_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_sec_params_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_sec_params_reply(cmock_call_instance, conn_handle, sec_status, p_sec_params, 0, p_sec_keyset, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_sec_params_reply_StubWithCallback(CMOCK_sd_ble_gap_sec_params_reply_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_sec_params_reply_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_sec_params_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const* p_sec_params, int p_sec_params_Depth, ble_gap_sec_keyset_t const* p_sec_keyset, int p_sec_keyset_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_sec_params_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_sec_params_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_sec_params_reply(cmock_call_instance, conn_handle, sec_status, p_sec_params, p_sec_params_Depth, p_sec_keyset, p_sec_keyset_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_params(UNITY_LINE_TYPE cmock_line, ble_gap_sec_params_t const* p_sec_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_params_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sec_params ReturnThruPtr called before Expect on 'sd_ble_gap_sec_params_reply'.");
+  cmock_call_instance->ReturnThruPtr_p_sec_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_sec_params_Val = p_sec_params;
+  cmock_call_instance->ReturnThruPtr_p_sec_params_Size = cmock_size;
+}
+
+void sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_keyset(UNITY_LINE_TYPE cmock_line, ble_gap_sec_keyset_t const* p_sec_keyset, int cmock_size)
+{
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_params_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sec_keyset ReturnThruPtr called before Expect on 'sd_ble_gap_sec_params_reply'.");
+  cmock_call_instance->ReturnThruPtr_p_sec_keyset_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_sec_keyset_Val = p_sec_keyset;
+  cmock_call_instance->ReturnThruPtr_p_sec_keyset_Size = cmock_size;
+}
+
+void sd_ble_gap_sec_params_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_params_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_sec_params_reply'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_sec_params_reply_CMockIgnoreArg_sec_status(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_params_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "sec_status IgnoreArg called before Expect on 'sd_ble_gap_sec_params_reply'.");
+  cmock_call_instance->IgnoreArg_sec_status = 1;
+}
+
+void sd_ble_gap_sec_params_reply_CMockIgnoreArg_p_sec_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_params_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sec_params IgnoreArg called before Expect on 'sd_ble_gap_sec_params_reply'.");
+  cmock_call_instance->IgnoreArg_p_sec_params = 1;
+}
+
+void sd_ble_gap_sec_params_reply_CMockIgnoreArg_p_sec_keyset(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_params_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sec_keyset IgnoreArg called before Expect on 'sd_ble_gap_sec_params_reply'.");
+  cmock_call_instance->IgnoreArg_p_sec_keyset = 1;
+}
+
+uint32_t sd_ble_gap_auth_key_reply(uint16_t conn_handle, uint8_t key_type, uint8_t const* p_key)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_auth_key_reply_CallInstance);
+  Mock.sd_ble_gap_auth_key_reply_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_auth_key_reply_CallInstance);
+  if (Mock.sd_ble_gap_auth_key_reply_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_auth_key_reply_FinalReturn;
+    Mock.sd_ble_gap_auth_key_reply_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_auth_key_reply_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_auth_key_reply_CallbackFunctionPointer(conn_handle, key_type, p_key, Mock.sd_ble_gap_auth_key_reply_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_auth_key_reply' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_auth_key_reply' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_auth_key_reply' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_auth_key_reply' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_key_type)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_key_type, key_type, cmock_line, "Function 'sd_ble_gap_auth_key_reply' called with unexpected value for argument 'key_type'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_key)
+  {
+    if (cmock_call_instance->Expected_p_key == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_key, cmock_line, "Expected NULL. Function 'sd_ble_gap_auth_key_reply' called with unexpected value for argument 'p_key'."); }
+    else if (cmock_call_instance->Expected_p_key_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_key, p_key, cmock_line, "Function 'sd_ble_gap_auth_key_reply' called with unexpected value for argument 'p_key'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_key, p_key, cmock_call_instance->Expected_p_key_Depth, cmock_line, "Function 'sd_ble_gap_auth_key_reply' called with unexpected value for argument 'p_key'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_key_Used)
+  {
+    memcpy((void*)p_key, (void*)cmock_call_instance->ReturnThruPtr_p_key_Val,
+      cmock_call_instance->ReturnThruPtr_p_key_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_auth_key_reply(CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint8_t key_type, uint8_t const* p_key, int p_key_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_key_type = key_type;
+  cmock_call_instance->IgnoreArg_key_type = 0;
+  cmock_call_instance->Expected_p_key = p_key;
+  cmock_call_instance->Expected_p_key_Depth = p_key_Depth;
+  cmock_call_instance->IgnoreArg_p_key = 0;
+  cmock_call_instance->ReturnThruPtr_p_key_Used = 0;
+}
+
+void sd_ble_gap_auth_key_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_auth_key_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_auth_key_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_auth_key_reply_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_auth_key_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t key_type, uint8_t const* p_key, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_auth_key_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_auth_key_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_auth_key_reply(cmock_call_instance, conn_handle, key_type, p_key, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_auth_key_reply_StubWithCallback(CMOCK_sd_ble_gap_auth_key_reply_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_auth_key_reply_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_auth_key_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t key_type, uint8_t const* p_key, int p_key_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_auth_key_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_auth_key_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_auth_key_reply(cmock_call_instance, conn_handle, key_type, p_key, p_key_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_auth_key_reply_CMockReturnMemThruPtr_p_key(UNITY_LINE_TYPE cmock_line, uint8_t const* p_key, int cmock_size)
+{
+  CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_auth_key_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_key ReturnThruPtr called before Expect on 'sd_ble_gap_auth_key_reply'.");
+  cmock_call_instance->ReturnThruPtr_p_key_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_key_Val = p_key;
+  cmock_call_instance->ReturnThruPtr_p_key_Size = cmock_size;
+}
+
+void sd_ble_gap_auth_key_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_auth_key_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_auth_key_reply'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_auth_key_reply_CMockIgnoreArg_key_type(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_auth_key_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "key_type IgnoreArg called before Expect on 'sd_ble_gap_auth_key_reply'.");
+  cmock_call_instance->IgnoreArg_key_type = 1;
+}
+
+void sd_ble_gap_auth_key_reply_CMockIgnoreArg_p_key(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_auth_key_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_key IgnoreArg called before Expect on 'sd_ble_gap_auth_key_reply'.");
+  cmock_call_instance->IgnoreArg_p_key = 1;
+}
+
+uint32_t sd_ble_gap_lesc_dhkey_reply(uint16_t conn_handle, ble_gap_lesc_dhkey_t const* p_dhkey)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance);
+  Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance);
+  if (Mock.sd_ble_gap_lesc_dhkey_reply_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_lesc_dhkey_reply_FinalReturn;
+    Mock.sd_ble_gap_lesc_dhkey_reply_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_lesc_dhkey_reply_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_lesc_dhkey_reply_CallbackFunctionPointer(conn_handle, p_dhkey, Mock.sd_ble_gap_lesc_dhkey_reply_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_lesc_dhkey_reply' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_lesc_dhkey_reply' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_lesc_dhkey_reply' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_lesc_dhkey_reply' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_dhkey)
+  {
+    if (cmock_call_instance->Expected_p_dhkey == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_dhkey, cmock_line, "Expected NULL. Function 'sd_ble_gap_lesc_dhkey_reply' called with unexpected value for argument 'p_dhkey'."); }
+    else if (cmock_call_instance->Expected_p_dhkey_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_dhkey, p_dhkey, cmock_line, "Function 'sd_ble_gap_lesc_dhkey_reply' called with unexpected value for argument 'p_dhkey'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_dhkey), (void*)(p_dhkey), sizeof(ble_gap_lesc_dhkey_t), cmock_call_instance->Expected_p_dhkey_Depth, cmock_line, "Function 'sd_ble_gap_lesc_dhkey_reply' called with unexpected value for argument 'p_dhkey'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_dhkey_Used)
+  {
+    memcpy((void*)p_dhkey, (void*)cmock_call_instance->ReturnThruPtr_p_dhkey_Val,
+      cmock_call_instance->ReturnThruPtr_p_dhkey_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_lesc_dhkey_reply(CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gap_lesc_dhkey_t const* p_dhkey, int p_dhkey_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_dhkey = p_dhkey;
+  cmock_call_instance->Expected_p_dhkey_Depth = p_dhkey_Depth;
+  cmock_call_instance->IgnoreArg_p_dhkey = 0;
+  cmock_call_instance->ReturnThruPtr_p_dhkey_Used = 0;
+}
+
+void sd_ble_gap_lesc_dhkey_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_lesc_dhkey_reply_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_lesc_dhkey_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_dhkey_t const* p_dhkey, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_lesc_dhkey_reply(cmock_call_instance, conn_handle, p_dhkey, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_lesc_dhkey_reply_StubWithCallback(CMOCK_sd_ble_gap_lesc_dhkey_reply_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_lesc_dhkey_reply_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_lesc_dhkey_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_dhkey_t const* p_dhkey, int p_dhkey_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_lesc_dhkey_reply(cmock_call_instance, conn_handle, p_dhkey, p_dhkey_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_lesc_dhkey_reply_CMockReturnMemThruPtr_p_dhkey(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_dhkey_t const* p_dhkey, int cmock_size)
+{
+  CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_dhkey ReturnThruPtr called before Expect on 'sd_ble_gap_lesc_dhkey_reply'.");
+  cmock_call_instance->ReturnThruPtr_p_dhkey_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_dhkey_Val = p_dhkey;
+  cmock_call_instance->ReturnThruPtr_p_dhkey_Size = cmock_size;
+}
+
+void sd_ble_gap_lesc_dhkey_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_lesc_dhkey_reply'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_lesc_dhkey_reply_CMockIgnoreArg_p_dhkey(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_dhkey IgnoreArg called before Expect on 'sd_ble_gap_lesc_dhkey_reply'.");
+  cmock_call_instance->IgnoreArg_p_dhkey = 1;
+}
+
+uint32_t sd_ble_gap_keypress_notify(uint16_t conn_handle, uint8_t kp_not)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_keypress_notify_CallInstance);
+  Mock.sd_ble_gap_keypress_notify_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_keypress_notify_CallInstance);
+  if (Mock.sd_ble_gap_keypress_notify_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_keypress_notify_FinalReturn;
+    Mock.sd_ble_gap_keypress_notify_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_keypress_notify_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_keypress_notify_CallbackFunctionPointer(conn_handle, kp_not, Mock.sd_ble_gap_keypress_notify_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_keypress_notify' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_keypress_notify' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_keypress_notify' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_keypress_notify' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_kp_not)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_kp_not, kp_not, cmock_line, "Function 'sd_ble_gap_keypress_notify' called with unexpected value for argument 'kp_not'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_keypress_notify(CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint8_t kp_not)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_kp_not = kp_not;
+  cmock_call_instance->IgnoreArg_kp_not = 0;
+}
+
+void sd_ble_gap_keypress_notify_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_keypress_notify_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_keypress_notify_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_keypress_notify_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_keypress_notify_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t kp_not, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_keypress_notify_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_keypress_notify_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_keypress_notify(cmock_call_instance, conn_handle, kp_not);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_keypress_notify_StubWithCallback(CMOCK_sd_ble_gap_keypress_notify_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_keypress_notify_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_keypress_notify_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_keypress_notify_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_keypress_notify'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_keypress_notify_CMockIgnoreArg_kp_not(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_keypress_notify_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "kp_not IgnoreArg called before Expect on 'sd_ble_gap_keypress_notify'.");
+  cmock_call_instance->IgnoreArg_kp_not = 1;
+}
+
+uint32_t sd_ble_gap_lesc_oob_data_get(uint16_t conn_handle, ble_gap_lesc_p256_pk_t const* p_pk_own, ble_gap_lesc_oob_data_t* p_oobd_own)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance);
+  Mock.sd_ble_gap_lesc_oob_data_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance);
+  if (Mock.sd_ble_gap_lesc_oob_data_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_lesc_oob_data_get_FinalReturn;
+    Mock.sd_ble_gap_lesc_oob_data_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_lesc_oob_data_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_lesc_oob_data_get_CallbackFunctionPointer(conn_handle, p_pk_own, p_oobd_own, Mock.sd_ble_gap_lesc_oob_data_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_pk_own)
+  {
+    if (cmock_call_instance->Expected_p_pk_own == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_pk_own, cmock_line, "Expected NULL. Function 'sd_ble_gap_lesc_oob_data_get' called with unexpected value for argument 'p_pk_own'."); }
+    else if (cmock_call_instance->Expected_p_pk_own_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_pk_own, p_pk_own, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called with unexpected value for argument 'p_pk_own'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_pk_own), (void*)(p_pk_own), sizeof(ble_gap_lesc_p256_pk_t), cmock_call_instance->Expected_p_pk_own_Depth, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called with unexpected value for argument 'p_pk_own'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_oobd_own)
+  {
+    if (cmock_call_instance->Expected_p_oobd_own == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_oobd_own, cmock_line, "Expected NULL. Function 'sd_ble_gap_lesc_oob_data_get' called with unexpected value for argument 'p_oobd_own'."); }
+    else if (cmock_call_instance->Expected_p_oobd_own_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_oobd_own, p_oobd_own, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called with unexpected value for argument 'p_oobd_own'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_oobd_own), (void*)(p_oobd_own), sizeof(ble_gap_lesc_oob_data_t), cmock_call_instance->Expected_p_oobd_own_Depth, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called with unexpected value for argument 'p_oobd_own'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_pk_own_Used)
+  {
+    memcpy((void*)p_pk_own, (void*)cmock_call_instance->ReturnThruPtr_p_pk_own_Val,
+      cmock_call_instance->ReturnThruPtr_p_pk_own_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_oobd_own_Used)
+  {
+    memcpy((void*)p_oobd_own, (void*)cmock_call_instance->ReturnThruPtr_p_oobd_own_Val,
+      cmock_call_instance->ReturnThruPtr_p_oobd_own_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_lesc_oob_data_get(CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gap_lesc_p256_pk_t const* p_pk_own, int p_pk_own_Depth, ble_gap_lesc_oob_data_t* p_oobd_own, int p_oobd_own_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_pk_own = p_pk_own;
+  cmock_call_instance->Expected_p_pk_own_Depth = p_pk_own_Depth;
+  cmock_call_instance->IgnoreArg_p_pk_own = 0;
+  cmock_call_instance->ReturnThruPtr_p_pk_own_Used = 0;
+  cmock_call_instance->Expected_p_oobd_own = p_oobd_own;
+  cmock_call_instance->Expected_p_oobd_own_Depth = p_oobd_own_Depth;
+  cmock_call_instance->IgnoreArg_p_oobd_own = 0;
+  cmock_call_instance->ReturnThruPtr_p_oobd_own_Used = 0;
+}
+
+void sd_ble_gap_lesc_oob_data_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_oob_data_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_lesc_oob_data_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_lesc_oob_data_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_p256_pk_t const* p_pk_own, ble_gap_lesc_oob_data_t* p_oobd_own, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_oob_data_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_lesc_oob_data_get(cmock_call_instance, conn_handle, p_pk_own, 0, p_oobd_own, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_lesc_oob_data_get_StubWithCallback(CMOCK_sd_ble_gap_lesc_oob_data_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_lesc_oob_data_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_lesc_oob_data_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_p256_pk_t const* p_pk_own, int p_pk_own_Depth, ble_gap_lesc_oob_data_t* p_oobd_own, int p_oobd_own_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_oob_data_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_lesc_oob_data_get(cmock_call_instance, conn_handle, p_pk_own, p_pk_own_Depth, p_oobd_own, p_oobd_own_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_pk_own(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_p256_pk_t const* p_pk_own, int cmock_size)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_pk_own ReturnThruPtr called before Expect on 'sd_ble_gap_lesc_oob_data_get'.");
+  cmock_call_instance->ReturnThruPtr_p_pk_own_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_pk_own_Val = p_pk_own;
+  cmock_call_instance->ReturnThruPtr_p_pk_own_Size = cmock_size;
+}
+
+void sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_oobd_own(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_oob_data_t* p_oobd_own, int cmock_size)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_oobd_own ReturnThruPtr called before Expect on 'sd_ble_gap_lesc_oob_data_get'.");
+  cmock_call_instance->ReturnThruPtr_p_oobd_own_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_oobd_own_Val = p_oobd_own;
+  cmock_call_instance->ReturnThruPtr_p_oobd_own_Size = cmock_size;
+}
+
+void sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_lesc_oob_data_get'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_p_pk_own(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_pk_own IgnoreArg called before Expect on 'sd_ble_gap_lesc_oob_data_get'.");
+  cmock_call_instance->IgnoreArg_p_pk_own = 1;
+}
+
+void sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_p_oobd_own(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_oobd_own IgnoreArg called before Expect on 'sd_ble_gap_lesc_oob_data_get'.");
+  cmock_call_instance->IgnoreArg_p_oobd_own = 1;
+}
+
+uint32_t sd_ble_gap_lesc_oob_data_set(uint16_t conn_handle, ble_gap_lesc_oob_data_t const* p_oobd_own, ble_gap_lesc_oob_data_t const* p_oobd_peer)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance);
+  Mock.sd_ble_gap_lesc_oob_data_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance);
+  if (Mock.sd_ble_gap_lesc_oob_data_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_lesc_oob_data_set_FinalReturn;
+    Mock.sd_ble_gap_lesc_oob_data_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_lesc_oob_data_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_lesc_oob_data_set_CallbackFunctionPointer(conn_handle, p_oobd_own, p_oobd_peer, Mock.sd_ble_gap_lesc_oob_data_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_oobd_own)
+  {
+    if (cmock_call_instance->Expected_p_oobd_own == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_oobd_own, cmock_line, "Expected NULL. Function 'sd_ble_gap_lesc_oob_data_set' called with unexpected value for argument 'p_oobd_own'."); }
+    else if (cmock_call_instance->Expected_p_oobd_own_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_oobd_own, p_oobd_own, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called with unexpected value for argument 'p_oobd_own'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_oobd_own), (void*)(p_oobd_own), sizeof(ble_gap_lesc_oob_data_t), cmock_call_instance->Expected_p_oobd_own_Depth, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called with unexpected value for argument 'p_oobd_own'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_oobd_peer)
+  {
+    if (cmock_call_instance->Expected_p_oobd_peer == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_oobd_peer, cmock_line, "Expected NULL. Function 'sd_ble_gap_lesc_oob_data_set' called with unexpected value for argument 'p_oobd_peer'."); }
+    else if (cmock_call_instance->Expected_p_oobd_peer_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_oobd_peer, p_oobd_peer, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called with unexpected value for argument 'p_oobd_peer'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_oobd_peer), (void*)(p_oobd_peer), sizeof(ble_gap_lesc_oob_data_t), cmock_call_instance->Expected_p_oobd_peer_Depth, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called with unexpected value for argument 'p_oobd_peer'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_oobd_own_Used)
+  {
+    memcpy((void*)p_oobd_own, (void*)cmock_call_instance->ReturnThruPtr_p_oobd_own_Val,
+      cmock_call_instance->ReturnThruPtr_p_oobd_own_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_oobd_peer_Used)
+  {
+    memcpy((void*)p_oobd_peer, (void*)cmock_call_instance->ReturnThruPtr_p_oobd_peer_Val,
+      cmock_call_instance->ReturnThruPtr_p_oobd_peer_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_lesc_oob_data_set(CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gap_lesc_oob_data_t const* p_oobd_own, int p_oobd_own_Depth, ble_gap_lesc_oob_data_t const* p_oobd_peer, int p_oobd_peer_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_oobd_own = p_oobd_own;
+  cmock_call_instance->Expected_p_oobd_own_Depth = p_oobd_own_Depth;
+  cmock_call_instance->IgnoreArg_p_oobd_own = 0;
+  cmock_call_instance->ReturnThruPtr_p_oobd_own_Used = 0;
+  cmock_call_instance->Expected_p_oobd_peer = p_oobd_peer;
+  cmock_call_instance->Expected_p_oobd_peer_Depth = p_oobd_peer_Depth;
+  cmock_call_instance->IgnoreArg_p_oobd_peer = 0;
+  cmock_call_instance->ReturnThruPtr_p_oobd_peer_Used = 0;
+}
+
+void sd_ble_gap_lesc_oob_data_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_oob_data_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_lesc_oob_data_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_lesc_oob_data_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_oob_data_t const* p_oobd_own, ble_gap_lesc_oob_data_t const* p_oobd_peer, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_oob_data_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_lesc_oob_data_set(cmock_call_instance, conn_handle, p_oobd_own, 0, p_oobd_peer, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_lesc_oob_data_set_StubWithCallback(CMOCK_sd_ble_gap_lesc_oob_data_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_lesc_oob_data_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_lesc_oob_data_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_oob_data_t const* p_oobd_own, int p_oobd_own_Depth, ble_gap_lesc_oob_data_t const* p_oobd_peer, int p_oobd_peer_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_oob_data_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_lesc_oob_data_set(cmock_call_instance, conn_handle, p_oobd_own, p_oobd_own_Depth, p_oobd_peer, p_oobd_peer_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_own(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_oob_data_t const* p_oobd_own, int cmock_size)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_oobd_own ReturnThruPtr called before Expect on 'sd_ble_gap_lesc_oob_data_set'.");
+  cmock_call_instance->ReturnThruPtr_p_oobd_own_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_oobd_own_Val = p_oobd_own;
+  cmock_call_instance->ReturnThruPtr_p_oobd_own_Size = cmock_size;
+}
+
+void sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_peer(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_oob_data_t const* p_oobd_peer, int cmock_size)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_oobd_peer ReturnThruPtr called before Expect on 'sd_ble_gap_lesc_oob_data_set'.");
+  cmock_call_instance->ReturnThruPtr_p_oobd_peer_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_oobd_peer_Val = p_oobd_peer;
+  cmock_call_instance->ReturnThruPtr_p_oobd_peer_Size = cmock_size;
+}
+
+void sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_lesc_oob_data_set'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_p_oobd_own(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_oobd_own IgnoreArg called before Expect on 'sd_ble_gap_lesc_oob_data_set'.");
+  cmock_call_instance->IgnoreArg_p_oobd_own = 1;
+}
+
+void sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_p_oobd_peer(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_oobd_peer IgnoreArg called before Expect on 'sd_ble_gap_lesc_oob_data_set'.");
+  cmock_call_instance->IgnoreArg_p_oobd_peer = 1;
+}
+
+uint32_t sd_ble_gap_encrypt(uint16_t conn_handle, ble_gap_master_id_t const* p_master_id, ble_gap_enc_info_t const* p_enc_info)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_encrypt_CallInstance);
+  Mock.sd_ble_gap_encrypt_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_encrypt_CallInstance);
+  if (Mock.sd_ble_gap_encrypt_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_encrypt_FinalReturn;
+    Mock.sd_ble_gap_encrypt_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_encrypt_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_encrypt_CallbackFunctionPointer(conn_handle, p_master_id, p_enc_info, Mock.sd_ble_gap_encrypt_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_encrypt' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_encrypt' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_encrypt' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_encrypt' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_master_id)
+  {
+    if (cmock_call_instance->Expected_p_master_id == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_master_id, cmock_line, "Expected NULL. Function 'sd_ble_gap_encrypt' called with unexpected value for argument 'p_master_id'."); }
+    else if (cmock_call_instance->Expected_p_master_id_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_master_id, p_master_id, cmock_line, "Function 'sd_ble_gap_encrypt' called with unexpected value for argument 'p_master_id'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_master_id), (void*)(p_master_id), sizeof(ble_gap_master_id_t), cmock_call_instance->Expected_p_master_id_Depth, cmock_line, "Function 'sd_ble_gap_encrypt' called with unexpected value for argument 'p_master_id'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_enc_info)
+  {
+    if (cmock_call_instance->Expected_p_enc_info == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_enc_info, cmock_line, "Expected NULL. Function 'sd_ble_gap_encrypt' called with unexpected value for argument 'p_enc_info'."); }
+    else if (cmock_call_instance->Expected_p_enc_info_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_enc_info, p_enc_info, cmock_line, "Function 'sd_ble_gap_encrypt' called with unexpected value for argument 'p_enc_info'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_enc_info), (void*)(p_enc_info), sizeof(ble_gap_enc_info_t), cmock_call_instance->Expected_p_enc_info_Depth, cmock_line, "Function 'sd_ble_gap_encrypt' called with unexpected value for argument 'p_enc_info'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_master_id_Used)
+  {
+    memcpy((void*)p_master_id, (void*)cmock_call_instance->ReturnThruPtr_p_master_id_Val,
+      cmock_call_instance->ReturnThruPtr_p_master_id_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_enc_info_Used)
+  {
+    memcpy((void*)p_enc_info, (void*)cmock_call_instance->ReturnThruPtr_p_enc_info_Val,
+      cmock_call_instance->ReturnThruPtr_p_enc_info_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_encrypt(CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gap_master_id_t const* p_master_id, int p_master_id_Depth, ble_gap_enc_info_t const* p_enc_info, int p_enc_info_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_master_id = p_master_id;
+  cmock_call_instance->Expected_p_master_id_Depth = p_master_id_Depth;
+  cmock_call_instance->IgnoreArg_p_master_id = 0;
+  cmock_call_instance->ReturnThruPtr_p_master_id_Used = 0;
+  cmock_call_instance->Expected_p_enc_info = p_enc_info;
+  cmock_call_instance->Expected_p_enc_info_Depth = p_enc_info_Depth;
+  cmock_call_instance->IgnoreArg_p_enc_info = 0;
+  cmock_call_instance->ReturnThruPtr_p_enc_info_Used = 0;
+}
+
+void sd_ble_gap_encrypt_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_encrypt_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_encrypt_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_encrypt_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_encrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_master_id_t const* p_master_id, ble_gap_enc_info_t const* p_enc_info, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_encrypt_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_encrypt_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_encrypt(cmock_call_instance, conn_handle, p_master_id, 0, p_enc_info, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_encrypt_StubWithCallback(CMOCK_sd_ble_gap_encrypt_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_encrypt_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_encrypt_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_master_id_t const* p_master_id, int p_master_id_Depth, ble_gap_enc_info_t const* p_enc_info, int p_enc_info_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_encrypt_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_encrypt_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_encrypt(cmock_call_instance, conn_handle, p_master_id, p_master_id_Depth, p_enc_info, p_enc_info_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_master_id(UNITY_LINE_TYPE cmock_line, ble_gap_master_id_t const* p_master_id, int cmock_size)
+{
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_encrypt_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_master_id ReturnThruPtr called before Expect on 'sd_ble_gap_encrypt'.");
+  cmock_call_instance->ReturnThruPtr_p_master_id_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_master_id_Val = p_master_id;
+  cmock_call_instance->ReturnThruPtr_p_master_id_Size = cmock_size;
+}
+
+void sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_enc_info(UNITY_LINE_TYPE cmock_line, ble_gap_enc_info_t const* p_enc_info, int cmock_size)
+{
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_encrypt_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_enc_info ReturnThruPtr called before Expect on 'sd_ble_gap_encrypt'.");
+  cmock_call_instance->ReturnThruPtr_p_enc_info_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_enc_info_Val = p_enc_info;
+  cmock_call_instance->ReturnThruPtr_p_enc_info_Size = cmock_size;
+}
+
+void sd_ble_gap_encrypt_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_encrypt_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_encrypt'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_encrypt_CMockIgnoreArg_p_master_id(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_encrypt_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_master_id IgnoreArg called before Expect on 'sd_ble_gap_encrypt'.");
+  cmock_call_instance->IgnoreArg_p_master_id = 1;
+}
+
+void sd_ble_gap_encrypt_CMockIgnoreArg_p_enc_info(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_encrypt_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_enc_info IgnoreArg called before Expect on 'sd_ble_gap_encrypt'.");
+  cmock_call_instance->IgnoreArg_p_enc_info = 1;
+}
+
+uint32_t sd_ble_gap_sec_info_reply(uint16_t conn_handle, ble_gap_enc_info_t const* p_enc_info, ble_gap_irk_t const* p_id_info, ble_gap_sign_info_t const* p_sign_info)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_sec_info_reply_CallInstance);
+  Mock.sd_ble_gap_sec_info_reply_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_sec_info_reply_CallInstance);
+  if (Mock.sd_ble_gap_sec_info_reply_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_sec_info_reply_FinalReturn;
+    Mock.sd_ble_gap_sec_info_reply_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_sec_info_reply_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_sec_info_reply_CallbackFunctionPointer(conn_handle, p_enc_info, p_id_info, p_sign_info, Mock.sd_ble_gap_sec_info_reply_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_sec_info_reply' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_sec_info_reply' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_enc_info)
+  {
+    if (cmock_call_instance->Expected_p_enc_info == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_enc_info, cmock_line, "Expected NULL. Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_enc_info'."); }
+    else if (cmock_call_instance->Expected_p_enc_info_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_enc_info, p_enc_info, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_enc_info'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_enc_info), (void*)(p_enc_info), sizeof(ble_gap_enc_info_t), cmock_call_instance->Expected_p_enc_info_Depth, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_enc_info'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_id_info)
+  {
+    if (cmock_call_instance->Expected_p_id_info == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_id_info, cmock_line, "Expected NULL. Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_id_info'."); }
+    else if (cmock_call_instance->Expected_p_id_info_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_id_info, p_id_info, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_id_info'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_id_info), (void*)(p_id_info), sizeof(ble_gap_irk_t), cmock_call_instance->Expected_p_id_info_Depth, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_id_info'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_sign_info)
+  {
+    if (cmock_call_instance->Expected_p_sign_info == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_sign_info, cmock_line, "Expected NULL. Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_sign_info'."); }
+    else if (cmock_call_instance->Expected_p_sign_info_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_sign_info, p_sign_info, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_sign_info'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_sign_info), (void*)(p_sign_info), sizeof(ble_gap_sign_info_t), cmock_call_instance->Expected_p_sign_info_Depth, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_sign_info'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_enc_info_Used)
+  {
+    memcpy((void*)p_enc_info, (void*)cmock_call_instance->ReturnThruPtr_p_enc_info_Val,
+      cmock_call_instance->ReturnThruPtr_p_enc_info_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_id_info_Used)
+  {
+    memcpy((void*)p_id_info, (void*)cmock_call_instance->ReturnThruPtr_p_id_info_Val,
+      cmock_call_instance->ReturnThruPtr_p_id_info_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_sign_info_Used)
+  {
+    memcpy((void*)p_sign_info, (void*)cmock_call_instance->ReturnThruPtr_p_sign_info_Val,
+      cmock_call_instance->ReturnThruPtr_p_sign_info_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_sec_info_reply(CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gap_enc_info_t const* p_enc_info, int p_enc_info_Depth, ble_gap_irk_t const* p_id_info, int p_id_info_Depth, ble_gap_sign_info_t const* p_sign_info, int p_sign_info_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_enc_info = p_enc_info;
+  cmock_call_instance->Expected_p_enc_info_Depth = p_enc_info_Depth;
+  cmock_call_instance->IgnoreArg_p_enc_info = 0;
+  cmock_call_instance->ReturnThruPtr_p_enc_info_Used = 0;
+  cmock_call_instance->Expected_p_id_info = p_id_info;
+  cmock_call_instance->Expected_p_id_info_Depth = p_id_info_Depth;
+  cmock_call_instance->IgnoreArg_p_id_info = 0;
+  cmock_call_instance->ReturnThruPtr_p_id_info_Used = 0;
+  cmock_call_instance->Expected_p_sign_info = p_sign_info;
+  cmock_call_instance->Expected_p_sign_info_Depth = p_sign_info_Depth;
+  cmock_call_instance->IgnoreArg_p_sign_info = 0;
+  cmock_call_instance->ReturnThruPtr_p_sign_info_Used = 0;
+}
+
+void sd_ble_gap_sec_info_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_sec_info_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_sec_info_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_sec_info_reply_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_sec_info_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_enc_info_t const* p_enc_info, ble_gap_irk_t const* p_id_info, ble_gap_sign_info_t const* p_sign_info, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_sec_info_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_sec_info_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_sec_info_reply(cmock_call_instance, conn_handle, p_enc_info, 0, p_id_info, 0, p_sign_info, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_sec_info_reply_StubWithCallback(CMOCK_sd_ble_gap_sec_info_reply_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_sec_info_reply_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_sec_info_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_enc_info_t const* p_enc_info, int p_enc_info_Depth, ble_gap_irk_t const* p_id_info, int p_id_info_Depth, ble_gap_sign_info_t const* p_sign_info, int p_sign_info_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_sec_info_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_sec_info_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_sec_info_reply(cmock_call_instance, conn_handle, p_enc_info, p_enc_info_Depth, p_id_info, p_id_info_Depth, p_sign_info, p_sign_info_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_enc_info(UNITY_LINE_TYPE cmock_line, ble_gap_enc_info_t const* p_enc_info, int cmock_size)
+{
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_info_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_enc_info ReturnThruPtr called before Expect on 'sd_ble_gap_sec_info_reply'.");
+  cmock_call_instance->ReturnThruPtr_p_enc_info_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_enc_info_Val = p_enc_info;
+  cmock_call_instance->ReturnThruPtr_p_enc_info_Size = cmock_size;
+}
+
+void sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_id_info(UNITY_LINE_TYPE cmock_line, ble_gap_irk_t const* p_id_info, int cmock_size)
+{
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_info_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_id_info ReturnThruPtr called before Expect on 'sd_ble_gap_sec_info_reply'.");
+  cmock_call_instance->ReturnThruPtr_p_id_info_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_id_info_Val = p_id_info;
+  cmock_call_instance->ReturnThruPtr_p_id_info_Size = cmock_size;
+}
+
+void sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_sign_info(UNITY_LINE_TYPE cmock_line, ble_gap_sign_info_t const* p_sign_info, int cmock_size)
+{
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_info_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sign_info ReturnThruPtr called before Expect on 'sd_ble_gap_sec_info_reply'.");
+  cmock_call_instance->ReturnThruPtr_p_sign_info_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_sign_info_Val = p_sign_info;
+  cmock_call_instance->ReturnThruPtr_p_sign_info_Size = cmock_size;
+}
+
+void sd_ble_gap_sec_info_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_info_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_sec_info_reply'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_enc_info(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_info_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_enc_info IgnoreArg called before Expect on 'sd_ble_gap_sec_info_reply'.");
+  cmock_call_instance->IgnoreArg_p_enc_info = 1;
+}
+
+void sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_id_info(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_info_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_id_info IgnoreArg called before Expect on 'sd_ble_gap_sec_info_reply'.");
+  cmock_call_instance->IgnoreArg_p_id_info = 1;
+}
+
+void sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_sign_info(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_info_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sign_info IgnoreArg called before Expect on 'sd_ble_gap_sec_info_reply'.");
+  cmock_call_instance->IgnoreArg_p_sign_info = 1;
+}
+
+uint32_t sd_ble_gap_conn_sec_get(uint16_t conn_handle, ble_gap_conn_sec_t* p_conn_sec)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_conn_sec_get_CallInstance);
+  Mock.sd_ble_gap_conn_sec_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_conn_sec_get_CallInstance);
+  if (Mock.sd_ble_gap_conn_sec_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_conn_sec_get_FinalReturn;
+    Mock.sd_ble_gap_conn_sec_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_conn_sec_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_conn_sec_get_CallbackFunctionPointer(conn_handle, p_conn_sec, Mock.sd_ble_gap_conn_sec_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_conn_sec_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_conn_sec_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_conn_sec_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_conn_sec_get' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_conn_sec)
+  {
+    if (cmock_call_instance->Expected_p_conn_sec == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_conn_sec, cmock_line, "Expected NULL. Function 'sd_ble_gap_conn_sec_get' called with unexpected value for argument 'p_conn_sec'."); }
+    else if (cmock_call_instance->Expected_p_conn_sec_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_conn_sec, p_conn_sec, cmock_line, "Function 'sd_ble_gap_conn_sec_get' called with unexpected value for argument 'p_conn_sec'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_conn_sec), (void*)(p_conn_sec), sizeof(ble_gap_conn_sec_t), cmock_call_instance->Expected_p_conn_sec_Depth, cmock_line, "Function 'sd_ble_gap_conn_sec_get' called with unexpected value for argument 'p_conn_sec'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_conn_sec_Used)
+  {
+    memcpy((void*)p_conn_sec, (void*)cmock_call_instance->ReturnThruPtr_p_conn_sec_Val,
+      cmock_call_instance->ReturnThruPtr_p_conn_sec_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_conn_sec_get(CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gap_conn_sec_t* p_conn_sec, int p_conn_sec_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_conn_sec = p_conn_sec;
+  cmock_call_instance->Expected_p_conn_sec_Depth = p_conn_sec_Depth;
+  cmock_call_instance->IgnoreArg_p_conn_sec = 0;
+  cmock_call_instance->ReturnThruPtr_p_conn_sec_Used = 0;
+}
+
+void sd_ble_gap_conn_sec_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_conn_sec_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_conn_sec_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_conn_sec_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_conn_sec_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_conn_sec_t* p_conn_sec, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_conn_sec_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_conn_sec_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_conn_sec_get(cmock_call_instance, conn_handle, p_conn_sec, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_conn_sec_get_StubWithCallback(CMOCK_sd_ble_gap_conn_sec_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_conn_sec_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_conn_sec_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_conn_sec_t* p_conn_sec, int p_conn_sec_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_conn_sec_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_conn_sec_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_conn_sec_get(cmock_call_instance, conn_handle, p_conn_sec, p_conn_sec_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_conn_sec_get_CMockReturnMemThruPtr_p_conn_sec(UNITY_LINE_TYPE cmock_line, ble_gap_conn_sec_t* p_conn_sec, int cmock_size)
+{
+  CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_conn_sec_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_sec ReturnThruPtr called before Expect on 'sd_ble_gap_conn_sec_get'.");
+  cmock_call_instance->ReturnThruPtr_p_conn_sec_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_conn_sec_Val = p_conn_sec;
+  cmock_call_instance->ReturnThruPtr_p_conn_sec_Size = cmock_size;
+}
+
+void sd_ble_gap_conn_sec_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_conn_sec_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_conn_sec_get'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_conn_sec_get_CMockIgnoreArg_p_conn_sec(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_conn_sec_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_sec IgnoreArg called before Expect on 'sd_ble_gap_conn_sec_get'.");
+  cmock_call_instance->IgnoreArg_p_conn_sec = 1;
+}
+
+uint32_t sd_ble_gap_rssi_start(uint16_t conn_handle, uint8_t threshold_dbm, uint8_t skip_count)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_rssi_start_CallInstance);
+  Mock.sd_ble_gap_rssi_start_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_rssi_start_CallInstance);
+  if (Mock.sd_ble_gap_rssi_start_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_rssi_start_FinalReturn;
+    Mock.sd_ble_gap_rssi_start_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_rssi_start_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_rssi_start_CallbackFunctionPointer(conn_handle, threshold_dbm, skip_count, Mock.sd_ble_gap_rssi_start_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_rssi_start' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_rssi_start' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_rssi_start' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_rssi_start' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_threshold_dbm)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_threshold_dbm, threshold_dbm, cmock_line, "Function 'sd_ble_gap_rssi_start' called with unexpected value for argument 'threshold_dbm'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_skip_count)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_skip_count, skip_count, cmock_line, "Function 'sd_ble_gap_rssi_start' called with unexpected value for argument 'skip_count'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_rssi_start(CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint8_t threshold_dbm, uint8_t skip_count)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_threshold_dbm = threshold_dbm;
+  cmock_call_instance->IgnoreArg_threshold_dbm = 0;
+  cmock_call_instance->Expected_skip_count = skip_count;
+  cmock_call_instance->IgnoreArg_skip_count = 0;
+}
+
+void sd_ble_gap_rssi_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_rssi_start_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_rssi_start_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_rssi_start_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_rssi_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t threshold_dbm, uint8_t skip_count, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_rssi_start_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_rssi_start_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_rssi_start(cmock_call_instance, conn_handle, threshold_dbm, skip_count);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_rssi_start_StubWithCallback(CMOCK_sd_ble_gap_rssi_start_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_rssi_start_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_rssi_start_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_rssi_start_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_rssi_start'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_rssi_start_CMockIgnoreArg_threshold_dbm(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_rssi_start_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "threshold_dbm IgnoreArg called before Expect on 'sd_ble_gap_rssi_start'.");
+  cmock_call_instance->IgnoreArg_threshold_dbm = 1;
+}
+
+void sd_ble_gap_rssi_start_CMockIgnoreArg_skip_count(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_rssi_start_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "skip_count IgnoreArg called before Expect on 'sd_ble_gap_rssi_start'.");
+  cmock_call_instance->IgnoreArg_skip_count = 1;
+}
+
+uint32_t sd_ble_gap_rssi_stop(uint16_t conn_handle)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_rssi_stop_CallInstance);
+  Mock.sd_ble_gap_rssi_stop_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_rssi_stop_CallInstance);
+  if (Mock.sd_ble_gap_rssi_stop_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_rssi_stop_FinalReturn;
+    Mock.sd_ble_gap_rssi_stop_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_rssi_stop_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_rssi_stop_CallbackFunctionPointer(conn_handle, Mock.sd_ble_gap_rssi_stop_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_rssi_stop' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_rssi_stop' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_rssi_stop' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_rssi_stop' called with unexpected value for argument 'conn_handle'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_rssi_stop(CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+}
+
+void sd_ble_gap_rssi_stop_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_rssi_stop_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_rssi_stop_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_rssi_stop_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_rssi_stop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_rssi_stop_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_rssi_stop_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_rssi_stop(cmock_call_instance, conn_handle);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_rssi_stop_StubWithCallback(CMOCK_sd_ble_gap_rssi_stop_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_rssi_stop_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_rssi_stop_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_rssi_stop_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_rssi_stop'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+uint32_t sd_ble_gap_rssi_get(uint16_t conn_handle, int8_t* p_rssi)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_rssi_get_CallInstance);
+  Mock.sd_ble_gap_rssi_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_rssi_get_CallInstance);
+  if (Mock.sd_ble_gap_rssi_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_rssi_get_FinalReturn;
+    Mock.sd_ble_gap_rssi_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_rssi_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_rssi_get_CallbackFunctionPointer(conn_handle, p_rssi, Mock.sd_ble_gap_rssi_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_rssi_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_rssi_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_rssi_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_rssi_get' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_rssi)
+  {
+    if (cmock_call_instance->Expected_p_rssi == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_rssi, cmock_line, "Expected NULL. Function 'sd_ble_gap_rssi_get' called with unexpected value for argument 'p_rssi'."); }
+    else if (cmock_call_instance->Expected_p_rssi_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_rssi, p_rssi, cmock_line, "Function 'sd_ble_gap_rssi_get' called with unexpected value for argument 'p_rssi'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_INT8_ARRAY(cmock_call_instance->Expected_p_rssi, p_rssi, cmock_call_instance->Expected_p_rssi_Depth, cmock_line, "Function 'sd_ble_gap_rssi_get' called with unexpected value for argument 'p_rssi'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_rssi_Used)
+  {
+    memcpy((void*)p_rssi, (void*)cmock_call_instance->ReturnThruPtr_p_rssi_Val,
+      cmock_call_instance->ReturnThruPtr_p_rssi_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_rssi_get(CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, int8_t* p_rssi, int p_rssi_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_rssi = p_rssi;
+  cmock_call_instance->Expected_p_rssi_Depth = p_rssi_Depth;
+  cmock_call_instance->IgnoreArg_p_rssi = 0;
+  cmock_call_instance->ReturnThruPtr_p_rssi_Used = 0;
+}
+
+void sd_ble_gap_rssi_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_rssi_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_rssi_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_rssi_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_rssi_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, int8_t* p_rssi, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_rssi_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_rssi_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_rssi_get(cmock_call_instance, conn_handle, p_rssi, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_rssi_get_StubWithCallback(CMOCK_sd_ble_gap_rssi_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_rssi_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_rssi_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, int8_t* p_rssi, int p_rssi_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_rssi_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_rssi_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_rssi_get(cmock_call_instance, conn_handle, p_rssi, p_rssi_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_rssi_get_CMockReturnMemThruPtr_p_rssi(UNITY_LINE_TYPE cmock_line, int8_t* p_rssi, int cmock_size)
+{
+  CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_rssi_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_rssi ReturnThruPtr called before Expect on 'sd_ble_gap_rssi_get'.");
+  cmock_call_instance->ReturnThruPtr_p_rssi_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_rssi_Val = p_rssi;
+  cmock_call_instance->ReturnThruPtr_p_rssi_Size = cmock_size;
+}
+
+void sd_ble_gap_rssi_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_rssi_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_rssi_get'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_rssi_get_CMockIgnoreArg_p_rssi(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_rssi_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_rssi IgnoreArg called before Expect on 'sd_ble_gap_rssi_get'.");
+  cmock_call_instance->IgnoreArg_p_rssi = 1;
+}
+
+uint32_t sd_ble_gap_scan_start(ble_gap_scan_params_t const* p_scan_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_scan_start_CallInstance);
+  Mock.sd_ble_gap_scan_start_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_scan_start_CallInstance);
+  if (Mock.sd_ble_gap_scan_start_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_scan_start_FinalReturn;
+    Mock.sd_ble_gap_scan_start_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_scan_start_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_scan_start_CallbackFunctionPointer(p_scan_params, Mock.sd_ble_gap_scan_start_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_scan_start' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_scan_start' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_scan_start' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_scan_params)
+  {
+    if (cmock_call_instance->Expected_p_scan_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_scan_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_scan_start' called with unexpected value for argument 'p_scan_params'."); }
+    else if (cmock_call_instance->Expected_p_scan_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_scan_params, p_scan_params, cmock_line, "Function 'sd_ble_gap_scan_start' called with unexpected value for argument 'p_scan_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_scan_params), (void*)(p_scan_params), sizeof(ble_gap_scan_params_t), cmock_call_instance->Expected_p_scan_params_Depth, cmock_line, "Function 'sd_ble_gap_scan_start' called with unexpected value for argument 'p_scan_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_scan_params_Used)
+  {
+    memcpy((void*)p_scan_params, (void*)cmock_call_instance->ReturnThruPtr_p_scan_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_scan_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_scan_start(CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE* cmock_call_instance, ble_gap_scan_params_t const* p_scan_params, int p_scan_params_Depth)
+{
+  cmock_call_instance->Expected_p_scan_params = p_scan_params;
+  cmock_call_instance->Expected_p_scan_params_Depth = p_scan_params_Depth;
+  cmock_call_instance->IgnoreArg_p_scan_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_scan_params_Used = 0;
+}
+
+void sd_ble_gap_scan_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_scan_start_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_scan_start_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_scan_start_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_scan_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_scan_params_t const* p_scan_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_scan_start_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_scan_start_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_scan_start(cmock_call_instance, p_scan_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_scan_start_StubWithCallback(CMOCK_sd_ble_gap_scan_start_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_scan_start_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_scan_start_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_scan_params_t const* p_scan_params, int p_scan_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_scan_start_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_scan_start_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_scan_start(cmock_call_instance, p_scan_params, p_scan_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_scan_start_CMockReturnMemThruPtr_p_scan_params(UNITY_LINE_TYPE cmock_line, ble_gap_scan_params_t const* p_scan_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_scan_start_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_scan_params ReturnThruPtr called before Expect on 'sd_ble_gap_scan_start'.");
+  cmock_call_instance->ReturnThruPtr_p_scan_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_scan_params_Val = p_scan_params;
+  cmock_call_instance->ReturnThruPtr_p_scan_params_Size = cmock_size;
+}
+
+void sd_ble_gap_scan_start_CMockIgnoreArg_p_scan_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_scan_start_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_scan_params IgnoreArg called before Expect on 'sd_ble_gap_scan_start'.");
+  cmock_call_instance->IgnoreArg_p_scan_params = 1;
+}
+
+uint32_t sd_ble_gap_scan_stop(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_scan_stop_CallInstance);
+  Mock.sd_ble_gap_scan_stop_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_scan_stop_CallInstance);
+  if (Mock.sd_ble_gap_scan_stop_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_scan_stop_FinalReturn;
+    Mock.sd_ble_gap_scan_stop_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_scan_stop_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_scan_stop_CallbackFunctionPointer(Mock.sd_ble_gap_scan_stop_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_scan_stop' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_scan_stop' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_scan_stop' called later than expected.");
+  return cmock_call_instance->ReturnVal;
+}
+
+void sd_ble_gap_scan_stop_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_scan_stop_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_scan_stop_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_scan_stop_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_scan_stop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_scan_stop_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_scan_stop_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_scan_stop_StubWithCallback(CMOCK_sd_ble_gap_scan_stop_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_scan_stop_CallbackFunctionPointer = Callback;
+}
+
+uint32_t sd_ble_gap_connect(ble_gap_addr_t const* p_peer_addr, ble_gap_scan_params_t const* p_scan_params, ble_gap_conn_params_t const* p_conn_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_connect_CallInstance);
+  Mock.sd_ble_gap_connect_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_connect_CallInstance);
+  if (Mock.sd_ble_gap_connect_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_connect_FinalReturn;
+    Mock.sd_ble_gap_connect_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_connect_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_connect_CallbackFunctionPointer(p_peer_addr, p_scan_params, p_conn_params, Mock.sd_ble_gap_connect_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_connect' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_connect' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_connect' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_peer_addr)
+  {
+    if (cmock_call_instance->Expected_p_peer_addr == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_peer_addr, cmock_line, "Expected NULL. Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_peer_addr'."); }
+    else if (cmock_call_instance->Expected_p_peer_addr_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_peer_addr, p_peer_addr, cmock_line, "Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_peer_addr'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_peer_addr), (void*)(p_peer_addr), sizeof(ble_gap_addr_t), cmock_call_instance->Expected_p_peer_addr_Depth, cmock_line, "Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_peer_addr'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_scan_params)
+  {
+    if (cmock_call_instance->Expected_p_scan_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_scan_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_scan_params'."); }
+    else if (cmock_call_instance->Expected_p_scan_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_scan_params, p_scan_params, cmock_line, "Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_scan_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_scan_params), (void*)(p_scan_params), sizeof(ble_gap_scan_params_t), cmock_call_instance->Expected_p_scan_params_Depth, cmock_line, "Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_scan_params'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_conn_params)
+  {
+    if (cmock_call_instance->Expected_p_conn_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_conn_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_conn_params'."); }
+    else if (cmock_call_instance->Expected_p_conn_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_conn_params, p_conn_params, cmock_line, "Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_conn_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_conn_params), (void*)(p_conn_params), sizeof(ble_gap_conn_params_t), cmock_call_instance->Expected_p_conn_params_Depth, cmock_line, "Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_conn_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_peer_addr_Used)
+  {
+    memcpy((void*)p_peer_addr, (void*)cmock_call_instance->ReturnThruPtr_p_peer_addr_Val,
+      cmock_call_instance->ReturnThruPtr_p_peer_addr_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_scan_params_Used)
+  {
+    memcpy((void*)p_scan_params, (void*)cmock_call_instance->ReturnThruPtr_p_scan_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_scan_params_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_conn_params_Used)
+  {
+    memcpy((void*)p_conn_params, (void*)cmock_call_instance->ReturnThruPtr_p_conn_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_conn_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_connect(CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance, ble_gap_addr_t const* p_peer_addr, int p_peer_addr_Depth, ble_gap_scan_params_t const* p_scan_params, int p_scan_params_Depth, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth)
+{
+  cmock_call_instance->Expected_p_peer_addr = p_peer_addr;
+  cmock_call_instance->Expected_p_peer_addr_Depth = p_peer_addr_Depth;
+  cmock_call_instance->IgnoreArg_p_peer_addr = 0;
+  cmock_call_instance->ReturnThruPtr_p_peer_addr_Used = 0;
+  cmock_call_instance->Expected_p_scan_params = p_scan_params;
+  cmock_call_instance->Expected_p_scan_params_Depth = p_scan_params_Depth;
+  cmock_call_instance->IgnoreArg_p_scan_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_scan_params_Used = 0;
+  cmock_call_instance->Expected_p_conn_params = p_conn_params;
+  cmock_call_instance->Expected_p_conn_params_Depth = p_conn_params_Depth;
+  cmock_call_instance->IgnoreArg_p_conn_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Used = 0;
+}
+
+void sd_ble_gap_connect_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_connect_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_connect_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_connect_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_connect_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_connect_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_peer_addr, ble_gap_scan_params_t const* p_scan_params, ble_gap_conn_params_t const* p_conn_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_connect_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_connect_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_connect_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_connect(cmock_call_instance, p_peer_addr, 0, p_scan_params, 0, p_conn_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_connect_StubWithCallback(CMOCK_sd_ble_gap_connect_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_connect_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_connect_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_peer_addr, int p_peer_addr_Depth, ble_gap_scan_params_t const* p_scan_params, int p_scan_params_Depth, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_connect_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_connect_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_connect_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_connect(cmock_call_instance, p_peer_addr, p_peer_addr_Depth, p_scan_params, p_scan_params_Depth, p_conn_params, p_conn_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_connect_CMockReturnMemThruPtr_p_peer_addr(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_peer_addr, int cmock_size)
+{
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_connect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_peer_addr ReturnThruPtr called before Expect on 'sd_ble_gap_connect'.");
+  cmock_call_instance->ReturnThruPtr_p_peer_addr_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_peer_addr_Val = p_peer_addr;
+  cmock_call_instance->ReturnThruPtr_p_peer_addr_Size = cmock_size;
+}
+
+void sd_ble_gap_connect_CMockReturnMemThruPtr_p_scan_params(UNITY_LINE_TYPE cmock_line, ble_gap_scan_params_t const* p_scan_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_connect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_scan_params ReturnThruPtr called before Expect on 'sd_ble_gap_connect'.");
+  cmock_call_instance->ReturnThruPtr_p_scan_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_scan_params_Val = p_scan_params;
+  cmock_call_instance->ReturnThruPtr_p_scan_params_Size = cmock_size;
+}
+
+void sd_ble_gap_connect_CMockReturnMemThruPtr_p_conn_params(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_connect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_params ReturnThruPtr called before Expect on 'sd_ble_gap_connect'.");
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Val = p_conn_params;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Size = cmock_size;
+}
+
+void sd_ble_gap_connect_CMockIgnoreArg_p_peer_addr(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_connect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_peer_addr IgnoreArg called before Expect on 'sd_ble_gap_connect'.");
+  cmock_call_instance->IgnoreArg_p_peer_addr = 1;
+}
+
+void sd_ble_gap_connect_CMockIgnoreArg_p_scan_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_connect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_scan_params IgnoreArg called before Expect on 'sd_ble_gap_connect'.");
+  cmock_call_instance->IgnoreArg_p_scan_params = 1;
+}
+
+void sd_ble_gap_connect_CMockIgnoreArg_p_conn_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_connect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_params IgnoreArg called before Expect on 'sd_ble_gap_connect'.");
+  cmock_call_instance->IgnoreArg_p_conn_params = 1;
+}
+
+uint32_t sd_ble_gap_connect_cancel(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_connect_cancel_CallInstance);
+  Mock.sd_ble_gap_connect_cancel_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_connect_cancel_CallInstance);
+  if (Mock.sd_ble_gap_connect_cancel_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_connect_cancel_FinalReturn;
+    Mock.sd_ble_gap_connect_cancel_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_connect_cancel_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_connect_cancel_CallbackFunctionPointer(Mock.sd_ble_gap_connect_cancel_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_connect_cancel' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_connect_cancel' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_connect_cancel' called later than expected.");
+  return cmock_call_instance->ReturnVal;
+}
+
+void sd_ble_gap_connect_cancel_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_connect_cancel_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_connect_cancel_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_connect_cancel_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_connect_cancel_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_connect_cancel_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_connect_cancel_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_connect_cancel_StubWithCallback(CMOCK_sd_ble_gap_connect_cancel_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_connect_cancel_CallbackFunctionPointer = Callback;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_gap.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_gap.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_gap.h 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_gap.h  2018-04-24 08:48:28.768150300 +0200
@@ -0,0 +1,572 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_BLE_GAP_H
+#define _MOCK_BLE_GAP_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <ble_gap.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_ble_gap_Init(void);
+void mock_ble_gap_Destroy(void);
+void mock_ble_gap_Verify(void);
+
+
+
+
+#define sd_ble_gap_addr_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_addr_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_addr_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_addr_set_ExpectAndReturn(p_addr, cmock_retval) sd_ble_gap_addr_set_CMockExpectAndReturn(__LINE__, p_addr, cmock_retval)
+void sd_ble_gap_addr_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_addr, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_addr_set_CALLBACK)(ble_gap_addr_t const* p_addr, int cmock_num_calls);
+void sd_ble_gap_addr_set_StubWithCallback(CMOCK_sd_ble_gap_addr_set_CALLBACK Callback);
+#define sd_ble_gap_addr_set_ExpectWithArrayAndReturn(p_addr, p_addr_Depth, cmock_retval) sd_ble_gap_addr_set_CMockExpectWithArrayAndReturn(__LINE__, p_addr, p_addr_Depth, cmock_retval)
+void sd_ble_gap_addr_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_addr, int p_addr_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_addr_set_ReturnThruPtr_p_addr(p_addr) sd_ble_gap_addr_set_CMockReturnMemThruPtr_p_addr(__LINE__, p_addr, sizeof(*p_addr))
+#define sd_ble_gap_addr_set_ReturnArrayThruPtr_p_addr(p_addr, cmock_len) sd_ble_gap_addr_set_CMockReturnMemThruPtr_p_addr(__LINE__, p_addr, cmock_len * sizeof(*p_addr))
+#define sd_ble_gap_addr_set_ReturnMemThruPtr_p_addr(p_addr, cmock_size) sd_ble_gap_addr_set_CMockReturnMemThruPtr_p_addr(__LINE__, p_addr, cmock_size)
+void sd_ble_gap_addr_set_CMockReturnMemThruPtr_p_addr(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_addr, int cmock_size);
+#define sd_ble_gap_addr_set_IgnoreArg_p_addr() sd_ble_gap_addr_set_CMockIgnoreArg_p_addr(__LINE__)
+void sd_ble_gap_addr_set_CMockIgnoreArg_p_addr(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_addr_get_IgnoreAndReturn(cmock_retval) sd_ble_gap_addr_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_addr_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_addr_get_ExpectAndReturn(p_addr, cmock_retval) sd_ble_gap_addr_get_CMockExpectAndReturn(__LINE__, p_addr, cmock_retval)
+void sd_ble_gap_addr_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t* p_addr, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_addr_get_CALLBACK)(ble_gap_addr_t* p_addr, int cmock_num_calls);
+void sd_ble_gap_addr_get_StubWithCallback(CMOCK_sd_ble_gap_addr_get_CALLBACK Callback);
+#define sd_ble_gap_addr_get_ExpectWithArrayAndReturn(p_addr, p_addr_Depth, cmock_retval) sd_ble_gap_addr_get_CMockExpectWithArrayAndReturn(__LINE__, p_addr, p_addr_Depth, cmock_retval)
+void sd_ble_gap_addr_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t* p_addr, int p_addr_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_addr_get_ReturnThruPtr_p_addr(p_addr) sd_ble_gap_addr_get_CMockReturnMemThruPtr_p_addr(__LINE__, p_addr, sizeof(*p_addr))
+#define sd_ble_gap_addr_get_ReturnArrayThruPtr_p_addr(p_addr, cmock_len) sd_ble_gap_addr_get_CMockReturnMemThruPtr_p_addr(__LINE__, p_addr, cmock_len * sizeof(*p_addr))
+#define sd_ble_gap_addr_get_ReturnMemThruPtr_p_addr(p_addr, cmock_size) sd_ble_gap_addr_get_CMockReturnMemThruPtr_p_addr(__LINE__, p_addr, cmock_size)
+void sd_ble_gap_addr_get_CMockReturnMemThruPtr_p_addr(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t* p_addr, int cmock_size);
+#define sd_ble_gap_addr_get_IgnoreArg_p_addr() sd_ble_gap_addr_get_CMockIgnoreArg_p_addr(__LINE__)
+void sd_ble_gap_addr_get_CMockIgnoreArg_p_addr(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_whitelist_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_whitelist_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_whitelist_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_whitelist_set_ExpectAndReturn(pp_wl_addrs, len, cmock_retval) sd_ble_gap_whitelist_set_CMockExpectAndReturn(__LINE__, pp_wl_addrs, len, cmock_retval)
+void sd_ble_gap_whitelist_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* const* pp_wl_addrs, uint8_t len, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_whitelist_set_CALLBACK)(ble_gap_addr_t const* const* pp_wl_addrs, uint8_t len, int cmock_num_calls);
+void sd_ble_gap_whitelist_set_StubWithCallback(CMOCK_sd_ble_gap_whitelist_set_CALLBACK Callback);
+#define sd_ble_gap_whitelist_set_ExpectWithArrayAndReturn(pp_wl_addrs, pp_wl_addrs_Depth, len, cmock_retval) sd_ble_gap_whitelist_set_CMockExpectWithArrayAndReturn(__LINE__, pp_wl_addrs, pp_wl_addrs_Depth, len, cmock_retval)
+void sd_ble_gap_whitelist_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* const* pp_wl_addrs, int pp_wl_addrs_Depth, uint8_t len, uint32_t cmock_to_return);
+#define sd_ble_gap_whitelist_set_ReturnThruPtr_pp_wl_addrs(pp_wl_addrs) sd_ble_gap_whitelist_set_CMockReturnMemThruPtr_pp_wl_addrs(__LINE__, pp_wl_addrs, sizeof(*pp_wl_addrs))
+#define sd_ble_gap_whitelist_set_ReturnArrayThruPtr_pp_wl_addrs(pp_wl_addrs, cmock_len) sd_ble_gap_whitelist_set_CMockReturnMemThruPtr_pp_wl_addrs(__LINE__, pp_wl_addrs, cmock_len * sizeof(*pp_wl_addrs))
+#define sd_ble_gap_whitelist_set_ReturnMemThruPtr_pp_wl_addrs(pp_wl_addrs, cmock_size) sd_ble_gap_whitelist_set_CMockReturnMemThruPtr_pp_wl_addrs(__LINE__, pp_wl_addrs, cmock_size)
+void sd_ble_gap_whitelist_set_CMockReturnMemThruPtr_pp_wl_addrs(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* const* pp_wl_addrs, int cmock_size);
+#define sd_ble_gap_whitelist_set_IgnoreArg_pp_wl_addrs() sd_ble_gap_whitelist_set_CMockIgnoreArg_pp_wl_addrs(__LINE__)
+void sd_ble_gap_whitelist_set_CMockIgnoreArg_pp_wl_addrs(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_whitelist_set_IgnoreArg_len() sd_ble_gap_whitelist_set_CMockIgnoreArg_len(__LINE__)
+void sd_ble_gap_whitelist_set_CMockIgnoreArg_len(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_device_identities_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_device_identities_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_device_identities_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_device_identities_set_ExpectAndReturn(pp_id_keys, pp_local_irks, len, cmock_retval) sd_ble_gap_device_identities_set_CMockExpectAndReturn(__LINE__, pp_id_keys, pp_local_irks, len, cmock_retval)
+void sd_ble_gap_device_identities_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_id_key_t const* const* pp_id_keys, ble_gap_irk_t const* const* pp_local_irks, uint8_t len, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_device_identities_set_CALLBACK)(ble_gap_id_key_t const* const* pp_id_keys, ble_gap_irk_t const* const* pp_local_irks, uint8_t len, int cmock_num_calls);
+void sd_ble_gap_device_identities_set_StubWithCallback(CMOCK_sd_ble_gap_device_identities_set_CALLBACK Callback);
+#define sd_ble_gap_device_identities_set_ExpectWithArrayAndReturn(pp_id_keys, pp_id_keys_Depth, pp_local_irks, pp_local_irks_Depth, len, cmock_retval) sd_ble_gap_device_identities_set_CMockExpectWithArrayAndReturn(__LINE__, pp_id_keys, pp_id_keys_Depth, pp_local_irks, pp_local_irks_Depth, len, cmock_retval)
+void sd_ble_gap_device_identities_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_id_key_t const* const* pp_id_keys, int pp_id_keys_Depth, ble_gap_irk_t const* const* pp_local_irks, int pp_local_irks_Depth, uint8_t len, uint32_t cmock_to_return);
+#define sd_ble_gap_device_identities_set_ReturnThruPtr_pp_id_keys(pp_id_keys) sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_id_keys(__LINE__, pp_id_keys, sizeof(*pp_id_keys))
+#define sd_ble_gap_device_identities_set_ReturnArrayThruPtr_pp_id_keys(pp_id_keys, cmock_len) sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_id_keys(__LINE__, pp_id_keys, cmock_len * sizeof(*pp_id_keys))
+#define sd_ble_gap_device_identities_set_ReturnMemThruPtr_pp_id_keys(pp_id_keys, cmock_size) sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_id_keys(__LINE__, pp_id_keys, cmock_size)
+void sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_id_keys(UNITY_LINE_TYPE cmock_line, ble_gap_id_key_t const* const* pp_id_keys, int cmock_size);
+#define sd_ble_gap_device_identities_set_ReturnThruPtr_pp_local_irks(pp_local_irks) sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_local_irks(__LINE__, pp_local_irks, sizeof(*pp_local_irks))
+#define sd_ble_gap_device_identities_set_ReturnArrayThruPtr_pp_local_irks(pp_local_irks, cmock_len) sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_local_irks(__LINE__, pp_local_irks, cmock_len * sizeof(*pp_local_irks))
+#define sd_ble_gap_device_identities_set_ReturnMemThruPtr_pp_local_irks(pp_local_irks, cmock_size) sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_local_irks(__LINE__, pp_local_irks, cmock_size)
+void sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_local_irks(UNITY_LINE_TYPE cmock_line, ble_gap_irk_t const* const* pp_local_irks, int cmock_size);
+#define sd_ble_gap_device_identities_set_IgnoreArg_pp_id_keys() sd_ble_gap_device_identities_set_CMockIgnoreArg_pp_id_keys(__LINE__)
+void sd_ble_gap_device_identities_set_CMockIgnoreArg_pp_id_keys(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_device_identities_set_IgnoreArg_pp_local_irks() sd_ble_gap_device_identities_set_CMockIgnoreArg_pp_local_irks(__LINE__)
+void sd_ble_gap_device_identities_set_CMockIgnoreArg_pp_local_irks(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_device_identities_set_IgnoreArg_len() sd_ble_gap_device_identities_set_CMockIgnoreArg_len(__LINE__)
+void sd_ble_gap_device_identities_set_CMockIgnoreArg_len(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_privacy_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_privacy_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_privacy_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_privacy_set_ExpectAndReturn(p_privacy_params, cmock_retval) sd_ble_gap_privacy_set_CMockExpectAndReturn(__LINE__, p_privacy_params, cmock_retval)
+void sd_ble_gap_privacy_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t const* p_privacy_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_privacy_set_CALLBACK)(ble_gap_privacy_params_t const* p_privacy_params, int cmock_num_calls);
+void sd_ble_gap_privacy_set_StubWithCallback(CMOCK_sd_ble_gap_privacy_set_CALLBACK Callback);
+#define sd_ble_gap_privacy_set_ExpectWithArrayAndReturn(p_privacy_params, p_privacy_params_Depth, cmock_retval) sd_ble_gap_privacy_set_CMockExpectWithArrayAndReturn(__LINE__, p_privacy_params, p_privacy_params_Depth, cmock_retval)
+void sd_ble_gap_privacy_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t const* p_privacy_params, int p_privacy_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_privacy_set_ReturnThruPtr_p_privacy_params(p_privacy_params) sd_ble_gap_privacy_set_CMockReturnMemThruPtr_p_privacy_params(__LINE__, p_privacy_params, sizeof(*p_privacy_params))
+#define sd_ble_gap_privacy_set_ReturnArrayThruPtr_p_privacy_params(p_privacy_params, cmock_len) sd_ble_gap_privacy_set_CMockReturnMemThruPtr_p_privacy_params(__LINE__, p_privacy_params, cmock_len * sizeof(*p_privacy_params))
+#define sd_ble_gap_privacy_set_ReturnMemThruPtr_p_privacy_params(p_privacy_params, cmock_size) sd_ble_gap_privacy_set_CMockReturnMemThruPtr_p_privacy_params(__LINE__, p_privacy_params, cmock_size)
+void sd_ble_gap_privacy_set_CMockReturnMemThruPtr_p_privacy_params(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t const* p_privacy_params, int cmock_size);
+#define sd_ble_gap_privacy_set_IgnoreArg_p_privacy_params() sd_ble_gap_privacy_set_CMockIgnoreArg_p_privacy_params(__LINE__)
+void sd_ble_gap_privacy_set_CMockIgnoreArg_p_privacy_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_privacy_get_IgnoreAndReturn(cmock_retval) sd_ble_gap_privacy_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_privacy_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_privacy_get_ExpectAndReturn(p_privacy_params, cmock_retval) sd_ble_gap_privacy_get_CMockExpectAndReturn(__LINE__, p_privacy_params, cmock_retval)
+void sd_ble_gap_privacy_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t* p_privacy_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_privacy_get_CALLBACK)(ble_gap_privacy_params_t* p_privacy_params, int cmock_num_calls);
+void sd_ble_gap_privacy_get_StubWithCallback(CMOCK_sd_ble_gap_privacy_get_CALLBACK Callback);
+#define sd_ble_gap_privacy_get_ExpectWithArrayAndReturn(p_privacy_params, p_privacy_params_Depth, cmock_retval) sd_ble_gap_privacy_get_CMockExpectWithArrayAndReturn(__LINE__, p_privacy_params, p_privacy_params_Depth, cmock_retval)
+void sd_ble_gap_privacy_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t* p_privacy_params, int p_privacy_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_privacy_get_ReturnThruPtr_p_privacy_params(p_privacy_params) sd_ble_gap_privacy_get_CMockReturnMemThruPtr_p_privacy_params(__LINE__, p_privacy_params, sizeof(*p_privacy_params))
+#define sd_ble_gap_privacy_get_ReturnArrayThruPtr_p_privacy_params(p_privacy_params, cmock_len) sd_ble_gap_privacy_get_CMockReturnMemThruPtr_p_privacy_params(__LINE__, p_privacy_params, cmock_len * sizeof(*p_privacy_params))
+#define sd_ble_gap_privacy_get_ReturnMemThruPtr_p_privacy_params(p_privacy_params, cmock_size) sd_ble_gap_privacy_get_CMockReturnMemThruPtr_p_privacy_params(__LINE__, p_privacy_params, cmock_size)
+void sd_ble_gap_privacy_get_CMockReturnMemThruPtr_p_privacy_params(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t* p_privacy_params, int cmock_size);
+#define sd_ble_gap_privacy_get_IgnoreArg_p_privacy_params() sd_ble_gap_privacy_get_CMockIgnoreArg_p_privacy_params(__LINE__)
+void sd_ble_gap_privacy_get_CMockIgnoreArg_p_privacy_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_adv_data_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_adv_data_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_adv_data_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_adv_data_set_ExpectAndReturn(p_data, dlen, p_sr_data, srdlen, cmock_retval) sd_ble_gap_adv_data_set_CMockExpectAndReturn(__LINE__, p_data, dlen, p_sr_data, srdlen, cmock_retval)
+void sd_ble_gap_adv_data_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t const* p_data, uint8_t dlen, uint8_t const* p_sr_data, uint8_t srdlen, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_adv_data_set_CALLBACK)(uint8_t const* p_data, uint8_t dlen, uint8_t const* p_sr_data, uint8_t srdlen, int cmock_num_calls);
+void sd_ble_gap_adv_data_set_StubWithCallback(CMOCK_sd_ble_gap_adv_data_set_CALLBACK Callback);
+#define sd_ble_gap_adv_data_set_ExpectWithArrayAndReturn(p_data, p_data_Depth, dlen, p_sr_data, p_sr_data_Depth, srdlen, cmock_retval) sd_ble_gap_adv_data_set_CMockExpectWithArrayAndReturn(__LINE__, p_data, p_data_Depth, dlen, p_sr_data, p_sr_data_Depth, srdlen, cmock_retval)
+void sd_ble_gap_adv_data_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t const* p_data, int p_data_Depth, uint8_t dlen, uint8_t const* p_sr_data, int p_sr_data_Depth, uint8_t srdlen, uint32_t cmock_to_return);
+#define sd_ble_gap_adv_data_set_ReturnThruPtr_p_data(p_data) sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_data(__LINE__, p_data, sizeof(*p_data))
+#define sd_ble_gap_adv_data_set_ReturnArrayThruPtr_p_data(p_data, cmock_len) sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_data(__LINE__, p_data, cmock_len * sizeof(*p_data))
+#define sd_ble_gap_adv_data_set_ReturnMemThruPtr_p_data(p_data, cmock_size) sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_data(__LINE__, p_data, cmock_size)
+void sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_data(UNITY_LINE_TYPE cmock_line, uint8_t const* p_data, int cmock_size);
+#define sd_ble_gap_adv_data_set_ReturnThruPtr_p_sr_data(p_sr_data) sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_sr_data(__LINE__, p_sr_data, sizeof(*p_sr_data))
+#define sd_ble_gap_adv_data_set_ReturnArrayThruPtr_p_sr_data(p_sr_data, cmock_len) sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_sr_data(__LINE__, p_sr_data, cmock_len * sizeof(*p_sr_data))
+#define sd_ble_gap_adv_data_set_ReturnMemThruPtr_p_sr_data(p_sr_data, cmock_size) sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_sr_data(__LINE__, p_sr_data, cmock_size)
+void sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_sr_data(UNITY_LINE_TYPE cmock_line, uint8_t const* p_sr_data, int cmock_size);
+#define sd_ble_gap_adv_data_set_IgnoreArg_p_data() sd_ble_gap_adv_data_set_CMockIgnoreArg_p_data(__LINE__)
+void sd_ble_gap_adv_data_set_CMockIgnoreArg_p_data(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_adv_data_set_IgnoreArg_dlen() sd_ble_gap_adv_data_set_CMockIgnoreArg_dlen(__LINE__)
+void sd_ble_gap_adv_data_set_CMockIgnoreArg_dlen(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_adv_data_set_IgnoreArg_p_sr_data() sd_ble_gap_adv_data_set_CMockIgnoreArg_p_sr_data(__LINE__)
+void sd_ble_gap_adv_data_set_CMockIgnoreArg_p_sr_data(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_adv_data_set_IgnoreArg_srdlen() sd_ble_gap_adv_data_set_CMockIgnoreArg_srdlen(__LINE__)
+void sd_ble_gap_adv_data_set_CMockIgnoreArg_srdlen(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_adv_start_IgnoreAndReturn(cmock_retval) sd_ble_gap_adv_start_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_adv_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_adv_start_ExpectAndReturn(p_adv_params, cmock_retval) sd_ble_gap_adv_start_CMockExpectAndReturn(__LINE__, p_adv_params, cmock_retval)
+void sd_ble_gap_adv_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_adv_params_t const* p_adv_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_adv_start_CALLBACK)(ble_gap_adv_params_t const* p_adv_params, int cmock_num_calls);
+void sd_ble_gap_adv_start_StubWithCallback(CMOCK_sd_ble_gap_adv_start_CALLBACK Callback);
+#define sd_ble_gap_adv_start_ExpectWithArrayAndReturn(p_adv_params, p_adv_params_Depth, cmock_retval) sd_ble_gap_adv_start_CMockExpectWithArrayAndReturn(__LINE__, p_adv_params, p_adv_params_Depth, cmock_retval)
+void sd_ble_gap_adv_start_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_adv_params_t const* p_adv_params, int p_adv_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_adv_start_ReturnThruPtr_p_adv_params(p_adv_params) sd_ble_gap_adv_start_CMockReturnMemThruPtr_p_adv_params(__LINE__, p_adv_params, sizeof(*p_adv_params))
+#define sd_ble_gap_adv_start_ReturnArrayThruPtr_p_adv_params(p_adv_params, cmock_len) sd_ble_gap_adv_start_CMockReturnMemThruPtr_p_adv_params(__LINE__, p_adv_params, cmock_len * sizeof(*p_adv_params))
+#define sd_ble_gap_adv_start_ReturnMemThruPtr_p_adv_params(p_adv_params, cmock_size) sd_ble_gap_adv_start_CMockReturnMemThruPtr_p_adv_params(__LINE__, p_adv_params, cmock_size)
+void sd_ble_gap_adv_start_CMockReturnMemThruPtr_p_adv_params(UNITY_LINE_TYPE cmock_line, ble_gap_adv_params_t const* p_adv_params, int cmock_size);
+#define sd_ble_gap_adv_start_IgnoreArg_p_adv_params() sd_ble_gap_adv_start_CMockIgnoreArg_p_adv_params(__LINE__)
+void sd_ble_gap_adv_start_CMockIgnoreArg_p_adv_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_adv_stop_IgnoreAndReturn(cmock_retval) sd_ble_gap_adv_stop_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_adv_stop_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_adv_stop_ExpectAndReturn(cmock_retval) sd_ble_gap_adv_stop_CMockExpectAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_adv_stop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_adv_stop_CALLBACK)(int cmock_num_calls);
+void sd_ble_gap_adv_stop_StubWithCallback(CMOCK_sd_ble_gap_adv_stop_CALLBACK Callback);
+#define sd_ble_gap_conn_param_update_IgnoreAndReturn(cmock_retval) sd_ble_gap_conn_param_update_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_conn_param_update_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_conn_param_update_ExpectAndReturn(conn_handle, p_conn_params, cmock_retval) sd_ble_gap_conn_param_update_CMockExpectAndReturn(__LINE__, conn_handle, p_conn_params, cmock_retval)
+void sd_ble_gap_conn_param_update_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_conn_params_t const* p_conn_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_conn_param_update_CALLBACK)(uint16_t conn_handle, ble_gap_conn_params_t const* p_conn_params, int cmock_num_calls);
+void sd_ble_gap_conn_param_update_StubWithCallback(CMOCK_sd_ble_gap_conn_param_update_CALLBACK Callback);
+#define sd_ble_gap_conn_param_update_ExpectWithArrayAndReturn(conn_handle, p_conn_params, p_conn_params_Depth, cmock_retval) sd_ble_gap_conn_param_update_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_conn_params, p_conn_params_Depth, cmock_retval)
+void sd_ble_gap_conn_param_update_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_conn_param_update_ReturnThruPtr_p_conn_params(p_conn_params) sd_ble_gap_conn_param_update_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, sizeof(*p_conn_params))
+#define sd_ble_gap_conn_param_update_ReturnArrayThruPtr_p_conn_params(p_conn_params, cmock_len) sd_ble_gap_conn_param_update_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, cmock_len * sizeof(*p_conn_params))
+#define sd_ble_gap_conn_param_update_ReturnMemThruPtr_p_conn_params(p_conn_params, cmock_size) sd_ble_gap_conn_param_update_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, cmock_size)
+void sd_ble_gap_conn_param_update_CMockReturnMemThruPtr_p_conn_params(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, int cmock_size);
+#define sd_ble_gap_conn_param_update_IgnoreArg_conn_handle() sd_ble_gap_conn_param_update_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_conn_param_update_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_conn_param_update_IgnoreArg_p_conn_params() sd_ble_gap_conn_param_update_CMockIgnoreArg_p_conn_params(__LINE__)
+void sd_ble_gap_conn_param_update_CMockIgnoreArg_p_conn_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_disconnect_IgnoreAndReturn(cmock_retval) sd_ble_gap_disconnect_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_disconnect_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_disconnect_ExpectAndReturn(conn_handle, hci_status_code, cmock_retval) sd_ble_gap_disconnect_CMockExpectAndReturn(__LINE__, conn_handle, hci_status_code, cmock_retval)
+void sd_ble_gap_disconnect_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t hci_status_code, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_disconnect_CALLBACK)(uint16_t conn_handle, uint8_t hci_status_code, int cmock_num_calls);
+void sd_ble_gap_disconnect_StubWithCallback(CMOCK_sd_ble_gap_disconnect_CALLBACK Callback);
+#define sd_ble_gap_disconnect_IgnoreArg_conn_handle() sd_ble_gap_disconnect_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_disconnect_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_disconnect_IgnoreArg_hci_status_code() sd_ble_gap_disconnect_CMockIgnoreArg_hci_status_code(__LINE__)
+void sd_ble_gap_disconnect_CMockIgnoreArg_hci_status_code(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_tx_power_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_tx_power_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_tx_power_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_tx_power_set_ExpectAndReturn(tx_power, cmock_retval) sd_ble_gap_tx_power_set_CMockExpectAndReturn(__LINE__, tx_power, cmock_retval)
+void sd_ble_gap_tx_power_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int8_t tx_power, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_tx_power_set_CALLBACK)(int8_t tx_power, int cmock_num_calls);
+void sd_ble_gap_tx_power_set_StubWithCallback(CMOCK_sd_ble_gap_tx_power_set_CALLBACK Callback);
+#define sd_ble_gap_tx_power_set_IgnoreArg_tx_power() sd_ble_gap_tx_power_set_CMockIgnoreArg_tx_power(__LINE__)
+void sd_ble_gap_tx_power_set_CMockIgnoreArg_tx_power(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_appearance_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_appearance_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_appearance_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_appearance_set_ExpectAndReturn(appearance, cmock_retval) sd_ble_gap_appearance_set_CMockExpectAndReturn(__LINE__, appearance, cmock_retval)
+void sd_ble_gap_appearance_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t appearance, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_appearance_set_CALLBACK)(uint16_t appearance, int cmock_num_calls);
+void sd_ble_gap_appearance_set_StubWithCallback(CMOCK_sd_ble_gap_appearance_set_CALLBACK Callback);
+#define sd_ble_gap_appearance_set_IgnoreArg_appearance() sd_ble_gap_appearance_set_CMockIgnoreArg_appearance(__LINE__)
+void sd_ble_gap_appearance_set_CMockIgnoreArg_appearance(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_appearance_get_IgnoreAndReturn(cmock_retval) sd_ble_gap_appearance_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_appearance_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_appearance_get_ExpectAndReturn(p_appearance, cmock_retval) sd_ble_gap_appearance_get_CMockExpectAndReturn(__LINE__, p_appearance, cmock_retval)
+void sd_ble_gap_appearance_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t* p_appearance, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_appearance_get_CALLBACK)(uint16_t* p_appearance, int cmock_num_calls);
+void sd_ble_gap_appearance_get_StubWithCallback(CMOCK_sd_ble_gap_appearance_get_CALLBACK Callback);
+#define sd_ble_gap_appearance_get_ExpectWithArrayAndReturn(p_appearance, p_appearance_Depth, cmock_retval) sd_ble_gap_appearance_get_CMockExpectWithArrayAndReturn(__LINE__, p_appearance, p_appearance_Depth, cmock_retval)
+void sd_ble_gap_appearance_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t* p_appearance, int p_appearance_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_appearance_get_ReturnThruPtr_p_appearance(p_appearance) sd_ble_gap_appearance_get_CMockReturnMemThruPtr_p_appearance(__LINE__, p_appearance, sizeof(*p_appearance))
+#define sd_ble_gap_appearance_get_ReturnArrayThruPtr_p_appearance(p_appearance, cmock_len) sd_ble_gap_appearance_get_CMockReturnMemThruPtr_p_appearance(__LINE__, p_appearance, cmock_len * sizeof(*p_appearance))
+#define sd_ble_gap_appearance_get_ReturnMemThruPtr_p_appearance(p_appearance, cmock_size) sd_ble_gap_appearance_get_CMockReturnMemThruPtr_p_appearance(__LINE__, p_appearance, cmock_size)
+void sd_ble_gap_appearance_get_CMockReturnMemThruPtr_p_appearance(UNITY_LINE_TYPE cmock_line, uint16_t* p_appearance, int cmock_size);
+#define sd_ble_gap_appearance_get_IgnoreArg_p_appearance() sd_ble_gap_appearance_get_CMockIgnoreArg_p_appearance(__LINE__)
+void sd_ble_gap_appearance_get_CMockIgnoreArg_p_appearance(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_ppcp_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_ppcp_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_ppcp_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_ppcp_set_ExpectAndReturn(p_conn_params, cmock_retval) sd_ble_gap_ppcp_set_CMockExpectAndReturn(__LINE__, p_conn_params, cmock_retval)
+void sd_ble_gap_ppcp_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_ppcp_set_CALLBACK)(ble_gap_conn_params_t const* p_conn_params, int cmock_num_calls);
+void sd_ble_gap_ppcp_set_StubWithCallback(CMOCK_sd_ble_gap_ppcp_set_CALLBACK Callback);
+#define sd_ble_gap_ppcp_set_ExpectWithArrayAndReturn(p_conn_params, p_conn_params_Depth, cmock_retval) sd_ble_gap_ppcp_set_CMockExpectWithArrayAndReturn(__LINE__, p_conn_params, p_conn_params_Depth, cmock_retval)
+void sd_ble_gap_ppcp_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_ppcp_set_ReturnThruPtr_p_conn_params(p_conn_params) sd_ble_gap_ppcp_set_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, sizeof(*p_conn_params))
+#define sd_ble_gap_ppcp_set_ReturnArrayThruPtr_p_conn_params(p_conn_params, cmock_len) sd_ble_gap_ppcp_set_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, cmock_len * sizeof(*p_conn_params))
+#define sd_ble_gap_ppcp_set_ReturnMemThruPtr_p_conn_params(p_conn_params, cmock_size) sd_ble_gap_ppcp_set_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, cmock_size)
+void sd_ble_gap_ppcp_set_CMockReturnMemThruPtr_p_conn_params(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, int cmock_size);
+#define sd_ble_gap_ppcp_set_IgnoreArg_p_conn_params() sd_ble_gap_ppcp_set_CMockIgnoreArg_p_conn_params(__LINE__)
+void sd_ble_gap_ppcp_set_CMockIgnoreArg_p_conn_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_ppcp_get_IgnoreAndReturn(cmock_retval) sd_ble_gap_ppcp_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_ppcp_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_ppcp_get_ExpectAndReturn(p_conn_params, cmock_retval) sd_ble_gap_ppcp_get_CMockExpectAndReturn(__LINE__, p_conn_params, cmock_retval)
+void sd_ble_gap_ppcp_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t* p_conn_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_ppcp_get_CALLBACK)(ble_gap_conn_params_t* p_conn_params, int cmock_num_calls);
+void sd_ble_gap_ppcp_get_StubWithCallback(CMOCK_sd_ble_gap_ppcp_get_CALLBACK Callback);
+#define sd_ble_gap_ppcp_get_ExpectWithArrayAndReturn(p_conn_params, p_conn_params_Depth, cmock_retval) sd_ble_gap_ppcp_get_CMockExpectWithArrayAndReturn(__LINE__, p_conn_params, p_conn_params_Depth, cmock_retval)
+void sd_ble_gap_ppcp_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t* p_conn_params, int p_conn_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_ppcp_get_ReturnThruPtr_p_conn_params(p_conn_params) sd_ble_gap_ppcp_get_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, sizeof(*p_conn_params))
+#define sd_ble_gap_ppcp_get_ReturnArrayThruPtr_p_conn_params(p_conn_params, cmock_len) sd_ble_gap_ppcp_get_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, cmock_len * sizeof(*p_conn_params))
+#define sd_ble_gap_ppcp_get_ReturnMemThruPtr_p_conn_params(p_conn_params, cmock_size) sd_ble_gap_ppcp_get_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, cmock_size)
+void sd_ble_gap_ppcp_get_CMockReturnMemThruPtr_p_conn_params(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t* p_conn_params, int cmock_size);
+#define sd_ble_gap_ppcp_get_IgnoreArg_p_conn_params() sd_ble_gap_ppcp_get_CMockIgnoreArg_p_conn_params(__LINE__)
+void sd_ble_gap_ppcp_get_CMockIgnoreArg_p_conn_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_device_name_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_device_name_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_device_name_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_device_name_set_ExpectAndReturn(p_write_perm, p_dev_name, len, cmock_retval) sd_ble_gap_device_name_set_CMockExpectAndReturn(__LINE__, p_write_perm, p_dev_name, len, cmock_retval)
+void sd_ble_gap_device_name_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_sec_mode_t const* p_write_perm, uint8_t const* p_dev_name, uint16_t len, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_device_name_set_CALLBACK)(ble_gap_conn_sec_mode_t const* p_write_perm, uint8_t const* p_dev_name, uint16_t len, int cmock_num_calls);
+void sd_ble_gap_device_name_set_StubWithCallback(CMOCK_sd_ble_gap_device_name_set_CALLBACK Callback);
+#define sd_ble_gap_device_name_set_ExpectWithArrayAndReturn(p_write_perm, p_write_perm_Depth, p_dev_name, p_dev_name_Depth, len, cmock_retval) sd_ble_gap_device_name_set_CMockExpectWithArrayAndReturn(__LINE__, p_write_perm, p_write_perm_Depth, p_dev_name, p_dev_name_Depth, len, cmock_retval)
+void sd_ble_gap_device_name_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_sec_mode_t const* p_write_perm, int p_write_perm_Depth, uint8_t const* p_dev_name, int p_dev_name_Depth, uint16_t len, uint32_t cmock_to_return);
+#define sd_ble_gap_device_name_set_ReturnThruPtr_p_write_perm(p_write_perm) sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_write_perm(__LINE__, p_write_perm, sizeof(*p_write_perm))
+#define sd_ble_gap_device_name_set_ReturnArrayThruPtr_p_write_perm(p_write_perm, cmock_len) sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_write_perm(__LINE__, p_write_perm, cmock_len * sizeof(*p_write_perm))
+#define sd_ble_gap_device_name_set_ReturnMemThruPtr_p_write_perm(p_write_perm, cmock_size) sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_write_perm(__LINE__, p_write_perm, cmock_size)
+void sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_write_perm(UNITY_LINE_TYPE cmock_line, ble_gap_conn_sec_mode_t const* p_write_perm, int cmock_size);
+#define sd_ble_gap_device_name_set_ReturnThruPtr_p_dev_name(p_dev_name) sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_dev_name(__LINE__, p_dev_name, sizeof(*p_dev_name))
+#define sd_ble_gap_device_name_set_ReturnArrayThruPtr_p_dev_name(p_dev_name, cmock_len) sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_dev_name(__LINE__, p_dev_name, cmock_len * sizeof(*p_dev_name))
+#define sd_ble_gap_device_name_set_ReturnMemThruPtr_p_dev_name(p_dev_name, cmock_size) sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_dev_name(__LINE__, p_dev_name, cmock_size)
+void sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_dev_name(UNITY_LINE_TYPE cmock_line, uint8_t const* p_dev_name, int cmock_size);
+#define sd_ble_gap_device_name_set_IgnoreArg_p_write_perm() sd_ble_gap_device_name_set_CMockIgnoreArg_p_write_perm(__LINE__)
+void sd_ble_gap_device_name_set_CMockIgnoreArg_p_write_perm(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_device_name_set_IgnoreArg_p_dev_name() sd_ble_gap_device_name_set_CMockIgnoreArg_p_dev_name(__LINE__)
+void sd_ble_gap_device_name_set_CMockIgnoreArg_p_dev_name(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_device_name_set_IgnoreArg_len() sd_ble_gap_device_name_set_CMockIgnoreArg_len(__LINE__)
+void sd_ble_gap_device_name_set_CMockIgnoreArg_len(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_device_name_get_IgnoreAndReturn(cmock_retval) sd_ble_gap_device_name_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_device_name_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_device_name_get_ExpectAndReturn(p_dev_name, p_len, cmock_retval) sd_ble_gap_device_name_get_CMockExpectAndReturn(__LINE__, p_dev_name, p_len, cmock_retval)
+void sd_ble_gap_device_name_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_dev_name, uint16_t* p_len, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_device_name_get_CALLBACK)(uint8_t* p_dev_name, uint16_t* p_len, int cmock_num_calls);
+void sd_ble_gap_device_name_get_StubWithCallback(CMOCK_sd_ble_gap_device_name_get_CALLBACK Callback);
+#define sd_ble_gap_device_name_get_ExpectWithArrayAndReturn(p_dev_name, p_dev_name_Depth, p_len, p_len_Depth, cmock_retval) sd_ble_gap_device_name_get_CMockExpectWithArrayAndReturn(__LINE__, p_dev_name, p_dev_name_Depth, p_len, p_len_Depth, cmock_retval)
+void sd_ble_gap_device_name_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_dev_name, int p_dev_name_Depth, uint16_t* p_len, int p_len_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_device_name_get_ReturnThruPtr_p_dev_name(p_dev_name) sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_dev_name(__LINE__, p_dev_name, sizeof(*p_dev_name))
+#define sd_ble_gap_device_name_get_ReturnArrayThruPtr_p_dev_name(p_dev_name, cmock_len) sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_dev_name(__LINE__, p_dev_name, cmock_len * sizeof(*p_dev_name))
+#define sd_ble_gap_device_name_get_ReturnMemThruPtr_p_dev_name(p_dev_name, cmock_size) sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_dev_name(__LINE__, p_dev_name, cmock_size)
+void sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_dev_name(UNITY_LINE_TYPE cmock_line, uint8_t* p_dev_name, int cmock_size);
+#define sd_ble_gap_device_name_get_ReturnThruPtr_p_len(p_len) sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_len(__LINE__, p_len, sizeof(*p_len))
+#define sd_ble_gap_device_name_get_ReturnArrayThruPtr_p_len(p_len, cmock_len) sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_len(__LINE__, p_len, cmock_len * sizeof(*p_len))
+#define sd_ble_gap_device_name_get_ReturnMemThruPtr_p_len(p_len, cmock_size) sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_len(__LINE__, p_len, cmock_size)
+void sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_len(UNITY_LINE_TYPE cmock_line, uint16_t* p_len, int cmock_size);
+#define sd_ble_gap_device_name_get_IgnoreArg_p_dev_name() sd_ble_gap_device_name_get_CMockIgnoreArg_p_dev_name(__LINE__)
+void sd_ble_gap_device_name_get_CMockIgnoreArg_p_dev_name(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_device_name_get_IgnoreArg_p_len() sd_ble_gap_device_name_get_CMockIgnoreArg_p_len(__LINE__)
+void sd_ble_gap_device_name_get_CMockIgnoreArg_p_len(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_authenticate_IgnoreAndReturn(cmock_retval) sd_ble_gap_authenticate_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_authenticate_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_authenticate_ExpectAndReturn(conn_handle, p_sec_params, cmock_retval) sd_ble_gap_authenticate_CMockExpectAndReturn(__LINE__, conn_handle, p_sec_params, cmock_retval)
+void sd_ble_gap_authenticate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_sec_params_t const* p_sec_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_authenticate_CALLBACK)(uint16_t conn_handle, ble_gap_sec_params_t const* p_sec_params, int cmock_num_calls);
+void sd_ble_gap_authenticate_StubWithCallback(CMOCK_sd_ble_gap_authenticate_CALLBACK Callback);
+#define sd_ble_gap_authenticate_ExpectWithArrayAndReturn(conn_handle, p_sec_params, p_sec_params_Depth, cmock_retval) sd_ble_gap_authenticate_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_sec_params, p_sec_params_Depth, cmock_retval)
+void sd_ble_gap_authenticate_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_sec_params_t const* p_sec_params, int p_sec_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_authenticate_ReturnThruPtr_p_sec_params(p_sec_params) sd_ble_gap_authenticate_CMockReturnMemThruPtr_p_sec_params(__LINE__, p_sec_params, sizeof(*p_sec_params))
+#define sd_ble_gap_authenticate_ReturnArrayThruPtr_p_sec_params(p_sec_params, cmock_len) sd_ble_gap_authenticate_CMockReturnMemThruPtr_p_sec_params(__LINE__, p_sec_params, cmock_len * sizeof(*p_sec_params))
+#define sd_ble_gap_authenticate_ReturnMemThruPtr_p_sec_params(p_sec_params, cmock_size) sd_ble_gap_authenticate_CMockReturnMemThruPtr_p_sec_params(__LINE__, p_sec_params, cmock_size)
+void sd_ble_gap_authenticate_CMockReturnMemThruPtr_p_sec_params(UNITY_LINE_TYPE cmock_line, ble_gap_sec_params_t const* p_sec_params, int cmock_size);
+#define sd_ble_gap_authenticate_IgnoreArg_conn_handle() sd_ble_gap_authenticate_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_authenticate_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_authenticate_IgnoreArg_p_sec_params() sd_ble_gap_authenticate_CMockIgnoreArg_p_sec_params(__LINE__)
+void sd_ble_gap_authenticate_CMockIgnoreArg_p_sec_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_sec_params_reply_IgnoreAndReturn(cmock_retval) sd_ble_gap_sec_params_reply_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_sec_params_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_sec_params_reply_ExpectAndReturn(conn_handle, sec_status, p_sec_params, p_sec_keyset, cmock_retval) sd_ble_gap_sec_params_reply_CMockExpectAndReturn(__LINE__, conn_handle, sec_status, p_sec_params, p_sec_keyset, cmock_retval)
+void sd_ble_gap_sec_params_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const* p_sec_params, ble_gap_sec_keyset_t const* p_sec_keyset, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_sec_params_reply_CALLBACK)(uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const* p_sec_params, ble_gap_sec_keyset_t const* p_sec_keyset, int cmock_num_calls);
+void sd_ble_gap_sec_params_reply_StubWithCallback(CMOCK_sd_ble_gap_sec_params_reply_CALLBACK Callback);
+#define sd_ble_gap_sec_params_reply_ExpectWithArrayAndReturn(conn_handle, sec_status, p_sec_params, p_sec_params_Depth, p_sec_keyset, p_sec_keyset_Depth, cmock_retval) sd_ble_gap_sec_params_reply_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, sec_status, p_sec_params, p_sec_params_Depth, p_sec_keyset, p_sec_keyset_Depth, cmock_retval)
+void sd_ble_gap_sec_params_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const* p_sec_params, int p_sec_params_Depth, ble_gap_sec_keyset_t const* p_sec_keyset, int p_sec_keyset_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_sec_params_reply_ReturnThruPtr_p_sec_params(p_sec_params) sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_params(__LINE__, p_sec_params, sizeof(*p_sec_params))
+#define sd_ble_gap_sec_params_reply_ReturnArrayThruPtr_p_sec_params(p_sec_params, cmock_len) sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_params(__LINE__, p_sec_params, cmock_len * sizeof(*p_sec_params))
+#define sd_ble_gap_sec_params_reply_ReturnMemThruPtr_p_sec_params(p_sec_params, cmock_size) sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_params(__LINE__, p_sec_params, cmock_size)
+void sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_params(UNITY_LINE_TYPE cmock_line, ble_gap_sec_params_t const* p_sec_params, int cmock_size);
+#define sd_ble_gap_sec_params_reply_ReturnThruPtr_p_sec_keyset(p_sec_keyset) sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_keyset(__LINE__, p_sec_keyset, sizeof(*p_sec_keyset))
+#define sd_ble_gap_sec_params_reply_ReturnArrayThruPtr_p_sec_keyset(p_sec_keyset, cmock_len) sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_keyset(__LINE__, p_sec_keyset, cmock_len * sizeof(*p_sec_keyset))
+#define sd_ble_gap_sec_params_reply_ReturnMemThruPtr_p_sec_keyset(p_sec_keyset, cmock_size) sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_keyset(__LINE__, p_sec_keyset, cmock_size)
+void sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_keyset(UNITY_LINE_TYPE cmock_line, ble_gap_sec_keyset_t const* p_sec_keyset, int cmock_size);
+#define sd_ble_gap_sec_params_reply_IgnoreArg_conn_handle() sd_ble_gap_sec_params_reply_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_sec_params_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_sec_params_reply_IgnoreArg_sec_status() sd_ble_gap_sec_params_reply_CMockIgnoreArg_sec_status(__LINE__)
+void sd_ble_gap_sec_params_reply_CMockIgnoreArg_sec_status(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_sec_params_reply_IgnoreArg_p_sec_params() sd_ble_gap_sec_params_reply_CMockIgnoreArg_p_sec_params(__LINE__)
+void sd_ble_gap_sec_params_reply_CMockIgnoreArg_p_sec_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_sec_params_reply_IgnoreArg_p_sec_keyset() sd_ble_gap_sec_params_reply_CMockIgnoreArg_p_sec_keyset(__LINE__)
+void sd_ble_gap_sec_params_reply_CMockIgnoreArg_p_sec_keyset(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_auth_key_reply_IgnoreAndReturn(cmock_retval) sd_ble_gap_auth_key_reply_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_auth_key_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_auth_key_reply_ExpectAndReturn(conn_handle, key_type, p_key, cmock_retval) sd_ble_gap_auth_key_reply_CMockExpectAndReturn(__LINE__, conn_handle, key_type, p_key, cmock_retval)
+void sd_ble_gap_auth_key_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t key_type, uint8_t const* p_key, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_auth_key_reply_CALLBACK)(uint16_t conn_handle, uint8_t key_type, uint8_t const* p_key, int cmock_num_calls);
+void sd_ble_gap_auth_key_reply_StubWithCallback(CMOCK_sd_ble_gap_auth_key_reply_CALLBACK Callback);
+#define sd_ble_gap_auth_key_reply_ExpectWithArrayAndReturn(conn_handle, key_type, p_key, p_key_Depth, cmock_retval) sd_ble_gap_auth_key_reply_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, key_type, p_key, p_key_Depth, cmock_retval)
+void sd_ble_gap_auth_key_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t key_type, uint8_t const* p_key, int p_key_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_auth_key_reply_ReturnThruPtr_p_key(p_key) sd_ble_gap_auth_key_reply_CMockReturnMemThruPtr_p_key(__LINE__, p_key, sizeof(*p_key))
+#define sd_ble_gap_auth_key_reply_ReturnArrayThruPtr_p_key(p_key, cmock_len) sd_ble_gap_auth_key_reply_CMockReturnMemThruPtr_p_key(__LINE__, p_key, cmock_len * sizeof(*p_key))
+#define sd_ble_gap_auth_key_reply_ReturnMemThruPtr_p_key(p_key, cmock_size) sd_ble_gap_auth_key_reply_CMockReturnMemThruPtr_p_key(__LINE__, p_key, cmock_size)
+void sd_ble_gap_auth_key_reply_CMockReturnMemThruPtr_p_key(UNITY_LINE_TYPE cmock_line, uint8_t const* p_key, int cmock_size);
+#define sd_ble_gap_auth_key_reply_IgnoreArg_conn_handle() sd_ble_gap_auth_key_reply_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_auth_key_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_auth_key_reply_IgnoreArg_key_type() sd_ble_gap_auth_key_reply_CMockIgnoreArg_key_type(__LINE__)
+void sd_ble_gap_auth_key_reply_CMockIgnoreArg_key_type(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_auth_key_reply_IgnoreArg_p_key() sd_ble_gap_auth_key_reply_CMockIgnoreArg_p_key(__LINE__)
+void sd_ble_gap_auth_key_reply_CMockIgnoreArg_p_key(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_lesc_dhkey_reply_IgnoreAndReturn(cmock_retval) sd_ble_gap_lesc_dhkey_reply_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_lesc_dhkey_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_lesc_dhkey_reply_ExpectAndReturn(conn_handle, p_dhkey, cmock_retval) sd_ble_gap_lesc_dhkey_reply_CMockExpectAndReturn(__LINE__, conn_handle, p_dhkey, cmock_retval)
+void sd_ble_gap_lesc_dhkey_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_dhkey_t const* p_dhkey, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_lesc_dhkey_reply_CALLBACK)(uint16_t conn_handle, ble_gap_lesc_dhkey_t const* p_dhkey, int cmock_num_calls);
+void sd_ble_gap_lesc_dhkey_reply_StubWithCallback(CMOCK_sd_ble_gap_lesc_dhkey_reply_CALLBACK Callback);
+#define sd_ble_gap_lesc_dhkey_reply_ExpectWithArrayAndReturn(conn_handle, p_dhkey, p_dhkey_Depth, cmock_retval) sd_ble_gap_lesc_dhkey_reply_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_dhkey, p_dhkey_Depth, cmock_retval)
+void sd_ble_gap_lesc_dhkey_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_dhkey_t const* p_dhkey, int p_dhkey_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_lesc_dhkey_reply_ReturnThruPtr_p_dhkey(p_dhkey) sd_ble_gap_lesc_dhkey_reply_CMockReturnMemThruPtr_p_dhkey(__LINE__, p_dhkey, sizeof(*p_dhkey))
+#define sd_ble_gap_lesc_dhkey_reply_ReturnArrayThruPtr_p_dhkey(p_dhkey, cmock_len) sd_ble_gap_lesc_dhkey_reply_CMockReturnMemThruPtr_p_dhkey(__LINE__, p_dhkey, cmock_len * sizeof(*p_dhkey))
+#define sd_ble_gap_lesc_dhkey_reply_ReturnMemThruPtr_p_dhkey(p_dhkey, cmock_size) sd_ble_gap_lesc_dhkey_reply_CMockReturnMemThruPtr_p_dhkey(__LINE__, p_dhkey, cmock_size)
+void sd_ble_gap_lesc_dhkey_reply_CMockReturnMemThruPtr_p_dhkey(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_dhkey_t const* p_dhkey, int cmock_size);
+#define sd_ble_gap_lesc_dhkey_reply_IgnoreArg_conn_handle() sd_ble_gap_lesc_dhkey_reply_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_lesc_dhkey_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_lesc_dhkey_reply_IgnoreArg_p_dhkey() sd_ble_gap_lesc_dhkey_reply_CMockIgnoreArg_p_dhkey(__LINE__)
+void sd_ble_gap_lesc_dhkey_reply_CMockIgnoreArg_p_dhkey(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_keypress_notify_IgnoreAndReturn(cmock_retval) sd_ble_gap_keypress_notify_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_keypress_notify_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_keypress_notify_ExpectAndReturn(conn_handle, kp_not, cmock_retval) sd_ble_gap_keypress_notify_CMockExpectAndReturn(__LINE__, conn_handle, kp_not, cmock_retval)
+void sd_ble_gap_keypress_notify_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t kp_not, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_keypress_notify_CALLBACK)(uint16_t conn_handle, uint8_t kp_not, int cmock_num_calls);
+void sd_ble_gap_keypress_notify_StubWithCallback(CMOCK_sd_ble_gap_keypress_notify_CALLBACK Callback);
+#define sd_ble_gap_keypress_notify_IgnoreArg_conn_handle() sd_ble_gap_keypress_notify_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_keypress_notify_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_keypress_notify_IgnoreArg_kp_not() sd_ble_gap_keypress_notify_CMockIgnoreArg_kp_not(__LINE__)
+void sd_ble_gap_keypress_notify_CMockIgnoreArg_kp_not(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_lesc_oob_data_get_IgnoreAndReturn(cmock_retval) sd_ble_gap_lesc_oob_data_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_lesc_oob_data_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_lesc_oob_data_get_ExpectAndReturn(conn_handle, p_pk_own, p_oobd_own, cmock_retval) sd_ble_gap_lesc_oob_data_get_CMockExpectAndReturn(__LINE__, conn_handle, p_pk_own, p_oobd_own, cmock_retval)
+void sd_ble_gap_lesc_oob_data_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_p256_pk_t const* p_pk_own, ble_gap_lesc_oob_data_t* p_oobd_own, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_lesc_oob_data_get_CALLBACK)(uint16_t conn_handle, ble_gap_lesc_p256_pk_t const* p_pk_own, ble_gap_lesc_oob_data_t* p_oobd_own, int cmock_num_calls);
+void sd_ble_gap_lesc_oob_data_get_StubWithCallback(CMOCK_sd_ble_gap_lesc_oob_data_get_CALLBACK Callback);
+#define sd_ble_gap_lesc_oob_data_get_ExpectWithArrayAndReturn(conn_handle, p_pk_own, p_pk_own_Depth, p_oobd_own, p_oobd_own_Depth, cmock_retval) sd_ble_gap_lesc_oob_data_get_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_pk_own, p_pk_own_Depth, p_oobd_own, p_oobd_own_Depth, cmock_retval)
+void sd_ble_gap_lesc_oob_data_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_p256_pk_t const* p_pk_own, int p_pk_own_Depth, ble_gap_lesc_oob_data_t* p_oobd_own, int p_oobd_own_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_lesc_oob_data_get_ReturnThruPtr_p_pk_own(p_pk_own) sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_pk_own(__LINE__, p_pk_own, sizeof(*p_pk_own))
+#define sd_ble_gap_lesc_oob_data_get_ReturnArrayThruPtr_p_pk_own(p_pk_own, cmock_len) sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_pk_own(__LINE__, p_pk_own, cmock_len * sizeof(*p_pk_own))
+#define sd_ble_gap_lesc_oob_data_get_ReturnMemThruPtr_p_pk_own(p_pk_own, cmock_size) sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_pk_own(__LINE__, p_pk_own, cmock_size)
+void sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_pk_own(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_p256_pk_t const* p_pk_own, int cmock_size);
+#define sd_ble_gap_lesc_oob_data_get_ReturnThruPtr_p_oobd_own(p_oobd_own) sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_oobd_own(__LINE__, p_oobd_own, sizeof(*p_oobd_own))
+#define sd_ble_gap_lesc_oob_data_get_ReturnArrayThruPtr_p_oobd_own(p_oobd_own, cmock_len) sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_oobd_own(__LINE__, p_oobd_own, cmock_len * sizeof(*p_oobd_own))
+#define sd_ble_gap_lesc_oob_data_get_ReturnMemThruPtr_p_oobd_own(p_oobd_own, cmock_size) sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_oobd_own(__LINE__, p_oobd_own, cmock_size)
+void sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_oobd_own(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_oob_data_t* p_oobd_own, int cmock_size);
+#define sd_ble_gap_lesc_oob_data_get_IgnoreArg_conn_handle() sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_lesc_oob_data_get_IgnoreArg_p_pk_own() sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_p_pk_own(__LINE__)
+void sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_p_pk_own(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_lesc_oob_data_get_IgnoreArg_p_oobd_own() sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_p_oobd_own(__LINE__)
+void sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_p_oobd_own(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_lesc_oob_data_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_lesc_oob_data_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_lesc_oob_data_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_lesc_oob_data_set_ExpectAndReturn(conn_handle, p_oobd_own, p_oobd_peer, cmock_retval) sd_ble_gap_lesc_oob_data_set_CMockExpectAndReturn(__LINE__, conn_handle, p_oobd_own, p_oobd_peer, cmock_retval)
+void sd_ble_gap_lesc_oob_data_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_oob_data_t const* p_oobd_own, ble_gap_lesc_oob_data_t const* p_oobd_peer, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_lesc_oob_data_set_CALLBACK)(uint16_t conn_handle, ble_gap_lesc_oob_data_t const* p_oobd_own, ble_gap_lesc_oob_data_t const* p_oobd_peer, int cmock_num_calls);
+void sd_ble_gap_lesc_oob_data_set_StubWithCallback(CMOCK_sd_ble_gap_lesc_oob_data_set_CALLBACK Callback);
+#define sd_ble_gap_lesc_oob_data_set_ExpectWithArrayAndReturn(conn_handle, p_oobd_own, p_oobd_own_Depth, p_oobd_peer, p_oobd_peer_Depth, cmock_retval) sd_ble_gap_lesc_oob_data_set_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_oobd_own, p_oobd_own_Depth, p_oobd_peer, p_oobd_peer_Depth, cmock_retval)
+void sd_ble_gap_lesc_oob_data_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_oob_data_t const* p_oobd_own, int p_oobd_own_Depth, ble_gap_lesc_oob_data_t const* p_oobd_peer, int p_oobd_peer_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_lesc_oob_data_set_ReturnThruPtr_p_oobd_own(p_oobd_own) sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_own(__LINE__, p_oobd_own, sizeof(*p_oobd_own))
+#define sd_ble_gap_lesc_oob_data_set_ReturnArrayThruPtr_p_oobd_own(p_oobd_own, cmock_len) sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_own(__LINE__, p_oobd_own, cmock_len * sizeof(*p_oobd_own))
+#define sd_ble_gap_lesc_oob_data_set_ReturnMemThruPtr_p_oobd_own(p_oobd_own, cmock_size) sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_own(__LINE__, p_oobd_own, cmock_size)
+void sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_own(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_oob_data_t const* p_oobd_own, int cmock_size);
+#define sd_ble_gap_lesc_oob_data_set_ReturnThruPtr_p_oobd_peer(p_oobd_peer) sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_peer(__LINE__, p_oobd_peer, sizeof(*p_oobd_peer))
+#define sd_ble_gap_lesc_oob_data_set_ReturnArrayThruPtr_p_oobd_peer(p_oobd_peer, cmock_len) sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_peer(__LINE__, p_oobd_peer, cmock_len * sizeof(*p_oobd_peer))
+#define sd_ble_gap_lesc_oob_data_set_ReturnMemThruPtr_p_oobd_peer(p_oobd_peer, cmock_size) sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_peer(__LINE__, p_oobd_peer, cmock_size)
+void sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_peer(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_oob_data_t const* p_oobd_peer, int cmock_size);
+#define sd_ble_gap_lesc_oob_data_set_IgnoreArg_conn_handle() sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_lesc_oob_data_set_IgnoreArg_p_oobd_own() sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_p_oobd_own(__LINE__)
+void sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_p_oobd_own(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_lesc_oob_data_set_IgnoreArg_p_oobd_peer() sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_p_oobd_peer(__LINE__)
+void sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_p_oobd_peer(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_encrypt_IgnoreAndReturn(cmock_retval) sd_ble_gap_encrypt_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_encrypt_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_encrypt_ExpectAndReturn(conn_handle, p_master_id, p_enc_info, cmock_retval) sd_ble_gap_encrypt_CMockExpectAndReturn(__LINE__, conn_handle, p_master_id, p_enc_info, cmock_retval)
+void sd_ble_gap_encrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_master_id_t const* p_master_id, ble_gap_enc_info_t const* p_enc_info, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_encrypt_CALLBACK)(uint16_t conn_handle, ble_gap_master_id_t const* p_master_id, ble_gap_enc_info_t const* p_enc_info, int cmock_num_calls);
+void sd_ble_gap_encrypt_StubWithCallback(CMOCK_sd_ble_gap_encrypt_CALLBACK Callback);
+#define sd_ble_gap_encrypt_ExpectWithArrayAndReturn(conn_handle, p_master_id, p_master_id_Depth, p_enc_info, p_enc_info_Depth, cmock_retval) sd_ble_gap_encrypt_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_master_id, p_master_id_Depth, p_enc_info, p_enc_info_Depth, cmock_retval)
+void sd_ble_gap_encrypt_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_master_id_t const* p_master_id, int p_master_id_Depth, ble_gap_enc_info_t const* p_enc_info, int p_enc_info_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_encrypt_ReturnThruPtr_p_master_id(p_master_id) sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_master_id(__LINE__, p_master_id, sizeof(*p_master_id))
+#define sd_ble_gap_encrypt_ReturnArrayThruPtr_p_master_id(p_master_id, cmock_len) sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_master_id(__LINE__, p_master_id, cmock_len * sizeof(*p_master_id))
+#define sd_ble_gap_encrypt_ReturnMemThruPtr_p_master_id(p_master_id, cmock_size) sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_master_id(__LINE__, p_master_id, cmock_size)
+void sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_master_id(UNITY_LINE_TYPE cmock_line, ble_gap_master_id_t const* p_master_id, int cmock_size);
+#define sd_ble_gap_encrypt_ReturnThruPtr_p_enc_info(p_enc_info) sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_enc_info(__LINE__, p_enc_info, sizeof(*p_enc_info))
+#define sd_ble_gap_encrypt_ReturnArrayThruPtr_p_enc_info(p_enc_info, cmock_len) sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_enc_info(__LINE__, p_enc_info, cmock_len * sizeof(*p_enc_info))
+#define sd_ble_gap_encrypt_ReturnMemThruPtr_p_enc_info(p_enc_info, cmock_size) sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_enc_info(__LINE__, p_enc_info, cmock_size)
+void sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_enc_info(UNITY_LINE_TYPE cmock_line, ble_gap_enc_info_t const* p_enc_info, int cmock_size);
+#define sd_ble_gap_encrypt_IgnoreArg_conn_handle() sd_ble_gap_encrypt_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_encrypt_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_encrypt_IgnoreArg_p_master_id() sd_ble_gap_encrypt_CMockIgnoreArg_p_master_id(__LINE__)
+void sd_ble_gap_encrypt_CMockIgnoreArg_p_master_id(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_encrypt_IgnoreArg_p_enc_info() sd_ble_gap_encrypt_CMockIgnoreArg_p_enc_info(__LINE__)
+void sd_ble_gap_encrypt_CMockIgnoreArg_p_enc_info(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_sec_info_reply_IgnoreAndReturn(cmock_retval) sd_ble_gap_sec_info_reply_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_sec_info_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_sec_info_reply_ExpectAndReturn(conn_handle, p_enc_info, p_id_info, p_sign_info, cmock_retval) sd_ble_gap_sec_info_reply_CMockExpectAndReturn(__LINE__, conn_handle, p_enc_info, p_id_info, p_sign_info, cmock_retval)
+void sd_ble_gap_sec_info_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_enc_info_t const* p_enc_info, ble_gap_irk_t const* p_id_info, ble_gap_sign_info_t const* p_sign_info, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_sec_info_reply_CALLBACK)(uint16_t conn_handle, ble_gap_enc_info_t const* p_enc_info, ble_gap_irk_t const* p_id_info, ble_gap_sign_info_t const* p_sign_info, int cmock_num_calls);
+void sd_ble_gap_sec_info_reply_StubWithCallback(CMOCK_sd_ble_gap_sec_info_reply_CALLBACK Callback);
+#define sd_ble_gap_sec_info_reply_ExpectWithArrayAndReturn(conn_handle, p_enc_info, p_enc_info_Depth, p_id_info, p_id_info_Depth, p_sign_info, p_sign_info_Depth, cmock_retval) sd_ble_gap_sec_info_reply_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_enc_info, p_enc_info_Depth, p_id_info, p_id_info_Depth, p_sign_info, p_sign_info_Depth, cmock_retval)
+void sd_ble_gap_sec_info_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_enc_info_t const* p_enc_info, int p_enc_info_Depth, ble_gap_irk_t const* p_id_info, int p_id_info_Depth, ble_gap_sign_info_t const* p_sign_info, int p_sign_info_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_sec_info_reply_ReturnThruPtr_p_enc_info(p_enc_info) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_enc_info(__LINE__, p_enc_info, sizeof(*p_enc_info))
+#define sd_ble_gap_sec_info_reply_ReturnArrayThruPtr_p_enc_info(p_enc_info, cmock_len) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_enc_info(__LINE__, p_enc_info, cmock_len * sizeof(*p_enc_info))
+#define sd_ble_gap_sec_info_reply_ReturnMemThruPtr_p_enc_info(p_enc_info, cmock_size) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_enc_info(__LINE__, p_enc_info, cmock_size)
+void sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_enc_info(UNITY_LINE_TYPE cmock_line, ble_gap_enc_info_t const* p_enc_info, int cmock_size);
+#define sd_ble_gap_sec_info_reply_ReturnThruPtr_p_id_info(p_id_info) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_id_info(__LINE__, p_id_info, sizeof(*p_id_info))
+#define sd_ble_gap_sec_info_reply_ReturnArrayThruPtr_p_id_info(p_id_info, cmock_len) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_id_info(__LINE__, p_id_info, cmock_len * sizeof(*p_id_info))
+#define sd_ble_gap_sec_info_reply_ReturnMemThruPtr_p_id_info(p_id_info, cmock_size) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_id_info(__LINE__, p_id_info, cmock_size)
+void sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_id_info(UNITY_LINE_TYPE cmock_line, ble_gap_irk_t const* p_id_info, int cmock_size);
+#define sd_ble_gap_sec_info_reply_ReturnThruPtr_p_sign_info(p_sign_info) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_sign_info(__LINE__, p_sign_info, sizeof(*p_sign_info))
+#define sd_ble_gap_sec_info_reply_ReturnArrayThruPtr_p_sign_info(p_sign_info, cmock_len) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_sign_info(__LINE__, p_sign_info, cmock_len * sizeof(*p_sign_info))
+#define sd_ble_gap_sec_info_reply_ReturnMemThruPtr_p_sign_info(p_sign_info, cmock_size) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_sign_info(__LINE__, p_sign_info, cmock_size)
+void sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_sign_info(UNITY_LINE_TYPE cmock_line, ble_gap_sign_info_t const* p_sign_info, int cmock_size);
+#define sd_ble_gap_sec_info_reply_IgnoreArg_conn_handle() sd_ble_gap_sec_info_reply_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_sec_info_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_sec_info_reply_IgnoreArg_p_enc_info() sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_enc_info(__LINE__)
+void sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_enc_info(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_sec_info_reply_IgnoreArg_p_id_info() sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_id_info(__LINE__)
+void sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_id_info(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_sec_info_reply_IgnoreArg_p_sign_info() sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_sign_info(__LINE__)
+void sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_sign_info(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_conn_sec_get_IgnoreAndReturn(cmock_retval) sd_ble_gap_conn_sec_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_conn_sec_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_conn_sec_get_ExpectAndReturn(conn_handle, p_conn_sec, cmock_retval) sd_ble_gap_conn_sec_get_CMockExpectAndReturn(__LINE__, conn_handle, p_conn_sec, cmock_retval)
+void sd_ble_gap_conn_sec_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_conn_sec_t* p_conn_sec, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_conn_sec_get_CALLBACK)(uint16_t conn_handle, ble_gap_conn_sec_t* p_conn_sec, int cmock_num_calls);
+void sd_ble_gap_conn_sec_get_StubWithCallback(CMOCK_sd_ble_gap_conn_sec_get_CALLBACK Callback);
+#define sd_ble_gap_conn_sec_get_ExpectWithArrayAndReturn(conn_handle, p_conn_sec, p_conn_sec_Depth, cmock_retval) sd_ble_gap_conn_sec_get_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_conn_sec, p_conn_sec_Depth, cmock_retval)
+void sd_ble_gap_conn_sec_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_conn_sec_t* p_conn_sec, int p_conn_sec_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_conn_sec_get_ReturnThruPtr_p_conn_sec(p_conn_sec) sd_ble_gap_conn_sec_get_CMockReturnMemThruPtr_p_conn_sec(__LINE__, p_conn_sec, sizeof(*p_conn_sec))
+#define sd_ble_gap_conn_sec_get_ReturnArrayThruPtr_p_conn_sec(p_conn_sec, cmock_len) sd_ble_gap_conn_sec_get_CMockReturnMemThruPtr_p_conn_sec(__LINE__, p_conn_sec, cmock_len * sizeof(*p_conn_sec))
+#define sd_ble_gap_conn_sec_get_ReturnMemThruPtr_p_conn_sec(p_conn_sec, cmock_size) sd_ble_gap_conn_sec_get_CMockReturnMemThruPtr_p_conn_sec(__LINE__, p_conn_sec, cmock_size)
+void sd_ble_gap_conn_sec_get_CMockReturnMemThruPtr_p_conn_sec(UNITY_LINE_TYPE cmock_line, ble_gap_conn_sec_t* p_conn_sec, int cmock_size);
+#define sd_ble_gap_conn_sec_get_IgnoreArg_conn_handle() sd_ble_gap_conn_sec_get_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_conn_sec_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_conn_sec_get_IgnoreArg_p_conn_sec() sd_ble_gap_conn_sec_get_CMockIgnoreArg_p_conn_sec(__LINE__)
+void sd_ble_gap_conn_sec_get_CMockIgnoreArg_p_conn_sec(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_rssi_start_IgnoreAndReturn(cmock_retval) sd_ble_gap_rssi_start_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_rssi_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_rssi_start_ExpectAndReturn(conn_handle, threshold_dbm, skip_count, cmock_retval) sd_ble_gap_rssi_start_CMockExpectAndReturn(__LINE__, conn_handle, threshold_dbm, skip_count, cmock_retval)
+void sd_ble_gap_rssi_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t threshold_dbm, uint8_t skip_count, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_rssi_start_CALLBACK)(uint16_t conn_handle, uint8_t threshold_dbm, uint8_t skip_count, int cmock_num_calls);
+void sd_ble_gap_rssi_start_StubWithCallback(CMOCK_sd_ble_gap_rssi_start_CALLBACK Callback);
+#define sd_ble_gap_rssi_start_IgnoreArg_conn_handle() sd_ble_gap_rssi_start_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_rssi_start_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_rssi_start_IgnoreArg_threshold_dbm() sd_ble_gap_rssi_start_CMockIgnoreArg_threshold_dbm(__LINE__)
+void sd_ble_gap_rssi_start_CMockIgnoreArg_threshold_dbm(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_rssi_start_IgnoreArg_skip_count() sd_ble_gap_rssi_start_CMockIgnoreArg_skip_count(__LINE__)
+void sd_ble_gap_rssi_start_CMockIgnoreArg_skip_count(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_rssi_stop_IgnoreAndReturn(cmock_retval) sd_ble_gap_rssi_stop_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_rssi_stop_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_rssi_stop_ExpectAndReturn(conn_handle, cmock_retval) sd_ble_gap_rssi_stop_CMockExpectAndReturn(__LINE__, conn_handle, cmock_retval)
+void sd_ble_gap_rssi_stop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_rssi_stop_CALLBACK)(uint16_t conn_handle, int cmock_num_calls);
+void sd_ble_gap_rssi_stop_StubWithCallback(CMOCK_sd_ble_gap_rssi_stop_CALLBACK Callback);
+#define sd_ble_gap_rssi_stop_IgnoreArg_conn_handle() sd_ble_gap_rssi_stop_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_rssi_stop_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_rssi_get_IgnoreAndReturn(cmock_retval) sd_ble_gap_rssi_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_rssi_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_rssi_get_ExpectAndReturn(conn_handle, p_rssi, cmock_retval) sd_ble_gap_rssi_get_CMockExpectAndReturn(__LINE__, conn_handle, p_rssi, cmock_retval)
+void sd_ble_gap_rssi_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, int8_t* p_rssi, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_rssi_get_CALLBACK)(uint16_t conn_handle, int8_t* p_rssi, int cmock_num_calls);
+void sd_ble_gap_rssi_get_StubWithCallback(CMOCK_sd_ble_gap_rssi_get_CALLBACK Callback);
+#define sd_ble_gap_rssi_get_ExpectWithArrayAndReturn(conn_handle, p_rssi, p_rssi_Depth, cmock_retval) sd_ble_gap_rssi_get_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_rssi, p_rssi_Depth, cmock_retval)
+void sd_ble_gap_rssi_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, int8_t* p_rssi, int p_rssi_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_rssi_get_ReturnThruPtr_p_rssi(p_rssi) sd_ble_gap_rssi_get_CMockReturnMemThruPtr_p_rssi(__LINE__, p_rssi, sizeof(*p_rssi))
+#define sd_ble_gap_rssi_get_ReturnArrayThruPtr_p_rssi(p_rssi, cmock_len) sd_ble_gap_rssi_get_CMockReturnMemThruPtr_p_rssi(__LINE__, p_rssi, cmock_len * sizeof(*p_rssi))
+#define sd_ble_gap_rssi_get_ReturnMemThruPtr_p_rssi(p_rssi, cmock_size) sd_ble_gap_rssi_get_CMockReturnMemThruPtr_p_rssi(__LINE__, p_rssi, cmock_size)
+void sd_ble_gap_rssi_get_CMockReturnMemThruPtr_p_rssi(UNITY_LINE_TYPE cmock_line, int8_t* p_rssi, int cmock_size);
+#define sd_ble_gap_rssi_get_IgnoreArg_conn_handle() sd_ble_gap_rssi_get_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_rssi_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_rssi_get_IgnoreArg_p_rssi() sd_ble_gap_rssi_get_CMockIgnoreArg_p_rssi(__LINE__)
+void sd_ble_gap_rssi_get_CMockIgnoreArg_p_rssi(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_scan_start_IgnoreAndReturn(cmock_retval) sd_ble_gap_scan_start_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_scan_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_scan_start_ExpectAndReturn(p_scan_params, cmock_retval) sd_ble_gap_scan_start_CMockExpectAndReturn(__LINE__, p_scan_params, cmock_retval)
+void sd_ble_gap_scan_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_scan_params_t const* p_scan_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_scan_start_CALLBACK)(ble_gap_scan_params_t const* p_scan_params, int cmock_num_calls);
+void sd_ble_gap_scan_start_StubWithCallback(CMOCK_sd_ble_gap_scan_start_CALLBACK Callback);
+#define sd_ble_gap_scan_start_ExpectWithArrayAndReturn(p_scan_params, p_scan_params_Depth, cmock_retval) sd_ble_gap_scan_start_CMockExpectWithArrayAndReturn(__LINE__, p_scan_params, p_scan_params_Depth, cmock_retval)
+void sd_ble_gap_scan_start_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_scan_params_t const* p_scan_params, int p_scan_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_scan_start_ReturnThruPtr_p_scan_params(p_scan_params) sd_ble_gap_scan_start_CMockReturnMemThruPtr_p_scan_params(__LINE__, p_scan_params, sizeof(*p_scan_params))
+#define sd_ble_gap_scan_start_ReturnArrayThruPtr_p_scan_params(p_scan_params, cmock_len) sd_ble_gap_scan_start_CMockReturnMemThruPtr_p_scan_params(__LINE__, p_scan_params, cmock_len * sizeof(*p_scan_params))
+#define sd_ble_gap_scan_start_ReturnMemThruPtr_p_scan_params(p_scan_params, cmock_size) sd_ble_gap_scan_start_CMockReturnMemThruPtr_p_scan_params(__LINE__, p_scan_params, cmock_size)
+void sd_ble_gap_scan_start_CMockReturnMemThruPtr_p_scan_params(UNITY_LINE_TYPE cmock_line, ble_gap_scan_params_t const* p_scan_params, int cmock_size);
+#define sd_ble_gap_scan_start_IgnoreArg_p_scan_params() sd_ble_gap_scan_start_CMockIgnoreArg_p_scan_params(__LINE__)
+void sd_ble_gap_scan_start_CMockIgnoreArg_p_scan_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_scan_stop_IgnoreAndReturn(cmock_retval) sd_ble_gap_scan_stop_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_scan_stop_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_scan_stop_ExpectAndReturn(cmock_retval) sd_ble_gap_scan_stop_CMockExpectAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_scan_stop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_scan_stop_CALLBACK)(int cmock_num_calls);
+void sd_ble_gap_scan_stop_StubWithCallback(CMOCK_sd_ble_gap_scan_stop_CALLBACK Callback);
+#define sd_ble_gap_connect_IgnoreAndReturn(cmock_retval) sd_ble_gap_connect_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_connect_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_connect_ExpectAndReturn(p_peer_addr, p_scan_params, p_conn_params, cmock_retval) sd_ble_gap_connect_CMockExpectAndReturn(__LINE__, p_peer_addr, p_scan_params, p_conn_params, cmock_retval)
+void sd_ble_gap_connect_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_peer_addr, ble_gap_scan_params_t const* p_scan_params, ble_gap_conn_params_t const* p_conn_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_connect_CALLBACK)(ble_gap_addr_t const* p_peer_addr, ble_gap_scan_params_t const* p_scan_params, ble_gap_conn_params_t const* p_conn_params, int cmock_num_calls);
+void sd_ble_gap_connect_StubWithCallback(CMOCK_sd_ble_gap_connect_CALLBACK Callback);
+#define sd_ble_gap_connect_ExpectWithArrayAndReturn(p_peer_addr, p_peer_addr_Depth, p_scan_params, p_scan_params_Depth, p_conn_params, p_conn_params_Depth, cmock_retval) sd_ble_gap_connect_CMockExpectWithArrayAndReturn(__LINE__, p_peer_addr, p_peer_addr_Depth, p_scan_params, p_scan_params_Depth, p_conn_params, p_conn_params_Depth, cmock_retval)
+void sd_ble_gap_connect_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_peer_addr, int p_peer_addr_Depth, ble_gap_scan_params_t const* p_scan_params, int p_scan_params_Depth, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_connect_ReturnThruPtr_p_peer_addr(p_peer_addr) sd_ble_gap_connect_CMockReturnMemThruPtr_p_peer_addr(__LINE__, p_peer_addr, sizeof(*p_peer_addr))
+#define sd_ble_gap_connect_ReturnArrayThruPtr_p_peer_addr(p_peer_addr, cmock_len) sd_ble_gap_connect_CMockReturnMemThruPtr_p_peer_addr(__LINE__, p_peer_addr, cmock_len * sizeof(*p_peer_addr))
+#define sd_ble_gap_connect_ReturnMemThruPtr_p_peer_addr(p_peer_addr, cmock_size) sd_ble_gap_connect_CMockReturnMemThruPtr_p_peer_addr(__LINE__, p_peer_addr, cmock_size)
+void sd_ble_gap_connect_CMockReturnMemThruPtr_p_peer_addr(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_peer_addr, int cmock_size);
+#define sd_ble_gap_connect_ReturnThruPtr_p_scan_params(p_scan_params) sd_ble_gap_connect_CMockReturnMemThruPtr_p_scan_params(__LINE__, p_scan_params, sizeof(*p_scan_params))
+#define sd_ble_gap_connect_ReturnArrayThruPtr_p_scan_params(p_scan_params, cmock_len) sd_ble_gap_connect_CMockReturnMemThruPtr_p_scan_params(__LINE__, p_scan_params, cmock_len * sizeof(*p_scan_params))
+#define sd_ble_gap_connect_ReturnMemThruPtr_p_scan_params(p_scan_params, cmock_size) sd_ble_gap_connect_CMockReturnMemThruPtr_p_scan_params(__LINE__, p_scan_params, cmock_size)
+void sd_ble_gap_connect_CMockReturnMemThruPtr_p_scan_params(UNITY_LINE_TYPE cmock_line, ble_gap_scan_params_t const* p_scan_params, int cmock_size);
+#define sd_ble_gap_connect_ReturnThruPtr_p_conn_params(p_conn_params) sd_ble_gap_connect_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, sizeof(*p_conn_params))
+#define sd_ble_gap_connect_ReturnArrayThruPtr_p_conn_params(p_conn_params, cmock_len) sd_ble_gap_connect_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, cmock_len * sizeof(*p_conn_params))
+#define sd_ble_gap_connect_ReturnMemThruPtr_p_conn_params(p_conn_params, cmock_size) sd_ble_gap_connect_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, cmock_size)
+void sd_ble_gap_connect_CMockReturnMemThruPtr_p_conn_params(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, int cmock_size);
+#define sd_ble_gap_connect_IgnoreArg_p_peer_addr() sd_ble_gap_connect_CMockIgnoreArg_p_peer_addr(__LINE__)
+void sd_ble_gap_connect_CMockIgnoreArg_p_peer_addr(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_connect_IgnoreArg_p_scan_params() sd_ble_gap_connect_CMockIgnoreArg_p_scan_params(__LINE__)
+void sd_ble_gap_connect_CMockIgnoreArg_p_scan_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_connect_IgnoreArg_p_conn_params() sd_ble_gap_connect_CMockIgnoreArg_p_conn_params(__LINE__)
+void sd_ble_gap_connect_CMockIgnoreArg_p_conn_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_connect_cancel_IgnoreAndReturn(cmock_retval) sd_ble_gap_connect_cancel_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_connect_cancel_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_connect_cancel_ExpectAndReturn(cmock_retval) sd_ble_gap_connect_cancel_CMockExpectAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_connect_cancel_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_connect_cancel_CALLBACK)(int cmock_num_calls);
+void sd_ble_gap_connect_cancel_StubWithCallback(CMOCK_sd_ble_gap_connect_cancel_CALLBACK Callback);
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_gatt.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_gatt.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_gatt.c    1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_gatt.c 2018-04-24 08:48:28.778150500 +0200
@@ -0,0 +1,36 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_ble_gatt.h"
+
+static struct mock_ble_gattInstance
+{
+  unsigned char placeHolder;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_ble_gatt_Verify(void)
+{
+}
+
+void mock_ble_gatt_Init(void)
+{
+  mock_ble_gatt_Destroy();
+}
+
+void mock_ble_gatt_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_gatt.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_gatt.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_gatt.h    1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_gatt.h 2018-04-24 08:48:28.778150500 +0200
@@ -0,0 +1,26 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_BLE_GATT_H
+#define _MOCK_BLE_GATT_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <ble_gatt.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_ble_gatt_Init(void);
+void mock_ble_gatt_Destroy(void);
+void mock_ble_gatt_Verify(void);
+
+
+
+
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_gattc.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_gattc.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_gattc.c   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_gattc.c    2018-04-24 08:48:28.788150700 +0200
@@ -0,0 +1,1739 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_ble_gattc.h"
+
+typedef struct _CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint16_t Expected_start_handle;
+  ble_uuid_t const* Expected_p_srvc_uuid;
+  int Expected_p_srvc_uuid_Depth;
+  int ReturnThruPtr_p_srvc_uuid_Used;
+  ble_uuid_t const* ReturnThruPtr_p_srvc_uuid_Val;
+  int ReturnThruPtr_p_srvc_uuid_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_start_handle;
+  int IgnoreArg_p_srvc_uuid;
+
+} CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gattc_handle_range_t const* Expected_p_handle_range;
+  int Expected_p_handle_range_Depth;
+  int ReturnThruPtr_p_handle_range_Used;
+  ble_gattc_handle_range_t const* ReturnThruPtr_p_handle_range_Val;
+  int ReturnThruPtr_p_handle_range_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_handle_range;
+
+} CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gattc_handle_range_t const* Expected_p_handle_range;
+  int Expected_p_handle_range_Depth;
+  int ReturnThruPtr_p_handle_range_Used;
+  ble_gattc_handle_range_t const* ReturnThruPtr_p_handle_range_Val;
+  int ReturnThruPtr_p_handle_range_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_handle_range;
+
+} CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gattc_handle_range_t const* Expected_p_handle_range;
+  int Expected_p_handle_range_Depth;
+  int ReturnThruPtr_p_handle_range_Used;
+  ble_gattc_handle_range_t const* ReturnThruPtr_p_handle_range_Val;
+  int ReturnThruPtr_p_handle_range_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_handle_range;
+
+} CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_uuid_t const* Expected_p_uuid;
+  ble_gattc_handle_range_t const* Expected_p_handle_range;
+  int Expected_p_uuid_Depth;
+  int Expected_p_handle_range_Depth;
+  int ReturnThruPtr_p_uuid_Used;
+  ble_uuid_t const* ReturnThruPtr_p_uuid_Val;
+  int ReturnThruPtr_p_uuid_Size;
+  int ReturnThruPtr_p_handle_range_Used;
+  ble_gattc_handle_range_t const* ReturnThruPtr_p_handle_range_Val;
+  int ReturnThruPtr_p_handle_range_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_uuid;
+  int IgnoreArg_p_handle_range;
+
+} CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gattc_read_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint16_t Expected_handle;
+  uint16_t Expected_offset;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_handle;
+  int IgnoreArg_offset;
+
+} CMOCK_sd_ble_gattc_read_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint16_t const* Expected_p_handles;
+  uint16_t Expected_handle_count;
+  int Expected_p_handles_Depth;
+  int ReturnThruPtr_p_handles_Used;
+  uint16_t const* ReturnThruPtr_p_handles_Val;
+  int ReturnThruPtr_p_handles_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_handles;
+  int IgnoreArg_handle_count;
+
+} CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gattc_write_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gattc_write_params_t const* Expected_p_write_params;
+  int Expected_p_write_params_Depth;
+  int ReturnThruPtr_p_write_params_Used;
+  ble_gattc_write_params_t const* ReturnThruPtr_p_write_params_Val;
+  int ReturnThruPtr_p_write_params_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_write_params;
+
+} CMOCK_sd_ble_gattc_write_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gattc_hv_confirm_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint16_t Expected_handle;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_handle;
+
+} CMOCK_sd_ble_gattc_hv_confirm_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gattc_handle_range_t const* Expected_p_handle_range;
+  int Expected_p_handle_range_Depth;
+  int ReturnThruPtr_p_handle_range_Used;
+  ble_gattc_handle_range_t const* ReturnThruPtr_p_handle_range_Val;
+  int ReturnThruPtr_p_handle_range_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_handle_range;
+
+} CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gattc_exchange_mtu_request_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint16_t Expected_client_rx_mtu;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_client_rx_mtu;
+
+} CMOCK_sd_ble_gattc_exchange_mtu_request_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gattc_evt_t* Expected_p_gattc_evt;
+  ble_gattc_handle_value_t* Expected_p_iter;
+  int Expected_p_gattc_evt_Depth;
+  int Expected_p_iter_Depth;
+  int ReturnThruPtr_p_gattc_evt_Used;
+  ble_gattc_evt_t* ReturnThruPtr_p_gattc_evt_Val;
+  int ReturnThruPtr_p_gattc_evt_Size;
+  int ReturnThruPtr_p_iter_Used;
+  ble_gattc_handle_value_t* ReturnThruPtr_p_iter_Val;
+  int ReturnThruPtr_p_iter_Size;
+  int IgnoreArg_p_gattc_evt;
+  int IgnoreArg_p_iter;
+
+} CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE;
+
+static struct mock_ble_gattcInstance
+{
+  int sd_ble_gattc_primary_services_discover_IgnoreBool;
+  uint32_t sd_ble_gattc_primary_services_discover_FinalReturn;
+  CMOCK_sd_ble_gattc_primary_services_discover_CALLBACK sd_ble_gattc_primary_services_discover_CallbackFunctionPointer;
+  int sd_ble_gattc_primary_services_discover_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gattc_primary_services_discover_CallInstance;
+  int sd_ble_gattc_relationships_discover_IgnoreBool;
+  uint32_t sd_ble_gattc_relationships_discover_FinalReturn;
+  CMOCK_sd_ble_gattc_relationships_discover_CALLBACK sd_ble_gattc_relationships_discover_CallbackFunctionPointer;
+  int sd_ble_gattc_relationships_discover_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gattc_relationships_discover_CallInstance;
+  int sd_ble_gattc_characteristics_discover_IgnoreBool;
+  uint32_t sd_ble_gattc_characteristics_discover_FinalReturn;
+  CMOCK_sd_ble_gattc_characteristics_discover_CALLBACK sd_ble_gattc_characteristics_discover_CallbackFunctionPointer;
+  int sd_ble_gattc_characteristics_discover_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gattc_characteristics_discover_CallInstance;
+  int sd_ble_gattc_descriptors_discover_IgnoreBool;
+  uint32_t sd_ble_gattc_descriptors_discover_FinalReturn;
+  CMOCK_sd_ble_gattc_descriptors_discover_CALLBACK sd_ble_gattc_descriptors_discover_CallbackFunctionPointer;
+  int sd_ble_gattc_descriptors_discover_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gattc_descriptors_discover_CallInstance;
+  int sd_ble_gattc_char_value_by_uuid_read_IgnoreBool;
+  uint32_t sd_ble_gattc_char_value_by_uuid_read_FinalReturn;
+  CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALLBACK sd_ble_gattc_char_value_by_uuid_read_CallbackFunctionPointer;
+  int sd_ble_gattc_char_value_by_uuid_read_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gattc_char_value_by_uuid_read_CallInstance;
+  int sd_ble_gattc_read_IgnoreBool;
+  uint32_t sd_ble_gattc_read_FinalReturn;
+  CMOCK_sd_ble_gattc_read_CALLBACK sd_ble_gattc_read_CallbackFunctionPointer;
+  int sd_ble_gattc_read_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gattc_read_CallInstance;
+  int sd_ble_gattc_char_values_read_IgnoreBool;
+  uint32_t sd_ble_gattc_char_values_read_FinalReturn;
+  CMOCK_sd_ble_gattc_char_values_read_CALLBACK sd_ble_gattc_char_values_read_CallbackFunctionPointer;
+  int sd_ble_gattc_char_values_read_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gattc_char_values_read_CallInstance;
+  int sd_ble_gattc_write_IgnoreBool;
+  uint32_t sd_ble_gattc_write_FinalReturn;
+  CMOCK_sd_ble_gattc_write_CALLBACK sd_ble_gattc_write_CallbackFunctionPointer;
+  int sd_ble_gattc_write_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gattc_write_CallInstance;
+  int sd_ble_gattc_hv_confirm_IgnoreBool;
+  uint32_t sd_ble_gattc_hv_confirm_FinalReturn;
+  CMOCK_sd_ble_gattc_hv_confirm_CALLBACK sd_ble_gattc_hv_confirm_CallbackFunctionPointer;
+  int sd_ble_gattc_hv_confirm_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gattc_hv_confirm_CallInstance;
+  int sd_ble_gattc_attr_info_discover_IgnoreBool;
+  uint32_t sd_ble_gattc_attr_info_discover_FinalReturn;
+  CMOCK_sd_ble_gattc_attr_info_discover_CALLBACK sd_ble_gattc_attr_info_discover_CallbackFunctionPointer;
+  int sd_ble_gattc_attr_info_discover_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gattc_attr_info_discover_CallInstance;
+  int sd_ble_gattc_exchange_mtu_request_IgnoreBool;
+  uint32_t sd_ble_gattc_exchange_mtu_request_FinalReturn;
+  CMOCK_sd_ble_gattc_exchange_mtu_request_CALLBACK sd_ble_gattc_exchange_mtu_request_CallbackFunctionPointer;
+  int sd_ble_gattc_exchange_mtu_request_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gattc_exchange_mtu_request_CallInstance;
+  int sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_IgnoreBool;
+  uint32_t sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_FinalReturn;
+  CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALLBACK sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallbackFunctionPointer;
+  int sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallInstance;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_ble_gattc_Verify(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gattc_primary_services_discover_CallInstance, cmock_line, "Function 'sd_ble_gattc_primary_services_discover' called less times than expected.");
+  if (Mock.sd_ble_gattc_primary_services_discover_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gattc_primary_services_discover_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gattc_relationships_discover_CallInstance, cmock_line, "Function 'sd_ble_gattc_relationships_discover' called less times than expected.");
+  if (Mock.sd_ble_gattc_relationships_discover_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gattc_relationships_discover_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gattc_characteristics_discover_CallInstance, cmock_line, "Function 'sd_ble_gattc_characteristics_discover' called less times than expected.");
+  if (Mock.sd_ble_gattc_characteristics_discover_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gattc_characteristics_discover_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gattc_descriptors_discover_CallInstance, cmock_line, "Function 'sd_ble_gattc_descriptors_discover' called less times than expected.");
+  if (Mock.sd_ble_gattc_descriptors_discover_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gattc_descriptors_discover_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gattc_char_value_by_uuid_read_CallInstance, cmock_line, "Function 'sd_ble_gattc_char_value_by_uuid_read' called less times than expected.");
+  if (Mock.sd_ble_gattc_char_value_by_uuid_read_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gattc_char_value_by_uuid_read_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gattc_read_CallInstance, cmock_line, "Function 'sd_ble_gattc_read' called less times than expected.");
+  if (Mock.sd_ble_gattc_read_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gattc_read_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gattc_char_values_read_CallInstance, cmock_line, "Function 'sd_ble_gattc_char_values_read' called less times than expected.");
+  if (Mock.sd_ble_gattc_char_values_read_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gattc_char_values_read_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gattc_write_CallInstance, cmock_line, "Function 'sd_ble_gattc_write' called less times than expected.");
+  if (Mock.sd_ble_gattc_write_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gattc_write_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gattc_hv_confirm_CallInstance, cmock_line, "Function 'sd_ble_gattc_hv_confirm' called less times than expected.");
+  if (Mock.sd_ble_gattc_hv_confirm_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gattc_hv_confirm_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gattc_attr_info_discover_CallInstance, cmock_line, "Function 'sd_ble_gattc_attr_info_discover' called less times than expected.");
+  if (Mock.sd_ble_gattc_attr_info_discover_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gattc_attr_info_discover_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gattc_exchange_mtu_request_CallInstance, cmock_line, "Function 'sd_ble_gattc_exchange_mtu_request' called less times than expected.");
+  if (Mock.sd_ble_gattc_exchange_mtu_request_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gattc_exchange_mtu_request_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallInstance, cmock_line, "Function 'sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter' called less times than expected.");
+  if (Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallInstance = CMOCK_GUTS_NONE;
+}
+
+void mock_ble_gattc_Init(void)
+{
+  mock_ble_gattc_Destroy();
+}
+
+void mock_ble_gattc_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  Mock.sd_ble_gattc_primary_services_discover_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gattc_primary_services_discover_CallbackCalls = 0;
+  Mock.sd_ble_gattc_relationships_discover_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gattc_relationships_discover_CallbackCalls = 0;
+  Mock.sd_ble_gattc_characteristics_discover_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gattc_characteristics_discover_CallbackCalls = 0;
+  Mock.sd_ble_gattc_descriptors_discover_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gattc_descriptors_discover_CallbackCalls = 0;
+  Mock.sd_ble_gattc_char_value_by_uuid_read_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gattc_char_value_by_uuid_read_CallbackCalls = 0;
+  Mock.sd_ble_gattc_read_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gattc_read_CallbackCalls = 0;
+  Mock.sd_ble_gattc_char_values_read_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gattc_char_values_read_CallbackCalls = 0;
+  Mock.sd_ble_gattc_write_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gattc_write_CallbackCalls = 0;
+  Mock.sd_ble_gattc_hv_confirm_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gattc_hv_confirm_CallbackCalls = 0;
+  Mock.sd_ble_gattc_attr_info_discover_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gattc_attr_info_discover_CallbackCalls = 0;
+  Mock.sd_ble_gattc_exchange_mtu_request_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gattc_exchange_mtu_request_CallbackCalls = 0;
+  Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallbackCalls = 0;
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+uint32_t sd_ble_gattc_primary_services_discover(uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const* p_srvc_uuid)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gattc_primary_services_discover_CallInstance);
+  Mock.sd_ble_gattc_primary_services_discover_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gattc_primary_services_discover_CallInstance);
+  if (Mock.sd_ble_gattc_primary_services_discover_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gattc_primary_services_discover_FinalReturn;
+    Mock.sd_ble_gattc_primary_services_discover_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gattc_primary_services_discover_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gattc_primary_services_discover_CallbackFunctionPointer(conn_handle, start_handle, p_srvc_uuid, Mock.sd_ble_gattc_primary_services_discover_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gattc_primary_services_discover' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_primary_services_discover' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_primary_services_discover' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gattc_primary_services_discover' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_start_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_start_handle, start_handle, cmock_line, "Function 'sd_ble_gattc_primary_services_discover' called with unexpected value for argument 'start_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_srvc_uuid)
+  {
+    if (cmock_call_instance->Expected_p_srvc_uuid == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_srvc_uuid, cmock_line, "Expected NULL. Function 'sd_ble_gattc_primary_services_discover' called with unexpected value for argument 'p_srvc_uuid'."); }
+    else if (cmock_call_instance->Expected_p_srvc_uuid_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_srvc_uuid, p_srvc_uuid, cmock_line, "Function 'sd_ble_gattc_primary_services_discover' called with unexpected value for argument 'p_srvc_uuid'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_srvc_uuid), (void*)(p_srvc_uuid), sizeof(ble_uuid_t), cmock_call_instance->Expected_p_srvc_uuid_Depth, cmock_line, "Function 'sd_ble_gattc_primary_services_discover' called with unexpected value for argument 'p_srvc_uuid'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_srvc_uuid_Used)
+  {
+    memcpy((void*)p_srvc_uuid, (void*)cmock_call_instance->ReturnThruPtr_p_srvc_uuid_Val,
+      cmock_call_instance->ReturnThruPtr_p_srvc_uuid_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gattc_primary_services_discover(CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const* p_srvc_uuid, int p_srvc_uuid_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_start_handle = start_handle;
+  cmock_call_instance->IgnoreArg_start_handle = 0;
+  cmock_call_instance->Expected_p_srvc_uuid = p_srvc_uuid;
+  cmock_call_instance->Expected_p_srvc_uuid_Depth = p_srvc_uuid_Depth;
+  cmock_call_instance->IgnoreArg_p_srvc_uuid = 0;
+  cmock_call_instance->ReturnThruPtr_p_srvc_uuid_Used = 0;
+}
+
+void sd_ble_gattc_primary_services_discover_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_primary_services_discover_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_primary_services_discover_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gattc_primary_services_discover_IgnoreBool = (int)1;
+}
+
+void sd_ble_gattc_primary_services_discover_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const* p_srvc_uuid, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_primary_services_discover_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_primary_services_discover_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_primary_services_discover(cmock_call_instance, conn_handle, start_handle, p_srvc_uuid, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_primary_services_discover_StubWithCallback(CMOCK_sd_ble_gattc_primary_services_discover_CALLBACK Callback)
+{
+  Mock.sd_ble_gattc_primary_services_discover_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gattc_primary_services_discover_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const* p_srvc_uuid, int p_srvc_uuid_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_primary_services_discover_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_primary_services_discover_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_primary_services_discover(cmock_call_instance, conn_handle, start_handle, p_srvc_uuid, p_srvc_uuid_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_primary_services_discover_CMockReturnMemThruPtr_p_srvc_uuid(UNITY_LINE_TYPE cmock_line, ble_uuid_t const* p_srvc_uuid, int cmock_size)
+{
+  CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_primary_services_discover_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_srvc_uuid ReturnThruPtr called before Expect on 'sd_ble_gattc_primary_services_discover'.");
+  cmock_call_instance->ReturnThruPtr_p_srvc_uuid_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_srvc_uuid_Val = p_srvc_uuid;
+  cmock_call_instance->ReturnThruPtr_p_srvc_uuid_Size = cmock_size;
+}
+
+void sd_ble_gattc_primary_services_discover_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_primary_services_discover_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gattc_primary_services_discover'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gattc_primary_services_discover_CMockIgnoreArg_start_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_primary_services_discover_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "start_handle IgnoreArg called before Expect on 'sd_ble_gattc_primary_services_discover'.");
+  cmock_call_instance->IgnoreArg_start_handle = 1;
+}
+
+void sd_ble_gattc_primary_services_discover_CMockIgnoreArg_p_srvc_uuid(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_primary_services_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_primary_services_discover_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_srvc_uuid IgnoreArg called before Expect on 'sd_ble_gattc_primary_services_discover'.");
+  cmock_call_instance->IgnoreArg_p_srvc_uuid = 1;
+}
+
+uint32_t sd_ble_gattc_relationships_discover(uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gattc_relationships_discover_CallInstance);
+  Mock.sd_ble_gattc_relationships_discover_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gattc_relationships_discover_CallInstance);
+  if (Mock.sd_ble_gattc_relationships_discover_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gattc_relationships_discover_FinalReturn;
+    Mock.sd_ble_gattc_relationships_discover_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gattc_relationships_discover_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gattc_relationships_discover_CallbackFunctionPointer(conn_handle, p_handle_range, Mock.sd_ble_gattc_relationships_discover_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gattc_relationships_discover' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_relationships_discover' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_relationships_discover' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gattc_relationships_discover' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_handle_range)
+  {
+    if (cmock_call_instance->Expected_p_handle_range == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_handle_range, cmock_line, "Expected NULL. Function 'sd_ble_gattc_relationships_discover' called with unexpected value for argument 'p_handle_range'."); }
+    else if (cmock_call_instance->Expected_p_handle_range_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_handle_range, p_handle_range, cmock_line, "Function 'sd_ble_gattc_relationships_discover' called with unexpected value for argument 'p_handle_range'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_handle_range), (void*)(p_handle_range), sizeof(ble_gattc_handle_range_t), cmock_call_instance->Expected_p_handle_range_Depth, cmock_line, "Function 'sd_ble_gattc_relationships_discover' called with unexpected value for argument 'p_handle_range'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_handle_range_Used)
+  {
+    memcpy((void*)p_handle_range, (void*)cmock_call_instance->ReturnThruPtr_p_handle_range_Val,
+      cmock_call_instance->ReturnThruPtr_p_handle_range_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gattc_relationships_discover(CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, int p_handle_range_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_handle_range = p_handle_range;
+  cmock_call_instance->Expected_p_handle_range_Depth = p_handle_range_Depth;
+  cmock_call_instance->IgnoreArg_p_handle_range = 0;
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Used = 0;
+}
+
+void sd_ble_gattc_relationships_discover_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_relationships_discover_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_relationships_discover_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gattc_relationships_discover_IgnoreBool = (int)1;
+}
+
+void sd_ble_gattc_relationships_discover_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_relationships_discover_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_relationships_discover_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_relationships_discover(cmock_call_instance, conn_handle, p_handle_range, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_relationships_discover_StubWithCallback(CMOCK_sd_ble_gattc_relationships_discover_CALLBACK Callback)
+{
+  Mock.sd_ble_gattc_relationships_discover_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gattc_relationships_discover_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, int p_handle_range_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_relationships_discover_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_relationships_discover_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_relationships_discover(cmock_call_instance, conn_handle, p_handle_range, p_handle_range_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_relationships_discover_CMockReturnMemThruPtr_p_handle_range(UNITY_LINE_TYPE cmock_line, ble_gattc_handle_range_t const* p_handle_range, int cmock_size)
+{
+  CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_relationships_discover_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handle_range ReturnThruPtr called before Expect on 'sd_ble_gattc_relationships_discover'.");
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Val = p_handle_range;
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Size = cmock_size;
+}
+
+void sd_ble_gattc_relationships_discover_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_relationships_discover_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gattc_relationships_discover'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gattc_relationships_discover_CMockIgnoreArg_p_handle_range(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_relationships_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_relationships_discover_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handle_range IgnoreArg called before Expect on 'sd_ble_gattc_relationships_discover'.");
+  cmock_call_instance->IgnoreArg_p_handle_range = 1;
+}
+
+uint32_t sd_ble_gattc_characteristics_discover(uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gattc_characteristics_discover_CallInstance);
+  Mock.sd_ble_gattc_characteristics_discover_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gattc_characteristics_discover_CallInstance);
+  if (Mock.sd_ble_gattc_characteristics_discover_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gattc_characteristics_discover_FinalReturn;
+    Mock.sd_ble_gattc_characteristics_discover_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gattc_characteristics_discover_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gattc_characteristics_discover_CallbackFunctionPointer(conn_handle, p_handle_range, Mock.sd_ble_gattc_characteristics_discover_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gattc_characteristics_discover' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_characteristics_discover' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_characteristics_discover' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gattc_characteristics_discover' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_handle_range)
+  {
+    if (cmock_call_instance->Expected_p_handle_range == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_handle_range, cmock_line, "Expected NULL. Function 'sd_ble_gattc_characteristics_discover' called with unexpected value for argument 'p_handle_range'."); }
+    else if (cmock_call_instance->Expected_p_handle_range_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_handle_range, p_handle_range, cmock_line, "Function 'sd_ble_gattc_characteristics_discover' called with unexpected value for argument 'p_handle_range'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_handle_range), (void*)(p_handle_range), sizeof(ble_gattc_handle_range_t), cmock_call_instance->Expected_p_handle_range_Depth, cmock_line, "Function 'sd_ble_gattc_characteristics_discover' called with unexpected value for argument 'p_handle_range'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_handle_range_Used)
+  {
+    memcpy((void*)p_handle_range, (void*)cmock_call_instance->ReturnThruPtr_p_handle_range_Val,
+      cmock_call_instance->ReturnThruPtr_p_handle_range_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gattc_characteristics_discover(CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, int p_handle_range_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_handle_range = p_handle_range;
+  cmock_call_instance->Expected_p_handle_range_Depth = p_handle_range_Depth;
+  cmock_call_instance->IgnoreArg_p_handle_range = 0;
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Used = 0;
+}
+
+void sd_ble_gattc_characteristics_discover_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_characteristics_discover_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_characteristics_discover_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gattc_characteristics_discover_IgnoreBool = (int)1;
+}
+
+void sd_ble_gattc_characteristics_discover_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_characteristics_discover_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_characteristics_discover_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_characteristics_discover(cmock_call_instance, conn_handle, p_handle_range, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_characteristics_discover_StubWithCallback(CMOCK_sd_ble_gattc_characteristics_discover_CALLBACK Callback)
+{
+  Mock.sd_ble_gattc_characteristics_discover_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gattc_characteristics_discover_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, int p_handle_range_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_characteristics_discover_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_characteristics_discover_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_characteristics_discover(cmock_call_instance, conn_handle, p_handle_range, p_handle_range_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_characteristics_discover_CMockReturnMemThruPtr_p_handle_range(UNITY_LINE_TYPE cmock_line, ble_gattc_handle_range_t const* p_handle_range, int cmock_size)
+{
+  CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_characteristics_discover_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handle_range ReturnThruPtr called before Expect on 'sd_ble_gattc_characteristics_discover'.");
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Val = p_handle_range;
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Size = cmock_size;
+}
+
+void sd_ble_gattc_characteristics_discover_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_characteristics_discover_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gattc_characteristics_discover'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gattc_characteristics_discover_CMockIgnoreArg_p_handle_range(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_characteristics_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_characteristics_discover_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handle_range IgnoreArg called before Expect on 'sd_ble_gattc_characteristics_discover'.");
+  cmock_call_instance->IgnoreArg_p_handle_range = 1;
+}
+
+uint32_t sd_ble_gattc_descriptors_discover(uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gattc_descriptors_discover_CallInstance);
+  Mock.sd_ble_gattc_descriptors_discover_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gattc_descriptors_discover_CallInstance);
+  if (Mock.sd_ble_gattc_descriptors_discover_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gattc_descriptors_discover_FinalReturn;
+    Mock.sd_ble_gattc_descriptors_discover_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gattc_descriptors_discover_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gattc_descriptors_discover_CallbackFunctionPointer(conn_handle, p_handle_range, Mock.sd_ble_gattc_descriptors_discover_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gattc_descriptors_discover' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_descriptors_discover' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_descriptors_discover' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gattc_descriptors_discover' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_handle_range)
+  {
+    if (cmock_call_instance->Expected_p_handle_range == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_handle_range, cmock_line, "Expected NULL. Function 'sd_ble_gattc_descriptors_discover' called with unexpected value for argument 'p_handle_range'."); }
+    else if (cmock_call_instance->Expected_p_handle_range_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_handle_range, p_handle_range, cmock_line, "Function 'sd_ble_gattc_descriptors_discover' called with unexpected value for argument 'p_handle_range'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_handle_range), (void*)(p_handle_range), sizeof(ble_gattc_handle_range_t), cmock_call_instance->Expected_p_handle_range_Depth, cmock_line, "Function 'sd_ble_gattc_descriptors_discover' called with unexpected value for argument 'p_handle_range'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_handle_range_Used)
+  {
+    memcpy((void*)p_handle_range, (void*)cmock_call_instance->ReturnThruPtr_p_handle_range_Val,
+      cmock_call_instance->ReturnThruPtr_p_handle_range_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gattc_descriptors_discover(CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, int p_handle_range_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_handle_range = p_handle_range;
+  cmock_call_instance->Expected_p_handle_range_Depth = p_handle_range_Depth;
+  cmock_call_instance->IgnoreArg_p_handle_range = 0;
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Used = 0;
+}
+
+void sd_ble_gattc_descriptors_discover_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_descriptors_discover_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_descriptors_discover_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gattc_descriptors_discover_IgnoreBool = (int)1;
+}
+
+void sd_ble_gattc_descriptors_discover_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_descriptors_discover_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_descriptors_discover_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_descriptors_discover(cmock_call_instance, conn_handle, p_handle_range, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_descriptors_discover_StubWithCallback(CMOCK_sd_ble_gattc_descriptors_discover_CALLBACK Callback)
+{
+  Mock.sd_ble_gattc_descriptors_discover_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gattc_descriptors_discover_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, int p_handle_range_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_descriptors_discover_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_descriptors_discover_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_descriptors_discover(cmock_call_instance, conn_handle, p_handle_range, p_handle_range_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_descriptors_discover_CMockReturnMemThruPtr_p_handle_range(UNITY_LINE_TYPE cmock_line, ble_gattc_handle_range_t const* p_handle_range, int cmock_size)
+{
+  CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_descriptors_discover_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handle_range ReturnThruPtr called before Expect on 'sd_ble_gattc_descriptors_discover'.");
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Val = p_handle_range;
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Size = cmock_size;
+}
+
+void sd_ble_gattc_descriptors_discover_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_descriptors_discover_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gattc_descriptors_discover'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gattc_descriptors_discover_CMockIgnoreArg_p_handle_range(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_descriptors_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_descriptors_discover_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handle_range IgnoreArg called before Expect on 'sd_ble_gattc_descriptors_discover'.");
+  cmock_call_instance->IgnoreArg_p_handle_range = 1;
+}
+
+uint32_t sd_ble_gattc_char_value_by_uuid_read(uint16_t conn_handle, ble_uuid_t const* p_uuid, ble_gattc_handle_range_t const* p_handle_range)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gattc_char_value_by_uuid_read_CallInstance);
+  Mock.sd_ble_gattc_char_value_by_uuid_read_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gattc_char_value_by_uuid_read_CallInstance);
+  if (Mock.sd_ble_gattc_char_value_by_uuid_read_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gattc_char_value_by_uuid_read_FinalReturn;
+    Mock.sd_ble_gattc_char_value_by_uuid_read_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gattc_char_value_by_uuid_read_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gattc_char_value_by_uuid_read_CallbackFunctionPointer(conn_handle, p_uuid, p_handle_range, Mock.sd_ble_gattc_char_value_by_uuid_read_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gattc_char_value_by_uuid_read' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_char_value_by_uuid_read' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_char_value_by_uuid_read' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gattc_char_value_by_uuid_read' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_uuid)
+  {
+    if (cmock_call_instance->Expected_p_uuid == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_uuid, cmock_line, "Expected NULL. Function 'sd_ble_gattc_char_value_by_uuid_read' called with unexpected value for argument 'p_uuid'."); }
+    else if (cmock_call_instance->Expected_p_uuid_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_uuid, p_uuid, cmock_line, "Function 'sd_ble_gattc_char_value_by_uuid_read' called with unexpected value for argument 'p_uuid'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_uuid), (void*)(p_uuid), sizeof(ble_uuid_t), cmock_call_instance->Expected_p_uuid_Depth, cmock_line, "Function 'sd_ble_gattc_char_value_by_uuid_read' called with unexpected value for argument 'p_uuid'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_handle_range)
+  {
+    if (cmock_call_instance->Expected_p_handle_range == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_handle_range, cmock_line, "Expected NULL. Function 'sd_ble_gattc_char_value_by_uuid_read' called with unexpected value for argument 'p_handle_range'."); }
+    else if (cmock_call_instance->Expected_p_handle_range_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_handle_range, p_handle_range, cmock_line, "Function 'sd_ble_gattc_char_value_by_uuid_read' called with unexpected value for argument 'p_handle_range'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_handle_range), (void*)(p_handle_range), sizeof(ble_gattc_handle_range_t), cmock_call_instance->Expected_p_handle_range_Depth, cmock_line, "Function 'sd_ble_gattc_char_value_by_uuid_read' called with unexpected value for argument 'p_handle_range'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_uuid_Used)
+  {
+    memcpy((void*)p_uuid, (void*)cmock_call_instance->ReturnThruPtr_p_uuid_Val,
+      cmock_call_instance->ReturnThruPtr_p_uuid_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_handle_range_Used)
+  {
+    memcpy((void*)p_handle_range, (void*)cmock_call_instance->ReturnThruPtr_p_handle_range_Val,
+      cmock_call_instance->ReturnThruPtr_p_handle_range_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gattc_char_value_by_uuid_read(CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_uuid_t const* p_uuid, int p_uuid_Depth, ble_gattc_handle_range_t const* p_handle_range, int p_handle_range_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_uuid = p_uuid;
+  cmock_call_instance->Expected_p_uuid_Depth = p_uuid_Depth;
+  cmock_call_instance->IgnoreArg_p_uuid = 0;
+  cmock_call_instance->ReturnThruPtr_p_uuid_Used = 0;
+  cmock_call_instance->Expected_p_handle_range = p_handle_range;
+  cmock_call_instance->Expected_p_handle_range_Depth = p_handle_range_Depth;
+  cmock_call_instance->IgnoreArg_p_handle_range = 0;
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Used = 0;
+}
+
+void sd_ble_gattc_char_value_by_uuid_read_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_char_value_by_uuid_read_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_char_value_by_uuid_read_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gattc_char_value_by_uuid_read_IgnoreBool = (int)1;
+}
+
+void sd_ble_gattc_char_value_by_uuid_read_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_uuid_t const* p_uuid, ble_gattc_handle_range_t const* p_handle_range, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_char_value_by_uuid_read_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_char_value_by_uuid_read_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_char_value_by_uuid_read(cmock_call_instance, conn_handle, p_uuid, 0, p_handle_range, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_char_value_by_uuid_read_StubWithCallback(CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALLBACK Callback)
+{
+  Mock.sd_ble_gattc_char_value_by_uuid_read_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gattc_char_value_by_uuid_read_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_uuid_t const* p_uuid, int p_uuid_Depth, ble_gattc_handle_range_t const* p_handle_range, int p_handle_range_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_char_value_by_uuid_read_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_char_value_by_uuid_read_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_char_value_by_uuid_read(cmock_call_instance, conn_handle, p_uuid, p_uuid_Depth, p_handle_range, p_handle_range_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_char_value_by_uuid_read_CMockReturnMemThruPtr_p_uuid(UNITY_LINE_TYPE cmock_line, ble_uuid_t const* p_uuid, int cmock_size)
+{
+  CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_char_value_by_uuid_read_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid ReturnThruPtr called before Expect on 'sd_ble_gattc_char_value_by_uuid_read'.");
+  cmock_call_instance->ReturnThruPtr_p_uuid_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_uuid_Val = p_uuid;
+  cmock_call_instance->ReturnThruPtr_p_uuid_Size = cmock_size;
+}
+
+void sd_ble_gattc_char_value_by_uuid_read_CMockReturnMemThruPtr_p_handle_range(UNITY_LINE_TYPE cmock_line, ble_gattc_handle_range_t const* p_handle_range, int cmock_size)
+{
+  CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_char_value_by_uuid_read_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handle_range ReturnThruPtr called before Expect on 'sd_ble_gattc_char_value_by_uuid_read'.");
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Val = p_handle_range;
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Size = cmock_size;
+}
+
+void sd_ble_gattc_char_value_by_uuid_read_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_char_value_by_uuid_read_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gattc_char_value_by_uuid_read'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gattc_char_value_by_uuid_read_CMockIgnoreArg_p_uuid(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_char_value_by_uuid_read_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid IgnoreArg called before Expect on 'sd_ble_gattc_char_value_by_uuid_read'.");
+  cmock_call_instance->IgnoreArg_p_uuid = 1;
+}
+
+void sd_ble_gattc_char_value_by_uuid_read_CMockIgnoreArg_p_handle_range(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_char_value_by_uuid_read_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handle_range IgnoreArg called before Expect on 'sd_ble_gattc_char_value_by_uuid_read'.");
+  cmock_call_instance->IgnoreArg_p_handle_range = 1;
+}
+
+uint32_t sd_ble_gattc_read(uint16_t conn_handle, uint16_t handle, uint16_t offset)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gattc_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gattc_read_CallInstance);
+  Mock.sd_ble_gattc_read_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gattc_read_CallInstance);
+  if (Mock.sd_ble_gattc_read_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gattc_read_FinalReturn;
+    Mock.sd_ble_gattc_read_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gattc_read_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gattc_read_CallbackFunctionPointer(conn_handle, handle, offset, Mock.sd_ble_gattc_read_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gattc_read' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_read' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_read' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gattc_read' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_handle, handle, cmock_line, "Function 'sd_ble_gattc_read' called with unexpected value for argument 'handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_offset)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_offset, offset, cmock_line, "Function 'sd_ble_gattc_read' called with unexpected value for argument 'offset'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gattc_read(CMOCK_sd_ble_gattc_read_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint16_t handle, uint16_t offset)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_handle = handle;
+  cmock_call_instance->IgnoreArg_handle = 0;
+  cmock_call_instance->Expected_offset = offset;
+  cmock_call_instance->IgnoreArg_offset = 0;
+}
+
+void sd_ble_gattc_read_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_read_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_read_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_read_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gattc_read_IgnoreBool = (int)1;
+}
+
+void sd_ble_gattc_read_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t handle, uint16_t offset, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_read_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_read_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_read_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_read(cmock_call_instance, conn_handle, handle, offset);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_read_StubWithCallback(CMOCK_sd_ble_gattc_read_CALLBACK Callback)
+{
+  Mock.sd_ble_gattc_read_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gattc_read_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_read_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_read_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gattc_read'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gattc_read_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_read_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_read_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "handle IgnoreArg called before Expect on 'sd_ble_gattc_read'.");
+  cmock_call_instance->IgnoreArg_handle = 1;
+}
+
+void sd_ble_gattc_read_CMockIgnoreArg_offset(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_read_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_read_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "offset IgnoreArg called before Expect on 'sd_ble_gattc_read'.");
+  cmock_call_instance->IgnoreArg_offset = 1;
+}
+
+uint32_t sd_ble_gattc_char_values_read(uint16_t conn_handle, uint16_t const* p_handles, uint16_t handle_count)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gattc_char_values_read_CallInstance);
+  Mock.sd_ble_gattc_char_values_read_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gattc_char_values_read_CallInstance);
+  if (Mock.sd_ble_gattc_char_values_read_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gattc_char_values_read_FinalReturn;
+    Mock.sd_ble_gattc_char_values_read_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gattc_char_values_read_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gattc_char_values_read_CallbackFunctionPointer(conn_handle, p_handles, handle_count, Mock.sd_ble_gattc_char_values_read_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gattc_char_values_read' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_char_values_read' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_char_values_read' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gattc_char_values_read' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_handles)
+  {
+    if (cmock_call_instance->Expected_p_handles == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_handles, cmock_line, "Expected NULL. Function 'sd_ble_gattc_char_values_read' called with unexpected value for argument 'p_handles'."); }
+    else if (cmock_call_instance->Expected_p_handles_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_handles, p_handles, cmock_line, "Function 'sd_ble_gattc_char_values_read' called with unexpected value for argument 'p_handles'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_p_handles, p_handles, cmock_call_instance->Expected_p_handles_Depth, cmock_line, "Function 'sd_ble_gattc_char_values_read' called with unexpected value for argument 'p_handles'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_handle_count)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_handle_count, handle_count, cmock_line, "Function 'sd_ble_gattc_char_values_read' called with unexpected value for argument 'handle_count'.");
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_handles_Used)
+  {
+    memcpy((void*)p_handles, (void*)cmock_call_instance->ReturnThruPtr_p_handles_Val,
+      cmock_call_instance->ReturnThruPtr_p_handles_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gattc_char_values_read(CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint16_t const* p_handles, int p_handles_Depth, uint16_t handle_count)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_handles = p_handles;
+  cmock_call_instance->Expected_p_handles_Depth = p_handles_Depth;
+  cmock_call_instance->IgnoreArg_p_handles = 0;
+  cmock_call_instance->ReturnThruPtr_p_handles_Used = 0;
+  cmock_call_instance->Expected_handle_count = handle_count;
+  cmock_call_instance->IgnoreArg_handle_count = 0;
+}
+
+void sd_ble_gattc_char_values_read_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_char_values_read_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_char_values_read_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gattc_char_values_read_IgnoreBool = (int)1;
+}
+
+void sd_ble_gattc_char_values_read_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t const* p_handles, uint16_t handle_count, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_char_values_read_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_char_values_read_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_char_values_read(cmock_call_instance, conn_handle, p_handles, 0, handle_count);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_char_values_read_StubWithCallback(CMOCK_sd_ble_gattc_char_values_read_CALLBACK Callback)
+{
+  Mock.sd_ble_gattc_char_values_read_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gattc_char_values_read_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t const* p_handles, int p_handles_Depth, uint16_t handle_count, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_char_values_read_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_char_values_read_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_char_values_read(cmock_call_instance, conn_handle, p_handles, p_handles_Depth, handle_count);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_char_values_read_CMockReturnMemThruPtr_p_handles(UNITY_LINE_TYPE cmock_line, uint16_t const* p_handles, int cmock_size)
+{
+  CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_char_values_read_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handles ReturnThruPtr called before Expect on 'sd_ble_gattc_char_values_read'.");
+  cmock_call_instance->ReturnThruPtr_p_handles_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_handles_Val = p_handles;
+  cmock_call_instance->ReturnThruPtr_p_handles_Size = cmock_size;
+}
+
+void sd_ble_gattc_char_values_read_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_char_values_read_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gattc_char_values_read'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gattc_char_values_read_CMockIgnoreArg_p_handles(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_char_values_read_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handles IgnoreArg called before Expect on 'sd_ble_gattc_char_values_read'.");
+  cmock_call_instance->IgnoreArg_p_handles = 1;
+}
+
+void sd_ble_gattc_char_values_read_CMockIgnoreArg_handle_count(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_char_values_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_char_values_read_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "handle_count IgnoreArg called before Expect on 'sd_ble_gattc_char_values_read'.");
+  cmock_call_instance->IgnoreArg_handle_count = 1;
+}
+
+uint32_t sd_ble_gattc_write(uint16_t conn_handle, ble_gattc_write_params_t const* p_write_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gattc_write_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gattc_write_CallInstance);
+  Mock.sd_ble_gattc_write_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gattc_write_CallInstance);
+  if (Mock.sd_ble_gattc_write_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gattc_write_FinalReturn;
+    Mock.sd_ble_gattc_write_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gattc_write_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gattc_write_CallbackFunctionPointer(conn_handle, p_write_params, Mock.sd_ble_gattc_write_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gattc_write' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_write' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_write' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gattc_write' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_write_params)
+  {
+    if (cmock_call_instance->Expected_p_write_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_write_params, cmock_line, "Expected NULL. Function 'sd_ble_gattc_write' called with unexpected value for argument 'p_write_params'."); }
+    else if (cmock_call_instance->Expected_p_write_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_write_params, p_write_params, cmock_line, "Function 'sd_ble_gattc_write' called with unexpected value for argument 'p_write_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_write_params), (void*)(p_write_params), sizeof(ble_gattc_write_params_t), cmock_call_instance->Expected_p_write_params_Depth, cmock_line, "Function 'sd_ble_gattc_write' called with unexpected value for argument 'p_write_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_write_params_Used)
+  {
+    memcpy((void*)p_write_params, (void*)cmock_call_instance->ReturnThruPtr_p_write_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_write_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gattc_write(CMOCK_sd_ble_gattc_write_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gattc_write_params_t const* p_write_params, int p_write_params_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_write_params = p_write_params;
+  cmock_call_instance->Expected_p_write_params_Depth = p_write_params_Depth;
+  cmock_call_instance->IgnoreArg_p_write_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_write_params_Used = 0;
+}
+
+void sd_ble_gattc_write_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_write_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_write_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_write_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_write_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gattc_write_IgnoreBool = (int)1;
+}
+
+void sd_ble_gattc_write_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_write_params_t const* p_write_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_write_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_write_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_write_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_write_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_write(cmock_call_instance, conn_handle, p_write_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_write_StubWithCallback(CMOCK_sd_ble_gattc_write_CALLBACK Callback)
+{
+  Mock.sd_ble_gattc_write_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gattc_write_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_write_params_t const* p_write_params, int p_write_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_write_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_write_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_write_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_write_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_write(cmock_call_instance, conn_handle, p_write_params, p_write_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_write_CMockReturnMemThruPtr_p_write_params(UNITY_LINE_TYPE cmock_line, ble_gattc_write_params_t const* p_write_params, int cmock_size)
+{
+  CMOCK_sd_ble_gattc_write_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_write_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_write_params ReturnThruPtr called before Expect on 'sd_ble_gattc_write'.");
+  cmock_call_instance->ReturnThruPtr_p_write_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_write_params_Val = p_write_params;
+  cmock_call_instance->ReturnThruPtr_p_write_params_Size = cmock_size;
+}
+
+void sd_ble_gattc_write_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_write_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_write_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gattc_write'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gattc_write_CMockIgnoreArg_p_write_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_write_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_write_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_write_params IgnoreArg called before Expect on 'sd_ble_gattc_write'.");
+  cmock_call_instance->IgnoreArg_p_write_params = 1;
+}
+
+uint32_t sd_ble_gattc_hv_confirm(uint16_t conn_handle, uint16_t handle)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gattc_hv_confirm_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_hv_confirm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gattc_hv_confirm_CallInstance);
+  Mock.sd_ble_gattc_hv_confirm_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gattc_hv_confirm_CallInstance);
+  if (Mock.sd_ble_gattc_hv_confirm_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gattc_hv_confirm_FinalReturn;
+    Mock.sd_ble_gattc_hv_confirm_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gattc_hv_confirm_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gattc_hv_confirm_CallbackFunctionPointer(conn_handle, handle, Mock.sd_ble_gattc_hv_confirm_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gattc_hv_confirm' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_hv_confirm' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_hv_confirm' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gattc_hv_confirm' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_handle, handle, cmock_line, "Function 'sd_ble_gattc_hv_confirm' called with unexpected value for argument 'handle'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gattc_hv_confirm(CMOCK_sd_ble_gattc_hv_confirm_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint16_t handle)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_handle = handle;
+  cmock_call_instance->IgnoreArg_handle = 0;
+}
+
+void sd_ble_gattc_hv_confirm_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_hv_confirm_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_hv_confirm_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_hv_confirm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_hv_confirm_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_hv_confirm_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gattc_hv_confirm_IgnoreBool = (int)1;
+}
+
+void sd_ble_gattc_hv_confirm_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t handle, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_hv_confirm_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_hv_confirm_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_hv_confirm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_hv_confirm_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_hv_confirm_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_hv_confirm(cmock_call_instance, conn_handle, handle);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_hv_confirm_StubWithCallback(CMOCK_sd_ble_gattc_hv_confirm_CALLBACK Callback)
+{
+  Mock.sd_ble_gattc_hv_confirm_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gattc_hv_confirm_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_hv_confirm_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_hv_confirm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_hv_confirm_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gattc_hv_confirm'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gattc_hv_confirm_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_hv_confirm_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_hv_confirm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_hv_confirm_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "handle IgnoreArg called before Expect on 'sd_ble_gattc_hv_confirm'.");
+  cmock_call_instance->IgnoreArg_handle = 1;
+}
+
+uint32_t sd_ble_gattc_attr_info_discover(uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gattc_attr_info_discover_CallInstance);
+  Mock.sd_ble_gattc_attr_info_discover_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gattc_attr_info_discover_CallInstance);
+  if (Mock.sd_ble_gattc_attr_info_discover_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gattc_attr_info_discover_FinalReturn;
+    Mock.sd_ble_gattc_attr_info_discover_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gattc_attr_info_discover_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gattc_attr_info_discover_CallbackFunctionPointer(conn_handle, p_handle_range, Mock.sd_ble_gattc_attr_info_discover_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gattc_attr_info_discover' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_attr_info_discover' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_attr_info_discover' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gattc_attr_info_discover' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_handle_range)
+  {
+    if (cmock_call_instance->Expected_p_handle_range == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_handle_range, cmock_line, "Expected NULL. Function 'sd_ble_gattc_attr_info_discover' called with unexpected value for argument 'p_handle_range'."); }
+    else if (cmock_call_instance->Expected_p_handle_range_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_handle_range, p_handle_range, cmock_line, "Function 'sd_ble_gattc_attr_info_discover' called with unexpected value for argument 'p_handle_range'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_handle_range), (void*)(p_handle_range), sizeof(ble_gattc_handle_range_t), cmock_call_instance->Expected_p_handle_range_Depth, cmock_line, "Function 'sd_ble_gattc_attr_info_discover' called with unexpected value for argument 'p_handle_range'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_handle_range_Used)
+  {
+    memcpy((void*)p_handle_range, (void*)cmock_call_instance->ReturnThruPtr_p_handle_range_Val,
+      cmock_call_instance->ReturnThruPtr_p_handle_range_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gattc_attr_info_discover(CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, int p_handle_range_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_handle_range = p_handle_range;
+  cmock_call_instance->Expected_p_handle_range_Depth = p_handle_range_Depth;
+  cmock_call_instance->IgnoreArg_p_handle_range = 0;
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Used = 0;
+}
+
+void sd_ble_gattc_attr_info_discover_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_attr_info_discover_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_attr_info_discover_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gattc_attr_info_discover_IgnoreBool = (int)1;
+}
+
+void sd_ble_gattc_attr_info_discover_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_attr_info_discover_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_attr_info_discover_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_attr_info_discover(cmock_call_instance, conn_handle, p_handle_range, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_attr_info_discover_StubWithCallback(CMOCK_sd_ble_gattc_attr_info_discover_CALLBACK Callback)
+{
+  Mock.sd_ble_gattc_attr_info_discover_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gattc_attr_info_discover_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, int p_handle_range_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_attr_info_discover_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_attr_info_discover_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_attr_info_discover(cmock_call_instance, conn_handle, p_handle_range, p_handle_range_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_attr_info_discover_CMockReturnMemThruPtr_p_handle_range(UNITY_LINE_TYPE cmock_line, ble_gattc_handle_range_t const* p_handle_range, int cmock_size)
+{
+  CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_attr_info_discover_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handle_range ReturnThruPtr called before Expect on 'sd_ble_gattc_attr_info_discover'.");
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Val = p_handle_range;
+  cmock_call_instance->ReturnThruPtr_p_handle_range_Size = cmock_size;
+}
+
+void sd_ble_gattc_attr_info_discover_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_attr_info_discover_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gattc_attr_info_discover'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gattc_attr_info_discover_CMockIgnoreArg_p_handle_range(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_attr_info_discover_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_attr_info_discover_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handle_range IgnoreArg called before Expect on 'sd_ble_gattc_attr_info_discover'.");
+  cmock_call_instance->IgnoreArg_p_handle_range = 1;
+}
+
+uint32_t sd_ble_gattc_exchange_mtu_request(uint16_t conn_handle, uint16_t client_rx_mtu)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gattc_exchange_mtu_request_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_exchange_mtu_request_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gattc_exchange_mtu_request_CallInstance);
+  Mock.sd_ble_gattc_exchange_mtu_request_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gattc_exchange_mtu_request_CallInstance);
+  if (Mock.sd_ble_gattc_exchange_mtu_request_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gattc_exchange_mtu_request_FinalReturn;
+    Mock.sd_ble_gattc_exchange_mtu_request_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gattc_exchange_mtu_request_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gattc_exchange_mtu_request_CallbackFunctionPointer(conn_handle, client_rx_mtu, Mock.sd_ble_gattc_exchange_mtu_request_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gattc_exchange_mtu_request' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_exchange_mtu_request' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_exchange_mtu_request' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gattc_exchange_mtu_request' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_client_rx_mtu)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_client_rx_mtu, client_rx_mtu, cmock_line, "Function 'sd_ble_gattc_exchange_mtu_request' called with unexpected value for argument 'client_rx_mtu'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gattc_exchange_mtu_request(CMOCK_sd_ble_gattc_exchange_mtu_request_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint16_t client_rx_mtu)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_client_rx_mtu = client_rx_mtu;
+  cmock_call_instance->IgnoreArg_client_rx_mtu = 0;
+}
+
+void sd_ble_gattc_exchange_mtu_request_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_exchange_mtu_request_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_exchange_mtu_request_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_exchange_mtu_request_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_exchange_mtu_request_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_exchange_mtu_request_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gattc_exchange_mtu_request_IgnoreBool = (int)1;
+}
+
+void sd_ble_gattc_exchange_mtu_request_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t client_rx_mtu, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_exchange_mtu_request_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_exchange_mtu_request_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_exchange_mtu_request_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_exchange_mtu_request_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_exchange_mtu_request_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_exchange_mtu_request(cmock_call_instance, conn_handle, client_rx_mtu);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_exchange_mtu_request_StubWithCallback(CMOCK_sd_ble_gattc_exchange_mtu_request_CALLBACK Callback)
+{
+  Mock.sd_ble_gattc_exchange_mtu_request_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gattc_exchange_mtu_request_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_exchange_mtu_request_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_exchange_mtu_request_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_exchange_mtu_request_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gattc_exchange_mtu_request'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gattc_exchange_mtu_request_CMockIgnoreArg_client_rx_mtu(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_exchange_mtu_request_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_exchange_mtu_request_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_exchange_mtu_request_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "client_rx_mtu IgnoreArg called before Expect on 'sd_ble_gattc_exchange_mtu_request'.");
+  cmock_call_instance->IgnoreArg_client_rx_mtu = 1;
+}
+
+uint32_t sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter(ble_gattc_evt_t* p_gattc_evt, ble_gattc_handle_value_t* p_iter)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallInstance);
+  Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallInstance);
+  if (Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_FinalReturn;
+    Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallbackFunctionPointer(p_gattc_evt, p_iter, Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_gattc_evt)
+  {
+    if (cmock_call_instance->Expected_p_gattc_evt == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_gattc_evt, cmock_line, "Expected NULL. Function 'sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter' called with unexpected value for argument 'p_gattc_evt'."); }
+    else if (cmock_call_instance->Expected_p_gattc_evt_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_gattc_evt, p_gattc_evt, cmock_line, "Function 'sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter' called with unexpected value for argument 'p_gattc_evt'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_gattc_evt), (void*)(p_gattc_evt), sizeof(ble_gattc_evt_t), cmock_call_instance->Expected_p_gattc_evt_Depth, cmock_line, "Function 'sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter' called with unexpected value for argument 'p_gattc_evt'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_iter)
+  {
+    if (cmock_call_instance->Expected_p_iter == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_iter, cmock_line, "Expected NULL. Function 'sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter' called with unexpected value for argument 'p_iter'."); }
+    else if (cmock_call_instance->Expected_p_iter_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_iter, p_iter, cmock_line, "Function 'sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter' called with unexpected value for argument 'p_iter'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_iter), (void*)(p_iter), sizeof(ble_gattc_handle_value_t), cmock_call_instance->Expected_p_iter_Depth, cmock_line, "Function 'sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter' called with unexpected value for argument 'p_iter'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_gattc_evt_Used)
+  {
+    memcpy((void*)p_gattc_evt, (void*)cmock_call_instance->ReturnThruPtr_p_gattc_evt_Val,
+      cmock_call_instance->ReturnThruPtr_p_gattc_evt_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_iter_Used)
+  {
+    memcpy((void*)p_iter, (void*)cmock_call_instance->ReturnThruPtr_p_iter_Val,
+      cmock_call_instance->ReturnThruPtr_p_iter_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter(CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE* cmock_call_instance, ble_gattc_evt_t* p_gattc_evt, int p_gattc_evt_Depth, ble_gattc_handle_value_t* p_iter, int p_iter_Depth)
+{
+  cmock_call_instance->Expected_p_gattc_evt = p_gattc_evt;
+  cmock_call_instance->Expected_p_gattc_evt_Depth = p_gattc_evt_Depth;
+  cmock_call_instance->IgnoreArg_p_gattc_evt = 0;
+  cmock_call_instance->ReturnThruPtr_p_gattc_evt_Used = 0;
+  cmock_call_instance->Expected_p_iter = p_iter;
+  cmock_call_instance->Expected_p_iter_Depth = p_iter_Depth;
+  cmock_call_instance->IgnoreArg_p_iter = 0;
+  cmock_call_instance->ReturnThruPtr_p_iter_Used = 0;
+}
+
+void sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_IgnoreBool = (int)1;
+}
+
+void sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gattc_evt_t* p_gattc_evt, ble_gattc_handle_value_t* p_iter, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter(cmock_call_instance, p_gattc_evt, 0, p_iter, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_StubWithCallback(CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALLBACK Callback)
+{
+  Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gattc_evt_t* p_gattc_evt, int p_gattc_evt_Depth, ble_gattc_handle_value_t* p_iter, int p_iter_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE));
+  CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter(cmock_call_instance, p_gattc_evt, p_gattc_evt_Depth, p_iter, p_iter_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockReturnMemThruPtr_p_gattc_evt(UNITY_LINE_TYPE cmock_line, ble_gattc_evt_t* p_gattc_evt, int cmock_size)
+{
+  CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_gattc_evt ReturnThruPtr called before Expect on 'sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter'.");
+  cmock_call_instance->ReturnThruPtr_p_gattc_evt_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_gattc_evt_Val = p_gattc_evt;
+  cmock_call_instance->ReturnThruPtr_p_gattc_evt_Size = cmock_size;
+}
+
+void sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockReturnMemThruPtr_p_iter(UNITY_LINE_TYPE cmock_line, ble_gattc_handle_value_t* p_iter, int cmock_size)
+{
+  CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_iter ReturnThruPtr called before Expect on 'sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter'.");
+  cmock_call_instance->ReturnThruPtr_p_iter_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_iter_Val = p_iter;
+  cmock_call_instance->ReturnThruPtr_p_iter_Size = cmock_size;
+}
+
+void sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockIgnoreArg_p_gattc_evt(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_gattc_evt IgnoreArg called before Expect on 'sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter'.");
+  cmock_call_instance->IgnoreArg_p_gattc_evt = 1;
+}
+
+void sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockIgnoreArg_p_iter(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_iter IgnoreArg called before Expect on 'sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter'.");
+  cmock_call_instance->IgnoreArg_p_iter = 1;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_gattc.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_gattc.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_gattc.h   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_gattc.h    2018-04-24 08:48:28.798150900 +0200
@@ -0,0 +1,216 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_BLE_GATTC_H
+#define _MOCK_BLE_GATTC_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <ble_gattc.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_ble_gattc_Init(void);
+void mock_ble_gattc_Destroy(void);
+void mock_ble_gattc_Verify(void);
+
+
+
+
+#define sd_ble_gattc_primary_services_discover_IgnoreAndReturn(cmock_retval) sd_ble_gattc_primary_services_discover_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gattc_primary_services_discover_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gattc_primary_services_discover_ExpectAndReturn(conn_handle, start_handle, p_srvc_uuid, cmock_retval) sd_ble_gattc_primary_services_discover_CMockExpectAndReturn(__LINE__, conn_handle, start_handle, p_srvc_uuid, cmock_retval)
+void sd_ble_gattc_primary_services_discover_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const* p_srvc_uuid, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gattc_primary_services_discover_CALLBACK)(uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const* p_srvc_uuid, int cmock_num_calls);
+void sd_ble_gattc_primary_services_discover_StubWithCallback(CMOCK_sd_ble_gattc_primary_services_discover_CALLBACK Callback);
+#define sd_ble_gattc_primary_services_discover_ExpectWithArrayAndReturn(conn_handle, start_handle, p_srvc_uuid, p_srvc_uuid_Depth, cmock_retval) sd_ble_gattc_primary_services_discover_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, start_handle, p_srvc_uuid, p_srvc_uuid_Depth, cmock_retval)
+void sd_ble_gattc_primary_services_discover_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const* p_srvc_uuid, int p_srvc_uuid_Depth, uint32_t cmock_to_return);
+#define sd_ble_gattc_primary_services_discover_ReturnThruPtr_p_srvc_uuid(p_srvc_uuid) sd_ble_gattc_primary_services_discover_CMockReturnMemThruPtr_p_srvc_uuid(__LINE__, p_srvc_uuid, sizeof(*p_srvc_uuid))
+#define sd_ble_gattc_primary_services_discover_ReturnArrayThruPtr_p_srvc_uuid(p_srvc_uuid, cmock_len) sd_ble_gattc_primary_services_discover_CMockReturnMemThruPtr_p_srvc_uuid(__LINE__, p_srvc_uuid, cmock_len * sizeof(*p_srvc_uuid))
+#define sd_ble_gattc_primary_services_discover_ReturnMemThruPtr_p_srvc_uuid(p_srvc_uuid, cmock_size) sd_ble_gattc_primary_services_discover_CMockReturnMemThruPtr_p_srvc_uuid(__LINE__, p_srvc_uuid, cmock_size)
+void sd_ble_gattc_primary_services_discover_CMockReturnMemThruPtr_p_srvc_uuid(UNITY_LINE_TYPE cmock_line, ble_uuid_t const* p_srvc_uuid, int cmock_size);
+#define sd_ble_gattc_primary_services_discover_IgnoreArg_conn_handle() sd_ble_gattc_primary_services_discover_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gattc_primary_services_discover_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_primary_services_discover_IgnoreArg_start_handle() sd_ble_gattc_primary_services_discover_CMockIgnoreArg_start_handle(__LINE__)
+void sd_ble_gattc_primary_services_discover_CMockIgnoreArg_start_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_primary_services_discover_IgnoreArg_p_srvc_uuid() sd_ble_gattc_primary_services_discover_CMockIgnoreArg_p_srvc_uuid(__LINE__)
+void sd_ble_gattc_primary_services_discover_CMockIgnoreArg_p_srvc_uuid(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_relationships_discover_IgnoreAndReturn(cmock_retval) sd_ble_gattc_relationships_discover_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gattc_relationships_discover_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gattc_relationships_discover_ExpectAndReturn(conn_handle, p_handle_range, cmock_retval) sd_ble_gattc_relationships_discover_CMockExpectAndReturn(__LINE__, conn_handle, p_handle_range, cmock_retval)
+void sd_ble_gattc_relationships_discover_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gattc_relationships_discover_CALLBACK)(uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, int cmock_num_calls);
+void sd_ble_gattc_relationships_discover_StubWithCallback(CMOCK_sd_ble_gattc_relationships_discover_CALLBACK Callback);
+#define sd_ble_gattc_relationships_discover_ExpectWithArrayAndReturn(conn_handle, p_handle_range, p_handle_range_Depth, cmock_retval) sd_ble_gattc_relationships_discover_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_handle_range, p_handle_range_Depth, cmock_retval)
+void sd_ble_gattc_relationships_discover_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, int p_handle_range_Depth, uint32_t cmock_to_return);
+#define sd_ble_gattc_relationships_discover_ReturnThruPtr_p_handle_range(p_handle_range) sd_ble_gattc_relationships_discover_CMockReturnMemThruPtr_p_handle_range(__LINE__, p_handle_range, sizeof(*p_handle_range))
+#define sd_ble_gattc_relationships_discover_ReturnArrayThruPtr_p_handle_range(p_handle_range, cmock_len) sd_ble_gattc_relationships_discover_CMockReturnMemThruPtr_p_handle_range(__LINE__, p_handle_range, cmock_len * sizeof(*p_handle_range))
+#define sd_ble_gattc_relationships_discover_ReturnMemThruPtr_p_handle_range(p_handle_range, cmock_size) sd_ble_gattc_relationships_discover_CMockReturnMemThruPtr_p_handle_range(__LINE__, p_handle_range, cmock_size)
+void sd_ble_gattc_relationships_discover_CMockReturnMemThruPtr_p_handle_range(UNITY_LINE_TYPE cmock_line, ble_gattc_handle_range_t const* p_handle_range, int cmock_size);
+#define sd_ble_gattc_relationships_discover_IgnoreArg_conn_handle() sd_ble_gattc_relationships_discover_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gattc_relationships_discover_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_relationships_discover_IgnoreArg_p_handle_range() sd_ble_gattc_relationships_discover_CMockIgnoreArg_p_handle_range(__LINE__)
+void sd_ble_gattc_relationships_discover_CMockIgnoreArg_p_handle_range(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_characteristics_discover_IgnoreAndReturn(cmock_retval) sd_ble_gattc_characteristics_discover_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gattc_characteristics_discover_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gattc_characteristics_discover_ExpectAndReturn(conn_handle, p_handle_range, cmock_retval) sd_ble_gattc_characteristics_discover_CMockExpectAndReturn(__LINE__, conn_handle, p_handle_range, cmock_retval)
+void sd_ble_gattc_characteristics_discover_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gattc_characteristics_discover_CALLBACK)(uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, int cmock_num_calls);
+void sd_ble_gattc_characteristics_discover_StubWithCallback(CMOCK_sd_ble_gattc_characteristics_discover_CALLBACK Callback);
+#define sd_ble_gattc_characteristics_discover_ExpectWithArrayAndReturn(conn_handle, p_handle_range, p_handle_range_Depth, cmock_retval) sd_ble_gattc_characteristics_discover_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_handle_range, p_handle_range_Depth, cmock_retval)
+void sd_ble_gattc_characteristics_discover_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, int p_handle_range_Depth, uint32_t cmock_to_return);
+#define sd_ble_gattc_characteristics_discover_ReturnThruPtr_p_handle_range(p_handle_range) sd_ble_gattc_characteristics_discover_CMockReturnMemThruPtr_p_handle_range(__LINE__, p_handle_range, sizeof(*p_handle_range))
+#define sd_ble_gattc_characteristics_discover_ReturnArrayThruPtr_p_handle_range(p_handle_range, cmock_len) sd_ble_gattc_characteristics_discover_CMockReturnMemThruPtr_p_handle_range(__LINE__, p_handle_range, cmock_len * sizeof(*p_handle_range))
+#define sd_ble_gattc_characteristics_discover_ReturnMemThruPtr_p_handle_range(p_handle_range, cmock_size) sd_ble_gattc_characteristics_discover_CMockReturnMemThruPtr_p_handle_range(__LINE__, p_handle_range, cmock_size)
+void sd_ble_gattc_characteristics_discover_CMockReturnMemThruPtr_p_handle_range(UNITY_LINE_TYPE cmock_line, ble_gattc_handle_range_t const* p_handle_range, int cmock_size);
+#define sd_ble_gattc_characteristics_discover_IgnoreArg_conn_handle() sd_ble_gattc_characteristics_discover_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gattc_characteristics_discover_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_characteristics_discover_IgnoreArg_p_handle_range() sd_ble_gattc_characteristics_discover_CMockIgnoreArg_p_handle_range(__LINE__)
+void sd_ble_gattc_characteristics_discover_CMockIgnoreArg_p_handle_range(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_descriptors_discover_IgnoreAndReturn(cmock_retval) sd_ble_gattc_descriptors_discover_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gattc_descriptors_discover_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gattc_descriptors_discover_ExpectAndReturn(conn_handle, p_handle_range, cmock_retval) sd_ble_gattc_descriptors_discover_CMockExpectAndReturn(__LINE__, conn_handle, p_handle_range, cmock_retval)
+void sd_ble_gattc_descriptors_discover_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gattc_descriptors_discover_CALLBACK)(uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, int cmock_num_calls);
+void sd_ble_gattc_descriptors_discover_StubWithCallback(CMOCK_sd_ble_gattc_descriptors_discover_CALLBACK Callback);
+#define sd_ble_gattc_descriptors_discover_ExpectWithArrayAndReturn(conn_handle, p_handle_range, p_handle_range_Depth, cmock_retval) sd_ble_gattc_descriptors_discover_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_handle_range, p_handle_range_Depth, cmock_retval)
+void sd_ble_gattc_descriptors_discover_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, int p_handle_range_Depth, uint32_t cmock_to_return);
+#define sd_ble_gattc_descriptors_discover_ReturnThruPtr_p_handle_range(p_handle_range) sd_ble_gattc_descriptors_discover_CMockReturnMemThruPtr_p_handle_range(__LINE__, p_handle_range, sizeof(*p_handle_range))
+#define sd_ble_gattc_descriptors_discover_ReturnArrayThruPtr_p_handle_range(p_handle_range, cmock_len) sd_ble_gattc_descriptors_discover_CMockReturnMemThruPtr_p_handle_range(__LINE__, p_handle_range, cmock_len * sizeof(*p_handle_range))
+#define sd_ble_gattc_descriptors_discover_ReturnMemThruPtr_p_handle_range(p_handle_range, cmock_size) sd_ble_gattc_descriptors_discover_CMockReturnMemThruPtr_p_handle_range(__LINE__, p_handle_range, cmock_size)
+void sd_ble_gattc_descriptors_discover_CMockReturnMemThruPtr_p_handle_range(UNITY_LINE_TYPE cmock_line, ble_gattc_handle_range_t const* p_handle_range, int cmock_size);
+#define sd_ble_gattc_descriptors_discover_IgnoreArg_conn_handle() sd_ble_gattc_descriptors_discover_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gattc_descriptors_discover_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_descriptors_discover_IgnoreArg_p_handle_range() sd_ble_gattc_descriptors_discover_CMockIgnoreArg_p_handle_range(__LINE__)
+void sd_ble_gattc_descriptors_discover_CMockIgnoreArg_p_handle_range(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_char_value_by_uuid_read_IgnoreAndReturn(cmock_retval) sd_ble_gattc_char_value_by_uuid_read_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gattc_char_value_by_uuid_read_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gattc_char_value_by_uuid_read_ExpectAndReturn(conn_handle, p_uuid, p_handle_range, cmock_retval) sd_ble_gattc_char_value_by_uuid_read_CMockExpectAndReturn(__LINE__, conn_handle, p_uuid, p_handle_range, cmock_retval)
+void sd_ble_gattc_char_value_by_uuid_read_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_uuid_t const* p_uuid, ble_gattc_handle_range_t const* p_handle_range, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALLBACK)(uint16_t conn_handle, ble_uuid_t const* p_uuid, ble_gattc_handle_range_t const* p_handle_range, int cmock_num_calls);
+void sd_ble_gattc_char_value_by_uuid_read_StubWithCallback(CMOCK_sd_ble_gattc_char_value_by_uuid_read_CALLBACK Callback);
+#define sd_ble_gattc_char_value_by_uuid_read_ExpectWithArrayAndReturn(conn_handle, p_uuid, p_uuid_Depth, p_handle_range, p_handle_range_Depth, cmock_retval) sd_ble_gattc_char_value_by_uuid_read_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_uuid, p_uuid_Depth, p_handle_range, p_handle_range_Depth, cmock_retval)
+void sd_ble_gattc_char_value_by_uuid_read_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_uuid_t const* p_uuid, int p_uuid_Depth, ble_gattc_handle_range_t const* p_handle_range, int p_handle_range_Depth, uint32_t cmock_to_return);
+#define sd_ble_gattc_char_value_by_uuid_read_ReturnThruPtr_p_uuid(p_uuid) sd_ble_gattc_char_value_by_uuid_read_CMockReturnMemThruPtr_p_uuid(__LINE__, p_uuid, sizeof(*p_uuid))
+#define sd_ble_gattc_char_value_by_uuid_read_ReturnArrayThruPtr_p_uuid(p_uuid, cmock_len) sd_ble_gattc_char_value_by_uuid_read_CMockReturnMemThruPtr_p_uuid(__LINE__, p_uuid, cmock_len * sizeof(*p_uuid))
+#define sd_ble_gattc_char_value_by_uuid_read_ReturnMemThruPtr_p_uuid(p_uuid, cmock_size) sd_ble_gattc_char_value_by_uuid_read_CMockReturnMemThruPtr_p_uuid(__LINE__, p_uuid, cmock_size)
+void sd_ble_gattc_char_value_by_uuid_read_CMockReturnMemThruPtr_p_uuid(UNITY_LINE_TYPE cmock_line, ble_uuid_t const* p_uuid, int cmock_size);
+#define sd_ble_gattc_char_value_by_uuid_read_ReturnThruPtr_p_handle_range(p_handle_range) sd_ble_gattc_char_value_by_uuid_read_CMockReturnMemThruPtr_p_handle_range(__LINE__, p_handle_range, sizeof(*p_handle_range))
+#define sd_ble_gattc_char_value_by_uuid_read_ReturnArrayThruPtr_p_handle_range(p_handle_range, cmock_len) sd_ble_gattc_char_value_by_uuid_read_CMockReturnMemThruPtr_p_handle_range(__LINE__, p_handle_range, cmock_len * sizeof(*p_handle_range))
+#define sd_ble_gattc_char_value_by_uuid_read_ReturnMemThruPtr_p_handle_range(p_handle_range, cmock_size) sd_ble_gattc_char_value_by_uuid_read_CMockReturnMemThruPtr_p_handle_range(__LINE__, p_handle_range, cmock_size)
+void sd_ble_gattc_char_value_by_uuid_read_CMockReturnMemThruPtr_p_handle_range(UNITY_LINE_TYPE cmock_line, ble_gattc_handle_range_t const* p_handle_range, int cmock_size);
+#define sd_ble_gattc_char_value_by_uuid_read_IgnoreArg_conn_handle() sd_ble_gattc_char_value_by_uuid_read_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gattc_char_value_by_uuid_read_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_char_value_by_uuid_read_IgnoreArg_p_uuid() sd_ble_gattc_char_value_by_uuid_read_CMockIgnoreArg_p_uuid(__LINE__)
+void sd_ble_gattc_char_value_by_uuid_read_CMockIgnoreArg_p_uuid(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_char_value_by_uuid_read_IgnoreArg_p_handle_range() sd_ble_gattc_char_value_by_uuid_read_CMockIgnoreArg_p_handle_range(__LINE__)
+void sd_ble_gattc_char_value_by_uuid_read_CMockIgnoreArg_p_handle_range(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_read_IgnoreAndReturn(cmock_retval) sd_ble_gattc_read_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gattc_read_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gattc_read_ExpectAndReturn(conn_handle, handle, offset, cmock_retval) sd_ble_gattc_read_CMockExpectAndReturn(__LINE__, conn_handle, handle, offset, cmock_retval)
+void sd_ble_gattc_read_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t handle, uint16_t offset, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gattc_read_CALLBACK)(uint16_t conn_handle, uint16_t handle, uint16_t offset, int cmock_num_calls);
+void sd_ble_gattc_read_StubWithCallback(CMOCK_sd_ble_gattc_read_CALLBACK Callback);
+#define sd_ble_gattc_read_IgnoreArg_conn_handle() sd_ble_gattc_read_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gattc_read_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_read_IgnoreArg_handle() sd_ble_gattc_read_CMockIgnoreArg_handle(__LINE__)
+void sd_ble_gattc_read_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_read_IgnoreArg_offset() sd_ble_gattc_read_CMockIgnoreArg_offset(__LINE__)
+void sd_ble_gattc_read_CMockIgnoreArg_offset(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_char_values_read_IgnoreAndReturn(cmock_retval) sd_ble_gattc_char_values_read_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gattc_char_values_read_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gattc_char_values_read_ExpectAndReturn(conn_handle, p_handles, handle_count, cmock_retval) sd_ble_gattc_char_values_read_CMockExpectAndReturn(__LINE__, conn_handle, p_handles, handle_count, cmock_retval)
+void sd_ble_gattc_char_values_read_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t const* p_handles, uint16_t handle_count, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gattc_char_values_read_CALLBACK)(uint16_t conn_handle, uint16_t const* p_handles, uint16_t handle_count, int cmock_num_calls);
+void sd_ble_gattc_char_values_read_StubWithCallback(CMOCK_sd_ble_gattc_char_values_read_CALLBACK Callback);
+#define sd_ble_gattc_char_values_read_ExpectWithArrayAndReturn(conn_handle, p_handles, p_handles_Depth, handle_count, cmock_retval) sd_ble_gattc_char_values_read_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_handles, p_handles_Depth, handle_count, cmock_retval)
+void sd_ble_gattc_char_values_read_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t const* p_handles, int p_handles_Depth, uint16_t handle_count, uint32_t cmock_to_return);
+#define sd_ble_gattc_char_values_read_ReturnThruPtr_p_handles(p_handles) sd_ble_gattc_char_values_read_CMockReturnMemThruPtr_p_handles(__LINE__, p_handles, sizeof(*p_handles))
+#define sd_ble_gattc_char_values_read_ReturnArrayThruPtr_p_handles(p_handles, cmock_len) sd_ble_gattc_char_values_read_CMockReturnMemThruPtr_p_handles(__LINE__, p_handles, cmock_len * sizeof(*p_handles))
+#define sd_ble_gattc_char_values_read_ReturnMemThruPtr_p_handles(p_handles, cmock_size) sd_ble_gattc_char_values_read_CMockReturnMemThruPtr_p_handles(__LINE__, p_handles, cmock_size)
+void sd_ble_gattc_char_values_read_CMockReturnMemThruPtr_p_handles(UNITY_LINE_TYPE cmock_line, uint16_t const* p_handles, int cmock_size);
+#define sd_ble_gattc_char_values_read_IgnoreArg_conn_handle() sd_ble_gattc_char_values_read_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gattc_char_values_read_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_char_values_read_IgnoreArg_p_handles() sd_ble_gattc_char_values_read_CMockIgnoreArg_p_handles(__LINE__)
+void sd_ble_gattc_char_values_read_CMockIgnoreArg_p_handles(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_char_values_read_IgnoreArg_handle_count() sd_ble_gattc_char_values_read_CMockIgnoreArg_handle_count(__LINE__)
+void sd_ble_gattc_char_values_read_CMockIgnoreArg_handle_count(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_write_IgnoreAndReturn(cmock_retval) sd_ble_gattc_write_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gattc_write_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gattc_write_ExpectAndReturn(conn_handle, p_write_params, cmock_retval) sd_ble_gattc_write_CMockExpectAndReturn(__LINE__, conn_handle, p_write_params, cmock_retval)
+void sd_ble_gattc_write_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_write_params_t const* p_write_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gattc_write_CALLBACK)(uint16_t conn_handle, ble_gattc_write_params_t const* p_write_params, int cmock_num_calls);
+void sd_ble_gattc_write_StubWithCallback(CMOCK_sd_ble_gattc_write_CALLBACK Callback);
+#define sd_ble_gattc_write_ExpectWithArrayAndReturn(conn_handle, p_write_params, p_write_params_Depth, cmock_retval) sd_ble_gattc_write_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_write_params, p_write_params_Depth, cmock_retval)
+void sd_ble_gattc_write_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_write_params_t const* p_write_params, int p_write_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gattc_write_ReturnThruPtr_p_write_params(p_write_params) sd_ble_gattc_write_CMockReturnMemThruPtr_p_write_params(__LINE__, p_write_params, sizeof(*p_write_params))
+#define sd_ble_gattc_write_ReturnArrayThruPtr_p_write_params(p_write_params, cmock_len) sd_ble_gattc_write_CMockReturnMemThruPtr_p_write_params(__LINE__, p_write_params, cmock_len * sizeof(*p_write_params))
+#define sd_ble_gattc_write_ReturnMemThruPtr_p_write_params(p_write_params, cmock_size) sd_ble_gattc_write_CMockReturnMemThruPtr_p_write_params(__LINE__, p_write_params, cmock_size)
+void sd_ble_gattc_write_CMockReturnMemThruPtr_p_write_params(UNITY_LINE_TYPE cmock_line, ble_gattc_write_params_t const* p_write_params, int cmock_size);
+#define sd_ble_gattc_write_IgnoreArg_conn_handle() sd_ble_gattc_write_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gattc_write_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_write_IgnoreArg_p_write_params() sd_ble_gattc_write_CMockIgnoreArg_p_write_params(__LINE__)
+void sd_ble_gattc_write_CMockIgnoreArg_p_write_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_hv_confirm_IgnoreAndReturn(cmock_retval) sd_ble_gattc_hv_confirm_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gattc_hv_confirm_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gattc_hv_confirm_ExpectAndReturn(conn_handle, handle, cmock_retval) sd_ble_gattc_hv_confirm_CMockExpectAndReturn(__LINE__, conn_handle, handle, cmock_retval)
+void sd_ble_gattc_hv_confirm_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t handle, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gattc_hv_confirm_CALLBACK)(uint16_t conn_handle, uint16_t handle, int cmock_num_calls);
+void sd_ble_gattc_hv_confirm_StubWithCallback(CMOCK_sd_ble_gattc_hv_confirm_CALLBACK Callback);
+#define sd_ble_gattc_hv_confirm_IgnoreArg_conn_handle() sd_ble_gattc_hv_confirm_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gattc_hv_confirm_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_hv_confirm_IgnoreArg_handle() sd_ble_gattc_hv_confirm_CMockIgnoreArg_handle(__LINE__)
+void sd_ble_gattc_hv_confirm_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_attr_info_discover_IgnoreAndReturn(cmock_retval) sd_ble_gattc_attr_info_discover_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gattc_attr_info_discover_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gattc_attr_info_discover_ExpectAndReturn(conn_handle, p_handle_range, cmock_retval) sd_ble_gattc_attr_info_discover_CMockExpectAndReturn(__LINE__, conn_handle, p_handle_range, cmock_retval)
+void sd_ble_gattc_attr_info_discover_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gattc_attr_info_discover_CALLBACK)(uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, int cmock_num_calls);
+void sd_ble_gattc_attr_info_discover_StubWithCallback(CMOCK_sd_ble_gattc_attr_info_discover_CALLBACK Callback);
+#define sd_ble_gattc_attr_info_discover_ExpectWithArrayAndReturn(conn_handle, p_handle_range, p_handle_range_Depth, cmock_retval) sd_ble_gattc_attr_info_discover_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_handle_range, p_handle_range_Depth, cmock_retval)
+void sd_ble_gattc_attr_info_discover_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gattc_handle_range_t const* p_handle_range, int p_handle_range_Depth, uint32_t cmock_to_return);
+#define sd_ble_gattc_attr_info_discover_ReturnThruPtr_p_handle_range(p_handle_range) sd_ble_gattc_attr_info_discover_CMockReturnMemThruPtr_p_handle_range(__LINE__, p_handle_range, sizeof(*p_handle_range))
+#define sd_ble_gattc_attr_info_discover_ReturnArrayThruPtr_p_handle_range(p_handle_range, cmock_len) sd_ble_gattc_attr_info_discover_CMockReturnMemThruPtr_p_handle_range(__LINE__, p_handle_range, cmock_len * sizeof(*p_handle_range))
+#define sd_ble_gattc_attr_info_discover_ReturnMemThruPtr_p_handle_range(p_handle_range, cmock_size) sd_ble_gattc_attr_info_discover_CMockReturnMemThruPtr_p_handle_range(__LINE__, p_handle_range, cmock_size)
+void sd_ble_gattc_attr_info_discover_CMockReturnMemThruPtr_p_handle_range(UNITY_LINE_TYPE cmock_line, ble_gattc_handle_range_t const* p_handle_range, int cmock_size);
+#define sd_ble_gattc_attr_info_discover_IgnoreArg_conn_handle() sd_ble_gattc_attr_info_discover_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gattc_attr_info_discover_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_attr_info_discover_IgnoreArg_p_handle_range() sd_ble_gattc_attr_info_discover_CMockIgnoreArg_p_handle_range(__LINE__)
+void sd_ble_gattc_attr_info_discover_CMockIgnoreArg_p_handle_range(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_exchange_mtu_request_IgnoreAndReturn(cmock_retval) sd_ble_gattc_exchange_mtu_request_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gattc_exchange_mtu_request_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gattc_exchange_mtu_request_ExpectAndReturn(conn_handle, client_rx_mtu, cmock_retval) sd_ble_gattc_exchange_mtu_request_CMockExpectAndReturn(__LINE__, conn_handle, client_rx_mtu, cmock_retval)
+void sd_ble_gattc_exchange_mtu_request_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t client_rx_mtu, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gattc_exchange_mtu_request_CALLBACK)(uint16_t conn_handle, uint16_t client_rx_mtu, int cmock_num_calls);
+void sd_ble_gattc_exchange_mtu_request_StubWithCallback(CMOCK_sd_ble_gattc_exchange_mtu_request_CALLBACK Callback);
+#define sd_ble_gattc_exchange_mtu_request_IgnoreArg_conn_handle() sd_ble_gattc_exchange_mtu_request_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gattc_exchange_mtu_request_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_exchange_mtu_request_IgnoreArg_client_rx_mtu() sd_ble_gattc_exchange_mtu_request_CMockIgnoreArg_client_rx_mtu(__LINE__)
+void sd_ble_gattc_exchange_mtu_request_CMockIgnoreArg_client_rx_mtu(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_IgnoreAndReturn(cmock_retval) sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_ExpectAndReturn(p_gattc_evt, p_iter, cmock_retval) sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockExpectAndReturn(__LINE__, p_gattc_evt, p_iter, cmock_retval)
+void sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gattc_evt_t* p_gattc_evt, ble_gattc_handle_value_t* p_iter, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALLBACK)(ble_gattc_evt_t* p_gattc_evt, ble_gattc_handle_value_t* p_iter, int cmock_num_calls);
+void sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_StubWithCallback(CMOCK_sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CALLBACK Callback);
+#define sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_ExpectWithArrayAndReturn(p_gattc_evt, p_gattc_evt_Depth, p_iter, p_iter_Depth, cmock_retval) sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockExpectWithArrayAndReturn(__LINE__, p_gattc_evt, p_gattc_evt_Depth, p_iter, p_iter_Depth, cmock_retval)
+void sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gattc_evt_t* p_gattc_evt, int p_gattc_evt_Depth, ble_gattc_handle_value_t* p_iter, int p_iter_Depth, uint32_t cmock_to_return);
+#define sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_ReturnThruPtr_p_gattc_evt(p_gattc_evt) sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockReturnMemThruPtr_p_gattc_evt(__LINE__, p_gattc_evt, sizeof(*p_gattc_evt))
+#define sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_ReturnArrayThruPtr_p_gattc_evt(p_gattc_evt, cmock_len) sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockReturnMemThruPtr_p_gattc_evt(__LINE__, p_gattc_evt, cmock_len * sizeof(*p_gattc_evt))
+#define sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_ReturnMemThruPtr_p_gattc_evt(p_gattc_evt, cmock_size) sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockReturnMemThruPtr_p_gattc_evt(__LINE__, p_gattc_evt, cmock_size)
+void sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockReturnMemThruPtr_p_gattc_evt(UNITY_LINE_TYPE cmock_line, ble_gattc_evt_t* p_gattc_evt, int cmock_size);
+#define sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_ReturnThruPtr_p_iter(p_iter) sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockReturnMemThruPtr_p_iter(__LINE__, p_iter, sizeof(*p_iter))
+#define sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_ReturnArrayThruPtr_p_iter(p_iter, cmock_len) sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockReturnMemThruPtr_p_iter(__LINE__, p_iter, cmock_len * sizeof(*p_iter))
+#define sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_ReturnMemThruPtr_p_iter(p_iter, cmock_size) sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockReturnMemThruPtr_p_iter(__LINE__, p_iter, cmock_size)
+void sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockReturnMemThruPtr_p_iter(UNITY_LINE_TYPE cmock_line, ble_gattc_handle_value_t* p_iter, int cmock_size);
+#define sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_IgnoreArg_p_gattc_evt() sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockIgnoreArg_p_gattc_evt(__LINE__)
+void sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockIgnoreArg_p_gattc_evt(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_IgnoreArg_p_iter() sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockIgnoreArg_p_iter(__LINE__)
+void sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter_CMockIgnoreArg_p_iter(UNITY_LINE_TYPE cmock_line);
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_gatts.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_gatts.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_gatts.c   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_gatts.c    2018-04-24 08:48:28.808151100 +0200
@@ -0,0 +1,2280 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_ble_gatts.h"
+
+typedef struct _CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t Expected_type;
+  ble_uuid_t const* Expected_p_uuid;
+  uint16_t* Expected_p_handle;
+  int Expected_p_uuid_Depth;
+  int Expected_p_handle_Depth;
+  int ReturnThruPtr_p_uuid_Used;
+  ble_uuid_t const* ReturnThruPtr_p_uuid_Val;
+  int ReturnThruPtr_p_uuid_Size;
+  int ReturnThruPtr_p_handle_Used;
+  uint16_t* ReturnThruPtr_p_handle_Val;
+  int ReturnThruPtr_p_handle_Size;
+  int IgnoreArg_type;
+  int IgnoreArg_p_uuid;
+  int IgnoreArg_p_handle;
+
+} CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_service_handle;
+  uint16_t Expected_inc_srvc_handle;
+  uint16_t* Expected_p_include_handle;
+  int Expected_p_include_handle_Depth;
+  int ReturnThruPtr_p_include_handle_Used;
+  uint16_t* ReturnThruPtr_p_include_handle_Val;
+  int ReturnThruPtr_p_include_handle_Size;
+  int IgnoreArg_service_handle;
+  int IgnoreArg_inc_srvc_handle;
+  int IgnoreArg_p_include_handle;
+
+} CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_service_handle;
+  ble_gatts_char_md_t const* Expected_p_char_md;
+  ble_gatts_attr_t const* Expected_p_attr_char_value;
+  ble_gatts_char_handles_t* Expected_p_handles;
+  int Expected_p_char_md_Depth;
+  int Expected_p_attr_char_value_Depth;
+  int Expected_p_handles_Depth;
+  int ReturnThruPtr_p_char_md_Used;
+  ble_gatts_char_md_t const* ReturnThruPtr_p_char_md_Val;
+  int ReturnThruPtr_p_char_md_Size;
+  int ReturnThruPtr_p_attr_char_value_Used;
+  ble_gatts_attr_t const* ReturnThruPtr_p_attr_char_value_Val;
+  int ReturnThruPtr_p_attr_char_value_Size;
+  int ReturnThruPtr_p_handles_Used;
+  ble_gatts_char_handles_t* ReturnThruPtr_p_handles_Val;
+  int ReturnThruPtr_p_handles_Size;
+  int IgnoreArg_service_handle;
+  int IgnoreArg_p_char_md;
+  int IgnoreArg_p_attr_char_value;
+  int IgnoreArg_p_handles;
+
+} CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_char_handle;
+  ble_gatts_attr_t const* Expected_p_attr;
+  uint16_t* Expected_p_handle;
+  int Expected_p_attr_Depth;
+  int Expected_p_handle_Depth;
+  int ReturnThruPtr_p_attr_Used;
+  ble_gatts_attr_t const* ReturnThruPtr_p_attr_Val;
+  int ReturnThruPtr_p_attr_Size;
+  int ReturnThruPtr_p_handle_Used;
+  uint16_t* ReturnThruPtr_p_handle_Val;
+  int ReturnThruPtr_p_handle_Size;
+  int IgnoreArg_char_handle;
+  int IgnoreArg_p_attr;
+  int IgnoreArg_p_handle;
+
+} CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint16_t Expected_handle;
+  ble_gatts_value_t* Expected_p_value;
+  int Expected_p_value_Depth;
+  int ReturnThruPtr_p_value_Used;
+  ble_gatts_value_t* ReturnThruPtr_p_value_Val;
+  int ReturnThruPtr_p_value_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_handle;
+  int IgnoreArg_p_value;
+
+} CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint16_t Expected_handle;
+  ble_gatts_value_t* Expected_p_value;
+  int Expected_p_value_Depth;
+  int ReturnThruPtr_p_value_Used;
+  ble_gatts_value_t* ReturnThruPtr_p_value_Val;
+  int ReturnThruPtr_p_value_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_handle;
+  int IgnoreArg_p_value;
+
+} CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gatts_hvx_params_t const* Expected_p_hvx_params;
+  int Expected_p_hvx_params_Depth;
+  int ReturnThruPtr_p_hvx_params_Used;
+  ble_gatts_hvx_params_t const* ReturnThruPtr_p_hvx_params_Val;
+  int ReturnThruPtr_p_hvx_params_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_hvx_params;
+
+} CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint16_t Expected_start_handle;
+  uint16_t Expected_end_handle;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_start_handle;
+  int IgnoreArg_end_handle;
+
+} CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gatts_rw_authorize_reply_params_t const* Expected_p_rw_authorize_reply_params;
+  int Expected_p_rw_authorize_reply_params_Depth;
+  int ReturnThruPtr_p_rw_authorize_reply_params_Used;
+  ble_gatts_rw_authorize_reply_params_t const* ReturnThruPtr_p_rw_authorize_reply_params_Val;
+  int ReturnThruPtr_p_rw_authorize_reply_params_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_rw_authorize_reply_params;
+
+} CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint8_t const* Expected_p_sys_attr_data;
+  uint16_t Expected_len;
+  uint32_t Expected_flags;
+  int Expected_p_sys_attr_data_Depth;
+  int ReturnThruPtr_p_sys_attr_data_Used;
+  uint8_t const* ReturnThruPtr_p_sys_attr_data_Val;
+  int ReturnThruPtr_p_sys_attr_data_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_sys_attr_data;
+  int IgnoreArg_len;
+  int IgnoreArg_flags;
+
+} CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint8_t* Expected_p_sys_attr_data;
+  uint16_t* Expected_p_len;
+  uint32_t Expected_flags;
+  int Expected_p_sys_attr_data_Depth;
+  int Expected_p_len_Depth;
+  int ReturnThruPtr_p_sys_attr_data_Used;
+  uint8_t* ReturnThruPtr_p_sys_attr_data_Val;
+  int ReturnThruPtr_p_sys_attr_data_Size;
+  int ReturnThruPtr_p_len_Used;
+  uint16_t* ReturnThruPtr_p_len_Val;
+  int ReturnThruPtr_p_len_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_sys_attr_data;
+  int IgnoreArg_p_len;
+  int IgnoreArg_flags;
+
+} CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t* Expected_p_handle;
+  int Expected_p_handle_Depth;
+  int ReturnThruPtr_p_handle_Used;
+  uint16_t* ReturnThruPtr_p_handle_Val;
+  int ReturnThruPtr_p_handle_Size;
+  int IgnoreArg_p_handle;
+
+} CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_handle;
+  ble_uuid_t* Expected_p_uuid;
+  ble_gatts_attr_md_t* Expected_p_md;
+  int Expected_p_uuid_Depth;
+  int Expected_p_md_Depth;
+  int ReturnThruPtr_p_uuid_Used;
+  ble_uuid_t* ReturnThruPtr_p_uuid_Val;
+  int ReturnThruPtr_p_uuid_Size;
+  int ReturnThruPtr_p_md_Used;
+  ble_gatts_attr_md_t* ReturnThruPtr_p_md_Val;
+  int ReturnThruPtr_p_md_Size;
+  int IgnoreArg_handle;
+  int IgnoreArg_p_uuid;
+  int IgnoreArg_p_md;
+
+} CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gatts_exchange_mtu_reply_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint16_t Expected_server_rx_mtu;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_server_rx_mtu;
+
+} CMOCK_sd_ble_gatts_exchange_mtu_reply_CALL_INSTANCE;
+
+static struct mock_ble_gattsInstance
+{
+  int sd_ble_gatts_service_add_IgnoreBool;
+  uint32_t sd_ble_gatts_service_add_FinalReturn;
+  CMOCK_sd_ble_gatts_service_add_CALLBACK sd_ble_gatts_service_add_CallbackFunctionPointer;
+  int sd_ble_gatts_service_add_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gatts_service_add_CallInstance;
+  int sd_ble_gatts_include_add_IgnoreBool;
+  uint32_t sd_ble_gatts_include_add_FinalReturn;
+  CMOCK_sd_ble_gatts_include_add_CALLBACK sd_ble_gatts_include_add_CallbackFunctionPointer;
+  int sd_ble_gatts_include_add_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gatts_include_add_CallInstance;
+  int sd_ble_gatts_characteristic_add_IgnoreBool;
+  uint32_t sd_ble_gatts_characteristic_add_FinalReturn;
+  CMOCK_sd_ble_gatts_characteristic_add_CALLBACK sd_ble_gatts_characteristic_add_CallbackFunctionPointer;
+  int sd_ble_gatts_characteristic_add_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gatts_characteristic_add_CallInstance;
+  int sd_ble_gatts_descriptor_add_IgnoreBool;
+  uint32_t sd_ble_gatts_descriptor_add_FinalReturn;
+  CMOCK_sd_ble_gatts_descriptor_add_CALLBACK sd_ble_gatts_descriptor_add_CallbackFunctionPointer;
+  int sd_ble_gatts_descriptor_add_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gatts_descriptor_add_CallInstance;
+  int sd_ble_gatts_value_set_IgnoreBool;
+  uint32_t sd_ble_gatts_value_set_FinalReturn;
+  CMOCK_sd_ble_gatts_value_set_CALLBACK sd_ble_gatts_value_set_CallbackFunctionPointer;
+  int sd_ble_gatts_value_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gatts_value_set_CallInstance;
+  int sd_ble_gatts_value_get_IgnoreBool;
+  uint32_t sd_ble_gatts_value_get_FinalReturn;
+  CMOCK_sd_ble_gatts_value_get_CALLBACK sd_ble_gatts_value_get_CallbackFunctionPointer;
+  int sd_ble_gatts_value_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gatts_value_get_CallInstance;
+  int sd_ble_gatts_hvx_IgnoreBool;
+  uint32_t sd_ble_gatts_hvx_FinalReturn;
+  CMOCK_sd_ble_gatts_hvx_CALLBACK sd_ble_gatts_hvx_CallbackFunctionPointer;
+  int sd_ble_gatts_hvx_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gatts_hvx_CallInstance;
+  int sd_ble_gatts_service_changed_IgnoreBool;
+  uint32_t sd_ble_gatts_service_changed_FinalReturn;
+  CMOCK_sd_ble_gatts_service_changed_CALLBACK sd_ble_gatts_service_changed_CallbackFunctionPointer;
+  int sd_ble_gatts_service_changed_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gatts_service_changed_CallInstance;
+  int sd_ble_gatts_rw_authorize_reply_IgnoreBool;
+  uint32_t sd_ble_gatts_rw_authorize_reply_FinalReturn;
+  CMOCK_sd_ble_gatts_rw_authorize_reply_CALLBACK sd_ble_gatts_rw_authorize_reply_CallbackFunctionPointer;
+  int sd_ble_gatts_rw_authorize_reply_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gatts_rw_authorize_reply_CallInstance;
+  int sd_ble_gatts_sys_attr_set_IgnoreBool;
+  uint32_t sd_ble_gatts_sys_attr_set_FinalReturn;
+  CMOCK_sd_ble_gatts_sys_attr_set_CALLBACK sd_ble_gatts_sys_attr_set_CallbackFunctionPointer;
+  int sd_ble_gatts_sys_attr_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gatts_sys_attr_set_CallInstance;
+  int sd_ble_gatts_sys_attr_get_IgnoreBool;
+  uint32_t sd_ble_gatts_sys_attr_get_FinalReturn;
+  CMOCK_sd_ble_gatts_sys_attr_get_CALLBACK sd_ble_gatts_sys_attr_get_CallbackFunctionPointer;
+  int sd_ble_gatts_sys_attr_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gatts_sys_attr_get_CallInstance;
+  int sd_ble_gatts_initial_user_handle_get_IgnoreBool;
+  uint32_t sd_ble_gatts_initial_user_handle_get_FinalReturn;
+  CMOCK_sd_ble_gatts_initial_user_handle_get_CALLBACK sd_ble_gatts_initial_user_handle_get_CallbackFunctionPointer;
+  int sd_ble_gatts_initial_user_handle_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gatts_initial_user_handle_get_CallInstance;
+  int sd_ble_gatts_attr_get_IgnoreBool;
+  uint32_t sd_ble_gatts_attr_get_FinalReturn;
+  CMOCK_sd_ble_gatts_attr_get_CALLBACK sd_ble_gatts_attr_get_CallbackFunctionPointer;
+  int sd_ble_gatts_attr_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gatts_attr_get_CallInstance;
+  int sd_ble_gatts_exchange_mtu_reply_IgnoreBool;
+  uint32_t sd_ble_gatts_exchange_mtu_reply_FinalReturn;
+  CMOCK_sd_ble_gatts_exchange_mtu_reply_CALLBACK sd_ble_gatts_exchange_mtu_reply_CallbackFunctionPointer;
+  int sd_ble_gatts_exchange_mtu_reply_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gatts_exchange_mtu_reply_CallInstance;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_ble_gatts_Verify(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gatts_service_add_CallInstance, cmock_line, "Function 'sd_ble_gatts_service_add' called less times than expected.");
+  if (Mock.sd_ble_gatts_service_add_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gatts_service_add_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gatts_include_add_CallInstance, cmock_line, "Function 'sd_ble_gatts_include_add' called less times than expected.");
+  if (Mock.sd_ble_gatts_include_add_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gatts_include_add_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gatts_characteristic_add_CallInstance, cmock_line, "Function 'sd_ble_gatts_characteristic_add' called less times than expected.");
+  if (Mock.sd_ble_gatts_characteristic_add_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gatts_characteristic_add_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gatts_descriptor_add_CallInstance, cmock_line, "Function 'sd_ble_gatts_descriptor_add' called less times than expected.");
+  if (Mock.sd_ble_gatts_descriptor_add_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gatts_descriptor_add_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gatts_value_set_CallInstance, cmock_line, "Function 'sd_ble_gatts_value_set' called less times than expected.");
+  if (Mock.sd_ble_gatts_value_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gatts_value_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gatts_value_get_CallInstance, cmock_line, "Function 'sd_ble_gatts_value_get' called less times than expected.");
+  if (Mock.sd_ble_gatts_value_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gatts_value_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gatts_hvx_CallInstance, cmock_line, "Function 'sd_ble_gatts_hvx' called less times than expected.");
+  if (Mock.sd_ble_gatts_hvx_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gatts_hvx_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gatts_service_changed_CallInstance, cmock_line, "Function 'sd_ble_gatts_service_changed' called less times than expected.");
+  if (Mock.sd_ble_gatts_service_changed_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gatts_service_changed_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gatts_rw_authorize_reply_CallInstance, cmock_line, "Function 'sd_ble_gatts_rw_authorize_reply' called less times than expected.");
+  if (Mock.sd_ble_gatts_rw_authorize_reply_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gatts_rw_authorize_reply_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gatts_sys_attr_set_CallInstance, cmock_line, "Function 'sd_ble_gatts_sys_attr_set' called less times than expected.");
+  if (Mock.sd_ble_gatts_sys_attr_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gatts_sys_attr_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gatts_sys_attr_get_CallInstance, cmock_line, "Function 'sd_ble_gatts_sys_attr_get' called less times than expected.");
+  if (Mock.sd_ble_gatts_sys_attr_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gatts_sys_attr_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gatts_initial_user_handle_get_CallInstance, cmock_line, "Function 'sd_ble_gatts_initial_user_handle_get' called less times than expected.");
+  if (Mock.sd_ble_gatts_initial_user_handle_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gatts_initial_user_handle_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gatts_attr_get_CallInstance, cmock_line, "Function 'sd_ble_gatts_attr_get' called less times than expected.");
+  if (Mock.sd_ble_gatts_attr_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gatts_attr_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gatts_exchange_mtu_reply_CallInstance, cmock_line, "Function 'sd_ble_gatts_exchange_mtu_reply' called less times than expected.");
+  if (Mock.sd_ble_gatts_exchange_mtu_reply_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gatts_exchange_mtu_reply_CallInstance = CMOCK_GUTS_NONE;
+}
+
+void mock_ble_gatts_Init(void)
+{
+  mock_ble_gatts_Destroy();
+}
+
+void mock_ble_gatts_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  Mock.sd_ble_gatts_service_add_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gatts_service_add_CallbackCalls = 0;
+  Mock.sd_ble_gatts_include_add_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gatts_include_add_CallbackCalls = 0;
+  Mock.sd_ble_gatts_characteristic_add_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gatts_characteristic_add_CallbackCalls = 0;
+  Mock.sd_ble_gatts_descriptor_add_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gatts_descriptor_add_CallbackCalls = 0;
+  Mock.sd_ble_gatts_value_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gatts_value_set_CallbackCalls = 0;
+  Mock.sd_ble_gatts_value_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gatts_value_get_CallbackCalls = 0;
+  Mock.sd_ble_gatts_hvx_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gatts_hvx_CallbackCalls = 0;
+  Mock.sd_ble_gatts_service_changed_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gatts_service_changed_CallbackCalls = 0;
+  Mock.sd_ble_gatts_rw_authorize_reply_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gatts_rw_authorize_reply_CallbackCalls = 0;
+  Mock.sd_ble_gatts_sys_attr_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gatts_sys_attr_set_CallbackCalls = 0;
+  Mock.sd_ble_gatts_sys_attr_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gatts_sys_attr_get_CallbackCalls = 0;
+  Mock.sd_ble_gatts_initial_user_handle_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gatts_initial_user_handle_get_CallbackCalls = 0;
+  Mock.sd_ble_gatts_attr_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gatts_attr_get_CallbackCalls = 0;
+  Mock.sd_ble_gatts_exchange_mtu_reply_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gatts_exchange_mtu_reply_CallbackCalls = 0;
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+uint32_t sd_ble_gatts_service_add(uint8_t type, ble_uuid_t const* p_uuid, uint16_t* p_handle)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gatts_service_add_CallInstance);
+  Mock.sd_ble_gatts_service_add_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gatts_service_add_CallInstance);
+  if (Mock.sd_ble_gatts_service_add_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gatts_service_add_FinalReturn;
+    Mock.sd_ble_gatts_service_add_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gatts_service_add_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gatts_service_add_CallbackFunctionPointer(type, p_uuid, p_handle, Mock.sd_ble_gatts_service_add_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gatts_service_add' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_service_add' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_service_add' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_type)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_type, type, cmock_line, "Function 'sd_ble_gatts_service_add' called with unexpected value for argument 'type'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_uuid)
+  {
+    if (cmock_call_instance->Expected_p_uuid == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_uuid, cmock_line, "Expected NULL. Function 'sd_ble_gatts_service_add' called with unexpected value for argument 'p_uuid'."); }
+    else if (cmock_call_instance->Expected_p_uuid_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_uuid, p_uuid, cmock_line, "Function 'sd_ble_gatts_service_add' called with unexpected value for argument 'p_uuid'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_uuid), (void*)(p_uuid), sizeof(ble_uuid_t), cmock_call_instance->Expected_p_uuid_Depth, cmock_line, "Function 'sd_ble_gatts_service_add' called with unexpected value for argument 'p_uuid'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_handle)
+  {
+    if (cmock_call_instance->Expected_p_handle == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_handle, cmock_line, "Expected NULL. Function 'sd_ble_gatts_service_add' called with unexpected value for argument 'p_handle'."); }
+    else if (cmock_call_instance->Expected_p_handle_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_handle, p_handle, cmock_line, "Function 'sd_ble_gatts_service_add' called with unexpected value for argument 'p_handle'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_p_handle, p_handle, cmock_call_instance->Expected_p_handle_Depth, cmock_line, "Function 'sd_ble_gatts_service_add' called with unexpected value for argument 'p_handle'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_uuid_Used)
+  {
+    memcpy((void*)p_uuid, (void*)cmock_call_instance->ReturnThruPtr_p_uuid_Val,
+      cmock_call_instance->ReturnThruPtr_p_uuid_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_handle_Used)
+  {
+    memcpy((void*)p_handle, (void*)cmock_call_instance->ReturnThruPtr_p_handle_Val,
+      cmock_call_instance->ReturnThruPtr_p_handle_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gatts_service_add(CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE* cmock_call_instance, uint8_t type, ble_uuid_t const* p_uuid, int p_uuid_Depth, uint16_t* p_handle, int p_handle_Depth)
+{
+  cmock_call_instance->Expected_type = type;
+  cmock_call_instance->IgnoreArg_type = 0;
+  cmock_call_instance->Expected_p_uuid = p_uuid;
+  cmock_call_instance->Expected_p_uuid_Depth = p_uuid_Depth;
+  cmock_call_instance->IgnoreArg_p_uuid = 0;
+  cmock_call_instance->ReturnThruPtr_p_uuid_Used = 0;
+  cmock_call_instance->Expected_p_handle = p_handle;
+  cmock_call_instance->Expected_p_handle_Depth = p_handle_Depth;
+  cmock_call_instance->IgnoreArg_p_handle = 0;
+  cmock_call_instance->ReturnThruPtr_p_handle_Used = 0;
+}
+
+void sd_ble_gatts_service_add_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_service_add_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_service_add_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gatts_service_add_IgnoreBool = (int)1;
+}
+
+void sd_ble_gatts_service_add_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t type, ble_uuid_t const* p_uuid, uint16_t* p_handle, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_service_add_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_service_add_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_service_add(cmock_call_instance, type, p_uuid, 0, p_handle, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_service_add_StubWithCallback(CMOCK_sd_ble_gatts_service_add_CALLBACK Callback)
+{
+  Mock.sd_ble_gatts_service_add_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gatts_service_add_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t type, ble_uuid_t const* p_uuid, int p_uuid_Depth, uint16_t* p_handle, int p_handle_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_service_add_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_service_add_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_service_add(cmock_call_instance, type, p_uuid, p_uuid_Depth, p_handle, p_handle_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_service_add_CMockReturnMemThruPtr_p_uuid(UNITY_LINE_TYPE cmock_line, ble_uuid_t const* p_uuid, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_service_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid ReturnThruPtr called before Expect on 'sd_ble_gatts_service_add'.");
+  cmock_call_instance->ReturnThruPtr_p_uuid_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_uuid_Val = p_uuid;
+  cmock_call_instance->ReturnThruPtr_p_uuid_Size = cmock_size;
+}
+
+void sd_ble_gatts_service_add_CMockReturnMemThruPtr_p_handle(UNITY_LINE_TYPE cmock_line, uint16_t* p_handle, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_service_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handle ReturnThruPtr called before Expect on 'sd_ble_gatts_service_add'.");
+  cmock_call_instance->ReturnThruPtr_p_handle_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_handle_Val = p_handle;
+  cmock_call_instance->ReturnThruPtr_p_handle_Size = cmock_size;
+}
+
+void sd_ble_gatts_service_add_CMockIgnoreArg_type(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_service_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "type IgnoreArg called before Expect on 'sd_ble_gatts_service_add'.");
+  cmock_call_instance->IgnoreArg_type = 1;
+}
+
+void sd_ble_gatts_service_add_CMockIgnoreArg_p_uuid(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_service_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid IgnoreArg called before Expect on 'sd_ble_gatts_service_add'.");
+  cmock_call_instance->IgnoreArg_p_uuid = 1;
+}
+
+void sd_ble_gatts_service_add_CMockIgnoreArg_p_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_service_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_service_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handle IgnoreArg called before Expect on 'sd_ble_gatts_service_add'.");
+  cmock_call_instance->IgnoreArg_p_handle = 1;
+}
+
+uint32_t sd_ble_gatts_include_add(uint16_t service_handle, uint16_t inc_srvc_handle, uint16_t* p_include_handle)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gatts_include_add_CallInstance);
+  Mock.sd_ble_gatts_include_add_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gatts_include_add_CallInstance);
+  if (Mock.sd_ble_gatts_include_add_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gatts_include_add_FinalReturn;
+    Mock.sd_ble_gatts_include_add_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gatts_include_add_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gatts_include_add_CallbackFunctionPointer(service_handle, inc_srvc_handle, p_include_handle, Mock.sd_ble_gatts_include_add_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gatts_include_add' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_include_add' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_include_add' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_service_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_service_handle, service_handle, cmock_line, "Function 'sd_ble_gatts_include_add' called with unexpected value for argument 'service_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_inc_srvc_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_inc_srvc_handle, inc_srvc_handle, cmock_line, "Function 'sd_ble_gatts_include_add' called with unexpected value for argument 'inc_srvc_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_include_handle)
+  {
+    if (cmock_call_instance->Expected_p_include_handle == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_include_handle, cmock_line, "Expected NULL. Function 'sd_ble_gatts_include_add' called with unexpected value for argument 'p_include_handle'."); }
+    else if (cmock_call_instance->Expected_p_include_handle_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_include_handle, p_include_handle, cmock_line, "Function 'sd_ble_gatts_include_add' called with unexpected value for argument 'p_include_handle'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_p_include_handle, p_include_handle, cmock_call_instance->Expected_p_include_handle_Depth, cmock_line, "Function 'sd_ble_gatts_include_add' called with unexpected value for argument 'p_include_handle'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_include_handle_Used)
+  {
+    memcpy((void*)p_include_handle, (void*)cmock_call_instance->ReturnThruPtr_p_include_handle_Val,
+      cmock_call_instance->ReturnThruPtr_p_include_handle_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gatts_include_add(CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE* cmock_call_instance, uint16_t service_handle, uint16_t inc_srvc_handle, uint16_t* p_include_handle, int p_include_handle_Depth)
+{
+  cmock_call_instance->Expected_service_handle = service_handle;
+  cmock_call_instance->IgnoreArg_service_handle = 0;
+  cmock_call_instance->Expected_inc_srvc_handle = inc_srvc_handle;
+  cmock_call_instance->IgnoreArg_inc_srvc_handle = 0;
+  cmock_call_instance->Expected_p_include_handle = p_include_handle;
+  cmock_call_instance->Expected_p_include_handle_Depth = p_include_handle_Depth;
+  cmock_call_instance->IgnoreArg_p_include_handle = 0;
+  cmock_call_instance->ReturnThruPtr_p_include_handle_Used = 0;
+}
+
+void sd_ble_gatts_include_add_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_include_add_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_include_add_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gatts_include_add_IgnoreBool = (int)1;
+}
+
+void sd_ble_gatts_include_add_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t service_handle, uint16_t inc_srvc_handle, uint16_t* p_include_handle, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_include_add_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_include_add_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_include_add(cmock_call_instance, service_handle, inc_srvc_handle, p_include_handle, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_include_add_StubWithCallback(CMOCK_sd_ble_gatts_include_add_CALLBACK Callback)
+{
+  Mock.sd_ble_gatts_include_add_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gatts_include_add_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t service_handle, uint16_t inc_srvc_handle, uint16_t* p_include_handle, int p_include_handle_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_include_add_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_include_add_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_include_add(cmock_call_instance, service_handle, inc_srvc_handle, p_include_handle, p_include_handle_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_include_add_CMockReturnMemThruPtr_p_include_handle(UNITY_LINE_TYPE cmock_line, uint16_t* p_include_handle, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_include_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_include_handle ReturnThruPtr called before Expect on 'sd_ble_gatts_include_add'.");
+  cmock_call_instance->ReturnThruPtr_p_include_handle_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_include_handle_Val = p_include_handle;
+  cmock_call_instance->ReturnThruPtr_p_include_handle_Size = cmock_size;
+}
+
+void sd_ble_gatts_include_add_CMockIgnoreArg_service_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_include_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "service_handle IgnoreArg called before Expect on 'sd_ble_gatts_include_add'.");
+  cmock_call_instance->IgnoreArg_service_handle = 1;
+}
+
+void sd_ble_gatts_include_add_CMockIgnoreArg_inc_srvc_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_include_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "inc_srvc_handle IgnoreArg called before Expect on 'sd_ble_gatts_include_add'.");
+  cmock_call_instance->IgnoreArg_inc_srvc_handle = 1;
+}
+
+void sd_ble_gatts_include_add_CMockIgnoreArg_p_include_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_include_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_include_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_include_handle IgnoreArg called before Expect on 'sd_ble_gatts_include_add'.");
+  cmock_call_instance->IgnoreArg_p_include_handle = 1;
+}
+
+uint32_t sd_ble_gatts_characteristic_add(uint16_t service_handle, ble_gatts_char_md_t const* p_char_md, ble_gatts_attr_t const* p_attr_char_value, ble_gatts_char_handles_t* p_handles)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gatts_characteristic_add_CallInstance);
+  Mock.sd_ble_gatts_characteristic_add_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gatts_characteristic_add_CallInstance);
+  if (Mock.sd_ble_gatts_characteristic_add_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gatts_characteristic_add_FinalReturn;
+    Mock.sd_ble_gatts_characteristic_add_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gatts_characteristic_add_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gatts_characteristic_add_CallbackFunctionPointer(service_handle, p_char_md, p_attr_char_value, p_handles, Mock.sd_ble_gatts_characteristic_add_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gatts_characteristic_add' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_characteristic_add' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_characteristic_add' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_service_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_service_handle, service_handle, cmock_line, "Function 'sd_ble_gatts_characteristic_add' called with unexpected value for argument 'service_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_char_md)
+  {
+    if (cmock_call_instance->Expected_p_char_md == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_char_md, cmock_line, "Expected NULL. Function 'sd_ble_gatts_characteristic_add' called with unexpected value for argument 'p_char_md'."); }
+    else if (cmock_call_instance->Expected_p_char_md_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_char_md, p_char_md, cmock_line, "Function 'sd_ble_gatts_characteristic_add' called with unexpected value for argument 'p_char_md'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_char_md), (void*)(p_char_md), sizeof(ble_gatts_char_md_t), cmock_call_instance->Expected_p_char_md_Depth, cmock_line, "Function 'sd_ble_gatts_characteristic_add' called with unexpected value for argument 'p_char_md'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_attr_char_value)
+  {
+    if (cmock_call_instance->Expected_p_attr_char_value == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_attr_char_value, cmock_line, "Expected NULL. Function 'sd_ble_gatts_characteristic_add' called with unexpected value for argument 'p_attr_char_value'."); }
+    else if (cmock_call_instance->Expected_p_attr_char_value_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_attr_char_value, p_attr_char_value, cmock_line, "Function 'sd_ble_gatts_characteristic_add' called with unexpected value for argument 'p_attr_char_value'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_attr_char_value), (void*)(p_attr_char_value), sizeof(ble_gatts_attr_t), cmock_call_instance->Expected_p_attr_char_value_Depth, cmock_line, "Function 'sd_ble_gatts_characteristic_add' called with unexpected value for argument 'p_attr_char_value'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_handles)
+  {
+    if (cmock_call_instance->Expected_p_handles == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_handles, cmock_line, "Expected NULL. Function 'sd_ble_gatts_characteristic_add' called with unexpected value for argument 'p_handles'."); }
+    else if (cmock_call_instance->Expected_p_handles_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_handles, p_handles, cmock_line, "Function 'sd_ble_gatts_characteristic_add' called with unexpected value for argument 'p_handles'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_handles), (void*)(p_handles), sizeof(ble_gatts_char_handles_t), cmock_call_instance->Expected_p_handles_Depth, cmock_line, "Function 'sd_ble_gatts_characteristic_add' called with unexpected value for argument 'p_handles'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_char_md_Used)
+  {
+    memcpy((void*)p_char_md, (void*)cmock_call_instance->ReturnThruPtr_p_char_md_Val,
+      cmock_call_instance->ReturnThruPtr_p_char_md_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_attr_char_value_Used)
+  {
+    memcpy((void*)p_attr_char_value, (void*)cmock_call_instance->ReturnThruPtr_p_attr_char_value_Val,
+      cmock_call_instance->ReturnThruPtr_p_attr_char_value_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_handles_Used)
+  {
+    memcpy((void*)p_handles, (void*)cmock_call_instance->ReturnThruPtr_p_handles_Val,
+      cmock_call_instance->ReturnThruPtr_p_handles_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gatts_characteristic_add(CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE* cmock_call_instance, uint16_t service_handle, ble_gatts_char_md_t const* p_char_md, int p_char_md_Depth, ble_gatts_attr_t const* p_attr_char_value, int p_attr_char_value_Depth, ble_gatts_char_handles_t* p_handles, int p_handles_Depth)
+{
+  cmock_call_instance->Expected_service_handle = service_handle;
+  cmock_call_instance->IgnoreArg_service_handle = 0;
+  cmock_call_instance->Expected_p_char_md = p_char_md;
+  cmock_call_instance->Expected_p_char_md_Depth = p_char_md_Depth;
+  cmock_call_instance->IgnoreArg_p_char_md = 0;
+  cmock_call_instance->ReturnThruPtr_p_char_md_Used = 0;
+  cmock_call_instance->Expected_p_attr_char_value = p_attr_char_value;
+  cmock_call_instance->Expected_p_attr_char_value_Depth = p_attr_char_value_Depth;
+  cmock_call_instance->IgnoreArg_p_attr_char_value = 0;
+  cmock_call_instance->ReturnThruPtr_p_attr_char_value_Used = 0;
+  cmock_call_instance->Expected_p_handles = p_handles;
+  cmock_call_instance->Expected_p_handles_Depth = p_handles_Depth;
+  cmock_call_instance->IgnoreArg_p_handles = 0;
+  cmock_call_instance->ReturnThruPtr_p_handles_Used = 0;
+}
+
+void sd_ble_gatts_characteristic_add_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_characteristic_add_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_characteristic_add_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gatts_characteristic_add_IgnoreBool = (int)1;
+}
+
+void sd_ble_gatts_characteristic_add_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t service_handle, ble_gatts_char_md_t const* p_char_md, ble_gatts_attr_t const* p_attr_char_value, ble_gatts_char_handles_t* p_handles, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_characteristic_add_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_characteristic_add_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_characteristic_add(cmock_call_instance, service_handle, p_char_md, 0, p_attr_char_value, 0, p_handles, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_characteristic_add_StubWithCallback(CMOCK_sd_ble_gatts_characteristic_add_CALLBACK Callback)
+{
+  Mock.sd_ble_gatts_characteristic_add_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gatts_characteristic_add_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t service_handle, ble_gatts_char_md_t const* p_char_md, int p_char_md_Depth, ble_gatts_attr_t const* p_attr_char_value, int p_attr_char_value_Depth, ble_gatts_char_handles_t* p_handles, int p_handles_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_characteristic_add_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_characteristic_add_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_characteristic_add(cmock_call_instance, service_handle, p_char_md, p_char_md_Depth, p_attr_char_value, p_attr_char_value_Depth, p_handles, p_handles_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_characteristic_add_CMockReturnMemThruPtr_p_char_md(UNITY_LINE_TYPE cmock_line, ble_gatts_char_md_t const* p_char_md, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_characteristic_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_char_md ReturnThruPtr called before Expect on 'sd_ble_gatts_characteristic_add'.");
+  cmock_call_instance->ReturnThruPtr_p_char_md_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_char_md_Val = p_char_md;
+  cmock_call_instance->ReturnThruPtr_p_char_md_Size = cmock_size;
+}
+
+void sd_ble_gatts_characteristic_add_CMockReturnMemThruPtr_p_attr_char_value(UNITY_LINE_TYPE cmock_line, ble_gatts_attr_t const* p_attr_char_value, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_characteristic_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_attr_char_value ReturnThruPtr called before Expect on 'sd_ble_gatts_characteristic_add'.");
+  cmock_call_instance->ReturnThruPtr_p_attr_char_value_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_attr_char_value_Val = p_attr_char_value;
+  cmock_call_instance->ReturnThruPtr_p_attr_char_value_Size = cmock_size;
+}
+
+void sd_ble_gatts_characteristic_add_CMockReturnMemThruPtr_p_handles(UNITY_LINE_TYPE cmock_line, ble_gatts_char_handles_t* p_handles, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_characteristic_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handles ReturnThruPtr called before Expect on 'sd_ble_gatts_characteristic_add'.");
+  cmock_call_instance->ReturnThruPtr_p_handles_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_handles_Val = p_handles;
+  cmock_call_instance->ReturnThruPtr_p_handles_Size = cmock_size;
+}
+
+void sd_ble_gatts_characteristic_add_CMockIgnoreArg_service_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_characteristic_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "service_handle IgnoreArg called before Expect on 'sd_ble_gatts_characteristic_add'.");
+  cmock_call_instance->IgnoreArg_service_handle = 1;
+}
+
+void sd_ble_gatts_characteristic_add_CMockIgnoreArg_p_char_md(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_characteristic_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_char_md IgnoreArg called before Expect on 'sd_ble_gatts_characteristic_add'.");
+  cmock_call_instance->IgnoreArg_p_char_md = 1;
+}
+
+void sd_ble_gatts_characteristic_add_CMockIgnoreArg_p_attr_char_value(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_characteristic_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_attr_char_value IgnoreArg called before Expect on 'sd_ble_gatts_characteristic_add'.");
+  cmock_call_instance->IgnoreArg_p_attr_char_value = 1;
+}
+
+void sd_ble_gatts_characteristic_add_CMockIgnoreArg_p_handles(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_characteristic_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_characteristic_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handles IgnoreArg called before Expect on 'sd_ble_gatts_characteristic_add'.");
+  cmock_call_instance->IgnoreArg_p_handles = 1;
+}
+
+uint32_t sd_ble_gatts_descriptor_add(uint16_t char_handle, ble_gatts_attr_t const* p_attr, uint16_t* p_handle)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gatts_descriptor_add_CallInstance);
+  Mock.sd_ble_gatts_descriptor_add_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gatts_descriptor_add_CallInstance);
+  if (Mock.sd_ble_gatts_descriptor_add_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gatts_descriptor_add_FinalReturn;
+    Mock.sd_ble_gatts_descriptor_add_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gatts_descriptor_add_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gatts_descriptor_add_CallbackFunctionPointer(char_handle, p_attr, p_handle, Mock.sd_ble_gatts_descriptor_add_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gatts_descriptor_add' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_descriptor_add' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_descriptor_add' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_char_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_char_handle, char_handle, cmock_line, "Function 'sd_ble_gatts_descriptor_add' called with unexpected value for argument 'char_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_attr)
+  {
+    if (cmock_call_instance->Expected_p_attr == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_attr, cmock_line, "Expected NULL. Function 'sd_ble_gatts_descriptor_add' called with unexpected value for argument 'p_attr'."); }
+    else if (cmock_call_instance->Expected_p_attr_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_attr, p_attr, cmock_line, "Function 'sd_ble_gatts_descriptor_add' called with unexpected value for argument 'p_attr'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_attr), (void*)(p_attr), sizeof(ble_gatts_attr_t), cmock_call_instance->Expected_p_attr_Depth, cmock_line, "Function 'sd_ble_gatts_descriptor_add' called with unexpected value for argument 'p_attr'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_handle)
+  {
+    if (cmock_call_instance->Expected_p_handle == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_handle, cmock_line, "Expected NULL. Function 'sd_ble_gatts_descriptor_add' called with unexpected value for argument 'p_handle'."); }
+    else if (cmock_call_instance->Expected_p_handle_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_handle, p_handle, cmock_line, "Function 'sd_ble_gatts_descriptor_add' called with unexpected value for argument 'p_handle'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_p_handle, p_handle, cmock_call_instance->Expected_p_handle_Depth, cmock_line, "Function 'sd_ble_gatts_descriptor_add' called with unexpected value for argument 'p_handle'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_attr_Used)
+  {
+    memcpy((void*)p_attr, (void*)cmock_call_instance->ReturnThruPtr_p_attr_Val,
+      cmock_call_instance->ReturnThruPtr_p_attr_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_handle_Used)
+  {
+    memcpy((void*)p_handle, (void*)cmock_call_instance->ReturnThruPtr_p_handle_Val,
+      cmock_call_instance->ReturnThruPtr_p_handle_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gatts_descriptor_add(CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE* cmock_call_instance, uint16_t char_handle, ble_gatts_attr_t const* p_attr, int p_attr_Depth, uint16_t* p_handle, int p_handle_Depth)
+{
+  cmock_call_instance->Expected_char_handle = char_handle;
+  cmock_call_instance->IgnoreArg_char_handle = 0;
+  cmock_call_instance->Expected_p_attr = p_attr;
+  cmock_call_instance->Expected_p_attr_Depth = p_attr_Depth;
+  cmock_call_instance->IgnoreArg_p_attr = 0;
+  cmock_call_instance->ReturnThruPtr_p_attr_Used = 0;
+  cmock_call_instance->Expected_p_handle = p_handle;
+  cmock_call_instance->Expected_p_handle_Depth = p_handle_Depth;
+  cmock_call_instance->IgnoreArg_p_handle = 0;
+  cmock_call_instance->ReturnThruPtr_p_handle_Used = 0;
+}
+
+void sd_ble_gatts_descriptor_add_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_descriptor_add_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_descriptor_add_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gatts_descriptor_add_IgnoreBool = (int)1;
+}
+
+void sd_ble_gatts_descriptor_add_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t char_handle, ble_gatts_attr_t const* p_attr, uint16_t* p_handle, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_descriptor_add_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_descriptor_add_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_descriptor_add(cmock_call_instance, char_handle, p_attr, 0, p_handle, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_descriptor_add_StubWithCallback(CMOCK_sd_ble_gatts_descriptor_add_CALLBACK Callback)
+{
+  Mock.sd_ble_gatts_descriptor_add_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gatts_descriptor_add_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t char_handle, ble_gatts_attr_t const* p_attr, int p_attr_Depth, uint16_t* p_handle, int p_handle_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_descriptor_add_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_descriptor_add_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_descriptor_add(cmock_call_instance, char_handle, p_attr, p_attr_Depth, p_handle, p_handle_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_descriptor_add_CMockReturnMemThruPtr_p_attr(UNITY_LINE_TYPE cmock_line, ble_gatts_attr_t const* p_attr, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_descriptor_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_attr ReturnThruPtr called before Expect on 'sd_ble_gatts_descriptor_add'.");
+  cmock_call_instance->ReturnThruPtr_p_attr_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_attr_Val = p_attr;
+  cmock_call_instance->ReturnThruPtr_p_attr_Size = cmock_size;
+}
+
+void sd_ble_gatts_descriptor_add_CMockReturnMemThruPtr_p_handle(UNITY_LINE_TYPE cmock_line, uint16_t* p_handle, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_descriptor_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handle ReturnThruPtr called before Expect on 'sd_ble_gatts_descriptor_add'.");
+  cmock_call_instance->ReturnThruPtr_p_handle_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_handle_Val = p_handle;
+  cmock_call_instance->ReturnThruPtr_p_handle_Size = cmock_size;
+}
+
+void sd_ble_gatts_descriptor_add_CMockIgnoreArg_char_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_descriptor_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "char_handle IgnoreArg called before Expect on 'sd_ble_gatts_descriptor_add'.");
+  cmock_call_instance->IgnoreArg_char_handle = 1;
+}
+
+void sd_ble_gatts_descriptor_add_CMockIgnoreArg_p_attr(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_descriptor_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_attr IgnoreArg called before Expect on 'sd_ble_gatts_descriptor_add'.");
+  cmock_call_instance->IgnoreArg_p_attr = 1;
+}
+
+void sd_ble_gatts_descriptor_add_CMockIgnoreArg_p_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_descriptor_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_descriptor_add_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handle IgnoreArg called before Expect on 'sd_ble_gatts_descriptor_add'.");
+  cmock_call_instance->IgnoreArg_p_handle = 1;
+}
+
+uint32_t sd_ble_gatts_value_set(uint16_t conn_handle, uint16_t handle, ble_gatts_value_t* p_value)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gatts_value_set_CallInstance);
+  Mock.sd_ble_gatts_value_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gatts_value_set_CallInstance);
+  if (Mock.sd_ble_gatts_value_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gatts_value_set_FinalReturn;
+    Mock.sd_ble_gatts_value_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gatts_value_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gatts_value_set_CallbackFunctionPointer(conn_handle, handle, p_value, Mock.sd_ble_gatts_value_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gatts_value_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_value_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_value_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gatts_value_set' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_handle, handle, cmock_line, "Function 'sd_ble_gatts_value_set' called with unexpected value for argument 'handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_value)
+  {
+    if (cmock_call_instance->Expected_p_value == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_value, cmock_line, "Expected NULL. Function 'sd_ble_gatts_value_set' called with unexpected value for argument 'p_value'."); }
+    else if (cmock_call_instance->Expected_p_value_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_value, p_value, cmock_line, "Function 'sd_ble_gatts_value_set' called with unexpected value for argument 'p_value'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_value), (void*)(p_value), sizeof(ble_gatts_value_t), cmock_call_instance->Expected_p_value_Depth, cmock_line, "Function 'sd_ble_gatts_value_set' called with unexpected value for argument 'p_value'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_value_Used)
+  {
+    memcpy((void*)p_value, (void*)cmock_call_instance->ReturnThruPtr_p_value_Val,
+      cmock_call_instance->ReturnThruPtr_p_value_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gatts_value_set(CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint16_t handle, ble_gatts_value_t* p_value, int p_value_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_handle = handle;
+  cmock_call_instance->IgnoreArg_handle = 0;
+  cmock_call_instance->Expected_p_value = p_value;
+  cmock_call_instance->Expected_p_value_Depth = p_value_Depth;
+  cmock_call_instance->IgnoreArg_p_value = 0;
+  cmock_call_instance->ReturnThruPtr_p_value_Used = 0;
+}
+
+void sd_ble_gatts_value_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_value_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_value_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gatts_value_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gatts_value_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t handle, ble_gatts_value_t* p_value, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_value_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_value_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_value_set(cmock_call_instance, conn_handle, handle, p_value, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_value_set_StubWithCallback(CMOCK_sd_ble_gatts_value_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gatts_value_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gatts_value_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t handle, ble_gatts_value_t* p_value, int p_value_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_value_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_value_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_value_set(cmock_call_instance, conn_handle, handle, p_value, p_value_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_value_set_CMockReturnMemThruPtr_p_value(UNITY_LINE_TYPE cmock_line, ble_gatts_value_t* p_value, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_value_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_value ReturnThruPtr called before Expect on 'sd_ble_gatts_value_set'.");
+  cmock_call_instance->ReturnThruPtr_p_value_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_value_Val = p_value;
+  cmock_call_instance->ReturnThruPtr_p_value_Size = cmock_size;
+}
+
+void sd_ble_gatts_value_set_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_value_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gatts_value_set'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gatts_value_set_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_value_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "handle IgnoreArg called before Expect on 'sd_ble_gatts_value_set'.");
+  cmock_call_instance->IgnoreArg_handle = 1;
+}
+
+void sd_ble_gatts_value_set_CMockIgnoreArg_p_value(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_value_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_value_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_value IgnoreArg called before Expect on 'sd_ble_gatts_value_set'.");
+  cmock_call_instance->IgnoreArg_p_value = 1;
+}
+
+uint32_t sd_ble_gatts_value_get(uint16_t conn_handle, uint16_t handle, ble_gatts_value_t* p_value)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gatts_value_get_CallInstance);
+  Mock.sd_ble_gatts_value_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gatts_value_get_CallInstance);
+  if (Mock.sd_ble_gatts_value_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gatts_value_get_FinalReturn;
+    Mock.sd_ble_gatts_value_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gatts_value_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gatts_value_get_CallbackFunctionPointer(conn_handle, handle, p_value, Mock.sd_ble_gatts_value_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gatts_value_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_value_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_value_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gatts_value_get' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_handle, handle, cmock_line, "Function 'sd_ble_gatts_value_get' called with unexpected value for argument 'handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_value)
+  {
+    if (cmock_call_instance->Expected_p_value == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_value, cmock_line, "Expected NULL. Function 'sd_ble_gatts_value_get' called with unexpected value for argument 'p_value'."); }
+    else if (cmock_call_instance->Expected_p_value_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_value, p_value, cmock_line, "Function 'sd_ble_gatts_value_get' called with unexpected value for argument 'p_value'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_value), (void*)(p_value), sizeof(ble_gatts_value_t), cmock_call_instance->Expected_p_value_Depth, cmock_line, "Function 'sd_ble_gatts_value_get' called with unexpected value for argument 'p_value'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_value_Used)
+  {
+    memcpy((void*)p_value, (void*)cmock_call_instance->ReturnThruPtr_p_value_Val,
+      cmock_call_instance->ReturnThruPtr_p_value_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gatts_value_get(CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint16_t handle, ble_gatts_value_t* p_value, int p_value_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_handle = handle;
+  cmock_call_instance->IgnoreArg_handle = 0;
+  cmock_call_instance->Expected_p_value = p_value;
+  cmock_call_instance->Expected_p_value_Depth = p_value_Depth;
+  cmock_call_instance->IgnoreArg_p_value = 0;
+  cmock_call_instance->ReturnThruPtr_p_value_Used = 0;
+}
+
+void sd_ble_gatts_value_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_value_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_value_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gatts_value_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gatts_value_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t handle, ble_gatts_value_t* p_value, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_value_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_value_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_value_get(cmock_call_instance, conn_handle, handle, p_value, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_value_get_StubWithCallback(CMOCK_sd_ble_gatts_value_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gatts_value_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gatts_value_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t handle, ble_gatts_value_t* p_value, int p_value_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_value_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_value_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_value_get(cmock_call_instance, conn_handle, handle, p_value, p_value_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_value_get_CMockReturnMemThruPtr_p_value(UNITY_LINE_TYPE cmock_line, ble_gatts_value_t* p_value, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_value_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_value ReturnThruPtr called before Expect on 'sd_ble_gatts_value_get'.");
+  cmock_call_instance->ReturnThruPtr_p_value_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_value_Val = p_value;
+  cmock_call_instance->ReturnThruPtr_p_value_Size = cmock_size;
+}
+
+void sd_ble_gatts_value_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_value_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gatts_value_get'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gatts_value_get_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_value_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "handle IgnoreArg called before Expect on 'sd_ble_gatts_value_get'.");
+  cmock_call_instance->IgnoreArg_handle = 1;
+}
+
+void sd_ble_gatts_value_get_CMockIgnoreArg_p_value(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_value_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_value_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_value IgnoreArg called before Expect on 'sd_ble_gatts_value_get'.");
+  cmock_call_instance->IgnoreArg_p_value = 1;
+}
+
+uint32_t sd_ble_gatts_hvx(uint16_t conn_handle, ble_gatts_hvx_params_t const* p_hvx_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gatts_hvx_CallInstance);
+  Mock.sd_ble_gatts_hvx_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gatts_hvx_CallInstance);
+  if (Mock.sd_ble_gatts_hvx_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gatts_hvx_FinalReturn;
+    Mock.sd_ble_gatts_hvx_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gatts_hvx_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gatts_hvx_CallbackFunctionPointer(conn_handle, p_hvx_params, Mock.sd_ble_gatts_hvx_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gatts_hvx' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_hvx' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_hvx' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gatts_hvx' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_hvx_params)
+  {
+    if (cmock_call_instance->Expected_p_hvx_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_hvx_params, cmock_line, "Expected NULL. Function 'sd_ble_gatts_hvx' called with unexpected value for argument 'p_hvx_params'."); }
+    else if (cmock_call_instance->Expected_p_hvx_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_hvx_params, p_hvx_params, cmock_line, "Function 'sd_ble_gatts_hvx' called with unexpected value for argument 'p_hvx_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_hvx_params), (void*)(p_hvx_params), sizeof(ble_gatts_hvx_params_t), cmock_call_instance->Expected_p_hvx_params_Depth, cmock_line, "Function 'sd_ble_gatts_hvx' called with unexpected value for argument 'p_hvx_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_hvx_params_Used)
+  {
+    memcpy((void*)p_hvx_params, (void*)cmock_call_instance->ReturnThruPtr_p_hvx_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_hvx_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gatts_hvx(CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gatts_hvx_params_t const* p_hvx_params, int p_hvx_params_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_hvx_params = p_hvx_params;
+  cmock_call_instance->Expected_p_hvx_params_Depth = p_hvx_params_Depth;
+  cmock_call_instance->IgnoreArg_p_hvx_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_hvx_params_Used = 0;
+}
+
+void sd_ble_gatts_hvx_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_hvx_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_hvx_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gatts_hvx_IgnoreBool = (int)1;
+}
+
+void sd_ble_gatts_hvx_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gatts_hvx_params_t const* p_hvx_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_hvx_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_hvx_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_hvx(cmock_call_instance, conn_handle, p_hvx_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_hvx_StubWithCallback(CMOCK_sd_ble_gatts_hvx_CALLBACK Callback)
+{
+  Mock.sd_ble_gatts_hvx_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gatts_hvx_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gatts_hvx_params_t const* p_hvx_params, int p_hvx_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_hvx_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_hvx_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_hvx(cmock_call_instance, conn_handle, p_hvx_params, p_hvx_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_hvx_CMockReturnMemThruPtr_p_hvx_params(UNITY_LINE_TYPE cmock_line, ble_gatts_hvx_params_t const* p_hvx_params, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_hvx_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_hvx_params ReturnThruPtr called before Expect on 'sd_ble_gatts_hvx'.");
+  cmock_call_instance->ReturnThruPtr_p_hvx_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_hvx_params_Val = p_hvx_params;
+  cmock_call_instance->ReturnThruPtr_p_hvx_params_Size = cmock_size;
+}
+
+void sd_ble_gatts_hvx_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_hvx_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gatts_hvx'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gatts_hvx_CMockIgnoreArg_p_hvx_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_hvx_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_hvx_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_hvx_params IgnoreArg called before Expect on 'sd_ble_gatts_hvx'.");
+  cmock_call_instance->IgnoreArg_p_hvx_params = 1;
+}
+
+uint32_t sd_ble_gatts_service_changed(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gatts_service_changed_CallInstance);
+  Mock.sd_ble_gatts_service_changed_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gatts_service_changed_CallInstance);
+  if (Mock.sd_ble_gatts_service_changed_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gatts_service_changed_FinalReturn;
+    Mock.sd_ble_gatts_service_changed_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gatts_service_changed_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gatts_service_changed_CallbackFunctionPointer(conn_handle, start_handle, end_handle, Mock.sd_ble_gatts_service_changed_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gatts_service_changed' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_service_changed' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_service_changed' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gatts_service_changed' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_start_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_start_handle, start_handle, cmock_line, "Function 'sd_ble_gatts_service_changed' called with unexpected value for argument 'start_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_end_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_end_handle, end_handle, cmock_line, "Function 'sd_ble_gatts_service_changed' called with unexpected value for argument 'end_handle'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gatts_service_changed(CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_start_handle = start_handle;
+  cmock_call_instance->IgnoreArg_start_handle = 0;
+  cmock_call_instance->Expected_end_handle = end_handle;
+  cmock_call_instance->IgnoreArg_end_handle = 0;
+}
+
+void sd_ble_gatts_service_changed_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_service_changed_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_service_changed_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gatts_service_changed_IgnoreBool = (int)1;
+}
+
+void sd_ble_gatts_service_changed_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_service_changed_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_service_changed_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_service_changed(cmock_call_instance, conn_handle, start_handle, end_handle);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_service_changed_StubWithCallback(CMOCK_sd_ble_gatts_service_changed_CALLBACK Callback)
+{
+  Mock.sd_ble_gatts_service_changed_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gatts_service_changed_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_service_changed_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gatts_service_changed'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gatts_service_changed_CMockIgnoreArg_start_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_service_changed_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "start_handle IgnoreArg called before Expect on 'sd_ble_gatts_service_changed'.");
+  cmock_call_instance->IgnoreArg_start_handle = 1;
+}
+
+void sd_ble_gatts_service_changed_CMockIgnoreArg_end_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_service_changed_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_service_changed_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "end_handle IgnoreArg called before Expect on 'sd_ble_gatts_service_changed'.");
+  cmock_call_instance->IgnoreArg_end_handle = 1;
+}
+
+uint32_t sd_ble_gatts_rw_authorize_reply(uint16_t conn_handle, ble_gatts_rw_authorize_reply_params_t const* p_rw_authorize_reply_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gatts_rw_authorize_reply_CallInstance);
+  Mock.sd_ble_gatts_rw_authorize_reply_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gatts_rw_authorize_reply_CallInstance);
+  if (Mock.sd_ble_gatts_rw_authorize_reply_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gatts_rw_authorize_reply_FinalReturn;
+    Mock.sd_ble_gatts_rw_authorize_reply_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gatts_rw_authorize_reply_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gatts_rw_authorize_reply_CallbackFunctionPointer(conn_handle, p_rw_authorize_reply_params, Mock.sd_ble_gatts_rw_authorize_reply_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gatts_rw_authorize_reply' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_rw_authorize_reply' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_rw_authorize_reply' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gatts_rw_authorize_reply' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_rw_authorize_reply_params)
+  {
+    if (cmock_call_instance->Expected_p_rw_authorize_reply_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_rw_authorize_reply_params, cmock_line, "Expected NULL. Function 'sd_ble_gatts_rw_authorize_reply' called with unexpected value for argument 'p_rw_authorize_reply_params'."); }
+    else if (cmock_call_instance->Expected_p_rw_authorize_reply_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_rw_authorize_reply_params, p_rw_authorize_reply_params, cmock_line, "Function 'sd_ble_gatts_rw_authorize_reply' called with unexpected value for argument 'p_rw_authorize_reply_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_rw_authorize_reply_params), (void*)(p_rw_authorize_reply_params), sizeof(ble_gatts_rw_authorize_reply_params_t), cmock_call_instance->Expected_p_rw_authorize_reply_params_Depth, cmock_line, "Function 'sd_ble_gatts_rw_authorize_reply' called with unexpected value for argument 'p_rw_authorize_reply_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_rw_authorize_reply_params_Used)
+  {
+    memcpy((void*)p_rw_authorize_reply_params, (void*)cmock_call_instance->ReturnThruPtr_p_rw_authorize_reply_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_rw_authorize_reply_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gatts_rw_authorize_reply(CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gatts_rw_authorize_reply_params_t const* p_rw_authorize_reply_params, int p_rw_authorize_reply_params_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_rw_authorize_reply_params = p_rw_authorize_reply_params;
+  cmock_call_instance->Expected_p_rw_authorize_reply_params_Depth = p_rw_authorize_reply_params_Depth;
+  cmock_call_instance->IgnoreArg_p_rw_authorize_reply_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_rw_authorize_reply_params_Used = 0;
+}
+
+void sd_ble_gatts_rw_authorize_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_rw_authorize_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_rw_authorize_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gatts_rw_authorize_reply_IgnoreBool = (int)1;
+}
+
+void sd_ble_gatts_rw_authorize_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gatts_rw_authorize_reply_params_t const* p_rw_authorize_reply_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_rw_authorize_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_rw_authorize_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_rw_authorize_reply(cmock_call_instance, conn_handle, p_rw_authorize_reply_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_rw_authorize_reply_StubWithCallback(CMOCK_sd_ble_gatts_rw_authorize_reply_CALLBACK Callback)
+{
+  Mock.sd_ble_gatts_rw_authorize_reply_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gatts_rw_authorize_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gatts_rw_authorize_reply_params_t const* p_rw_authorize_reply_params, int p_rw_authorize_reply_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_rw_authorize_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_rw_authorize_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_rw_authorize_reply(cmock_call_instance, conn_handle, p_rw_authorize_reply_params, p_rw_authorize_reply_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_rw_authorize_reply_CMockReturnMemThruPtr_p_rw_authorize_reply_params(UNITY_LINE_TYPE cmock_line, ble_gatts_rw_authorize_reply_params_t const* p_rw_authorize_reply_params, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_rw_authorize_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_rw_authorize_reply_params ReturnThruPtr called before Expect on 'sd_ble_gatts_rw_authorize_reply'.");
+  cmock_call_instance->ReturnThruPtr_p_rw_authorize_reply_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_rw_authorize_reply_params_Val = p_rw_authorize_reply_params;
+  cmock_call_instance->ReturnThruPtr_p_rw_authorize_reply_params_Size = cmock_size;
+}
+
+void sd_ble_gatts_rw_authorize_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_rw_authorize_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gatts_rw_authorize_reply'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gatts_rw_authorize_reply_CMockIgnoreArg_p_rw_authorize_reply_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_rw_authorize_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_rw_authorize_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_rw_authorize_reply_params IgnoreArg called before Expect on 'sd_ble_gatts_rw_authorize_reply'.");
+  cmock_call_instance->IgnoreArg_p_rw_authorize_reply_params = 1;
+}
+
+uint32_t sd_ble_gatts_sys_attr_set(uint16_t conn_handle, uint8_t const* p_sys_attr_data, uint16_t len, uint32_t flags)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gatts_sys_attr_set_CallInstance);
+  Mock.sd_ble_gatts_sys_attr_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gatts_sys_attr_set_CallInstance);
+  if (Mock.sd_ble_gatts_sys_attr_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gatts_sys_attr_set_FinalReturn;
+    Mock.sd_ble_gatts_sys_attr_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gatts_sys_attr_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gatts_sys_attr_set_CallbackFunctionPointer(conn_handle, p_sys_attr_data, len, flags, Mock.sd_ble_gatts_sys_attr_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gatts_sys_attr_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_sys_attr_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_sys_attr_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gatts_sys_attr_set' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_sys_attr_data)
+  {
+    if (cmock_call_instance->Expected_p_sys_attr_data == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_sys_attr_data, cmock_line, "Expected NULL. Function 'sd_ble_gatts_sys_attr_set' called with unexpected value for argument 'p_sys_attr_data'."); }
+    else if (cmock_call_instance->Expected_p_sys_attr_data_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_sys_attr_data, p_sys_attr_data, cmock_line, "Function 'sd_ble_gatts_sys_attr_set' called with unexpected value for argument 'p_sys_attr_data'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_sys_attr_data, p_sys_attr_data, cmock_call_instance->Expected_p_sys_attr_data_Depth, cmock_line, "Function 'sd_ble_gatts_sys_attr_set' called with unexpected value for argument 'p_sys_attr_data'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_len)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_len, len, cmock_line, "Function 'sd_ble_gatts_sys_attr_set' called with unexpected value for argument 'len'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_flags)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_flags, flags, cmock_line, "Function 'sd_ble_gatts_sys_attr_set' called with unexpected value for argument 'flags'.");
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_sys_attr_data_Used)
+  {
+    memcpy((void*)p_sys_attr_data, (void*)cmock_call_instance->ReturnThruPtr_p_sys_attr_data_Val,
+      cmock_call_instance->ReturnThruPtr_p_sys_attr_data_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gatts_sys_attr_set(CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint8_t const* p_sys_attr_data, int p_sys_attr_data_Depth, uint16_t len, uint32_t flags)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_sys_attr_data = p_sys_attr_data;
+  cmock_call_instance->Expected_p_sys_attr_data_Depth = p_sys_attr_data_Depth;
+  cmock_call_instance->IgnoreArg_p_sys_attr_data = 0;
+  cmock_call_instance->ReturnThruPtr_p_sys_attr_data_Used = 0;
+  cmock_call_instance->Expected_len = len;
+  cmock_call_instance->IgnoreArg_len = 0;
+  cmock_call_instance->Expected_flags = flags;
+  cmock_call_instance->IgnoreArg_flags = 0;
+}
+
+void sd_ble_gatts_sys_attr_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_sys_attr_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_sys_attr_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gatts_sys_attr_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gatts_sys_attr_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t const* p_sys_attr_data, uint16_t len, uint32_t flags, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_sys_attr_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_sys_attr_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_sys_attr_set(cmock_call_instance, conn_handle, p_sys_attr_data, 0, len, flags);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_sys_attr_set_StubWithCallback(CMOCK_sd_ble_gatts_sys_attr_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gatts_sys_attr_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gatts_sys_attr_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t const* p_sys_attr_data, int p_sys_attr_data_Depth, uint16_t len, uint32_t flags, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_sys_attr_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_sys_attr_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_sys_attr_set(cmock_call_instance, conn_handle, p_sys_attr_data, p_sys_attr_data_Depth, len, flags);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_sys_attr_set_CMockReturnMemThruPtr_p_sys_attr_data(UNITY_LINE_TYPE cmock_line, uint8_t const* p_sys_attr_data, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_sys_attr_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sys_attr_data ReturnThruPtr called before Expect on 'sd_ble_gatts_sys_attr_set'.");
+  cmock_call_instance->ReturnThruPtr_p_sys_attr_data_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_sys_attr_data_Val = p_sys_attr_data;
+  cmock_call_instance->ReturnThruPtr_p_sys_attr_data_Size = cmock_size;
+}
+
+void sd_ble_gatts_sys_attr_set_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_sys_attr_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gatts_sys_attr_set'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gatts_sys_attr_set_CMockIgnoreArg_p_sys_attr_data(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_sys_attr_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sys_attr_data IgnoreArg called before Expect on 'sd_ble_gatts_sys_attr_set'.");
+  cmock_call_instance->IgnoreArg_p_sys_attr_data = 1;
+}
+
+void sd_ble_gatts_sys_attr_set_CMockIgnoreArg_len(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_sys_attr_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "len IgnoreArg called before Expect on 'sd_ble_gatts_sys_attr_set'.");
+  cmock_call_instance->IgnoreArg_len = 1;
+}
+
+void sd_ble_gatts_sys_attr_set_CMockIgnoreArg_flags(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_sys_attr_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "flags IgnoreArg called before Expect on 'sd_ble_gatts_sys_attr_set'.");
+  cmock_call_instance->IgnoreArg_flags = 1;
+}
+
+uint32_t sd_ble_gatts_sys_attr_get(uint16_t conn_handle, uint8_t* p_sys_attr_data, uint16_t* p_len, uint32_t flags)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gatts_sys_attr_get_CallInstance);
+  Mock.sd_ble_gatts_sys_attr_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gatts_sys_attr_get_CallInstance);
+  if (Mock.sd_ble_gatts_sys_attr_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gatts_sys_attr_get_FinalReturn;
+    Mock.sd_ble_gatts_sys_attr_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gatts_sys_attr_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gatts_sys_attr_get_CallbackFunctionPointer(conn_handle, p_sys_attr_data, p_len, flags, Mock.sd_ble_gatts_sys_attr_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gatts_sys_attr_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_sys_attr_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_sys_attr_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gatts_sys_attr_get' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_sys_attr_data)
+  {
+    if (cmock_call_instance->Expected_p_sys_attr_data == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_sys_attr_data, cmock_line, "Expected NULL. Function 'sd_ble_gatts_sys_attr_get' called with unexpected value for argument 'p_sys_attr_data'."); }
+    else if (cmock_call_instance->Expected_p_sys_attr_data_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_sys_attr_data, p_sys_attr_data, cmock_line, "Function 'sd_ble_gatts_sys_attr_get' called with unexpected value for argument 'p_sys_attr_data'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_sys_attr_data, p_sys_attr_data, cmock_call_instance->Expected_p_sys_attr_data_Depth, cmock_line, "Function 'sd_ble_gatts_sys_attr_get' called with unexpected value for argument 'p_sys_attr_data'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_len)
+  {
+    if (cmock_call_instance->Expected_p_len == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_len, cmock_line, "Expected NULL. Function 'sd_ble_gatts_sys_attr_get' called with unexpected value for argument 'p_len'."); }
+    else if (cmock_call_instance->Expected_p_len_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_len, p_len, cmock_line, "Function 'sd_ble_gatts_sys_attr_get' called with unexpected value for argument 'p_len'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_p_len, p_len, cmock_call_instance->Expected_p_len_Depth, cmock_line, "Function 'sd_ble_gatts_sys_attr_get' called with unexpected value for argument 'p_len'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_flags)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_flags, flags, cmock_line, "Function 'sd_ble_gatts_sys_attr_get' called with unexpected value for argument 'flags'.");
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_sys_attr_data_Used)
+  {
+    memcpy((void*)p_sys_attr_data, (void*)cmock_call_instance->ReturnThruPtr_p_sys_attr_data_Val,
+      cmock_call_instance->ReturnThruPtr_p_sys_attr_data_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_len_Used)
+  {
+    memcpy((void*)p_len, (void*)cmock_call_instance->ReturnThruPtr_p_len_Val,
+      cmock_call_instance->ReturnThruPtr_p_len_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gatts_sys_attr_get(CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint8_t* p_sys_attr_data, int p_sys_attr_data_Depth, uint16_t* p_len, int p_len_Depth, uint32_t flags)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_sys_attr_data = p_sys_attr_data;
+  cmock_call_instance->Expected_p_sys_attr_data_Depth = p_sys_attr_data_Depth;
+  cmock_call_instance->IgnoreArg_p_sys_attr_data = 0;
+  cmock_call_instance->ReturnThruPtr_p_sys_attr_data_Used = 0;
+  cmock_call_instance->Expected_p_len = p_len;
+  cmock_call_instance->Expected_p_len_Depth = p_len_Depth;
+  cmock_call_instance->IgnoreArg_p_len = 0;
+  cmock_call_instance->ReturnThruPtr_p_len_Used = 0;
+  cmock_call_instance->Expected_flags = flags;
+  cmock_call_instance->IgnoreArg_flags = 0;
+}
+
+void sd_ble_gatts_sys_attr_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_sys_attr_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_sys_attr_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gatts_sys_attr_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gatts_sys_attr_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t* p_sys_attr_data, uint16_t* p_len, uint32_t flags, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_sys_attr_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_sys_attr_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_sys_attr_get(cmock_call_instance, conn_handle, p_sys_attr_data, 0, p_len, 0, flags);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_sys_attr_get_StubWithCallback(CMOCK_sd_ble_gatts_sys_attr_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gatts_sys_attr_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gatts_sys_attr_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t* p_sys_attr_data, int p_sys_attr_data_Depth, uint16_t* p_len, int p_len_Depth, uint32_t flags, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_sys_attr_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_sys_attr_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_sys_attr_get(cmock_call_instance, conn_handle, p_sys_attr_data, p_sys_attr_data_Depth, p_len, p_len_Depth, flags);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_sys_attr_get_CMockReturnMemThruPtr_p_sys_attr_data(UNITY_LINE_TYPE cmock_line, uint8_t* p_sys_attr_data, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_sys_attr_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sys_attr_data ReturnThruPtr called before Expect on 'sd_ble_gatts_sys_attr_get'.");
+  cmock_call_instance->ReturnThruPtr_p_sys_attr_data_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_sys_attr_data_Val = p_sys_attr_data;
+  cmock_call_instance->ReturnThruPtr_p_sys_attr_data_Size = cmock_size;
+}
+
+void sd_ble_gatts_sys_attr_get_CMockReturnMemThruPtr_p_len(UNITY_LINE_TYPE cmock_line, uint16_t* p_len, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_sys_attr_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_len ReturnThruPtr called before Expect on 'sd_ble_gatts_sys_attr_get'.");
+  cmock_call_instance->ReturnThruPtr_p_len_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_len_Val = p_len;
+  cmock_call_instance->ReturnThruPtr_p_len_Size = cmock_size;
+}
+
+void sd_ble_gatts_sys_attr_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_sys_attr_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gatts_sys_attr_get'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gatts_sys_attr_get_CMockIgnoreArg_p_sys_attr_data(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_sys_attr_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sys_attr_data IgnoreArg called before Expect on 'sd_ble_gatts_sys_attr_get'.");
+  cmock_call_instance->IgnoreArg_p_sys_attr_data = 1;
+}
+
+void sd_ble_gatts_sys_attr_get_CMockIgnoreArg_p_len(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_sys_attr_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_len IgnoreArg called before Expect on 'sd_ble_gatts_sys_attr_get'.");
+  cmock_call_instance->IgnoreArg_p_len = 1;
+}
+
+void sd_ble_gatts_sys_attr_get_CMockIgnoreArg_flags(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_sys_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_sys_attr_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "flags IgnoreArg called before Expect on 'sd_ble_gatts_sys_attr_get'.");
+  cmock_call_instance->IgnoreArg_flags = 1;
+}
+
+uint32_t sd_ble_gatts_initial_user_handle_get(uint16_t* p_handle)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gatts_initial_user_handle_get_CallInstance);
+  Mock.sd_ble_gatts_initial_user_handle_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gatts_initial_user_handle_get_CallInstance);
+  if (Mock.sd_ble_gatts_initial_user_handle_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gatts_initial_user_handle_get_FinalReturn;
+    Mock.sd_ble_gatts_initial_user_handle_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gatts_initial_user_handle_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gatts_initial_user_handle_get_CallbackFunctionPointer(p_handle, Mock.sd_ble_gatts_initial_user_handle_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gatts_initial_user_handle_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_initial_user_handle_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_initial_user_handle_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_handle)
+  {
+    if (cmock_call_instance->Expected_p_handle == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_handle, cmock_line, "Expected NULL. Function 'sd_ble_gatts_initial_user_handle_get' called with unexpected value for argument 'p_handle'."); }
+    else if (cmock_call_instance->Expected_p_handle_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_handle, p_handle, cmock_line, "Function 'sd_ble_gatts_initial_user_handle_get' called with unexpected value for argument 'p_handle'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_p_handle, p_handle, cmock_call_instance->Expected_p_handle_Depth, cmock_line, "Function 'sd_ble_gatts_initial_user_handle_get' called with unexpected value for argument 'p_handle'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_handle_Used)
+  {
+    memcpy((void*)p_handle, (void*)cmock_call_instance->ReturnThruPtr_p_handle_Val,
+      cmock_call_instance->ReturnThruPtr_p_handle_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gatts_initial_user_handle_get(CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE* cmock_call_instance, uint16_t* p_handle, int p_handle_Depth)
+{
+  cmock_call_instance->Expected_p_handle = p_handle;
+  cmock_call_instance->Expected_p_handle_Depth = p_handle_Depth;
+  cmock_call_instance->IgnoreArg_p_handle = 0;
+  cmock_call_instance->ReturnThruPtr_p_handle_Used = 0;
+}
+
+void sd_ble_gatts_initial_user_handle_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_initial_user_handle_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_initial_user_handle_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gatts_initial_user_handle_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gatts_initial_user_handle_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t* p_handle, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_initial_user_handle_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_initial_user_handle_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_initial_user_handle_get(cmock_call_instance, p_handle, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_initial_user_handle_get_StubWithCallback(CMOCK_sd_ble_gatts_initial_user_handle_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gatts_initial_user_handle_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gatts_initial_user_handle_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t* p_handle, int p_handle_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_initial_user_handle_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_initial_user_handle_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_initial_user_handle_get(cmock_call_instance, p_handle, p_handle_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_initial_user_handle_get_CMockReturnMemThruPtr_p_handle(UNITY_LINE_TYPE cmock_line, uint16_t* p_handle, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_initial_user_handle_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handle ReturnThruPtr called before Expect on 'sd_ble_gatts_initial_user_handle_get'.");
+  cmock_call_instance->ReturnThruPtr_p_handle_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_handle_Val = p_handle;
+  cmock_call_instance->ReturnThruPtr_p_handle_Size = cmock_size;
+}
+
+void sd_ble_gatts_initial_user_handle_get_CMockIgnoreArg_p_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_initial_user_handle_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_initial_user_handle_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_handle IgnoreArg called before Expect on 'sd_ble_gatts_initial_user_handle_get'.");
+  cmock_call_instance->IgnoreArg_p_handle = 1;
+}
+
+uint32_t sd_ble_gatts_attr_get(uint16_t handle, ble_uuid_t* p_uuid, ble_gatts_attr_md_t* p_md)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gatts_attr_get_CallInstance);
+  Mock.sd_ble_gatts_attr_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gatts_attr_get_CallInstance);
+  if (Mock.sd_ble_gatts_attr_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gatts_attr_get_FinalReturn;
+    Mock.sd_ble_gatts_attr_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gatts_attr_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gatts_attr_get_CallbackFunctionPointer(handle, p_uuid, p_md, Mock.sd_ble_gatts_attr_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gatts_attr_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_attr_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_attr_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_handle, handle, cmock_line, "Function 'sd_ble_gatts_attr_get' called with unexpected value for argument 'handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_uuid)
+  {
+    if (cmock_call_instance->Expected_p_uuid == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_uuid, cmock_line, "Expected NULL. Function 'sd_ble_gatts_attr_get' called with unexpected value for argument 'p_uuid'."); }
+    else if (cmock_call_instance->Expected_p_uuid_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_uuid, p_uuid, cmock_line, "Function 'sd_ble_gatts_attr_get' called with unexpected value for argument 'p_uuid'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_uuid), (void*)(p_uuid), sizeof(ble_uuid_t), cmock_call_instance->Expected_p_uuid_Depth, cmock_line, "Function 'sd_ble_gatts_attr_get' called with unexpected value for argument 'p_uuid'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_md)
+  {
+    if (cmock_call_instance->Expected_p_md == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_md, cmock_line, "Expected NULL. Function 'sd_ble_gatts_attr_get' called with unexpected value for argument 'p_md'."); }
+    else if (cmock_call_instance->Expected_p_md_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_md, p_md, cmock_line, "Function 'sd_ble_gatts_attr_get' called with unexpected value for argument 'p_md'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_md), (void*)(p_md), sizeof(ble_gatts_attr_md_t), cmock_call_instance->Expected_p_md_Depth, cmock_line, "Function 'sd_ble_gatts_attr_get' called with unexpected value for argument 'p_md'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_uuid_Used)
+  {
+    memcpy((void*)p_uuid, (void*)cmock_call_instance->ReturnThruPtr_p_uuid_Val,
+      cmock_call_instance->ReturnThruPtr_p_uuid_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_md_Used)
+  {
+    memcpy((void*)p_md, (void*)cmock_call_instance->ReturnThruPtr_p_md_Val,
+      cmock_call_instance->ReturnThruPtr_p_md_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gatts_attr_get(CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE* cmock_call_instance, uint16_t handle, ble_uuid_t* p_uuid, int p_uuid_Depth, ble_gatts_attr_md_t* p_md, int p_md_Depth)
+{
+  cmock_call_instance->Expected_handle = handle;
+  cmock_call_instance->IgnoreArg_handle = 0;
+  cmock_call_instance->Expected_p_uuid = p_uuid;
+  cmock_call_instance->Expected_p_uuid_Depth = p_uuid_Depth;
+  cmock_call_instance->IgnoreArg_p_uuid = 0;
+  cmock_call_instance->ReturnThruPtr_p_uuid_Used = 0;
+  cmock_call_instance->Expected_p_md = p_md;
+  cmock_call_instance->Expected_p_md_Depth = p_md_Depth;
+  cmock_call_instance->IgnoreArg_p_md = 0;
+  cmock_call_instance->ReturnThruPtr_p_md_Used = 0;
+}
+
+void sd_ble_gatts_attr_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_attr_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_attr_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gatts_attr_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gatts_attr_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t handle, ble_uuid_t* p_uuid, ble_gatts_attr_md_t* p_md, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_attr_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_attr_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_attr_get(cmock_call_instance, handle, p_uuid, 0, p_md, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_attr_get_StubWithCallback(CMOCK_sd_ble_gatts_attr_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gatts_attr_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gatts_attr_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t handle, ble_uuid_t* p_uuid, int p_uuid_Depth, ble_gatts_attr_md_t* p_md, int p_md_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_attr_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_attr_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_attr_get(cmock_call_instance, handle, p_uuid, p_uuid_Depth, p_md, p_md_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_attr_get_CMockReturnMemThruPtr_p_uuid(UNITY_LINE_TYPE cmock_line, ble_uuid_t* p_uuid, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_attr_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid ReturnThruPtr called before Expect on 'sd_ble_gatts_attr_get'.");
+  cmock_call_instance->ReturnThruPtr_p_uuid_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_uuid_Val = p_uuid;
+  cmock_call_instance->ReturnThruPtr_p_uuid_Size = cmock_size;
+}
+
+void sd_ble_gatts_attr_get_CMockReturnMemThruPtr_p_md(UNITY_LINE_TYPE cmock_line, ble_gatts_attr_md_t* p_md, int cmock_size)
+{
+  CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_attr_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_md ReturnThruPtr called before Expect on 'sd_ble_gatts_attr_get'.");
+  cmock_call_instance->ReturnThruPtr_p_md_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_md_Val = p_md;
+  cmock_call_instance->ReturnThruPtr_p_md_Size = cmock_size;
+}
+
+void sd_ble_gatts_attr_get_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_attr_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "handle IgnoreArg called before Expect on 'sd_ble_gatts_attr_get'.");
+  cmock_call_instance->IgnoreArg_handle = 1;
+}
+
+void sd_ble_gatts_attr_get_CMockIgnoreArg_p_uuid(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_attr_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_uuid IgnoreArg called before Expect on 'sd_ble_gatts_attr_get'.");
+  cmock_call_instance->IgnoreArg_p_uuid = 1;
+}
+
+void sd_ble_gatts_attr_get_CMockIgnoreArg_p_md(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_attr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_attr_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_md IgnoreArg called before Expect on 'sd_ble_gatts_attr_get'.");
+  cmock_call_instance->IgnoreArg_p_md = 1;
+}
+
+uint32_t sd_ble_gatts_exchange_mtu_reply(uint16_t conn_handle, uint16_t server_rx_mtu)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gatts_exchange_mtu_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_exchange_mtu_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gatts_exchange_mtu_reply_CallInstance);
+  Mock.sd_ble_gatts_exchange_mtu_reply_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gatts_exchange_mtu_reply_CallInstance);
+  if (Mock.sd_ble_gatts_exchange_mtu_reply_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gatts_exchange_mtu_reply_FinalReturn;
+    Mock.sd_ble_gatts_exchange_mtu_reply_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gatts_exchange_mtu_reply_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gatts_exchange_mtu_reply_CallbackFunctionPointer(conn_handle, server_rx_mtu, Mock.sd_ble_gatts_exchange_mtu_reply_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gatts_exchange_mtu_reply' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_exchange_mtu_reply' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gatts_exchange_mtu_reply' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gatts_exchange_mtu_reply' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_server_rx_mtu)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_server_rx_mtu, server_rx_mtu, cmock_line, "Function 'sd_ble_gatts_exchange_mtu_reply' called with unexpected value for argument 'server_rx_mtu'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gatts_exchange_mtu_reply(CMOCK_sd_ble_gatts_exchange_mtu_reply_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint16_t server_rx_mtu)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_server_rx_mtu = server_rx_mtu;
+  cmock_call_instance->IgnoreArg_server_rx_mtu = 0;
+}
+
+void sd_ble_gatts_exchange_mtu_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_exchange_mtu_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_exchange_mtu_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_exchange_mtu_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_exchange_mtu_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_exchange_mtu_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gatts_exchange_mtu_reply_IgnoreBool = (int)1;
+}
+
+void sd_ble_gatts_exchange_mtu_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t server_rx_mtu, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gatts_exchange_mtu_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gatts_exchange_mtu_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gatts_exchange_mtu_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gatts_exchange_mtu_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gatts_exchange_mtu_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gatts_exchange_mtu_reply(cmock_call_instance, conn_handle, server_rx_mtu);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gatts_exchange_mtu_reply_StubWithCallback(CMOCK_sd_ble_gatts_exchange_mtu_reply_CALLBACK Callback)
+{
+  Mock.sd_ble_gatts_exchange_mtu_reply_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gatts_exchange_mtu_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_exchange_mtu_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_exchange_mtu_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_exchange_mtu_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gatts_exchange_mtu_reply'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gatts_exchange_mtu_reply_CMockIgnoreArg_server_rx_mtu(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gatts_exchange_mtu_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gatts_exchange_mtu_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gatts_exchange_mtu_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "server_rx_mtu IgnoreArg called before Expect on 'sd_ble_gatts_exchange_mtu_reply'.");
+  cmock_call_instance->IgnoreArg_server_rx_mtu = 1;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_gatts.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_gatts.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_gatts.h   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_gatts.h    2018-04-24 08:48:28.818151300 +0200
@@ -0,0 +1,286 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_BLE_GATTS_H
+#define _MOCK_BLE_GATTS_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <ble_gatts.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_ble_gatts_Init(void);
+void mock_ble_gatts_Destroy(void);
+void mock_ble_gatts_Verify(void);
+
+
+
+
+#define sd_ble_gatts_service_add_IgnoreAndReturn(cmock_retval) sd_ble_gatts_service_add_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gatts_service_add_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gatts_service_add_ExpectAndReturn(type, p_uuid, p_handle, cmock_retval) sd_ble_gatts_service_add_CMockExpectAndReturn(__LINE__, type, p_uuid, p_handle, cmock_retval)
+void sd_ble_gatts_service_add_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t type, ble_uuid_t const* p_uuid, uint16_t* p_handle, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gatts_service_add_CALLBACK)(uint8_t type, ble_uuid_t const* p_uuid, uint16_t* p_handle, int cmock_num_calls);
+void sd_ble_gatts_service_add_StubWithCallback(CMOCK_sd_ble_gatts_service_add_CALLBACK Callback);
+#define sd_ble_gatts_service_add_ExpectWithArrayAndReturn(type, p_uuid, p_uuid_Depth, p_handle, p_handle_Depth, cmock_retval) sd_ble_gatts_service_add_CMockExpectWithArrayAndReturn(__LINE__, type, p_uuid, p_uuid_Depth, p_handle, p_handle_Depth, cmock_retval)
+void sd_ble_gatts_service_add_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t type, ble_uuid_t const* p_uuid, int p_uuid_Depth, uint16_t* p_handle, int p_handle_Depth, uint32_t cmock_to_return);
+#define sd_ble_gatts_service_add_ReturnThruPtr_p_uuid(p_uuid) sd_ble_gatts_service_add_CMockReturnMemThruPtr_p_uuid(__LINE__, p_uuid, sizeof(*p_uuid))
+#define sd_ble_gatts_service_add_ReturnArrayThruPtr_p_uuid(p_uuid, cmock_len) sd_ble_gatts_service_add_CMockReturnMemThruPtr_p_uuid(__LINE__, p_uuid, cmock_len * sizeof(*p_uuid))
+#define sd_ble_gatts_service_add_ReturnMemThruPtr_p_uuid(p_uuid, cmock_size) sd_ble_gatts_service_add_CMockReturnMemThruPtr_p_uuid(__LINE__, p_uuid, cmock_size)
+void sd_ble_gatts_service_add_CMockReturnMemThruPtr_p_uuid(UNITY_LINE_TYPE cmock_line, ble_uuid_t const* p_uuid, int cmock_size);
+#define sd_ble_gatts_service_add_ReturnThruPtr_p_handle(p_handle) sd_ble_gatts_service_add_CMockReturnMemThruPtr_p_handle(__LINE__, p_handle, sizeof(*p_handle))
+#define sd_ble_gatts_service_add_ReturnArrayThruPtr_p_handle(p_handle, cmock_len) sd_ble_gatts_service_add_CMockReturnMemThruPtr_p_handle(__LINE__, p_handle, cmock_len * sizeof(*p_handle))
+#define sd_ble_gatts_service_add_ReturnMemThruPtr_p_handle(p_handle, cmock_size) sd_ble_gatts_service_add_CMockReturnMemThruPtr_p_handle(__LINE__, p_handle, cmock_size)
+void sd_ble_gatts_service_add_CMockReturnMemThruPtr_p_handle(UNITY_LINE_TYPE cmock_line, uint16_t* p_handle, int cmock_size);
+#define sd_ble_gatts_service_add_IgnoreArg_type() sd_ble_gatts_service_add_CMockIgnoreArg_type(__LINE__)
+void sd_ble_gatts_service_add_CMockIgnoreArg_type(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_service_add_IgnoreArg_p_uuid() sd_ble_gatts_service_add_CMockIgnoreArg_p_uuid(__LINE__)
+void sd_ble_gatts_service_add_CMockIgnoreArg_p_uuid(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_service_add_IgnoreArg_p_handle() sd_ble_gatts_service_add_CMockIgnoreArg_p_handle(__LINE__)
+void sd_ble_gatts_service_add_CMockIgnoreArg_p_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_include_add_IgnoreAndReturn(cmock_retval) sd_ble_gatts_include_add_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gatts_include_add_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gatts_include_add_ExpectAndReturn(service_handle, inc_srvc_handle, p_include_handle, cmock_retval) sd_ble_gatts_include_add_CMockExpectAndReturn(__LINE__, service_handle, inc_srvc_handle, p_include_handle, cmock_retval)
+void sd_ble_gatts_include_add_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t service_handle, uint16_t inc_srvc_handle, uint16_t* p_include_handle, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gatts_include_add_CALLBACK)(uint16_t service_handle, uint16_t inc_srvc_handle, uint16_t* p_include_handle, int cmock_num_calls);
+void sd_ble_gatts_include_add_StubWithCallback(CMOCK_sd_ble_gatts_include_add_CALLBACK Callback);
+#define sd_ble_gatts_include_add_ExpectWithArrayAndReturn(service_handle, inc_srvc_handle, p_include_handle, p_include_handle_Depth, cmock_retval) sd_ble_gatts_include_add_CMockExpectWithArrayAndReturn(__LINE__, service_handle, inc_srvc_handle, p_include_handle, p_include_handle_Depth, cmock_retval)
+void sd_ble_gatts_include_add_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t service_handle, uint16_t inc_srvc_handle, uint16_t* p_include_handle, int p_include_handle_Depth, uint32_t cmock_to_return);
+#define sd_ble_gatts_include_add_ReturnThruPtr_p_include_handle(p_include_handle) sd_ble_gatts_include_add_CMockReturnMemThruPtr_p_include_handle(__LINE__, p_include_handle, sizeof(*p_include_handle))
+#define sd_ble_gatts_include_add_ReturnArrayThruPtr_p_include_handle(p_include_handle, cmock_len) sd_ble_gatts_include_add_CMockReturnMemThruPtr_p_include_handle(__LINE__, p_include_handle, cmock_len * sizeof(*p_include_handle))
+#define sd_ble_gatts_include_add_ReturnMemThruPtr_p_include_handle(p_include_handle, cmock_size) sd_ble_gatts_include_add_CMockReturnMemThruPtr_p_include_handle(__LINE__, p_include_handle, cmock_size)
+void sd_ble_gatts_include_add_CMockReturnMemThruPtr_p_include_handle(UNITY_LINE_TYPE cmock_line, uint16_t* p_include_handle, int cmock_size);
+#define sd_ble_gatts_include_add_IgnoreArg_service_handle() sd_ble_gatts_include_add_CMockIgnoreArg_service_handle(__LINE__)
+void sd_ble_gatts_include_add_CMockIgnoreArg_service_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_include_add_IgnoreArg_inc_srvc_handle() sd_ble_gatts_include_add_CMockIgnoreArg_inc_srvc_handle(__LINE__)
+void sd_ble_gatts_include_add_CMockIgnoreArg_inc_srvc_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_include_add_IgnoreArg_p_include_handle() sd_ble_gatts_include_add_CMockIgnoreArg_p_include_handle(__LINE__)
+void sd_ble_gatts_include_add_CMockIgnoreArg_p_include_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_characteristic_add_IgnoreAndReturn(cmock_retval) sd_ble_gatts_characteristic_add_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gatts_characteristic_add_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gatts_characteristic_add_ExpectAndReturn(service_handle, p_char_md, p_attr_char_value, p_handles, cmock_retval) sd_ble_gatts_characteristic_add_CMockExpectAndReturn(__LINE__, service_handle, p_char_md, p_attr_char_value, p_handles, cmock_retval)
+void sd_ble_gatts_characteristic_add_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t service_handle, ble_gatts_char_md_t const* p_char_md, ble_gatts_attr_t const* p_attr_char_value, ble_gatts_char_handles_t* p_handles, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gatts_characteristic_add_CALLBACK)(uint16_t service_handle, ble_gatts_char_md_t const* p_char_md, ble_gatts_attr_t const* p_attr_char_value, ble_gatts_char_handles_t* p_handles, int cmock_num_calls);
+void sd_ble_gatts_characteristic_add_StubWithCallback(CMOCK_sd_ble_gatts_characteristic_add_CALLBACK Callback);
+#define sd_ble_gatts_characteristic_add_ExpectWithArrayAndReturn(service_handle, p_char_md, p_char_md_Depth, p_attr_char_value, p_attr_char_value_Depth, p_handles, p_handles_Depth, cmock_retval) sd_ble_gatts_characteristic_add_CMockExpectWithArrayAndReturn(__LINE__, service_handle, p_char_md, p_char_md_Depth, p_attr_char_value, p_attr_char_value_Depth, p_handles, p_handles_Depth, cmock_retval)
+void sd_ble_gatts_characteristic_add_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t service_handle, ble_gatts_char_md_t const* p_char_md, int p_char_md_Depth, ble_gatts_attr_t const* p_attr_char_value, int p_attr_char_value_Depth, ble_gatts_char_handles_t* p_handles, int p_handles_Depth, uint32_t cmock_to_return);
+#define sd_ble_gatts_characteristic_add_ReturnThruPtr_p_char_md(p_char_md) sd_ble_gatts_characteristic_add_CMockReturnMemThruPtr_p_char_md(__LINE__, p_char_md, sizeof(*p_char_md))
+#define sd_ble_gatts_characteristic_add_ReturnArrayThruPtr_p_char_md(p_char_md, cmock_len) sd_ble_gatts_characteristic_add_CMockReturnMemThruPtr_p_char_md(__LINE__, p_char_md, cmock_len * sizeof(*p_char_md))
+#define sd_ble_gatts_characteristic_add_ReturnMemThruPtr_p_char_md(p_char_md, cmock_size) sd_ble_gatts_characteristic_add_CMockReturnMemThruPtr_p_char_md(__LINE__, p_char_md, cmock_size)
+void sd_ble_gatts_characteristic_add_CMockReturnMemThruPtr_p_char_md(UNITY_LINE_TYPE cmock_line, ble_gatts_char_md_t const* p_char_md, int cmock_size);
+#define sd_ble_gatts_characteristic_add_ReturnThruPtr_p_attr_char_value(p_attr_char_value) sd_ble_gatts_characteristic_add_CMockReturnMemThruPtr_p_attr_char_value(__LINE__, p_attr_char_value, sizeof(*p_attr_char_value))
+#define sd_ble_gatts_characteristic_add_ReturnArrayThruPtr_p_attr_char_value(p_attr_char_value, cmock_len) sd_ble_gatts_characteristic_add_CMockReturnMemThruPtr_p_attr_char_value(__LINE__, p_attr_char_value, cmock_len * sizeof(*p_attr_char_value))
+#define sd_ble_gatts_characteristic_add_ReturnMemThruPtr_p_attr_char_value(p_attr_char_value, cmock_size) sd_ble_gatts_characteristic_add_CMockReturnMemThruPtr_p_attr_char_value(__LINE__, p_attr_char_value, cmock_size)
+void sd_ble_gatts_characteristic_add_CMockReturnMemThruPtr_p_attr_char_value(UNITY_LINE_TYPE cmock_line, ble_gatts_attr_t const* p_attr_char_value, int cmock_size);
+#define sd_ble_gatts_characteristic_add_ReturnThruPtr_p_handles(p_handles) sd_ble_gatts_characteristic_add_CMockReturnMemThruPtr_p_handles(__LINE__, p_handles, sizeof(*p_handles))
+#define sd_ble_gatts_characteristic_add_ReturnArrayThruPtr_p_handles(p_handles, cmock_len) sd_ble_gatts_characteristic_add_CMockReturnMemThruPtr_p_handles(__LINE__, p_handles, cmock_len * sizeof(*p_handles))
+#define sd_ble_gatts_characteristic_add_ReturnMemThruPtr_p_handles(p_handles, cmock_size) sd_ble_gatts_characteristic_add_CMockReturnMemThruPtr_p_handles(__LINE__, p_handles, cmock_size)
+void sd_ble_gatts_characteristic_add_CMockReturnMemThruPtr_p_handles(UNITY_LINE_TYPE cmock_line, ble_gatts_char_handles_t* p_handles, int cmock_size);
+#define sd_ble_gatts_characteristic_add_IgnoreArg_service_handle() sd_ble_gatts_characteristic_add_CMockIgnoreArg_service_handle(__LINE__)
+void sd_ble_gatts_characteristic_add_CMockIgnoreArg_service_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_characteristic_add_IgnoreArg_p_char_md() sd_ble_gatts_characteristic_add_CMockIgnoreArg_p_char_md(__LINE__)
+void sd_ble_gatts_characteristic_add_CMockIgnoreArg_p_char_md(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_characteristic_add_IgnoreArg_p_attr_char_value() sd_ble_gatts_characteristic_add_CMockIgnoreArg_p_attr_char_value(__LINE__)
+void sd_ble_gatts_characteristic_add_CMockIgnoreArg_p_attr_char_value(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_characteristic_add_IgnoreArg_p_handles() sd_ble_gatts_characteristic_add_CMockIgnoreArg_p_handles(__LINE__)
+void sd_ble_gatts_characteristic_add_CMockIgnoreArg_p_handles(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_descriptor_add_IgnoreAndReturn(cmock_retval) sd_ble_gatts_descriptor_add_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gatts_descriptor_add_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gatts_descriptor_add_ExpectAndReturn(char_handle, p_attr, p_handle, cmock_retval) sd_ble_gatts_descriptor_add_CMockExpectAndReturn(__LINE__, char_handle, p_attr, p_handle, cmock_retval)
+void sd_ble_gatts_descriptor_add_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t char_handle, ble_gatts_attr_t const* p_attr, uint16_t* p_handle, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gatts_descriptor_add_CALLBACK)(uint16_t char_handle, ble_gatts_attr_t const* p_attr, uint16_t* p_handle, int cmock_num_calls);
+void sd_ble_gatts_descriptor_add_StubWithCallback(CMOCK_sd_ble_gatts_descriptor_add_CALLBACK Callback);
+#define sd_ble_gatts_descriptor_add_ExpectWithArrayAndReturn(char_handle, p_attr, p_attr_Depth, p_handle, p_handle_Depth, cmock_retval) sd_ble_gatts_descriptor_add_CMockExpectWithArrayAndReturn(__LINE__, char_handle, p_attr, p_attr_Depth, p_handle, p_handle_Depth, cmock_retval)
+void sd_ble_gatts_descriptor_add_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t char_handle, ble_gatts_attr_t const* p_attr, int p_attr_Depth, uint16_t* p_handle, int p_handle_Depth, uint32_t cmock_to_return);
+#define sd_ble_gatts_descriptor_add_ReturnThruPtr_p_attr(p_attr) sd_ble_gatts_descriptor_add_CMockReturnMemThruPtr_p_attr(__LINE__, p_attr, sizeof(*p_attr))
+#define sd_ble_gatts_descriptor_add_ReturnArrayThruPtr_p_attr(p_attr, cmock_len) sd_ble_gatts_descriptor_add_CMockReturnMemThruPtr_p_attr(__LINE__, p_attr, cmock_len * sizeof(*p_attr))
+#define sd_ble_gatts_descriptor_add_ReturnMemThruPtr_p_attr(p_attr, cmock_size) sd_ble_gatts_descriptor_add_CMockReturnMemThruPtr_p_attr(__LINE__, p_attr, cmock_size)
+void sd_ble_gatts_descriptor_add_CMockReturnMemThruPtr_p_attr(UNITY_LINE_TYPE cmock_line, ble_gatts_attr_t const* p_attr, int cmock_size);
+#define sd_ble_gatts_descriptor_add_ReturnThruPtr_p_handle(p_handle) sd_ble_gatts_descriptor_add_CMockReturnMemThruPtr_p_handle(__LINE__, p_handle, sizeof(*p_handle))
+#define sd_ble_gatts_descriptor_add_ReturnArrayThruPtr_p_handle(p_handle, cmock_len) sd_ble_gatts_descriptor_add_CMockReturnMemThruPtr_p_handle(__LINE__, p_handle, cmock_len * sizeof(*p_handle))
+#define sd_ble_gatts_descriptor_add_ReturnMemThruPtr_p_handle(p_handle, cmock_size) sd_ble_gatts_descriptor_add_CMockReturnMemThruPtr_p_handle(__LINE__, p_handle, cmock_size)
+void sd_ble_gatts_descriptor_add_CMockReturnMemThruPtr_p_handle(UNITY_LINE_TYPE cmock_line, uint16_t* p_handle, int cmock_size);
+#define sd_ble_gatts_descriptor_add_IgnoreArg_char_handle() sd_ble_gatts_descriptor_add_CMockIgnoreArg_char_handle(__LINE__)
+void sd_ble_gatts_descriptor_add_CMockIgnoreArg_char_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_descriptor_add_IgnoreArg_p_attr() sd_ble_gatts_descriptor_add_CMockIgnoreArg_p_attr(__LINE__)
+void sd_ble_gatts_descriptor_add_CMockIgnoreArg_p_attr(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_descriptor_add_IgnoreArg_p_handle() sd_ble_gatts_descriptor_add_CMockIgnoreArg_p_handle(__LINE__)
+void sd_ble_gatts_descriptor_add_CMockIgnoreArg_p_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_value_set_IgnoreAndReturn(cmock_retval) sd_ble_gatts_value_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gatts_value_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gatts_value_set_ExpectAndReturn(conn_handle, handle, p_value, cmock_retval) sd_ble_gatts_value_set_CMockExpectAndReturn(__LINE__, conn_handle, handle, p_value, cmock_retval)
+void sd_ble_gatts_value_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t handle, ble_gatts_value_t* p_value, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gatts_value_set_CALLBACK)(uint16_t conn_handle, uint16_t handle, ble_gatts_value_t* p_value, int cmock_num_calls);
+void sd_ble_gatts_value_set_StubWithCallback(CMOCK_sd_ble_gatts_value_set_CALLBACK Callback);
+#define sd_ble_gatts_value_set_ExpectWithArrayAndReturn(conn_handle, handle, p_value, p_value_Depth, cmock_retval) sd_ble_gatts_value_set_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, handle, p_value, p_value_Depth, cmock_retval)
+void sd_ble_gatts_value_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t handle, ble_gatts_value_t* p_value, int p_value_Depth, uint32_t cmock_to_return);
+#define sd_ble_gatts_value_set_ReturnThruPtr_p_value(p_value) sd_ble_gatts_value_set_CMockReturnMemThruPtr_p_value(__LINE__, p_value, sizeof(*p_value))
+#define sd_ble_gatts_value_set_ReturnArrayThruPtr_p_value(p_value, cmock_len) sd_ble_gatts_value_set_CMockReturnMemThruPtr_p_value(__LINE__, p_value, cmock_len * sizeof(*p_value))
+#define sd_ble_gatts_value_set_ReturnMemThruPtr_p_value(p_value, cmock_size) sd_ble_gatts_value_set_CMockReturnMemThruPtr_p_value(__LINE__, p_value, cmock_size)
+void sd_ble_gatts_value_set_CMockReturnMemThruPtr_p_value(UNITY_LINE_TYPE cmock_line, ble_gatts_value_t* p_value, int cmock_size);
+#define sd_ble_gatts_value_set_IgnoreArg_conn_handle() sd_ble_gatts_value_set_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gatts_value_set_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_value_set_IgnoreArg_handle() sd_ble_gatts_value_set_CMockIgnoreArg_handle(__LINE__)
+void sd_ble_gatts_value_set_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_value_set_IgnoreArg_p_value() sd_ble_gatts_value_set_CMockIgnoreArg_p_value(__LINE__)
+void sd_ble_gatts_value_set_CMockIgnoreArg_p_value(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_value_get_IgnoreAndReturn(cmock_retval) sd_ble_gatts_value_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gatts_value_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gatts_value_get_ExpectAndReturn(conn_handle, handle, p_value, cmock_retval) sd_ble_gatts_value_get_CMockExpectAndReturn(__LINE__, conn_handle, handle, p_value, cmock_retval)
+void sd_ble_gatts_value_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t handle, ble_gatts_value_t* p_value, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gatts_value_get_CALLBACK)(uint16_t conn_handle, uint16_t handle, ble_gatts_value_t* p_value, int cmock_num_calls);
+void sd_ble_gatts_value_get_StubWithCallback(CMOCK_sd_ble_gatts_value_get_CALLBACK Callback);
+#define sd_ble_gatts_value_get_ExpectWithArrayAndReturn(conn_handle, handle, p_value, p_value_Depth, cmock_retval) sd_ble_gatts_value_get_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, handle, p_value, p_value_Depth, cmock_retval)
+void sd_ble_gatts_value_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t handle, ble_gatts_value_t* p_value, int p_value_Depth, uint32_t cmock_to_return);
+#define sd_ble_gatts_value_get_ReturnThruPtr_p_value(p_value) sd_ble_gatts_value_get_CMockReturnMemThruPtr_p_value(__LINE__, p_value, sizeof(*p_value))
+#define sd_ble_gatts_value_get_ReturnArrayThruPtr_p_value(p_value, cmock_len) sd_ble_gatts_value_get_CMockReturnMemThruPtr_p_value(__LINE__, p_value, cmock_len * sizeof(*p_value))
+#define sd_ble_gatts_value_get_ReturnMemThruPtr_p_value(p_value, cmock_size) sd_ble_gatts_value_get_CMockReturnMemThruPtr_p_value(__LINE__, p_value, cmock_size)
+void sd_ble_gatts_value_get_CMockReturnMemThruPtr_p_value(UNITY_LINE_TYPE cmock_line, ble_gatts_value_t* p_value, int cmock_size);
+#define sd_ble_gatts_value_get_IgnoreArg_conn_handle() sd_ble_gatts_value_get_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gatts_value_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_value_get_IgnoreArg_handle() sd_ble_gatts_value_get_CMockIgnoreArg_handle(__LINE__)
+void sd_ble_gatts_value_get_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_value_get_IgnoreArg_p_value() sd_ble_gatts_value_get_CMockIgnoreArg_p_value(__LINE__)
+void sd_ble_gatts_value_get_CMockIgnoreArg_p_value(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_hvx_IgnoreAndReturn(cmock_retval) sd_ble_gatts_hvx_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gatts_hvx_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gatts_hvx_ExpectAndReturn(conn_handle, p_hvx_params, cmock_retval) sd_ble_gatts_hvx_CMockExpectAndReturn(__LINE__, conn_handle, p_hvx_params, cmock_retval)
+void sd_ble_gatts_hvx_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gatts_hvx_params_t const* p_hvx_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gatts_hvx_CALLBACK)(uint16_t conn_handle, ble_gatts_hvx_params_t const* p_hvx_params, int cmock_num_calls);
+void sd_ble_gatts_hvx_StubWithCallback(CMOCK_sd_ble_gatts_hvx_CALLBACK Callback);
+#define sd_ble_gatts_hvx_ExpectWithArrayAndReturn(conn_handle, p_hvx_params, p_hvx_params_Depth, cmock_retval) sd_ble_gatts_hvx_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_hvx_params, p_hvx_params_Depth, cmock_retval)
+void sd_ble_gatts_hvx_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gatts_hvx_params_t const* p_hvx_params, int p_hvx_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gatts_hvx_ReturnThruPtr_p_hvx_params(p_hvx_params) sd_ble_gatts_hvx_CMockReturnMemThruPtr_p_hvx_params(__LINE__, p_hvx_params, sizeof(*p_hvx_params))
+#define sd_ble_gatts_hvx_ReturnArrayThruPtr_p_hvx_params(p_hvx_params, cmock_len) sd_ble_gatts_hvx_CMockReturnMemThruPtr_p_hvx_params(__LINE__, p_hvx_params, cmock_len * sizeof(*p_hvx_params))
+#define sd_ble_gatts_hvx_ReturnMemThruPtr_p_hvx_params(p_hvx_params, cmock_size) sd_ble_gatts_hvx_CMockReturnMemThruPtr_p_hvx_params(__LINE__, p_hvx_params, cmock_size)
+void sd_ble_gatts_hvx_CMockReturnMemThruPtr_p_hvx_params(UNITY_LINE_TYPE cmock_line, ble_gatts_hvx_params_t const* p_hvx_params, int cmock_size);
+#define sd_ble_gatts_hvx_IgnoreArg_conn_handle() sd_ble_gatts_hvx_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gatts_hvx_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_hvx_IgnoreArg_p_hvx_params() sd_ble_gatts_hvx_CMockIgnoreArg_p_hvx_params(__LINE__)
+void sd_ble_gatts_hvx_CMockIgnoreArg_p_hvx_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_service_changed_IgnoreAndReturn(cmock_retval) sd_ble_gatts_service_changed_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gatts_service_changed_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gatts_service_changed_ExpectAndReturn(conn_handle, start_handle, end_handle, cmock_retval) sd_ble_gatts_service_changed_CMockExpectAndReturn(__LINE__, conn_handle, start_handle, end_handle, cmock_retval)
+void sd_ble_gatts_service_changed_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gatts_service_changed_CALLBACK)(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle, int cmock_num_calls);
+void sd_ble_gatts_service_changed_StubWithCallback(CMOCK_sd_ble_gatts_service_changed_CALLBACK Callback);
+#define sd_ble_gatts_service_changed_IgnoreArg_conn_handle() sd_ble_gatts_service_changed_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gatts_service_changed_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_service_changed_IgnoreArg_start_handle() sd_ble_gatts_service_changed_CMockIgnoreArg_start_handle(__LINE__)
+void sd_ble_gatts_service_changed_CMockIgnoreArg_start_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_service_changed_IgnoreArg_end_handle() sd_ble_gatts_service_changed_CMockIgnoreArg_end_handle(__LINE__)
+void sd_ble_gatts_service_changed_CMockIgnoreArg_end_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_rw_authorize_reply_IgnoreAndReturn(cmock_retval) sd_ble_gatts_rw_authorize_reply_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gatts_rw_authorize_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gatts_rw_authorize_reply_ExpectAndReturn(conn_handle, p_rw_authorize_reply_params, cmock_retval) sd_ble_gatts_rw_authorize_reply_CMockExpectAndReturn(__LINE__, conn_handle, p_rw_authorize_reply_params, cmock_retval)
+void sd_ble_gatts_rw_authorize_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gatts_rw_authorize_reply_params_t const* p_rw_authorize_reply_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gatts_rw_authorize_reply_CALLBACK)(uint16_t conn_handle, ble_gatts_rw_authorize_reply_params_t const* p_rw_authorize_reply_params, int cmock_num_calls);
+void sd_ble_gatts_rw_authorize_reply_StubWithCallback(CMOCK_sd_ble_gatts_rw_authorize_reply_CALLBACK Callback);
+#define sd_ble_gatts_rw_authorize_reply_ExpectWithArrayAndReturn(conn_handle, p_rw_authorize_reply_params, p_rw_authorize_reply_params_Depth, cmock_retval) sd_ble_gatts_rw_authorize_reply_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_rw_authorize_reply_params, p_rw_authorize_reply_params_Depth, cmock_retval)
+void sd_ble_gatts_rw_authorize_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gatts_rw_authorize_reply_params_t const* p_rw_authorize_reply_params, int p_rw_authorize_reply_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gatts_rw_authorize_reply_ReturnThruPtr_p_rw_authorize_reply_params(p_rw_authorize_reply_params) sd_ble_gatts_rw_authorize_reply_CMockReturnMemThruPtr_p_rw_authorize_reply_params(__LINE__, p_rw_authorize_reply_params, sizeof(*p_rw_authorize_reply_params))
+#define sd_ble_gatts_rw_authorize_reply_ReturnArrayThruPtr_p_rw_authorize_reply_params(p_rw_authorize_reply_params, cmock_len) sd_ble_gatts_rw_authorize_reply_CMockReturnMemThruPtr_p_rw_authorize_reply_params(__LINE__, p_rw_authorize_reply_params, cmock_len * sizeof(*p_rw_authorize_reply_params))
+#define sd_ble_gatts_rw_authorize_reply_ReturnMemThruPtr_p_rw_authorize_reply_params(p_rw_authorize_reply_params, cmock_size) sd_ble_gatts_rw_authorize_reply_CMockReturnMemThruPtr_p_rw_authorize_reply_params(__LINE__, p_rw_authorize_reply_params, cmock_size)
+void sd_ble_gatts_rw_authorize_reply_CMockReturnMemThruPtr_p_rw_authorize_reply_params(UNITY_LINE_TYPE cmock_line, ble_gatts_rw_authorize_reply_params_t const* p_rw_authorize_reply_params, int cmock_size);
+#define sd_ble_gatts_rw_authorize_reply_IgnoreArg_conn_handle() sd_ble_gatts_rw_authorize_reply_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gatts_rw_authorize_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_rw_authorize_reply_IgnoreArg_p_rw_authorize_reply_params() sd_ble_gatts_rw_authorize_reply_CMockIgnoreArg_p_rw_authorize_reply_params(__LINE__)
+void sd_ble_gatts_rw_authorize_reply_CMockIgnoreArg_p_rw_authorize_reply_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_sys_attr_set_IgnoreAndReturn(cmock_retval) sd_ble_gatts_sys_attr_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gatts_sys_attr_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gatts_sys_attr_set_ExpectAndReturn(conn_handle, p_sys_attr_data, len, flags, cmock_retval) sd_ble_gatts_sys_attr_set_CMockExpectAndReturn(__LINE__, conn_handle, p_sys_attr_data, len, flags, cmock_retval)
+void sd_ble_gatts_sys_attr_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t const* p_sys_attr_data, uint16_t len, uint32_t flags, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gatts_sys_attr_set_CALLBACK)(uint16_t conn_handle, uint8_t const* p_sys_attr_data, uint16_t len, uint32_t flags, int cmock_num_calls);
+void sd_ble_gatts_sys_attr_set_StubWithCallback(CMOCK_sd_ble_gatts_sys_attr_set_CALLBACK Callback);
+#define sd_ble_gatts_sys_attr_set_ExpectWithArrayAndReturn(conn_handle, p_sys_attr_data, p_sys_attr_data_Depth, len, flags, cmock_retval) sd_ble_gatts_sys_attr_set_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_sys_attr_data, p_sys_attr_data_Depth, len, flags, cmock_retval)
+void sd_ble_gatts_sys_attr_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t const* p_sys_attr_data, int p_sys_attr_data_Depth, uint16_t len, uint32_t flags, uint32_t cmock_to_return);
+#define sd_ble_gatts_sys_attr_set_ReturnThruPtr_p_sys_attr_data(p_sys_attr_data) sd_ble_gatts_sys_attr_set_CMockReturnMemThruPtr_p_sys_attr_data(__LINE__, p_sys_attr_data, sizeof(*p_sys_attr_data))
+#define sd_ble_gatts_sys_attr_set_ReturnArrayThruPtr_p_sys_attr_data(p_sys_attr_data, cmock_len) sd_ble_gatts_sys_attr_set_CMockReturnMemThruPtr_p_sys_attr_data(__LINE__, p_sys_attr_data, cmock_len * sizeof(*p_sys_attr_data))
+#define sd_ble_gatts_sys_attr_set_ReturnMemThruPtr_p_sys_attr_data(p_sys_attr_data, cmock_size) sd_ble_gatts_sys_attr_set_CMockReturnMemThruPtr_p_sys_attr_data(__LINE__, p_sys_attr_data, cmock_size)
+void sd_ble_gatts_sys_attr_set_CMockReturnMemThruPtr_p_sys_attr_data(UNITY_LINE_TYPE cmock_line, uint8_t const* p_sys_attr_data, int cmock_size);
+#define sd_ble_gatts_sys_attr_set_IgnoreArg_conn_handle() sd_ble_gatts_sys_attr_set_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gatts_sys_attr_set_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_sys_attr_set_IgnoreArg_p_sys_attr_data() sd_ble_gatts_sys_attr_set_CMockIgnoreArg_p_sys_attr_data(__LINE__)
+void sd_ble_gatts_sys_attr_set_CMockIgnoreArg_p_sys_attr_data(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_sys_attr_set_IgnoreArg_len() sd_ble_gatts_sys_attr_set_CMockIgnoreArg_len(__LINE__)
+void sd_ble_gatts_sys_attr_set_CMockIgnoreArg_len(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_sys_attr_set_IgnoreArg_flags() sd_ble_gatts_sys_attr_set_CMockIgnoreArg_flags(__LINE__)
+void sd_ble_gatts_sys_attr_set_CMockIgnoreArg_flags(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_sys_attr_get_IgnoreAndReturn(cmock_retval) sd_ble_gatts_sys_attr_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gatts_sys_attr_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gatts_sys_attr_get_ExpectAndReturn(conn_handle, p_sys_attr_data, p_len, flags, cmock_retval) sd_ble_gatts_sys_attr_get_CMockExpectAndReturn(__LINE__, conn_handle, p_sys_attr_data, p_len, flags, cmock_retval)
+void sd_ble_gatts_sys_attr_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t* p_sys_attr_data, uint16_t* p_len, uint32_t flags, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gatts_sys_attr_get_CALLBACK)(uint16_t conn_handle, uint8_t* p_sys_attr_data, uint16_t* p_len, uint32_t flags, int cmock_num_calls);
+void sd_ble_gatts_sys_attr_get_StubWithCallback(CMOCK_sd_ble_gatts_sys_attr_get_CALLBACK Callback);
+#define sd_ble_gatts_sys_attr_get_ExpectWithArrayAndReturn(conn_handle, p_sys_attr_data, p_sys_attr_data_Depth, p_len, p_len_Depth, flags, cmock_retval) sd_ble_gatts_sys_attr_get_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_sys_attr_data, p_sys_attr_data_Depth, p_len, p_len_Depth, flags, cmock_retval)
+void sd_ble_gatts_sys_attr_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t* p_sys_attr_data, int p_sys_attr_data_Depth, uint16_t* p_len, int p_len_Depth, uint32_t flags, uint32_t cmock_to_return);
+#define sd_ble_gatts_sys_attr_get_ReturnThruPtr_p_sys_attr_data(p_sys_attr_data) sd_ble_gatts_sys_attr_get_CMockReturnMemThruPtr_p_sys_attr_data(__LINE__, p_sys_attr_data, sizeof(*p_sys_attr_data))
+#define sd_ble_gatts_sys_attr_get_ReturnArrayThruPtr_p_sys_attr_data(p_sys_attr_data, cmock_len) sd_ble_gatts_sys_attr_get_CMockReturnMemThruPtr_p_sys_attr_data(__LINE__, p_sys_attr_data, cmock_len * sizeof(*p_sys_attr_data))
+#define sd_ble_gatts_sys_attr_get_ReturnMemThruPtr_p_sys_attr_data(p_sys_attr_data, cmock_size) sd_ble_gatts_sys_attr_get_CMockReturnMemThruPtr_p_sys_attr_data(__LINE__, p_sys_attr_data, cmock_size)
+void sd_ble_gatts_sys_attr_get_CMockReturnMemThruPtr_p_sys_attr_data(UNITY_LINE_TYPE cmock_line, uint8_t* p_sys_attr_data, int cmock_size);
+#define sd_ble_gatts_sys_attr_get_ReturnThruPtr_p_len(p_len) sd_ble_gatts_sys_attr_get_CMockReturnMemThruPtr_p_len(__LINE__, p_len, sizeof(*p_len))
+#define sd_ble_gatts_sys_attr_get_ReturnArrayThruPtr_p_len(p_len, cmock_len) sd_ble_gatts_sys_attr_get_CMockReturnMemThruPtr_p_len(__LINE__, p_len, cmock_len * sizeof(*p_len))
+#define sd_ble_gatts_sys_attr_get_ReturnMemThruPtr_p_len(p_len, cmock_size) sd_ble_gatts_sys_attr_get_CMockReturnMemThruPtr_p_len(__LINE__, p_len, cmock_size)
+void sd_ble_gatts_sys_attr_get_CMockReturnMemThruPtr_p_len(UNITY_LINE_TYPE cmock_line, uint16_t* p_len, int cmock_size);
+#define sd_ble_gatts_sys_attr_get_IgnoreArg_conn_handle() sd_ble_gatts_sys_attr_get_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gatts_sys_attr_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_sys_attr_get_IgnoreArg_p_sys_attr_data() sd_ble_gatts_sys_attr_get_CMockIgnoreArg_p_sys_attr_data(__LINE__)
+void sd_ble_gatts_sys_attr_get_CMockIgnoreArg_p_sys_attr_data(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_sys_attr_get_IgnoreArg_p_len() sd_ble_gatts_sys_attr_get_CMockIgnoreArg_p_len(__LINE__)
+void sd_ble_gatts_sys_attr_get_CMockIgnoreArg_p_len(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_sys_attr_get_IgnoreArg_flags() sd_ble_gatts_sys_attr_get_CMockIgnoreArg_flags(__LINE__)
+void sd_ble_gatts_sys_attr_get_CMockIgnoreArg_flags(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_initial_user_handle_get_IgnoreAndReturn(cmock_retval) sd_ble_gatts_initial_user_handle_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gatts_initial_user_handle_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gatts_initial_user_handle_get_ExpectAndReturn(p_handle, cmock_retval) sd_ble_gatts_initial_user_handle_get_CMockExpectAndReturn(__LINE__, p_handle, cmock_retval)
+void sd_ble_gatts_initial_user_handle_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t* p_handle, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gatts_initial_user_handle_get_CALLBACK)(uint16_t* p_handle, int cmock_num_calls);
+void sd_ble_gatts_initial_user_handle_get_StubWithCallback(CMOCK_sd_ble_gatts_initial_user_handle_get_CALLBACK Callback);
+#define sd_ble_gatts_initial_user_handle_get_ExpectWithArrayAndReturn(p_handle, p_handle_Depth, cmock_retval) sd_ble_gatts_initial_user_handle_get_CMockExpectWithArrayAndReturn(__LINE__, p_handle, p_handle_Depth, cmock_retval)
+void sd_ble_gatts_initial_user_handle_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t* p_handle, int p_handle_Depth, uint32_t cmock_to_return);
+#define sd_ble_gatts_initial_user_handle_get_ReturnThruPtr_p_handle(p_handle) sd_ble_gatts_initial_user_handle_get_CMockReturnMemThruPtr_p_handle(__LINE__, p_handle, sizeof(*p_handle))
+#define sd_ble_gatts_initial_user_handle_get_ReturnArrayThruPtr_p_handle(p_handle, cmock_len) sd_ble_gatts_initial_user_handle_get_CMockReturnMemThruPtr_p_handle(__LINE__, p_handle, cmock_len * sizeof(*p_handle))
+#define sd_ble_gatts_initial_user_handle_get_ReturnMemThruPtr_p_handle(p_handle, cmock_size) sd_ble_gatts_initial_user_handle_get_CMockReturnMemThruPtr_p_handle(__LINE__, p_handle, cmock_size)
+void sd_ble_gatts_initial_user_handle_get_CMockReturnMemThruPtr_p_handle(UNITY_LINE_TYPE cmock_line, uint16_t* p_handle, int cmock_size);
+#define sd_ble_gatts_initial_user_handle_get_IgnoreArg_p_handle() sd_ble_gatts_initial_user_handle_get_CMockIgnoreArg_p_handle(__LINE__)
+void sd_ble_gatts_initial_user_handle_get_CMockIgnoreArg_p_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_attr_get_IgnoreAndReturn(cmock_retval) sd_ble_gatts_attr_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gatts_attr_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gatts_attr_get_ExpectAndReturn(handle, p_uuid, p_md, cmock_retval) sd_ble_gatts_attr_get_CMockExpectAndReturn(__LINE__, handle, p_uuid, p_md, cmock_retval)
+void sd_ble_gatts_attr_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t handle, ble_uuid_t* p_uuid, ble_gatts_attr_md_t* p_md, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gatts_attr_get_CALLBACK)(uint16_t handle, ble_uuid_t* p_uuid, ble_gatts_attr_md_t* p_md, int cmock_num_calls);
+void sd_ble_gatts_attr_get_StubWithCallback(CMOCK_sd_ble_gatts_attr_get_CALLBACK Callback);
+#define sd_ble_gatts_attr_get_ExpectWithArrayAndReturn(handle, p_uuid, p_uuid_Depth, p_md, p_md_Depth, cmock_retval) sd_ble_gatts_attr_get_CMockExpectWithArrayAndReturn(__LINE__, handle, p_uuid, p_uuid_Depth, p_md, p_md_Depth, cmock_retval)
+void sd_ble_gatts_attr_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t handle, ble_uuid_t* p_uuid, int p_uuid_Depth, ble_gatts_attr_md_t* p_md, int p_md_Depth, uint32_t cmock_to_return);
+#define sd_ble_gatts_attr_get_ReturnThruPtr_p_uuid(p_uuid) sd_ble_gatts_attr_get_CMockReturnMemThruPtr_p_uuid(__LINE__, p_uuid, sizeof(*p_uuid))
+#define sd_ble_gatts_attr_get_ReturnArrayThruPtr_p_uuid(p_uuid, cmock_len) sd_ble_gatts_attr_get_CMockReturnMemThruPtr_p_uuid(__LINE__, p_uuid, cmock_len * sizeof(*p_uuid))
+#define sd_ble_gatts_attr_get_ReturnMemThruPtr_p_uuid(p_uuid, cmock_size) sd_ble_gatts_attr_get_CMockReturnMemThruPtr_p_uuid(__LINE__, p_uuid, cmock_size)
+void sd_ble_gatts_attr_get_CMockReturnMemThruPtr_p_uuid(UNITY_LINE_TYPE cmock_line, ble_uuid_t* p_uuid, int cmock_size);
+#define sd_ble_gatts_attr_get_ReturnThruPtr_p_md(p_md) sd_ble_gatts_attr_get_CMockReturnMemThruPtr_p_md(__LINE__, p_md, sizeof(*p_md))
+#define sd_ble_gatts_attr_get_ReturnArrayThruPtr_p_md(p_md, cmock_len) sd_ble_gatts_attr_get_CMockReturnMemThruPtr_p_md(__LINE__, p_md, cmock_len * sizeof(*p_md))
+#define sd_ble_gatts_attr_get_ReturnMemThruPtr_p_md(p_md, cmock_size) sd_ble_gatts_attr_get_CMockReturnMemThruPtr_p_md(__LINE__, p_md, cmock_size)
+void sd_ble_gatts_attr_get_CMockReturnMemThruPtr_p_md(UNITY_LINE_TYPE cmock_line, ble_gatts_attr_md_t* p_md, int cmock_size);
+#define sd_ble_gatts_attr_get_IgnoreArg_handle() sd_ble_gatts_attr_get_CMockIgnoreArg_handle(__LINE__)
+void sd_ble_gatts_attr_get_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_attr_get_IgnoreArg_p_uuid() sd_ble_gatts_attr_get_CMockIgnoreArg_p_uuid(__LINE__)
+void sd_ble_gatts_attr_get_CMockIgnoreArg_p_uuid(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_attr_get_IgnoreArg_p_md() sd_ble_gatts_attr_get_CMockIgnoreArg_p_md(__LINE__)
+void sd_ble_gatts_attr_get_CMockIgnoreArg_p_md(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_exchange_mtu_reply_IgnoreAndReturn(cmock_retval) sd_ble_gatts_exchange_mtu_reply_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gatts_exchange_mtu_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gatts_exchange_mtu_reply_ExpectAndReturn(conn_handle, server_rx_mtu, cmock_retval) sd_ble_gatts_exchange_mtu_reply_CMockExpectAndReturn(__LINE__, conn_handle, server_rx_mtu, cmock_retval)
+void sd_ble_gatts_exchange_mtu_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint16_t server_rx_mtu, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gatts_exchange_mtu_reply_CALLBACK)(uint16_t conn_handle, uint16_t server_rx_mtu, int cmock_num_calls);
+void sd_ble_gatts_exchange_mtu_reply_StubWithCallback(CMOCK_sd_ble_gatts_exchange_mtu_reply_CALLBACK Callback);
+#define sd_ble_gatts_exchange_mtu_reply_IgnoreArg_conn_handle() sd_ble_gatts_exchange_mtu_reply_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gatts_exchange_mtu_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gatts_exchange_mtu_reply_IgnoreArg_server_rx_mtu() sd_ble_gatts_exchange_mtu_reply_CMockIgnoreArg_server_rx_mtu(__LINE__)
+void sd_ble_gatts_exchange_mtu_reply_CMockIgnoreArg_server_rx_mtu(UNITY_LINE_TYPE cmock_line);
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_hci.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_hci.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_hci.c 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_hci.c  2018-04-24 08:48:28.818151300 +0200
@@ -0,0 +1,36 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_ble_hci.h"
+
+static struct mock_ble_hciInstance
+{
+  unsigned char placeHolder;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_ble_hci_Verify(void)
+{
+}
+
+void mock_ble_hci_Init(void)
+{
+  mock_ble_hci_Destroy();
+}
+
+void mock_ble_hci_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_hci.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_hci.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_hci.h 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_hci.h  2018-04-24 08:48:28.828151500 +0200
@@ -0,0 +1,26 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_BLE_HCI_H
+#define _MOCK_BLE_HCI_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <ble_hci.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_ble_hci_Init(void);
+void mock_ble_hci_Destroy(void);
+void mock_ble_hci_Verify(void);
+
+
+
+
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_l2cap.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_l2cap.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_l2cap.c   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_l2cap.c    2018-04-24 08:48:28.828151500 +0200
@@ -0,0 +1,398 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_ble_l2cap.h"
+
+typedef struct _CMOCK_sd_ble_l2cap_cid_register_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_cid;
+  int IgnoreArg_cid;
+
+} CMOCK_sd_ble_l2cap_cid_register_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_l2cap_cid_unregister_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_cid;
+  int IgnoreArg_cid;
+
+} CMOCK_sd_ble_l2cap_cid_unregister_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_l2cap_header_t const* Expected_p_header;
+  uint8_t const* Expected_p_data;
+  int Expected_p_header_Depth;
+  int Expected_p_data_Depth;
+  int ReturnThruPtr_p_header_Used;
+  ble_l2cap_header_t const* ReturnThruPtr_p_header_Val;
+  int ReturnThruPtr_p_header_Size;
+  int ReturnThruPtr_p_data_Used;
+  uint8_t const* ReturnThruPtr_p_data_Val;
+  int ReturnThruPtr_p_data_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_header;
+  int IgnoreArg_p_data;
+
+} CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE;
+
+static struct mock_ble_l2capInstance
+{
+  int sd_ble_l2cap_cid_register_IgnoreBool;
+  uint32_t sd_ble_l2cap_cid_register_FinalReturn;
+  CMOCK_sd_ble_l2cap_cid_register_CALLBACK sd_ble_l2cap_cid_register_CallbackFunctionPointer;
+  int sd_ble_l2cap_cid_register_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_l2cap_cid_register_CallInstance;
+  int sd_ble_l2cap_cid_unregister_IgnoreBool;
+  uint32_t sd_ble_l2cap_cid_unregister_FinalReturn;
+  CMOCK_sd_ble_l2cap_cid_unregister_CALLBACK sd_ble_l2cap_cid_unregister_CallbackFunctionPointer;
+  int sd_ble_l2cap_cid_unregister_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_l2cap_cid_unregister_CallInstance;
+  int sd_ble_l2cap_tx_IgnoreBool;
+  uint32_t sd_ble_l2cap_tx_FinalReturn;
+  CMOCK_sd_ble_l2cap_tx_CALLBACK sd_ble_l2cap_tx_CallbackFunctionPointer;
+  int sd_ble_l2cap_tx_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_l2cap_tx_CallInstance;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_ble_l2cap_Verify(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_l2cap_cid_register_CallInstance, cmock_line, "Function 'sd_ble_l2cap_cid_register' called less times than expected.");
+  if (Mock.sd_ble_l2cap_cid_register_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_l2cap_cid_register_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_l2cap_cid_unregister_CallInstance, cmock_line, "Function 'sd_ble_l2cap_cid_unregister' called less times than expected.");
+  if (Mock.sd_ble_l2cap_cid_unregister_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_l2cap_cid_unregister_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_l2cap_tx_CallInstance, cmock_line, "Function 'sd_ble_l2cap_tx' called less times than expected.");
+  if (Mock.sd_ble_l2cap_tx_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_l2cap_tx_CallInstance = CMOCK_GUTS_NONE;
+}
+
+void mock_ble_l2cap_Init(void)
+{
+  mock_ble_l2cap_Destroy();
+}
+
+void mock_ble_l2cap_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  Mock.sd_ble_l2cap_cid_register_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_l2cap_cid_register_CallbackCalls = 0;
+  Mock.sd_ble_l2cap_cid_unregister_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_l2cap_cid_unregister_CallbackCalls = 0;
+  Mock.sd_ble_l2cap_tx_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_l2cap_tx_CallbackCalls = 0;
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+uint32_t sd_ble_l2cap_cid_register(uint16_t cid)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_l2cap_cid_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_l2cap_cid_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_l2cap_cid_register_CallInstance);
+  Mock.sd_ble_l2cap_cid_register_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_l2cap_cid_register_CallInstance);
+  if (Mock.sd_ble_l2cap_cid_register_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_l2cap_cid_register_FinalReturn;
+    Mock.sd_ble_l2cap_cid_register_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_l2cap_cid_register_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_l2cap_cid_register_CallbackFunctionPointer(cid, Mock.sd_ble_l2cap_cid_register_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_l2cap_cid_register' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_l2cap_cid_register' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_l2cap_cid_register' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_cid)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_cid, cid, cmock_line, "Function 'sd_ble_l2cap_cid_register' called with unexpected value for argument 'cid'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_l2cap_cid_register(CMOCK_sd_ble_l2cap_cid_register_CALL_INSTANCE* cmock_call_instance, uint16_t cid)
+{
+  cmock_call_instance->Expected_cid = cid;
+  cmock_call_instance->IgnoreArg_cid = 0;
+}
+
+void sd_ble_l2cap_cid_register_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_l2cap_cid_register_CALL_INSTANCE));
+  CMOCK_sd_ble_l2cap_cid_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_l2cap_cid_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_l2cap_cid_register_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_l2cap_cid_register_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_l2cap_cid_register_IgnoreBool = (int)1;
+}
+
+void sd_ble_l2cap_cid_register_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t cid, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_l2cap_cid_register_CALL_INSTANCE));
+  CMOCK_sd_ble_l2cap_cid_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_l2cap_cid_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_l2cap_cid_register_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_l2cap_cid_register_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_l2cap_cid_register(cmock_call_instance, cid);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_l2cap_cid_register_StubWithCallback(CMOCK_sd_ble_l2cap_cid_register_CALLBACK Callback)
+{
+  Mock.sd_ble_l2cap_cid_register_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_l2cap_cid_register_CMockIgnoreArg_cid(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_l2cap_cid_register_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_l2cap_cid_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_l2cap_cid_register_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "cid IgnoreArg called before Expect on 'sd_ble_l2cap_cid_register'.");
+  cmock_call_instance->IgnoreArg_cid = 1;
+}
+
+uint32_t sd_ble_l2cap_cid_unregister(uint16_t cid)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_l2cap_cid_unregister_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_l2cap_cid_unregister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_l2cap_cid_unregister_CallInstance);
+  Mock.sd_ble_l2cap_cid_unregister_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_l2cap_cid_unregister_CallInstance);
+  if (Mock.sd_ble_l2cap_cid_unregister_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_l2cap_cid_unregister_FinalReturn;
+    Mock.sd_ble_l2cap_cid_unregister_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_l2cap_cid_unregister_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_l2cap_cid_unregister_CallbackFunctionPointer(cid, Mock.sd_ble_l2cap_cid_unregister_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_l2cap_cid_unregister' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_l2cap_cid_unregister' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_l2cap_cid_unregister' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_cid)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_cid, cid, cmock_line, "Function 'sd_ble_l2cap_cid_unregister' called with unexpected value for argument 'cid'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_l2cap_cid_unregister(CMOCK_sd_ble_l2cap_cid_unregister_CALL_INSTANCE* cmock_call_instance, uint16_t cid)
+{
+  cmock_call_instance->Expected_cid = cid;
+  cmock_call_instance->IgnoreArg_cid = 0;
+}
+
+void sd_ble_l2cap_cid_unregister_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_l2cap_cid_unregister_CALL_INSTANCE));
+  CMOCK_sd_ble_l2cap_cid_unregister_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_l2cap_cid_unregister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_l2cap_cid_unregister_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_l2cap_cid_unregister_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_l2cap_cid_unregister_IgnoreBool = (int)1;
+}
+
+void sd_ble_l2cap_cid_unregister_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t cid, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_l2cap_cid_unregister_CALL_INSTANCE));
+  CMOCK_sd_ble_l2cap_cid_unregister_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_l2cap_cid_unregister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_l2cap_cid_unregister_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_l2cap_cid_unregister_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_l2cap_cid_unregister(cmock_call_instance, cid);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_l2cap_cid_unregister_StubWithCallback(CMOCK_sd_ble_l2cap_cid_unregister_CALLBACK Callback)
+{
+  Mock.sd_ble_l2cap_cid_unregister_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_l2cap_cid_unregister_CMockIgnoreArg_cid(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_l2cap_cid_unregister_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_l2cap_cid_unregister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_l2cap_cid_unregister_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "cid IgnoreArg called before Expect on 'sd_ble_l2cap_cid_unregister'.");
+  cmock_call_instance->IgnoreArg_cid = 1;
+}
+
+uint32_t sd_ble_l2cap_tx(uint16_t conn_handle, ble_l2cap_header_t const* p_header, uint8_t const* p_data)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_l2cap_tx_CallInstance);
+  Mock.sd_ble_l2cap_tx_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_l2cap_tx_CallInstance);
+  if (Mock.sd_ble_l2cap_tx_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_l2cap_tx_FinalReturn;
+    Mock.sd_ble_l2cap_tx_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_l2cap_tx_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_l2cap_tx_CallbackFunctionPointer(conn_handle, p_header, p_data, Mock.sd_ble_l2cap_tx_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_l2cap_tx' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_l2cap_tx' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_l2cap_tx' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_l2cap_tx' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_header)
+  {
+    if (cmock_call_instance->Expected_p_header == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_header, cmock_line, "Expected NULL. Function 'sd_ble_l2cap_tx' called with unexpected value for argument 'p_header'."); }
+    else if (cmock_call_instance->Expected_p_header_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_header, p_header, cmock_line, "Function 'sd_ble_l2cap_tx' called with unexpected value for argument 'p_header'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_header), (void*)(p_header), sizeof(ble_l2cap_header_t), cmock_call_instance->Expected_p_header_Depth, cmock_line, "Function 'sd_ble_l2cap_tx' called with unexpected value for argument 'p_header'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_data)
+  {
+    if (cmock_call_instance->Expected_p_data == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_data, cmock_line, "Expected NULL. Function 'sd_ble_l2cap_tx' called with unexpected value for argument 'p_data'."); }
+    else if (cmock_call_instance->Expected_p_data_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_data, p_data, cmock_line, "Function 'sd_ble_l2cap_tx' called with unexpected value for argument 'p_data'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_data, p_data, cmock_call_instance->Expected_p_data_Depth, cmock_line, "Function 'sd_ble_l2cap_tx' called with unexpected value for argument 'p_data'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_header_Used)
+  {
+    memcpy((void*)p_header, (void*)cmock_call_instance->ReturnThruPtr_p_header_Val,
+      cmock_call_instance->ReturnThruPtr_p_header_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_data_Used)
+  {
+    memcpy((void*)p_data, (void*)cmock_call_instance->ReturnThruPtr_p_data_Val,
+      cmock_call_instance->ReturnThruPtr_p_data_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_l2cap_tx(CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_l2cap_header_t const* p_header, int p_header_Depth, uint8_t const* p_data, int p_data_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_header = p_header;
+  cmock_call_instance->Expected_p_header_Depth = p_header_Depth;
+  cmock_call_instance->IgnoreArg_p_header = 0;
+  cmock_call_instance->ReturnThruPtr_p_header_Used = 0;
+  cmock_call_instance->Expected_p_data = p_data;
+  cmock_call_instance->Expected_p_data_Depth = p_data_Depth;
+  cmock_call_instance->IgnoreArg_p_data = 0;
+  cmock_call_instance->ReturnThruPtr_p_data_Used = 0;
+}
+
+void sd_ble_l2cap_tx_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE));
+  CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_l2cap_tx_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_l2cap_tx_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_l2cap_tx_IgnoreBool = (int)1;
+}
+
+void sd_ble_l2cap_tx_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_l2cap_header_t const* p_header, uint8_t const* p_data, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE));
+  CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_l2cap_tx_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_l2cap_tx_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_l2cap_tx(cmock_call_instance, conn_handle, p_header, 0, p_data, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_l2cap_tx_StubWithCallback(CMOCK_sd_ble_l2cap_tx_CALLBACK Callback)
+{
+  Mock.sd_ble_l2cap_tx_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_l2cap_tx_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_l2cap_header_t const* p_header, int p_header_Depth, uint8_t const* p_data, int p_data_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE));
+  CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_l2cap_tx_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_l2cap_tx_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_l2cap_tx(cmock_call_instance, conn_handle, p_header, p_header_Depth, p_data, p_data_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_l2cap_tx_CMockReturnMemThruPtr_p_header(UNITY_LINE_TYPE cmock_line, ble_l2cap_header_t const* p_header, int cmock_size)
+{
+  CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_l2cap_tx_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_header ReturnThruPtr called before Expect on 'sd_ble_l2cap_tx'.");
+  cmock_call_instance->ReturnThruPtr_p_header_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_header_Val = p_header;
+  cmock_call_instance->ReturnThruPtr_p_header_Size = cmock_size;
+}
+
+void sd_ble_l2cap_tx_CMockReturnMemThruPtr_p_data(UNITY_LINE_TYPE cmock_line, uint8_t const* p_data, int cmock_size)
+{
+  CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_l2cap_tx_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_data ReturnThruPtr called before Expect on 'sd_ble_l2cap_tx'.");
+  cmock_call_instance->ReturnThruPtr_p_data_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_data_Val = p_data;
+  cmock_call_instance->ReturnThruPtr_p_data_Size = cmock_size;
+}
+
+void sd_ble_l2cap_tx_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_l2cap_tx_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_l2cap_tx'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_l2cap_tx_CMockIgnoreArg_p_header(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_l2cap_tx_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_header IgnoreArg called before Expect on 'sd_ble_l2cap_tx'.");
+  cmock_call_instance->IgnoreArg_p_header = 1;
+}
+
+void sd_ble_l2cap_tx_CMockIgnoreArg_p_data(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_l2cap_tx_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_l2cap_tx_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_data IgnoreArg called before Expect on 'sd_ble_l2cap_tx'.");
+  cmock_call_instance->IgnoreArg_p_data = 1;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_l2cap.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_l2cap.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_l2cap.h   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_l2cap.h    2018-04-24 08:48:28.838151700 +0200
@@ -0,0 +1,64 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_BLE_L2CAP_H
+#define _MOCK_BLE_L2CAP_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <ble_l2cap.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_ble_l2cap_Init(void);
+void mock_ble_l2cap_Destroy(void);
+void mock_ble_l2cap_Verify(void);
+
+
+
+
+#define sd_ble_l2cap_cid_register_IgnoreAndReturn(cmock_retval) sd_ble_l2cap_cid_register_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_l2cap_cid_register_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_l2cap_cid_register_ExpectAndReturn(cid, cmock_retval) sd_ble_l2cap_cid_register_CMockExpectAndReturn(__LINE__, cid, cmock_retval)
+void sd_ble_l2cap_cid_register_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t cid, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_l2cap_cid_register_CALLBACK)(uint16_t cid, int cmock_num_calls);
+void sd_ble_l2cap_cid_register_StubWithCallback(CMOCK_sd_ble_l2cap_cid_register_CALLBACK Callback);
+#define sd_ble_l2cap_cid_register_IgnoreArg_cid() sd_ble_l2cap_cid_register_CMockIgnoreArg_cid(__LINE__)
+void sd_ble_l2cap_cid_register_CMockIgnoreArg_cid(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_l2cap_cid_unregister_IgnoreAndReturn(cmock_retval) sd_ble_l2cap_cid_unregister_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_l2cap_cid_unregister_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_l2cap_cid_unregister_ExpectAndReturn(cid, cmock_retval) sd_ble_l2cap_cid_unregister_CMockExpectAndReturn(__LINE__, cid, cmock_retval)
+void sd_ble_l2cap_cid_unregister_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t cid, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_l2cap_cid_unregister_CALLBACK)(uint16_t cid, int cmock_num_calls);
+void sd_ble_l2cap_cid_unregister_StubWithCallback(CMOCK_sd_ble_l2cap_cid_unregister_CALLBACK Callback);
+#define sd_ble_l2cap_cid_unregister_IgnoreArg_cid() sd_ble_l2cap_cid_unregister_CMockIgnoreArg_cid(__LINE__)
+void sd_ble_l2cap_cid_unregister_CMockIgnoreArg_cid(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_l2cap_tx_IgnoreAndReturn(cmock_retval) sd_ble_l2cap_tx_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_l2cap_tx_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_l2cap_tx_ExpectAndReturn(conn_handle, p_header, p_data, cmock_retval) sd_ble_l2cap_tx_CMockExpectAndReturn(__LINE__, conn_handle, p_header, p_data, cmock_retval)
+void sd_ble_l2cap_tx_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_l2cap_header_t const* p_header, uint8_t const* p_data, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_l2cap_tx_CALLBACK)(uint16_t conn_handle, ble_l2cap_header_t const* p_header, uint8_t const* p_data, int cmock_num_calls);
+void sd_ble_l2cap_tx_StubWithCallback(CMOCK_sd_ble_l2cap_tx_CALLBACK Callback);
+#define sd_ble_l2cap_tx_ExpectWithArrayAndReturn(conn_handle, p_header, p_header_Depth, p_data, p_data_Depth, cmock_retval) sd_ble_l2cap_tx_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_header, p_header_Depth, p_data, p_data_Depth, cmock_retval)
+void sd_ble_l2cap_tx_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_l2cap_header_t const* p_header, int p_header_Depth, uint8_t const* p_data, int p_data_Depth, uint32_t cmock_to_return);
+#define sd_ble_l2cap_tx_ReturnThruPtr_p_header(p_header) sd_ble_l2cap_tx_CMockReturnMemThruPtr_p_header(__LINE__, p_header, sizeof(*p_header))
+#define sd_ble_l2cap_tx_ReturnArrayThruPtr_p_header(p_header, cmock_len) sd_ble_l2cap_tx_CMockReturnMemThruPtr_p_header(__LINE__, p_header, cmock_len * sizeof(*p_header))
+#define sd_ble_l2cap_tx_ReturnMemThruPtr_p_header(p_header, cmock_size) sd_ble_l2cap_tx_CMockReturnMemThruPtr_p_header(__LINE__, p_header, cmock_size)
+void sd_ble_l2cap_tx_CMockReturnMemThruPtr_p_header(UNITY_LINE_TYPE cmock_line, ble_l2cap_header_t const* p_header, int cmock_size);
+#define sd_ble_l2cap_tx_ReturnThruPtr_p_data(p_data) sd_ble_l2cap_tx_CMockReturnMemThruPtr_p_data(__LINE__, p_data, sizeof(*p_data))
+#define sd_ble_l2cap_tx_ReturnArrayThruPtr_p_data(p_data, cmock_len) sd_ble_l2cap_tx_CMockReturnMemThruPtr_p_data(__LINE__, p_data, cmock_len * sizeof(*p_data))
+#define sd_ble_l2cap_tx_ReturnMemThruPtr_p_data(p_data, cmock_size) sd_ble_l2cap_tx_CMockReturnMemThruPtr_p_data(__LINE__, p_data, cmock_size)
+void sd_ble_l2cap_tx_CMockReturnMemThruPtr_p_data(UNITY_LINE_TYPE cmock_line, uint8_t const* p_data, int cmock_size);
+#define sd_ble_l2cap_tx_IgnoreArg_conn_handle() sd_ble_l2cap_tx_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_l2cap_tx_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_l2cap_tx_IgnoreArg_p_header() sd_ble_l2cap_tx_CMockIgnoreArg_p_header(__LINE__)
+void sd_ble_l2cap_tx_CMockIgnoreArg_p_header(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_l2cap_tx_IgnoreArg_p_data() sd_ble_l2cap_tx_CMockIgnoreArg_p_data(__LINE__)
+void sd_ble_l2cap_tx_CMockIgnoreArg_p_data(UNITY_LINE_TYPE cmock_line);
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_ranges.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_ranges.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_ranges.c  1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_ranges.c   2018-04-24 08:48:28.838151700 +0200
@@ -0,0 +1,36 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_ble_ranges.h"
+
+static struct mock_ble_rangesInstance
+{
+  unsigned char placeHolder;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_ble_ranges_Verify(void)
+{
+}
+
+void mock_ble_ranges_Init(void)
+{
+  mock_ble_ranges_Destroy();
+}
+
+void mock_ble_ranges_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_ranges.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_ranges.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_ranges.h  1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_ranges.h   2018-04-24 08:48:28.838151700 +0200
@@ -0,0 +1,26 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_BLE_RANGES_H
+#define _MOCK_BLE_RANGES_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <ble_ranges.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_ble_ranges_Init(void);
+void mock_ble_ranges_Destroy(void);
+void mock_ble_ranges_Verify(void);
+
+
+
+
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_types.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_types.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_types.c   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_types.c    2018-04-24 08:48:28.848151900 +0200
@@ -0,0 +1,36 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_ble_types.h"
+
+static struct mock_ble_typesInstance
+{
+  unsigned char placeHolder;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_ble_types_Verify(void)
+{
+}
+
+void mock_ble_types_Init(void)
+{
+  mock_ble_types_Destroy();
+}
+
+void mock_ble_types_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_types.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_types.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_ble_types.h   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_ble_types.h    2018-04-24 08:48:28.848151900 +0200
@@ -0,0 +1,26 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_BLE_TYPES_H
+#define _MOCK_BLE_TYPES_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <ble_types.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_ble_types_Init(void);
+void mock_ble_types_Destroy(void);
+void mock_ble_types_Verify(void);
+
+
+
+
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_error.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_error.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_error.c   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_error.c    2018-04-24 08:48:28.848151900 +0200
@@ -0,0 +1,36 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_nrf_error.h"
+
+static struct mock_nrf_errorInstance
+{
+  unsigned char placeHolder;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_nrf_error_Verify(void)
+{
+}
+
+void mock_nrf_error_Init(void)
+{
+  mock_nrf_error_Destroy();
+}
+
+void mock_nrf_error_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_error.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_error.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_error.h   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_error.h    2018-04-24 08:48:28.858152100 +0200
@@ -0,0 +1,26 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_NRF_ERROR_H
+#define _MOCK_NRF_ERROR_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <nrf_error.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_nrf_error_Init(void);
+void mock_nrf_error_Destroy(void);
+void mock_nrf_error_Verify(void);
+
+
+
+
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_error_sdm.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_error_sdm.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_error_sdm.c   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_error_sdm.c    2018-04-24 08:48:28.858152100 +0200
@@ -0,0 +1,36 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_nrf_error_sdm.h"
+
+static struct mock_nrf_error_sdmInstance
+{
+  unsigned char placeHolder;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_nrf_error_sdm_Verify(void)
+{
+}
+
+void mock_nrf_error_sdm_Init(void)
+{
+  mock_nrf_error_sdm_Destroy();
+}
+
+void mock_nrf_error_sdm_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_error_sdm.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_error_sdm.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_error_sdm.h   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_error_sdm.h    2018-04-24 08:48:28.858152100 +0200
@@ -0,0 +1,26 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_NRF_ERROR_SDM_H
+#define _MOCK_NRF_ERROR_SDM_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <nrf_error_sdm.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_nrf_error_sdm_Init(void);
+void mock_nrf_error_sdm_Destroy(void);
+void mock_nrf_error_sdm_Verify(void);
+
+
+
+
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_error_soc.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_error_soc.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_error_soc.c   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_error_soc.c    2018-04-24 08:48:28.868152300 +0200
@@ -0,0 +1,36 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_nrf_error_soc.h"
+
+static struct mock_nrf_error_socInstance
+{
+  unsigned char placeHolder;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_nrf_error_soc_Verify(void)
+{
+}
+
+void mock_nrf_error_soc_Init(void)
+{
+  mock_nrf_error_soc_Destroy();
+}
+
+void mock_nrf_error_soc_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_error_soc.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_error_soc.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_error_soc.h   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_error_soc.h    2018-04-24 08:48:28.868152300 +0200
@@ -0,0 +1,26 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_NRF_ERROR_SOC_H
+#define _MOCK_NRF_ERROR_SOC_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <nrf_error_soc.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_nrf_error_soc_Init(void);
+void mock_nrf_error_soc_Destroy(void);
+void mock_nrf_error_soc_Verify(void);
+
+
+
+
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_mbr.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_mbr.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_mbr.c 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_mbr.c  2018-04-24 08:48:28.878152500 +0200
@@ -0,0 +1,163 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_nrf_mbr.h"
+
+typedef struct _CMOCK_sd_mbr_command_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  sd_mbr_command_t* Expected_param;
+  int Expected_param_Depth;
+  int ReturnThruPtr_param_Used;
+  sd_mbr_command_t* ReturnThruPtr_param_Val;
+  int ReturnThruPtr_param_Size;
+  int IgnoreArg_param;
+
+} CMOCK_sd_mbr_command_CALL_INSTANCE;
+
+static struct mock_nrf_mbrInstance
+{
+  int sd_mbr_command_IgnoreBool;
+  uint32_t sd_mbr_command_FinalReturn;
+  CMOCK_sd_mbr_command_CALLBACK sd_mbr_command_CallbackFunctionPointer;
+  int sd_mbr_command_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_mbr_command_CallInstance;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_nrf_mbr_Verify(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_mbr_command_CallInstance, cmock_line, "Function 'sd_mbr_command' called less times than expected.");
+  if (Mock.sd_mbr_command_CallbackFunctionPointer != NULL)
+    Mock.sd_mbr_command_CallInstance = CMOCK_GUTS_NONE;
+}
+
+void mock_nrf_mbr_Init(void)
+{
+  mock_nrf_mbr_Destroy();
+}
+
+void mock_nrf_mbr_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  Mock.sd_mbr_command_CallbackFunctionPointer = NULL;
+  Mock.sd_mbr_command_CallbackCalls = 0;
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+uint32_t sd_mbr_command(sd_mbr_command_t* param)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_mbr_command_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_mbr_command_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_mbr_command_CallInstance);
+  Mock.sd_mbr_command_CallInstance = CMock_Guts_MemNext(Mock.sd_mbr_command_CallInstance);
+  if (Mock.sd_mbr_command_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_mbr_command_FinalReturn;
+    Mock.sd_mbr_command_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_mbr_command_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_mbr_command_CallbackFunctionPointer(param, Mock.sd_mbr_command_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_mbr_command' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_mbr_command' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_mbr_command' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_param)
+  {
+    if (cmock_call_instance->Expected_param == NULL)
+      { UNITY_TEST_ASSERT_NULL(param, cmock_line, "Expected NULL. Function 'sd_mbr_command' called with unexpected value for argument 'param'."); }
+    else if (cmock_call_instance->Expected_param_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_param, param, cmock_line, "Function 'sd_mbr_command' called with unexpected value for argument 'param'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_param), (void*)(param), sizeof(sd_mbr_command_t), cmock_call_instance->Expected_param_Depth, cmock_line, "Function 'sd_mbr_command' called with unexpected value for argument 'param'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_param_Used)
+  {
+    memcpy((void*)param, (void*)cmock_call_instance->ReturnThruPtr_param_Val,
+      cmock_call_instance->ReturnThruPtr_param_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_mbr_command(CMOCK_sd_mbr_command_CALL_INSTANCE* cmock_call_instance, sd_mbr_command_t* param, int param_Depth)
+{
+  cmock_call_instance->Expected_param = param;
+  cmock_call_instance->Expected_param_Depth = param_Depth;
+  cmock_call_instance->IgnoreArg_param = 0;
+  cmock_call_instance->ReturnThruPtr_param_Used = 0;
+}
+
+void sd_mbr_command_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_mbr_command_CALL_INSTANCE));
+  CMOCK_sd_mbr_command_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_mbr_command_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_mbr_command_CallInstance = CMock_Guts_MemChain(Mock.sd_mbr_command_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_mbr_command_IgnoreBool = (int)1;
+}
+
+void sd_mbr_command_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, sd_mbr_command_t* param, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_mbr_command_CALL_INSTANCE));
+  CMOCK_sd_mbr_command_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_mbr_command_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_mbr_command_CallInstance = CMock_Guts_MemChain(Mock.sd_mbr_command_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_mbr_command(cmock_call_instance, param, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_mbr_command_StubWithCallback(CMOCK_sd_mbr_command_CALLBACK Callback)
+{
+  Mock.sd_mbr_command_CallbackFunctionPointer = Callback;
+}
+
+void sd_mbr_command_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, sd_mbr_command_t* param, int param_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_mbr_command_CALL_INSTANCE));
+  CMOCK_sd_mbr_command_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_mbr_command_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_mbr_command_CallInstance = CMock_Guts_MemChain(Mock.sd_mbr_command_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_mbr_command(cmock_call_instance, param, param_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_mbr_command_CMockReturnMemThruPtr_param(UNITY_LINE_TYPE cmock_line, sd_mbr_command_t* param, int cmock_size)
+{
+  CMOCK_sd_mbr_command_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_mbr_command_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_mbr_command_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "param ReturnThruPtr called before Expect on 'sd_mbr_command'.");
+  cmock_call_instance->ReturnThruPtr_param_Used = 1;
+  cmock_call_instance->ReturnThruPtr_param_Val = param;
+  cmock_call_instance->ReturnThruPtr_param_Size = cmock_size;
+}
+
+void sd_mbr_command_CMockIgnoreArg_param(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_mbr_command_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_mbr_command_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_mbr_command_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "param IgnoreArg called before Expect on 'sd_mbr_command'.");
+  cmock_call_instance->IgnoreArg_param = 1;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_mbr.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_mbr.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_mbr.h 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_mbr.h  2018-04-24 08:48:28.878152500 +0200
@@ -0,0 +1,40 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_NRF_MBR_H
+#define _MOCK_NRF_MBR_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <nrf_mbr.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_nrf_mbr_Init(void);
+void mock_nrf_mbr_Destroy(void);
+void mock_nrf_mbr_Verify(void);
+
+
+
+
+#define sd_mbr_command_IgnoreAndReturn(cmock_retval) sd_mbr_command_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_mbr_command_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_mbr_command_ExpectAndReturn(param, cmock_retval) sd_mbr_command_CMockExpectAndReturn(__LINE__, param, cmock_retval)
+void sd_mbr_command_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, sd_mbr_command_t* param, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_mbr_command_CALLBACK)(sd_mbr_command_t* param, int cmock_num_calls);
+void sd_mbr_command_StubWithCallback(CMOCK_sd_mbr_command_CALLBACK Callback);
+#define sd_mbr_command_ExpectWithArrayAndReturn(param, param_Depth, cmock_retval) sd_mbr_command_CMockExpectWithArrayAndReturn(__LINE__, param, param_Depth, cmock_retval)
+void sd_mbr_command_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, sd_mbr_command_t* param, int param_Depth, uint32_t cmock_to_return);
+#define sd_mbr_command_ReturnThruPtr_param(param) sd_mbr_command_CMockReturnMemThruPtr_param(__LINE__, param, sizeof(*param))
+#define sd_mbr_command_ReturnArrayThruPtr_param(param, cmock_len) sd_mbr_command_CMockReturnMemThruPtr_param(__LINE__, param, cmock_len * sizeof(*param))
+#define sd_mbr_command_ReturnMemThruPtr_param(param, cmock_size) sd_mbr_command_CMockReturnMemThruPtr_param(__LINE__, param, cmock_size)
+void sd_mbr_command_CMockReturnMemThruPtr_param(UNITY_LINE_TYPE cmock_line, sd_mbr_command_t* param, int cmock_size);
+#define sd_mbr_command_IgnoreArg_param() sd_mbr_command_CMockIgnoreArg_param(__LINE__)
+void sd_mbr_command_CMockIgnoreArg_param(UNITY_LINE_TYPE cmock_line);
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_nvic.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_nvic.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_nvic.c    1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_nvic.c 2018-04-24 08:48:28.888152700 +0200
@@ -0,0 +1,1380 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_nrf_nvic.h"
+
+typedef struct _CMOCK___sd_nvic_irq_disable_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  int ReturnVal;
+  int CallOrder;
+
+} CMOCK___sd_nvic_irq_disable_CALL_INSTANCE;
+
+typedef struct _CMOCK___sd_nvic_irq_enable_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  int CallOrder;
+
+} CMOCK___sd_nvic_irq_enable_CALL_INSTANCE;
+
+typedef struct _CMOCK___sd_nvic_app_accessible_irq_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  IRQn_Type Expected_IRQn;
+  int IgnoreArg_IRQn;
+
+} CMOCK___sd_nvic_app_accessible_irq_CALL_INSTANCE;
+
+typedef struct _CMOCK___sd_nvic_is_app_accessible_priority_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t Expected_priority;
+  int IgnoreArg_priority;
+
+} CMOCK___sd_nvic_is_app_accessible_priority_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_nvic_EnableIRQ_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  IRQn_Type Expected_IRQn;
+  int IgnoreArg_IRQn;
+
+} CMOCK_sd_nvic_EnableIRQ_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_nvic_DisableIRQ_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  IRQn_Type Expected_IRQn;
+  int IgnoreArg_IRQn;
+
+} CMOCK_sd_nvic_DisableIRQ_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  IRQn_Type Expected_IRQn;
+  uint32_t* Expected_p_pending_irq;
+  int Expected_p_pending_irq_Depth;
+  int ReturnThruPtr_p_pending_irq_Used;
+  uint32_t* ReturnThruPtr_p_pending_irq_Val;
+  int ReturnThruPtr_p_pending_irq_Size;
+  int IgnoreArg_IRQn;
+  int IgnoreArg_p_pending_irq;
+
+} CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_nvic_SetPendingIRQ_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  IRQn_Type Expected_IRQn;
+  int IgnoreArg_IRQn;
+
+} CMOCK_sd_nvic_SetPendingIRQ_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_nvic_ClearPendingIRQ_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  IRQn_Type Expected_IRQn;
+  int IgnoreArg_IRQn;
+
+} CMOCK_sd_nvic_ClearPendingIRQ_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_nvic_SetPriority_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  IRQn_Type Expected_IRQn;
+  uint32_t Expected_priority;
+  int IgnoreArg_IRQn;
+  int IgnoreArg_priority;
+
+} CMOCK_sd_nvic_SetPriority_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_nvic_GetPriority_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  IRQn_Type Expected_IRQn;
+  uint32_t* Expected_p_priority;
+  int Expected_p_priority_Depth;
+  int ReturnThruPtr_p_priority_Used;
+  uint32_t* ReturnThruPtr_p_priority_Val;
+  int ReturnThruPtr_p_priority_Size;
+  int IgnoreArg_IRQn;
+  int IgnoreArg_p_priority;
+
+} CMOCK_sd_nvic_GetPriority_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_nvic_SystemReset_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+
+} CMOCK_sd_nvic_SystemReset_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t* Expected_p_is_nested_critical_region;
+  int Expected_p_is_nested_critical_region_Depth;
+  int ReturnThruPtr_p_is_nested_critical_region_Used;
+  uint8_t* ReturnThruPtr_p_is_nested_critical_region_Val;
+  int ReturnThruPtr_p_is_nested_critical_region_Size;
+  int IgnoreArg_p_is_nested_critical_region;
+
+} CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_nvic_critical_region_exit_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t Expected_is_nested_critical_region;
+  int IgnoreArg_is_nested_critical_region;
+
+} CMOCK_sd_nvic_critical_region_exit_CALL_INSTANCE;
+
+static struct mock_nrf_nvicInstance
+{
+  int __sd_nvic_irq_disable_IgnoreBool;
+  int __sd_nvic_irq_disable_FinalReturn;
+  CMOCK___sd_nvic_irq_disable_CALLBACK __sd_nvic_irq_disable_CallbackFunctionPointer;
+  int __sd_nvic_irq_disable_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE __sd_nvic_irq_disable_CallInstance;
+  int __sd_nvic_irq_enable_IgnoreBool;
+  CMOCK___sd_nvic_irq_enable_CALLBACK __sd_nvic_irq_enable_CallbackFunctionPointer;
+  int __sd_nvic_irq_enable_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE __sd_nvic_irq_enable_CallInstance;
+  int __sd_nvic_app_accessible_irq_IgnoreBool;
+  uint32_t __sd_nvic_app_accessible_irq_FinalReturn;
+  CMOCK___sd_nvic_app_accessible_irq_CALLBACK __sd_nvic_app_accessible_irq_CallbackFunctionPointer;
+  int __sd_nvic_app_accessible_irq_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE __sd_nvic_app_accessible_irq_CallInstance;
+  int __sd_nvic_is_app_accessible_priority_IgnoreBool;
+  uint32_t __sd_nvic_is_app_accessible_priority_FinalReturn;
+  CMOCK___sd_nvic_is_app_accessible_priority_CALLBACK __sd_nvic_is_app_accessible_priority_CallbackFunctionPointer;
+  int __sd_nvic_is_app_accessible_priority_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE __sd_nvic_is_app_accessible_priority_CallInstance;
+  int sd_nvic_EnableIRQ_IgnoreBool;
+  uint32_t sd_nvic_EnableIRQ_FinalReturn;
+  CMOCK_sd_nvic_EnableIRQ_CALLBACK sd_nvic_EnableIRQ_CallbackFunctionPointer;
+  int sd_nvic_EnableIRQ_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_nvic_EnableIRQ_CallInstance;
+  int sd_nvic_DisableIRQ_IgnoreBool;
+  uint32_t sd_nvic_DisableIRQ_FinalReturn;
+  CMOCK_sd_nvic_DisableIRQ_CALLBACK sd_nvic_DisableIRQ_CallbackFunctionPointer;
+  int sd_nvic_DisableIRQ_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_nvic_DisableIRQ_CallInstance;
+  int sd_nvic_GetPendingIRQ_IgnoreBool;
+  uint32_t sd_nvic_GetPendingIRQ_FinalReturn;
+  CMOCK_sd_nvic_GetPendingIRQ_CALLBACK sd_nvic_GetPendingIRQ_CallbackFunctionPointer;
+  int sd_nvic_GetPendingIRQ_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_nvic_GetPendingIRQ_CallInstance;
+  int sd_nvic_SetPendingIRQ_IgnoreBool;
+  uint32_t sd_nvic_SetPendingIRQ_FinalReturn;
+  CMOCK_sd_nvic_SetPendingIRQ_CALLBACK sd_nvic_SetPendingIRQ_CallbackFunctionPointer;
+  int sd_nvic_SetPendingIRQ_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_nvic_SetPendingIRQ_CallInstance;
+  int sd_nvic_ClearPendingIRQ_IgnoreBool;
+  uint32_t sd_nvic_ClearPendingIRQ_FinalReturn;
+  CMOCK_sd_nvic_ClearPendingIRQ_CALLBACK sd_nvic_ClearPendingIRQ_CallbackFunctionPointer;
+  int sd_nvic_ClearPendingIRQ_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_nvic_ClearPendingIRQ_CallInstance;
+  int sd_nvic_SetPriority_IgnoreBool;
+  uint32_t sd_nvic_SetPriority_FinalReturn;
+  CMOCK_sd_nvic_SetPriority_CALLBACK sd_nvic_SetPriority_CallbackFunctionPointer;
+  int sd_nvic_SetPriority_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_nvic_SetPriority_CallInstance;
+  int sd_nvic_GetPriority_IgnoreBool;
+  uint32_t sd_nvic_GetPriority_FinalReturn;
+  CMOCK_sd_nvic_GetPriority_CALLBACK sd_nvic_GetPriority_CallbackFunctionPointer;
+  int sd_nvic_GetPriority_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_nvic_GetPriority_CallInstance;
+  int sd_nvic_SystemReset_IgnoreBool;
+  uint32_t sd_nvic_SystemReset_FinalReturn;
+  CMOCK_sd_nvic_SystemReset_CALLBACK sd_nvic_SystemReset_CallbackFunctionPointer;
+  int sd_nvic_SystemReset_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_nvic_SystemReset_CallInstance;
+  int sd_nvic_critical_region_enter_IgnoreBool;
+  uint32_t sd_nvic_critical_region_enter_FinalReturn;
+  CMOCK_sd_nvic_critical_region_enter_CALLBACK sd_nvic_critical_region_enter_CallbackFunctionPointer;
+  int sd_nvic_critical_region_enter_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_nvic_critical_region_enter_CallInstance;
+  int sd_nvic_critical_region_exit_IgnoreBool;
+  uint32_t sd_nvic_critical_region_exit_FinalReturn;
+  CMOCK_sd_nvic_critical_region_exit_CALLBACK sd_nvic_critical_region_exit_CallbackFunctionPointer;
+  int sd_nvic_critical_region_exit_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_nvic_critical_region_exit_CallInstance;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_nrf_nvic_Verify(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.__sd_nvic_irq_disable_CallInstance, cmock_line, "Function '__sd_nvic_irq_disable' called less times than expected.");
+  if (Mock.__sd_nvic_irq_disable_CallbackFunctionPointer != NULL)
+    Mock.__sd_nvic_irq_disable_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.__sd_nvic_irq_enable_CallInstance, cmock_line, "Function '__sd_nvic_irq_enable' called less times than expected.");
+  if (Mock.__sd_nvic_irq_enable_CallbackFunctionPointer != NULL)
+    Mock.__sd_nvic_irq_enable_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.__sd_nvic_app_accessible_irq_CallInstance, cmock_line, "Function '__sd_nvic_app_accessible_irq' called less times than expected.");
+  if (Mock.__sd_nvic_app_accessible_irq_CallbackFunctionPointer != NULL)
+    Mock.__sd_nvic_app_accessible_irq_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.__sd_nvic_is_app_accessible_priority_CallInstance, cmock_line, "Function '__sd_nvic_is_app_accessible_priority' called less times than expected.");
+  if (Mock.__sd_nvic_is_app_accessible_priority_CallbackFunctionPointer != NULL)
+    Mock.__sd_nvic_is_app_accessible_priority_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_nvic_EnableIRQ_CallInstance, cmock_line, "Function 'sd_nvic_EnableIRQ' called less times than expected.");
+  if (Mock.sd_nvic_EnableIRQ_CallbackFunctionPointer != NULL)
+    Mock.sd_nvic_EnableIRQ_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_nvic_DisableIRQ_CallInstance, cmock_line, "Function 'sd_nvic_DisableIRQ' called less times than expected.");
+  if (Mock.sd_nvic_DisableIRQ_CallbackFunctionPointer != NULL)
+    Mock.sd_nvic_DisableIRQ_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_nvic_GetPendingIRQ_CallInstance, cmock_line, "Function 'sd_nvic_GetPendingIRQ' called less times than expected.");
+  if (Mock.sd_nvic_GetPendingIRQ_CallbackFunctionPointer != NULL)
+    Mock.sd_nvic_GetPendingIRQ_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_nvic_SetPendingIRQ_CallInstance, cmock_line, "Function 'sd_nvic_SetPendingIRQ' called less times than expected.");
+  if (Mock.sd_nvic_SetPendingIRQ_CallbackFunctionPointer != NULL)
+    Mock.sd_nvic_SetPendingIRQ_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_nvic_ClearPendingIRQ_CallInstance, cmock_line, "Function 'sd_nvic_ClearPendingIRQ' called less times than expected.");
+  if (Mock.sd_nvic_ClearPendingIRQ_CallbackFunctionPointer != NULL)
+    Mock.sd_nvic_ClearPendingIRQ_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_nvic_SetPriority_CallInstance, cmock_line, "Function 'sd_nvic_SetPriority' called less times than expected.");
+  if (Mock.sd_nvic_SetPriority_CallbackFunctionPointer != NULL)
+    Mock.sd_nvic_SetPriority_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_nvic_GetPriority_CallInstance, cmock_line, "Function 'sd_nvic_GetPriority' called less times than expected.");
+  if (Mock.sd_nvic_GetPriority_CallbackFunctionPointer != NULL)
+    Mock.sd_nvic_GetPriority_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_nvic_SystemReset_CallInstance, cmock_line, "Function 'sd_nvic_SystemReset' called less times than expected.");
+  if (Mock.sd_nvic_SystemReset_CallbackFunctionPointer != NULL)
+    Mock.sd_nvic_SystemReset_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_nvic_critical_region_enter_CallInstance, cmock_line, "Function 'sd_nvic_critical_region_enter' called less times than expected.");
+  if (Mock.sd_nvic_critical_region_enter_CallbackFunctionPointer != NULL)
+    Mock.sd_nvic_critical_region_enter_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_nvic_critical_region_exit_CallInstance, cmock_line, "Function 'sd_nvic_critical_region_exit' called less times than expected.");
+  if (Mock.sd_nvic_critical_region_exit_CallbackFunctionPointer != NULL)
+    Mock.sd_nvic_critical_region_exit_CallInstance = CMOCK_GUTS_NONE;
+}
+
+void mock_nrf_nvic_Init(void)
+{
+  mock_nrf_nvic_Destroy();
+}
+
+void mock_nrf_nvic_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  Mock.__sd_nvic_irq_disable_CallbackFunctionPointer = NULL;
+  Mock.__sd_nvic_irq_disable_CallbackCalls = 0;
+  Mock.__sd_nvic_irq_enable_CallbackFunctionPointer = NULL;
+  Mock.__sd_nvic_irq_enable_CallbackCalls = 0;
+  Mock.__sd_nvic_app_accessible_irq_CallbackFunctionPointer = NULL;
+  Mock.__sd_nvic_app_accessible_irq_CallbackCalls = 0;
+  Mock.__sd_nvic_is_app_accessible_priority_CallbackFunctionPointer = NULL;
+  Mock.__sd_nvic_is_app_accessible_priority_CallbackCalls = 0;
+  Mock.sd_nvic_EnableIRQ_CallbackFunctionPointer = NULL;
+  Mock.sd_nvic_EnableIRQ_CallbackCalls = 0;
+  Mock.sd_nvic_DisableIRQ_CallbackFunctionPointer = NULL;
+  Mock.sd_nvic_DisableIRQ_CallbackCalls = 0;
+  Mock.sd_nvic_GetPendingIRQ_CallbackFunctionPointer = NULL;
+  Mock.sd_nvic_GetPendingIRQ_CallbackCalls = 0;
+  Mock.sd_nvic_SetPendingIRQ_CallbackFunctionPointer = NULL;
+  Mock.sd_nvic_SetPendingIRQ_CallbackCalls = 0;
+  Mock.sd_nvic_ClearPendingIRQ_CallbackFunctionPointer = NULL;
+  Mock.sd_nvic_ClearPendingIRQ_CallbackCalls = 0;
+  Mock.sd_nvic_SetPriority_CallbackFunctionPointer = NULL;
+  Mock.sd_nvic_SetPriority_CallbackCalls = 0;
+  Mock.sd_nvic_GetPriority_CallbackFunctionPointer = NULL;
+  Mock.sd_nvic_GetPriority_CallbackCalls = 0;
+  Mock.sd_nvic_SystemReset_CallbackFunctionPointer = NULL;
+  Mock.sd_nvic_SystemReset_CallbackCalls = 0;
+  Mock.sd_nvic_critical_region_enter_CallbackFunctionPointer = NULL;
+  Mock.sd_nvic_critical_region_enter_CallbackCalls = 0;
+  Mock.sd_nvic_critical_region_exit_CallbackFunctionPointer = NULL;
+  Mock.sd_nvic_critical_region_exit_CallbackCalls = 0;
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+int __sd_nvic_irq_disable(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK___sd_nvic_irq_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK___sd_nvic_irq_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.__sd_nvic_irq_disable_CallInstance);
+  Mock.__sd_nvic_irq_disable_CallInstance = CMock_Guts_MemNext(Mock.__sd_nvic_irq_disable_CallInstance);
+  if (Mock.__sd_nvic_irq_disable_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.__sd_nvic_irq_disable_FinalReturn;
+    Mock.__sd_nvic_irq_disable_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.__sd_nvic_irq_disable_CallbackFunctionPointer != NULL)
+  {
+    return Mock.__sd_nvic_irq_disable_CallbackFunctionPointer(Mock.__sd_nvic_irq_disable_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function '__sd_nvic_irq_disable' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function '__sd_nvic_irq_disable' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function '__sd_nvic_irq_disable' called later than expected.");
+  return cmock_call_instance->ReturnVal;
+}
+
+void __sd_nvic_irq_disable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK___sd_nvic_irq_disable_CALL_INSTANCE));
+  CMOCK___sd_nvic_irq_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK___sd_nvic_irq_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.__sd_nvic_irq_disable_CallInstance = CMock_Guts_MemChain(Mock.__sd_nvic_irq_disable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.__sd_nvic_irq_disable_IgnoreBool = (int)1;
+}
+
+void __sd_nvic_irq_disable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK___sd_nvic_irq_disable_CALL_INSTANCE));
+  CMOCK___sd_nvic_irq_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK___sd_nvic_irq_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.__sd_nvic_irq_disable_CallInstance = CMock_Guts_MemChain(Mock.__sd_nvic_irq_disable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void __sd_nvic_irq_disable_StubWithCallback(CMOCK___sd_nvic_irq_disable_CALLBACK Callback)
+{
+  Mock.__sd_nvic_irq_disable_CallbackFunctionPointer = Callback;
+}
+
+void __sd_nvic_irq_enable(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK___sd_nvic_irq_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK___sd_nvic_irq_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.__sd_nvic_irq_enable_CallInstance);
+  Mock.__sd_nvic_irq_enable_CallInstance = CMock_Guts_MemNext(Mock.__sd_nvic_irq_enable_CallInstance);
+  if (Mock.__sd_nvic_irq_enable_IgnoreBool)
+  {
+    return;
+  }
+  if (Mock.__sd_nvic_irq_enable_CallbackFunctionPointer != NULL)
+  {
+    Mock.__sd_nvic_irq_enable_CallbackFunctionPointer(Mock.__sd_nvic_irq_enable_CallbackCalls++);
+    return;
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function '__sd_nvic_irq_enable' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function '__sd_nvic_irq_enable' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function '__sd_nvic_irq_enable' called later than expected.");
+}
+
+void __sd_nvic_irq_enable_CMockIgnore(void)
+{
+  Mock.__sd_nvic_irq_enable_IgnoreBool = (int)1;
+}
+
+void __sd_nvic_irq_enable_CMockExpect(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK___sd_nvic_irq_enable_CALL_INSTANCE));
+  CMOCK___sd_nvic_irq_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK___sd_nvic_irq_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.__sd_nvic_irq_enable_CallInstance = CMock_Guts_MemChain(Mock.__sd_nvic_irq_enable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+}
+
+void __sd_nvic_irq_enable_StubWithCallback(CMOCK___sd_nvic_irq_enable_CALLBACK Callback)
+{
+  Mock.__sd_nvic_irq_enable_CallbackFunctionPointer = Callback;
+}
+
+uint32_t __sd_nvic_app_accessible_irq(IRQn_Type IRQn)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK___sd_nvic_app_accessible_irq_CALL_INSTANCE* cmock_call_instance = (CMOCK___sd_nvic_app_accessible_irq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.__sd_nvic_app_accessible_irq_CallInstance);
+  Mock.__sd_nvic_app_accessible_irq_CallInstance = CMock_Guts_MemNext(Mock.__sd_nvic_app_accessible_irq_CallInstance);
+  if (Mock.__sd_nvic_app_accessible_irq_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.__sd_nvic_app_accessible_irq_FinalReturn;
+    Mock.__sd_nvic_app_accessible_irq_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.__sd_nvic_app_accessible_irq_CallbackFunctionPointer != NULL)
+  {
+    return Mock.__sd_nvic_app_accessible_irq_CallbackFunctionPointer(IRQn, Mock.__sd_nvic_app_accessible_irq_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function '__sd_nvic_app_accessible_irq' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function '__sd_nvic_app_accessible_irq' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function '__sd_nvic_app_accessible_irq' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_IRQn)
+  {
+    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_IRQn), (void*)(&IRQn), sizeof(IRQn_Type), cmock_line, "Function '__sd_nvic_app_accessible_irq' called with unexpected value for argument 'IRQn'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters___sd_nvic_app_accessible_irq(CMOCK___sd_nvic_app_accessible_irq_CALL_INSTANCE* cmock_call_instance, IRQn_Type IRQn)
+{
+  memcpy(&cmock_call_instance->Expected_IRQn, &IRQn, sizeof(IRQn_Type));
+  cmock_call_instance->IgnoreArg_IRQn = 0;
+}
+
+void __sd_nvic_app_accessible_irq_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK___sd_nvic_app_accessible_irq_CALL_INSTANCE));
+  CMOCK___sd_nvic_app_accessible_irq_CALL_INSTANCE* cmock_call_instance = (CMOCK___sd_nvic_app_accessible_irq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.__sd_nvic_app_accessible_irq_CallInstance = CMock_Guts_MemChain(Mock.__sd_nvic_app_accessible_irq_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.__sd_nvic_app_accessible_irq_IgnoreBool = (int)1;
+}
+
+void __sd_nvic_app_accessible_irq_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK___sd_nvic_app_accessible_irq_CALL_INSTANCE));
+  CMOCK___sd_nvic_app_accessible_irq_CALL_INSTANCE* cmock_call_instance = (CMOCK___sd_nvic_app_accessible_irq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.__sd_nvic_app_accessible_irq_CallInstance = CMock_Guts_MemChain(Mock.__sd_nvic_app_accessible_irq_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters___sd_nvic_app_accessible_irq(cmock_call_instance, IRQn);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void __sd_nvic_app_accessible_irq_StubWithCallback(CMOCK___sd_nvic_app_accessible_irq_CALLBACK Callback)
+{
+  Mock.__sd_nvic_app_accessible_irq_CallbackFunctionPointer = Callback;
+}
+
+void __sd_nvic_app_accessible_irq_CMockIgnoreArg_IRQn(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK___sd_nvic_app_accessible_irq_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK___sd_nvic_app_accessible_irq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.__sd_nvic_app_accessible_irq_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "IRQn IgnoreArg called before Expect on '__sd_nvic_app_accessible_irq'.");
+  cmock_call_instance->IgnoreArg_IRQn = 1;
+}
+
+uint32_t __sd_nvic_is_app_accessible_priority(uint32_t priority)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK___sd_nvic_is_app_accessible_priority_CALL_INSTANCE* cmock_call_instance = (CMOCK___sd_nvic_is_app_accessible_priority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.__sd_nvic_is_app_accessible_priority_CallInstance);
+  Mock.__sd_nvic_is_app_accessible_priority_CallInstance = CMock_Guts_MemNext(Mock.__sd_nvic_is_app_accessible_priority_CallInstance);
+  if (Mock.__sd_nvic_is_app_accessible_priority_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.__sd_nvic_is_app_accessible_priority_FinalReturn;
+    Mock.__sd_nvic_is_app_accessible_priority_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.__sd_nvic_is_app_accessible_priority_CallbackFunctionPointer != NULL)
+  {
+    return Mock.__sd_nvic_is_app_accessible_priority_CallbackFunctionPointer(priority, Mock.__sd_nvic_is_app_accessible_priority_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function '__sd_nvic_is_app_accessible_priority' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function '__sd_nvic_is_app_accessible_priority' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function '__sd_nvic_is_app_accessible_priority' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_priority)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_priority, priority, cmock_line, "Function '__sd_nvic_is_app_accessible_priority' called with unexpected value for argument 'priority'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters___sd_nvic_is_app_accessible_priority(CMOCK___sd_nvic_is_app_accessible_priority_CALL_INSTANCE* cmock_call_instance, uint32_t priority)
+{
+  cmock_call_instance->Expected_priority = priority;
+  cmock_call_instance->IgnoreArg_priority = 0;
+}
+
+void __sd_nvic_is_app_accessible_priority_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK___sd_nvic_is_app_accessible_priority_CALL_INSTANCE));
+  CMOCK___sd_nvic_is_app_accessible_priority_CALL_INSTANCE* cmock_call_instance = (CMOCK___sd_nvic_is_app_accessible_priority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.__sd_nvic_is_app_accessible_priority_CallInstance = CMock_Guts_MemChain(Mock.__sd_nvic_is_app_accessible_priority_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.__sd_nvic_is_app_accessible_priority_IgnoreBool = (int)1;
+}
+
+void __sd_nvic_is_app_accessible_priority_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t priority, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK___sd_nvic_is_app_accessible_priority_CALL_INSTANCE));
+  CMOCK___sd_nvic_is_app_accessible_priority_CALL_INSTANCE* cmock_call_instance = (CMOCK___sd_nvic_is_app_accessible_priority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.__sd_nvic_is_app_accessible_priority_CallInstance = CMock_Guts_MemChain(Mock.__sd_nvic_is_app_accessible_priority_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters___sd_nvic_is_app_accessible_priority(cmock_call_instance, priority);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void __sd_nvic_is_app_accessible_priority_StubWithCallback(CMOCK___sd_nvic_is_app_accessible_priority_CALLBACK Callback)
+{
+  Mock.__sd_nvic_is_app_accessible_priority_CallbackFunctionPointer = Callback;
+}
+
+void __sd_nvic_is_app_accessible_priority_CMockIgnoreArg_priority(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK___sd_nvic_is_app_accessible_priority_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK___sd_nvic_is_app_accessible_priority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.__sd_nvic_is_app_accessible_priority_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "priority IgnoreArg called before Expect on '__sd_nvic_is_app_accessible_priority'.");
+  cmock_call_instance->IgnoreArg_priority = 1;
+}
+
+uint32_t sd_nvic_EnableIRQ(IRQn_Type IRQn)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_nvic_EnableIRQ_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_EnableIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_nvic_EnableIRQ_CallInstance);
+  Mock.sd_nvic_EnableIRQ_CallInstance = CMock_Guts_MemNext(Mock.sd_nvic_EnableIRQ_CallInstance);
+  if (Mock.sd_nvic_EnableIRQ_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_nvic_EnableIRQ_FinalReturn;
+    Mock.sd_nvic_EnableIRQ_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_nvic_EnableIRQ_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_nvic_EnableIRQ_CallbackFunctionPointer(IRQn, Mock.sd_nvic_EnableIRQ_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_nvic_EnableIRQ' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_EnableIRQ' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_EnableIRQ' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_IRQn)
+  {
+    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_IRQn), (void*)(&IRQn), sizeof(IRQn_Type), cmock_line, "Function 'sd_nvic_EnableIRQ' called with unexpected value for argument 'IRQn'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_nvic_EnableIRQ(CMOCK_sd_nvic_EnableIRQ_CALL_INSTANCE* cmock_call_instance, IRQn_Type IRQn)
+{
+  memcpy(&cmock_call_instance->Expected_IRQn, &IRQn, sizeof(IRQn_Type));
+  cmock_call_instance->IgnoreArg_IRQn = 0;
+}
+
+void sd_nvic_EnableIRQ_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_EnableIRQ_CALL_INSTANCE));
+  CMOCK_sd_nvic_EnableIRQ_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_EnableIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_EnableIRQ_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_EnableIRQ_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_nvic_EnableIRQ_IgnoreBool = (int)1;
+}
+
+void sd_nvic_EnableIRQ_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_EnableIRQ_CALL_INSTANCE));
+  CMOCK_sd_nvic_EnableIRQ_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_EnableIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_EnableIRQ_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_EnableIRQ_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_nvic_EnableIRQ(cmock_call_instance, IRQn);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_nvic_EnableIRQ_StubWithCallback(CMOCK_sd_nvic_EnableIRQ_CALLBACK Callback)
+{
+  Mock.sd_nvic_EnableIRQ_CallbackFunctionPointer = Callback;
+}
+
+void sd_nvic_EnableIRQ_CMockIgnoreArg_IRQn(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_nvic_EnableIRQ_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_nvic_EnableIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_nvic_EnableIRQ_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "IRQn IgnoreArg called before Expect on 'sd_nvic_EnableIRQ'.");
+  cmock_call_instance->IgnoreArg_IRQn = 1;
+}
+
+uint32_t sd_nvic_DisableIRQ(IRQn_Type IRQn)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_nvic_DisableIRQ_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_DisableIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_nvic_DisableIRQ_CallInstance);
+  Mock.sd_nvic_DisableIRQ_CallInstance = CMock_Guts_MemNext(Mock.sd_nvic_DisableIRQ_CallInstance);
+  if (Mock.sd_nvic_DisableIRQ_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_nvic_DisableIRQ_FinalReturn;
+    Mock.sd_nvic_DisableIRQ_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_nvic_DisableIRQ_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_nvic_DisableIRQ_CallbackFunctionPointer(IRQn, Mock.sd_nvic_DisableIRQ_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_nvic_DisableIRQ' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_DisableIRQ' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_DisableIRQ' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_IRQn)
+  {
+    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_IRQn), (void*)(&IRQn), sizeof(IRQn_Type), cmock_line, "Function 'sd_nvic_DisableIRQ' called with unexpected value for argument 'IRQn'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_nvic_DisableIRQ(CMOCK_sd_nvic_DisableIRQ_CALL_INSTANCE* cmock_call_instance, IRQn_Type IRQn)
+{
+  memcpy(&cmock_call_instance->Expected_IRQn, &IRQn, sizeof(IRQn_Type));
+  cmock_call_instance->IgnoreArg_IRQn = 0;
+}
+
+void sd_nvic_DisableIRQ_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_DisableIRQ_CALL_INSTANCE));
+  CMOCK_sd_nvic_DisableIRQ_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_DisableIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_DisableIRQ_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_DisableIRQ_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_nvic_DisableIRQ_IgnoreBool = (int)1;
+}
+
+void sd_nvic_DisableIRQ_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_DisableIRQ_CALL_INSTANCE));
+  CMOCK_sd_nvic_DisableIRQ_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_DisableIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_DisableIRQ_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_DisableIRQ_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_nvic_DisableIRQ(cmock_call_instance, IRQn);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_nvic_DisableIRQ_StubWithCallback(CMOCK_sd_nvic_DisableIRQ_CALLBACK Callback)
+{
+  Mock.sd_nvic_DisableIRQ_CallbackFunctionPointer = Callback;
+}
+
+void sd_nvic_DisableIRQ_CMockIgnoreArg_IRQn(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_nvic_DisableIRQ_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_nvic_DisableIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_nvic_DisableIRQ_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "IRQn IgnoreArg called before Expect on 'sd_nvic_DisableIRQ'.");
+  cmock_call_instance->IgnoreArg_IRQn = 1;
+}
+
+uint32_t sd_nvic_GetPendingIRQ(IRQn_Type IRQn, uint32_t* p_pending_irq)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_nvic_GetPendingIRQ_CallInstance);
+  Mock.sd_nvic_GetPendingIRQ_CallInstance = CMock_Guts_MemNext(Mock.sd_nvic_GetPendingIRQ_CallInstance);
+  if (Mock.sd_nvic_GetPendingIRQ_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_nvic_GetPendingIRQ_FinalReturn;
+    Mock.sd_nvic_GetPendingIRQ_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_nvic_GetPendingIRQ_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_nvic_GetPendingIRQ_CallbackFunctionPointer(IRQn, p_pending_irq, Mock.sd_nvic_GetPendingIRQ_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_nvic_GetPendingIRQ' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_GetPendingIRQ' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_GetPendingIRQ' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_IRQn)
+  {
+    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_IRQn), (void*)(&IRQn), sizeof(IRQn_Type), cmock_line, "Function 'sd_nvic_GetPendingIRQ' called with unexpected value for argument 'IRQn'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_pending_irq)
+  {
+    if (cmock_call_instance->Expected_p_pending_irq == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_pending_irq, cmock_line, "Expected NULL. Function 'sd_nvic_GetPendingIRQ' called with unexpected value for argument 'p_pending_irq'."); }
+    else if (cmock_call_instance->Expected_p_pending_irq_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_pending_irq, p_pending_irq, cmock_line, "Function 'sd_nvic_GetPendingIRQ' called with unexpected value for argument 'p_pending_irq'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_p_pending_irq, p_pending_irq, cmock_call_instance->Expected_p_pending_irq_Depth, cmock_line, "Function 'sd_nvic_GetPendingIRQ' called with unexpected value for argument 'p_pending_irq'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_pending_irq_Used)
+  {
+    memcpy((void*)p_pending_irq, (void*)cmock_call_instance->ReturnThruPtr_p_pending_irq_Val,
+      cmock_call_instance->ReturnThruPtr_p_pending_irq_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_nvic_GetPendingIRQ(CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE* cmock_call_instance, IRQn_Type IRQn, uint32_t* p_pending_irq, int p_pending_irq_Depth)
+{
+  memcpy(&cmock_call_instance->Expected_IRQn, &IRQn, sizeof(IRQn_Type));
+  cmock_call_instance->IgnoreArg_IRQn = 0;
+  cmock_call_instance->Expected_p_pending_irq = p_pending_irq;
+  cmock_call_instance->Expected_p_pending_irq_Depth = p_pending_irq_Depth;
+  cmock_call_instance->IgnoreArg_p_pending_irq = 0;
+  cmock_call_instance->ReturnThruPtr_p_pending_irq_Used = 0;
+}
+
+void sd_nvic_GetPendingIRQ_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE));
+  CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_GetPendingIRQ_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_GetPendingIRQ_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_nvic_GetPendingIRQ_IgnoreBool = (int)1;
+}
+
+void sd_nvic_GetPendingIRQ_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t* p_pending_irq, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE));
+  CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_GetPendingIRQ_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_GetPendingIRQ_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_nvic_GetPendingIRQ(cmock_call_instance, IRQn, p_pending_irq, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_nvic_GetPendingIRQ_StubWithCallback(CMOCK_sd_nvic_GetPendingIRQ_CALLBACK Callback)
+{
+  Mock.sd_nvic_GetPendingIRQ_CallbackFunctionPointer = Callback;
+}
+
+void sd_nvic_GetPendingIRQ_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t* p_pending_irq, int p_pending_irq_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE));
+  CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_GetPendingIRQ_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_GetPendingIRQ_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_nvic_GetPendingIRQ(cmock_call_instance, IRQn, p_pending_irq, p_pending_irq_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_nvic_GetPendingIRQ_CMockReturnMemThruPtr_p_pending_irq(UNITY_LINE_TYPE cmock_line, uint32_t* p_pending_irq, int cmock_size)
+{
+  CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_nvic_GetPendingIRQ_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_pending_irq ReturnThruPtr called before Expect on 'sd_nvic_GetPendingIRQ'.");
+  cmock_call_instance->ReturnThruPtr_p_pending_irq_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_pending_irq_Val = p_pending_irq;
+  cmock_call_instance->ReturnThruPtr_p_pending_irq_Size = cmock_size;
+}
+
+void sd_nvic_GetPendingIRQ_CMockIgnoreArg_IRQn(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_nvic_GetPendingIRQ_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "IRQn IgnoreArg called before Expect on 'sd_nvic_GetPendingIRQ'.");
+  cmock_call_instance->IgnoreArg_IRQn = 1;
+}
+
+void sd_nvic_GetPendingIRQ_CMockIgnoreArg_p_pending_irq(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_nvic_GetPendingIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_nvic_GetPendingIRQ_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_pending_irq IgnoreArg called before Expect on 'sd_nvic_GetPendingIRQ'.");
+  cmock_call_instance->IgnoreArg_p_pending_irq = 1;
+}
+
+uint32_t sd_nvic_SetPendingIRQ(IRQn_Type IRQn)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_nvic_SetPendingIRQ_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_SetPendingIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_nvic_SetPendingIRQ_CallInstance);
+  Mock.sd_nvic_SetPendingIRQ_CallInstance = CMock_Guts_MemNext(Mock.sd_nvic_SetPendingIRQ_CallInstance);
+  if (Mock.sd_nvic_SetPendingIRQ_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_nvic_SetPendingIRQ_FinalReturn;
+    Mock.sd_nvic_SetPendingIRQ_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_nvic_SetPendingIRQ_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_nvic_SetPendingIRQ_CallbackFunctionPointer(IRQn, Mock.sd_nvic_SetPendingIRQ_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_nvic_SetPendingIRQ' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_SetPendingIRQ' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_SetPendingIRQ' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_IRQn)
+  {
+    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_IRQn), (void*)(&IRQn), sizeof(IRQn_Type), cmock_line, "Function 'sd_nvic_SetPendingIRQ' called with unexpected value for argument 'IRQn'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_nvic_SetPendingIRQ(CMOCK_sd_nvic_SetPendingIRQ_CALL_INSTANCE* cmock_call_instance, IRQn_Type IRQn)
+{
+  memcpy(&cmock_call_instance->Expected_IRQn, &IRQn, sizeof(IRQn_Type));
+  cmock_call_instance->IgnoreArg_IRQn = 0;
+}
+
+void sd_nvic_SetPendingIRQ_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_SetPendingIRQ_CALL_INSTANCE));
+  CMOCK_sd_nvic_SetPendingIRQ_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_SetPendingIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_SetPendingIRQ_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_SetPendingIRQ_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_nvic_SetPendingIRQ_IgnoreBool = (int)1;
+}
+
+void sd_nvic_SetPendingIRQ_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_SetPendingIRQ_CALL_INSTANCE));
+  CMOCK_sd_nvic_SetPendingIRQ_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_SetPendingIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_SetPendingIRQ_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_SetPendingIRQ_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_nvic_SetPendingIRQ(cmock_call_instance, IRQn);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_nvic_SetPendingIRQ_StubWithCallback(CMOCK_sd_nvic_SetPendingIRQ_CALLBACK Callback)
+{
+  Mock.sd_nvic_SetPendingIRQ_CallbackFunctionPointer = Callback;
+}
+
+void sd_nvic_SetPendingIRQ_CMockIgnoreArg_IRQn(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_nvic_SetPendingIRQ_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_nvic_SetPendingIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_nvic_SetPendingIRQ_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "IRQn IgnoreArg called before Expect on 'sd_nvic_SetPendingIRQ'.");
+  cmock_call_instance->IgnoreArg_IRQn = 1;
+}
+
+uint32_t sd_nvic_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_nvic_ClearPendingIRQ_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_ClearPendingIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_nvic_ClearPendingIRQ_CallInstance);
+  Mock.sd_nvic_ClearPendingIRQ_CallInstance = CMock_Guts_MemNext(Mock.sd_nvic_ClearPendingIRQ_CallInstance);
+  if (Mock.sd_nvic_ClearPendingIRQ_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_nvic_ClearPendingIRQ_FinalReturn;
+    Mock.sd_nvic_ClearPendingIRQ_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_nvic_ClearPendingIRQ_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_nvic_ClearPendingIRQ_CallbackFunctionPointer(IRQn, Mock.sd_nvic_ClearPendingIRQ_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_nvic_ClearPendingIRQ' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_ClearPendingIRQ' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_ClearPendingIRQ' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_IRQn)
+  {
+    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_IRQn), (void*)(&IRQn), sizeof(IRQn_Type), cmock_line, "Function 'sd_nvic_ClearPendingIRQ' called with unexpected value for argument 'IRQn'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_nvic_ClearPendingIRQ(CMOCK_sd_nvic_ClearPendingIRQ_CALL_INSTANCE* cmock_call_instance, IRQn_Type IRQn)
+{
+  memcpy(&cmock_call_instance->Expected_IRQn, &IRQn, sizeof(IRQn_Type));
+  cmock_call_instance->IgnoreArg_IRQn = 0;
+}
+
+void sd_nvic_ClearPendingIRQ_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_ClearPendingIRQ_CALL_INSTANCE));
+  CMOCK_sd_nvic_ClearPendingIRQ_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_ClearPendingIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_ClearPendingIRQ_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_ClearPendingIRQ_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_nvic_ClearPendingIRQ_IgnoreBool = (int)1;
+}
+
+void sd_nvic_ClearPendingIRQ_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_ClearPendingIRQ_CALL_INSTANCE));
+  CMOCK_sd_nvic_ClearPendingIRQ_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_ClearPendingIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_ClearPendingIRQ_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_ClearPendingIRQ_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_nvic_ClearPendingIRQ(cmock_call_instance, IRQn);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_nvic_ClearPendingIRQ_StubWithCallback(CMOCK_sd_nvic_ClearPendingIRQ_CALLBACK Callback)
+{
+  Mock.sd_nvic_ClearPendingIRQ_CallbackFunctionPointer = Callback;
+}
+
+void sd_nvic_ClearPendingIRQ_CMockIgnoreArg_IRQn(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_nvic_ClearPendingIRQ_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_nvic_ClearPendingIRQ_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_nvic_ClearPendingIRQ_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "IRQn IgnoreArg called before Expect on 'sd_nvic_ClearPendingIRQ'.");
+  cmock_call_instance->IgnoreArg_IRQn = 1;
+}
+
+uint32_t sd_nvic_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_nvic_SetPriority_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_SetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_nvic_SetPriority_CallInstance);
+  Mock.sd_nvic_SetPriority_CallInstance = CMock_Guts_MemNext(Mock.sd_nvic_SetPriority_CallInstance);
+  if (Mock.sd_nvic_SetPriority_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_nvic_SetPriority_FinalReturn;
+    Mock.sd_nvic_SetPriority_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_nvic_SetPriority_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_nvic_SetPriority_CallbackFunctionPointer(IRQn, priority, Mock.sd_nvic_SetPriority_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_nvic_SetPriority' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_SetPriority' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_SetPriority' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_IRQn)
+  {
+    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_IRQn), (void*)(&IRQn), sizeof(IRQn_Type), cmock_line, "Function 'sd_nvic_SetPriority' called with unexpected value for argument 'IRQn'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_priority)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_priority, priority, cmock_line, "Function 'sd_nvic_SetPriority' called with unexpected value for argument 'priority'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_nvic_SetPriority(CMOCK_sd_nvic_SetPriority_CALL_INSTANCE* cmock_call_instance, IRQn_Type IRQn, uint32_t priority)
+{
+  memcpy(&cmock_call_instance->Expected_IRQn, &IRQn, sizeof(IRQn_Type));
+  cmock_call_instance->IgnoreArg_IRQn = 0;
+  cmock_call_instance->Expected_priority = priority;
+  cmock_call_instance->IgnoreArg_priority = 0;
+}
+
+void sd_nvic_SetPriority_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_SetPriority_CALL_INSTANCE));
+  CMOCK_sd_nvic_SetPriority_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_SetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_SetPriority_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_SetPriority_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_nvic_SetPriority_IgnoreBool = (int)1;
+}
+
+void sd_nvic_SetPriority_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t priority, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_SetPriority_CALL_INSTANCE));
+  CMOCK_sd_nvic_SetPriority_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_SetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_SetPriority_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_SetPriority_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_nvic_SetPriority(cmock_call_instance, IRQn, priority);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_nvic_SetPriority_StubWithCallback(CMOCK_sd_nvic_SetPriority_CALLBACK Callback)
+{
+  Mock.sd_nvic_SetPriority_CallbackFunctionPointer = Callback;
+}
+
+void sd_nvic_SetPriority_CMockIgnoreArg_IRQn(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_nvic_SetPriority_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_nvic_SetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_nvic_SetPriority_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "IRQn IgnoreArg called before Expect on 'sd_nvic_SetPriority'.");
+  cmock_call_instance->IgnoreArg_IRQn = 1;
+}
+
+void sd_nvic_SetPriority_CMockIgnoreArg_priority(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_nvic_SetPriority_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_nvic_SetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_nvic_SetPriority_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "priority IgnoreArg called before Expect on 'sd_nvic_SetPriority'.");
+  cmock_call_instance->IgnoreArg_priority = 1;
+}
+
+uint32_t sd_nvic_GetPriority(IRQn_Type IRQn, uint32_t* p_priority)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_nvic_GetPriority_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_GetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_nvic_GetPriority_CallInstance);
+  Mock.sd_nvic_GetPriority_CallInstance = CMock_Guts_MemNext(Mock.sd_nvic_GetPriority_CallInstance);
+  if (Mock.sd_nvic_GetPriority_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_nvic_GetPriority_FinalReturn;
+    Mock.sd_nvic_GetPriority_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_nvic_GetPriority_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_nvic_GetPriority_CallbackFunctionPointer(IRQn, p_priority, Mock.sd_nvic_GetPriority_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_nvic_GetPriority' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_GetPriority' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_GetPriority' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_IRQn)
+  {
+    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_IRQn), (void*)(&IRQn), sizeof(IRQn_Type), cmock_line, "Function 'sd_nvic_GetPriority' called with unexpected value for argument 'IRQn'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_priority)
+  {
+    if (cmock_call_instance->Expected_p_priority == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_priority, cmock_line, "Expected NULL. Function 'sd_nvic_GetPriority' called with unexpected value for argument 'p_priority'."); }
+    else if (cmock_call_instance->Expected_p_priority_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_priority, p_priority, cmock_line, "Function 'sd_nvic_GetPriority' called with unexpected value for argument 'p_priority'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_p_priority, p_priority, cmock_call_instance->Expected_p_priority_Depth, cmock_line, "Function 'sd_nvic_GetPriority' called with unexpected value for argument 'p_priority'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_priority_Used)
+  {
+    memcpy((void*)p_priority, (void*)cmock_call_instance->ReturnThruPtr_p_priority_Val,
+      cmock_call_instance->ReturnThruPtr_p_priority_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_nvic_GetPriority(CMOCK_sd_nvic_GetPriority_CALL_INSTANCE* cmock_call_instance, IRQn_Type IRQn, uint32_t* p_priority, int p_priority_Depth)
+{
+  memcpy(&cmock_call_instance->Expected_IRQn, &IRQn, sizeof(IRQn_Type));
+  cmock_call_instance->IgnoreArg_IRQn = 0;
+  cmock_call_instance->Expected_p_priority = p_priority;
+  cmock_call_instance->Expected_p_priority_Depth = p_priority_Depth;
+  cmock_call_instance->IgnoreArg_p_priority = 0;
+  cmock_call_instance->ReturnThruPtr_p_priority_Used = 0;
+}
+
+void sd_nvic_GetPriority_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_GetPriority_CALL_INSTANCE));
+  CMOCK_sd_nvic_GetPriority_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_GetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_GetPriority_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_GetPriority_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_nvic_GetPriority_IgnoreBool = (int)1;
+}
+
+void sd_nvic_GetPriority_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t* p_priority, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_GetPriority_CALL_INSTANCE));
+  CMOCK_sd_nvic_GetPriority_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_GetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_GetPriority_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_GetPriority_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_nvic_GetPriority(cmock_call_instance, IRQn, p_priority, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_nvic_GetPriority_StubWithCallback(CMOCK_sd_nvic_GetPriority_CALLBACK Callback)
+{
+  Mock.sd_nvic_GetPriority_CallbackFunctionPointer = Callback;
+}
+
+void sd_nvic_GetPriority_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t* p_priority, int p_priority_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_GetPriority_CALL_INSTANCE));
+  CMOCK_sd_nvic_GetPriority_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_GetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_GetPriority_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_GetPriority_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_nvic_GetPriority(cmock_call_instance, IRQn, p_priority, p_priority_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_nvic_GetPriority_CMockReturnMemThruPtr_p_priority(UNITY_LINE_TYPE cmock_line, uint32_t* p_priority, int cmock_size)
+{
+  CMOCK_sd_nvic_GetPriority_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_nvic_GetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_nvic_GetPriority_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_priority ReturnThruPtr called before Expect on 'sd_nvic_GetPriority'.");
+  cmock_call_instance->ReturnThruPtr_p_priority_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_priority_Val = p_priority;
+  cmock_call_instance->ReturnThruPtr_p_priority_Size = cmock_size;
+}
+
+void sd_nvic_GetPriority_CMockIgnoreArg_IRQn(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_nvic_GetPriority_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_nvic_GetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_nvic_GetPriority_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "IRQn IgnoreArg called before Expect on 'sd_nvic_GetPriority'.");
+  cmock_call_instance->IgnoreArg_IRQn = 1;
+}
+
+void sd_nvic_GetPriority_CMockIgnoreArg_p_priority(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_nvic_GetPriority_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_nvic_GetPriority_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_nvic_GetPriority_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_priority IgnoreArg called before Expect on 'sd_nvic_GetPriority'.");
+  cmock_call_instance->IgnoreArg_p_priority = 1;
+}
+
+uint32_t sd_nvic_SystemReset(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_nvic_SystemReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_SystemReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_nvic_SystemReset_CallInstance);
+  Mock.sd_nvic_SystemReset_CallInstance = CMock_Guts_MemNext(Mock.sd_nvic_SystemReset_CallInstance);
+  if (Mock.sd_nvic_SystemReset_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_nvic_SystemReset_FinalReturn;
+    Mock.sd_nvic_SystemReset_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_nvic_SystemReset_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_nvic_SystemReset_CallbackFunctionPointer(Mock.sd_nvic_SystemReset_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_nvic_SystemReset' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_SystemReset' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_SystemReset' called later than expected.");
+  return cmock_call_instance->ReturnVal;
+}
+
+void sd_nvic_SystemReset_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_SystemReset_CALL_INSTANCE));
+  CMOCK_sd_nvic_SystemReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_SystemReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_SystemReset_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_SystemReset_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_nvic_SystemReset_IgnoreBool = (int)1;
+}
+
+void sd_nvic_SystemReset_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_SystemReset_CALL_INSTANCE));
+  CMOCK_sd_nvic_SystemReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_SystemReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_SystemReset_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_SystemReset_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_nvic_SystemReset_StubWithCallback(CMOCK_sd_nvic_SystemReset_CALLBACK Callback)
+{
+  Mock.sd_nvic_SystemReset_CallbackFunctionPointer = Callback;
+}
+
+uint32_t sd_nvic_critical_region_enter(uint8_t* p_is_nested_critical_region)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_nvic_critical_region_enter_CallInstance);
+  Mock.sd_nvic_critical_region_enter_CallInstance = CMock_Guts_MemNext(Mock.sd_nvic_critical_region_enter_CallInstance);
+  if (Mock.sd_nvic_critical_region_enter_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_nvic_critical_region_enter_FinalReturn;
+    Mock.sd_nvic_critical_region_enter_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_nvic_critical_region_enter_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_nvic_critical_region_enter_CallbackFunctionPointer(p_is_nested_critical_region, Mock.sd_nvic_critical_region_enter_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_nvic_critical_region_enter' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_critical_region_enter' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_critical_region_enter' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_is_nested_critical_region)
+  {
+    if (cmock_call_instance->Expected_p_is_nested_critical_region == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_is_nested_critical_region, cmock_line, "Expected NULL. Function 'sd_nvic_critical_region_enter' called with unexpected value for argument 'p_is_nested_critical_region'."); }
+    else if (cmock_call_instance->Expected_p_is_nested_critical_region_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_is_nested_critical_region, p_is_nested_critical_region, cmock_line, "Function 'sd_nvic_critical_region_enter' called with unexpected value for argument 'p_is_nested_critical_region'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_is_nested_critical_region, p_is_nested_critical_region, cmock_call_instance->Expected_p_is_nested_critical_region_Depth, cmock_line, "Function 'sd_nvic_critical_region_enter' called with unexpected value for argument 'p_is_nested_critical_region'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_is_nested_critical_region_Used)
+  {
+    memcpy((void*)p_is_nested_critical_region, (void*)cmock_call_instance->ReturnThruPtr_p_is_nested_critical_region_Val,
+      cmock_call_instance->ReturnThruPtr_p_is_nested_critical_region_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_nvic_critical_region_enter(CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE* cmock_call_instance, uint8_t* p_is_nested_critical_region, int p_is_nested_critical_region_Depth)
+{
+  cmock_call_instance->Expected_p_is_nested_critical_region = p_is_nested_critical_region;
+  cmock_call_instance->Expected_p_is_nested_critical_region_Depth = p_is_nested_critical_region_Depth;
+  cmock_call_instance->IgnoreArg_p_is_nested_critical_region = 0;
+  cmock_call_instance->ReturnThruPtr_p_is_nested_critical_region_Used = 0;
+}
+
+void sd_nvic_critical_region_enter_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE));
+  CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_critical_region_enter_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_critical_region_enter_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_nvic_critical_region_enter_IgnoreBool = (int)1;
+}
+
+void sd_nvic_critical_region_enter_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_is_nested_critical_region, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE));
+  CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_critical_region_enter_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_critical_region_enter_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_nvic_critical_region_enter(cmock_call_instance, p_is_nested_critical_region, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_nvic_critical_region_enter_StubWithCallback(CMOCK_sd_nvic_critical_region_enter_CALLBACK Callback)
+{
+  Mock.sd_nvic_critical_region_enter_CallbackFunctionPointer = Callback;
+}
+
+void sd_nvic_critical_region_enter_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_is_nested_critical_region, int p_is_nested_critical_region_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE));
+  CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_critical_region_enter_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_critical_region_enter_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_nvic_critical_region_enter(cmock_call_instance, p_is_nested_critical_region, p_is_nested_critical_region_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_nvic_critical_region_enter_CMockReturnMemThruPtr_p_is_nested_critical_region(UNITY_LINE_TYPE cmock_line, uint8_t* p_is_nested_critical_region, int cmock_size)
+{
+  CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_nvic_critical_region_enter_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_is_nested_critical_region ReturnThruPtr called before Expect on 'sd_nvic_critical_region_enter'.");
+  cmock_call_instance->ReturnThruPtr_p_is_nested_critical_region_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_is_nested_critical_region_Val = p_is_nested_critical_region;
+  cmock_call_instance->ReturnThruPtr_p_is_nested_critical_region_Size = cmock_size;
+}
+
+void sd_nvic_critical_region_enter_CMockIgnoreArg_p_is_nested_critical_region(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_nvic_critical_region_enter_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_nvic_critical_region_enter_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_is_nested_critical_region IgnoreArg called before Expect on 'sd_nvic_critical_region_enter'.");
+  cmock_call_instance->IgnoreArg_p_is_nested_critical_region = 1;
+}
+
+uint32_t sd_nvic_critical_region_exit(uint8_t is_nested_critical_region)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_nvic_critical_region_exit_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_critical_region_exit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_nvic_critical_region_exit_CallInstance);
+  Mock.sd_nvic_critical_region_exit_CallInstance = CMock_Guts_MemNext(Mock.sd_nvic_critical_region_exit_CallInstance);
+  if (Mock.sd_nvic_critical_region_exit_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_nvic_critical_region_exit_FinalReturn;
+    Mock.sd_nvic_critical_region_exit_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_nvic_critical_region_exit_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_nvic_critical_region_exit_CallbackFunctionPointer(is_nested_critical_region, Mock.sd_nvic_critical_region_exit_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_nvic_critical_region_exit' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_critical_region_exit' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_nvic_critical_region_exit' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_is_nested_critical_region)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_is_nested_critical_region, is_nested_critical_region, cmock_line, "Function 'sd_nvic_critical_region_exit' called with unexpected value for argument 'is_nested_critical_region'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_nvic_critical_region_exit(CMOCK_sd_nvic_critical_region_exit_CALL_INSTANCE* cmock_call_instance, uint8_t is_nested_critical_region)
+{
+  cmock_call_instance->Expected_is_nested_critical_region = is_nested_critical_region;
+  cmock_call_instance->IgnoreArg_is_nested_critical_region = 0;
+}
+
+void sd_nvic_critical_region_exit_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_critical_region_exit_CALL_INSTANCE));
+  CMOCK_sd_nvic_critical_region_exit_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_critical_region_exit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_critical_region_exit_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_critical_region_exit_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_nvic_critical_region_exit_IgnoreBool = (int)1;
+}
+
+void sd_nvic_critical_region_exit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t is_nested_critical_region, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_nvic_critical_region_exit_CALL_INSTANCE));
+  CMOCK_sd_nvic_critical_region_exit_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_nvic_critical_region_exit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_nvic_critical_region_exit_CallInstance = CMock_Guts_MemChain(Mock.sd_nvic_critical_region_exit_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_nvic_critical_region_exit(cmock_call_instance, is_nested_critical_region);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_nvic_critical_region_exit_StubWithCallback(CMOCK_sd_nvic_critical_region_exit_CALLBACK Callback)
+{
+  Mock.sd_nvic_critical_region_exit_CallbackFunctionPointer = Callback;
+}
+
+void sd_nvic_critical_region_exit_CMockIgnoreArg_is_nested_critical_region(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_nvic_critical_region_exit_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_nvic_critical_region_exit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_nvic_critical_region_exit_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "is_nested_critical_region IgnoreArg called before Expect on 'sd_nvic_critical_region_exit'.");
+  cmock_call_instance->IgnoreArg_is_nested_critical_region = 1;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_nvic.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_nvic.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_nvic.h    1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_nvic.h 2018-04-24 08:48:28.888152700 +0200
@@ -0,0 +1,156 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_NRF_NVIC_H
+#define _MOCK_NRF_NVIC_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <nrf_nvic.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_nrf_nvic_Init(void);
+void mock_nrf_nvic_Destroy(void);
+void mock_nrf_nvic_Verify(void);
+
+
+
+
+#define __sd_nvic_irq_disable_IgnoreAndReturn(cmock_retval) __sd_nvic_irq_disable_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void __sd_nvic_irq_disable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return);
+#define __sd_nvic_irq_disable_ExpectAndReturn(cmock_retval) __sd_nvic_irq_disable_CMockExpectAndReturn(__LINE__, cmock_retval)
+void __sd_nvic_irq_disable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return);
+typedef int (* CMOCK___sd_nvic_irq_disable_CALLBACK)(int cmock_num_calls);
+void __sd_nvic_irq_disable_StubWithCallback(CMOCK___sd_nvic_irq_disable_CALLBACK Callback);
+#define __sd_nvic_irq_enable_Ignore() __sd_nvic_irq_enable_CMockIgnore()
+void __sd_nvic_irq_enable_CMockIgnore(void);
+#define __sd_nvic_irq_enable_Expect() __sd_nvic_irq_enable_CMockExpect(__LINE__)
+void __sd_nvic_irq_enable_CMockExpect(UNITY_LINE_TYPE cmock_line);
+typedef void (* CMOCK___sd_nvic_irq_enable_CALLBACK)(int cmock_num_calls);
+void __sd_nvic_irq_enable_StubWithCallback(CMOCK___sd_nvic_irq_enable_CALLBACK Callback);
+#define __sd_nvic_app_accessible_irq_IgnoreAndReturn(cmock_retval) __sd_nvic_app_accessible_irq_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void __sd_nvic_app_accessible_irq_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define __sd_nvic_app_accessible_irq_ExpectAndReturn(IRQn, cmock_retval) __sd_nvic_app_accessible_irq_CMockExpectAndReturn(__LINE__, IRQn, cmock_retval)
+void __sd_nvic_app_accessible_irq_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK___sd_nvic_app_accessible_irq_CALLBACK)(IRQn_Type IRQn, int cmock_num_calls);
+void __sd_nvic_app_accessible_irq_StubWithCallback(CMOCK___sd_nvic_app_accessible_irq_CALLBACK Callback);
+#define __sd_nvic_app_accessible_irq_IgnoreArg_IRQn() __sd_nvic_app_accessible_irq_CMockIgnoreArg_IRQn(__LINE__)
+void __sd_nvic_app_accessible_irq_CMockIgnoreArg_IRQn(UNITY_LINE_TYPE cmock_line);
+#define __sd_nvic_is_app_accessible_priority_IgnoreAndReturn(cmock_retval) __sd_nvic_is_app_accessible_priority_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void __sd_nvic_is_app_accessible_priority_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define __sd_nvic_is_app_accessible_priority_ExpectAndReturn(priority, cmock_retval) __sd_nvic_is_app_accessible_priority_CMockExpectAndReturn(__LINE__, priority, cmock_retval)
+void __sd_nvic_is_app_accessible_priority_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t priority, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK___sd_nvic_is_app_accessible_priority_CALLBACK)(uint32_t priority, int cmock_num_calls);
+void __sd_nvic_is_app_accessible_priority_StubWithCallback(CMOCK___sd_nvic_is_app_accessible_priority_CALLBACK Callback);
+#define __sd_nvic_is_app_accessible_priority_IgnoreArg_priority() __sd_nvic_is_app_accessible_priority_CMockIgnoreArg_priority(__LINE__)
+void __sd_nvic_is_app_accessible_priority_CMockIgnoreArg_priority(UNITY_LINE_TYPE cmock_line);
+#define sd_nvic_EnableIRQ_IgnoreAndReturn(cmock_retval) sd_nvic_EnableIRQ_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_nvic_EnableIRQ_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_nvic_EnableIRQ_ExpectAndReturn(IRQn, cmock_retval) sd_nvic_EnableIRQ_CMockExpectAndReturn(__LINE__, IRQn, cmock_retval)
+void sd_nvic_EnableIRQ_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_nvic_EnableIRQ_CALLBACK)(IRQn_Type IRQn, int cmock_num_calls);
+void sd_nvic_EnableIRQ_StubWithCallback(CMOCK_sd_nvic_EnableIRQ_CALLBACK Callback);
+#define sd_nvic_EnableIRQ_IgnoreArg_IRQn() sd_nvic_EnableIRQ_CMockIgnoreArg_IRQn(__LINE__)
+void sd_nvic_EnableIRQ_CMockIgnoreArg_IRQn(UNITY_LINE_TYPE cmock_line);
+#define sd_nvic_DisableIRQ_IgnoreAndReturn(cmock_retval) sd_nvic_DisableIRQ_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_nvic_DisableIRQ_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_nvic_DisableIRQ_ExpectAndReturn(IRQn, cmock_retval) sd_nvic_DisableIRQ_CMockExpectAndReturn(__LINE__, IRQn, cmock_retval)
+void sd_nvic_DisableIRQ_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_nvic_DisableIRQ_CALLBACK)(IRQn_Type IRQn, int cmock_num_calls);
+void sd_nvic_DisableIRQ_StubWithCallback(CMOCK_sd_nvic_DisableIRQ_CALLBACK Callback);
+#define sd_nvic_DisableIRQ_IgnoreArg_IRQn() sd_nvic_DisableIRQ_CMockIgnoreArg_IRQn(__LINE__)
+void sd_nvic_DisableIRQ_CMockIgnoreArg_IRQn(UNITY_LINE_TYPE cmock_line);
+#define sd_nvic_GetPendingIRQ_IgnoreAndReturn(cmock_retval) sd_nvic_GetPendingIRQ_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_nvic_GetPendingIRQ_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_nvic_GetPendingIRQ_ExpectAndReturn(IRQn, p_pending_irq, cmock_retval) sd_nvic_GetPendingIRQ_CMockExpectAndReturn(__LINE__, IRQn, p_pending_irq, cmock_retval)
+void sd_nvic_GetPendingIRQ_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t* p_pending_irq, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_nvic_GetPendingIRQ_CALLBACK)(IRQn_Type IRQn, uint32_t* p_pending_irq, int cmock_num_calls);
+void sd_nvic_GetPendingIRQ_StubWithCallback(CMOCK_sd_nvic_GetPendingIRQ_CALLBACK Callback);
+#define sd_nvic_GetPendingIRQ_ExpectWithArrayAndReturn(IRQn, p_pending_irq, p_pending_irq_Depth, cmock_retval) sd_nvic_GetPendingIRQ_CMockExpectWithArrayAndReturn(__LINE__, IRQn, p_pending_irq, p_pending_irq_Depth, cmock_retval)
+void sd_nvic_GetPendingIRQ_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t* p_pending_irq, int p_pending_irq_Depth, uint32_t cmock_to_return);
+#define sd_nvic_GetPendingIRQ_ReturnThruPtr_p_pending_irq(p_pending_irq) sd_nvic_GetPendingIRQ_CMockReturnMemThruPtr_p_pending_irq(__LINE__, p_pending_irq, sizeof(*p_pending_irq))
+#define sd_nvic_GetPendingIRQ_ReturnArrayThruPtr_p_pending_irq(p_pending_irq, cmock_len) sd_nvic_GetPendingIRQ_CMockReturnMemThruPtr_p_pending_irq(__LINE__, p_pending_irq, cmock_len * sizeof(*p_pending_irq))
+#define sd_nvic_GetPendingIRQ_ReturnMemThruPtr_p_pending_irq(p_pending_irq, cmock_size) sd_nvic_GetPendingIRQ_CMockReturnMemThruPtr_p_pending_irq(__LINE__, p_pending_irq, cmock_size)
+void sd_nvic_GetPendingIRQ_CMockReturnMemThruPtr_p_pending_irq(UNITY_LINE_TYPE cmock_line, uint32_t* p_pending_irq, int cmock_size);
+#define sd_nvic_GetPendingIRQ_IgnoreArg_IRQn() sd_nvic_GetPendingIRQ_CMockIgnoreArg_IRQn(__LINE__)
+void sd_nvic_GetPendingIRQ_CMockIgnoreArg_IRQn(UNITY_LINE_TYPE cmock_line);
+#define sd_nvic_GetPendingIRQ_IgnoreArg_p_pending_irq() sd_nvic_GetPendingIRQ_CMockIgnoreArg_p_pending_irq(__LINE__)
+void sd_nvic_GetPendingIRQ_CMockIgnoreArg_p_pending_irq(UNITY_LINE_TYPE cmock_line);
+#define sd_nvic_SetPendingIRQ_IgnoreAndReturn(cmock_retval) sd_nvic_SetPendingIRQ_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_nvic_SetPendingIRQ_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_nvic_SetPendingIRQ_ExpectAndReturn(IRQn, cmock_retval) sd_nvic_SetPendingIRQ_CMockExpectAndReturn(__LINE__, IRQn, cmock_retval)
+void sd_nvic_SetPendingIRQ_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_nvic_SetPendingIRQ_CALLBACK)(IRQn_Type IRQn, int cmock_num_calls);
+void sd_nvic_SetPendingIRQ_StubWithCallback(CMOCK_sd_nvic_SetPendingIRQ_CALLBACK Callback);
+#define sd_nvic_SetPendingIRQ_IgnoreArg_IRQn() sd_nvic_SetPendingIRQ_CMockIgnoreArg_IRQn(__LINE__)
+void sd_nvic_SetPendingIRQ_CMockIgnoreArg_IRQn(UNITY_LINE_TYPE cmock_line);
+#define sd_nvic_ClearPendingIRQ_IgnoreAndReturn(cmock_retval) sd_nvic_ClearPendingIRQ_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_nvic_ClearPendingIRQ_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_nvic_ClearPendingIRQ_ExpectAndReturn(IRQn, cmock_retval) sd_nvic_ClearPendingIRQ_CMockExpectAndReturn(__LINE__, IRQn, cmock_retval)
+void sd_nvic_ClearPendingIRQ_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_nvic_ClearPendingIRQ_CALLBACK)(IRQn_Type IRQn, int cmock_num_calls);
+void sd_nvic_ClearPendingIRQ_StubWithCallback(CMOCK_sd_nvic_ClearPendingIRQ_CALLBACK Callback);
+#define sd_nvic_ClearPendingIRQ_IgnoreArg_IRQn() sd_nvic_ClearPendingIRQ_CMockIgnoreArg_IRQn(__LINE__)
+void sd_nvic_ClearPendingIRQ_CMockIgnoreArg_IRQn(UNITY_LINE_TYPE cmock_line);
+#define sd_nvic_SetPriority_IgnoreAndReturn(cmock_retval) sd_nvic_SetPriority_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_nvic_SetPriority_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_nvic_SetPriority_ExpectAndReturn(IRQn, priority, cmock_retval) sd_nvic_SetPriority_CMockExpectAndReturn(__LINE__, IRQn, priority, cmock_retval)
+void sd_nvic_SetPriority_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t priority, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_nvic_SetPriority_CALLBACK)(IRQn_Type IRQn, uint32_t priority, int cmock_num_calls);
+void sd_nvic_SetPriority_StubWithCallback(CMOCK_sd_nvic_SetPriority_CALLBACK Callback);
+#define sd_nvic_SetPriority_IgnoreArg_IRQn() sd_nvic_SetPriority_CMockIgnoreArg_IRQn(__LINE__)
+void sd_nvic_SetPriority_CMockIgnoreArg_IRQn(UNITY_LINE_TYPE cmock_line);
+#define sd_nvic_SetPriority_IgnoreArg_priority() sd_nvic_SetPriority_CMockIgnoreArg_priority(__LINE__)
+void sd_nvic_SetPriority_CMockIgnoreArg_priority(UNITY_LINE_TYPE cmock_line);
+#define sd_nvic_GetPriority_IgnoreAndReturn(cmock_retval) sd_nvic_GetPriority_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_nvic_GetPriority_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_nvic_GetPriority_ExpectAndReturn(IRQn, p_priority, cmock_retval) sd_nvic_GetPriority_CMockExpectAndReturn(__LINE__, IRQn, p_priority, cmock_retval)
+void sd_nvic_GetPriority_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t* p_priority, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_nvic_GetPriority_CALLBACK)(IRQn_Type IRQn, uint32_t* p_priority, int cmock_num_calls);
+void sd_nvic_GetPriority_StubWithCallback(CMOCK_sd_nvic_GetPriority_CALLBACK Callback);
+#define sd_nvic_GetPriority_ExpectWithArrayAndReturn(IRQn, p_priority, p_priority_Depth, cmock_retval) sd_nvic_GetPriority_CMockExpectWithArrayAndReturn(__LINE__, IRQn, p_priority, p_priority_Depth, cmock_retval)
+void sd_nvic_GetPriority_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, IRQn_Type IRQn, uint32_t* p_priority, int p_priority_Depth, uint32_t cmock_to_return);
+#define sd_nvic_GetPriority_ReturnThruPtr_p_priority(p_priority) sd_nvic_GetPriority_CMockReturnMemThruPtr_p_priority(__LINE__, p_priority, sizeof(*p_priority))
+#define sd_nvic_GetPriority_ReturnArrayThruPtr_p_priority(p_priority, cmock_len) sd_nvic_GetPriority_CMockReturnMemThruPtr_p_priority(__LINE__, p_priority, cmock_len * sizeof(*p_priority))
+#define sd_nvic_GetPriority_ReturnMemThruPtr_p_priority(p_priority, cmock_size) sd_nvic_GetPriority_CMockReturnMemThruPtr_p_priority(__LINE__, p_priority, cmock_size)
+void sd_nvic_GetPriority_CMockReturnMemThruPtr_p_priority(UNITY_LINE_TYPE cmock_line, uint32_t* p_priority, int cmock_size);
+#define sd_nvic_GetPriority_IgnoreArg_IRQn() sd_nvic_GetPriority_CMockIgnoreArg_IRQn(__LINE__)
+void sd_nvic_GetPriority_CMockIgnoreArg_IRQn(UNITY_LINE_TYPE cmock_line);
+#define sd_nvic_GetPriority_IgnoreArg_p_priority() sd_nvic_GetPriority_CMockIgnoreArg_p_priority(__LINE__)
+void sd_nvic_GetPriority_CMockIgnoreArg_p_priority(UNITY_LINE_TYPE cmock_line);
+#define sd_nvic_SystemReset_IgnoreAndReturn(cmock_retval) sd_nvic_SystemReset_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_nvic_SystemReset_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_nvic_SystemReset_ExpectAndReturn(cmock_retval) sd_nvic_SystemReset_CMockExpectAndReturn(__LINE__, cmock_retval)
+void sd_nvic_SystemReset_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_nvic_SystemReset_CALLBACK)(int cmock_num_calls);
+void sd_nvic_SystemReset_StubWithCallback(CMOCK_sd_nvic_SystemReset_CALLBACK Callback);
+#define sd_nvic_critical_region_enter_IgnoreAndReturn(cmock_retval) sd_nvic_critical_region_enter_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_nvic_critical_region_enter_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_nvic_critical_region_enter_ExpectAndReturn(p_is_nested_critical_region, cmock_retval) sd_nvic_critical_region_enter_CMockExpectAndReturn(__LINE__, p_is_nested_critical_region, cmock_retval)
+void sd_nvic_critical_region_enter_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_is_nested_critical_region, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_nvic_critical_region_enter_CALLBACK)(uint8_t* p_is_nested_critical_region, int cmock_num_calls);
+void sd_nvic_critical_region_enter_StubWithCallback(CMOCK_sd_nvic_critical_region_enter_CALLBACK Callback);
+#define sd_nvic_critical_region_enter_ExpectWithArrayAndReturn(p_is_nested_critical_region, p_is_nested_critical_region_Depth, cmock_retval) sd_nvic_critical_region_enter_CMockExpectWithArrayAndReturn(__LINE__, p_is_nested_critical_region, p_is_nested_critical_region_Depth, cmock_retval)
+void sd_nvic_critical_region_enter_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_is_nested_critical_region, int p_is_nested_critical_region_Depth, uint32_t cmock_to_return);
+#define sd_nvic_critical_region_enter_ReturnThruPtr_p_is_nested_critical_region(p_is_nested_critical_region) sd_nvic_critical_region_enter_CMockReturnMemThruPtr_p_is_nested_critical_region(__LINE__, p_is_nested_critical_region, sizeof(*p_is_nested_critical_region))
+#define sd_nvic_critical_region_enter_ReturnArrayThruPtr_p_is_nested_critical_region(p_is_nested_critical_region, cmock_len) sd_nvic_critical_region_enter_CMockReturnMemThruPtr_p_is_nested_critical_region(__LINE__, p_is_nested_critical_region, cmock_len * sizeof(*p_is_nested_critical_region))
+#define sd_nvic_critical_region_enter_ReturnMemThruPtr_p_is_nested_critical_region(p_is_nested_critical_region, cmock_size) sd_nvic_critical_region_enter_CMockReturnMemThruPtr_p_is_nested_critical_region(__LINE__, p_is_nested_critical_region, cmock_size)
+void sd_nvic_critical_region_enter_CMockReturnMemThruPtr_p_is_nested_critical_region(UNITY_LINE_TYPE cmock_line, uint8_t* p_is_nested_critical_region, int cmock_size);
+#define sd_nvic_critical_region_enter_IgnoreArg_p_is_nested_critical_region() sd_nvic_critical_region_enter_CMockIgnoreArg_p_is_nested_critical_region(__LINE__)
+void sd_nvic_critical_region_enter_CMockIgnoreArg_p_is_nested_critical_region(UNITY_LINE_TYPE cmock_line);
+#define sd_nvic_critical_region_exit_IgnoreAndReturn(cmock_retval) sd_nvic_critical_region_exit_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_nvic_critical_region_exit_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_nvic_critical_region_exit_ExpectAndReturn(is_nested_critical_region, cmock_retval) sd_nvic_critical_region_exit_CMockExpectAndReturn(__LINE__, is_nested_critical_region, cmock_retval)
+void sd_nvic_critical_region_exit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t is_nested_critical_region, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_nvic_critical_region_exit_CALLBACK)(uint8_t is_nested_critical_region, int cmock_num_calls);
+void sd_nvic_critical_region_exit_StubWithCallback(CMOCK_sd_nvic_critical_region_exit_CALLBACK Callback);
+#define sd_nvic_critical_region_exit_IgnoreArg_is_nested_critical_region() sd_nvic_critical_region_exit_CMockIgnoreArg_is_nested_critical_region(__LINE__)
+void sd_nvic_critical_region_exit_CMockIgnoreArg_is_nested_critical_region(UNITY_LINE_TYPE cmock_line);
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_sd_def.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_sd_def.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_sd_def.c  1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_sd_def.c   2018-04-24 08:48:28.898152900 +0200
@@ -0,0 +1,36 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_nrf_sd_def.h"
+
+static struct mock_nrf_sd_defInstance
+{
+  unsigned char placeHolder;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_nrf_sd_def_Verify(void)
+{
+}
+
+void mock_nrf_sd_def_Init(void)
+{
+  mock_nrf_sd_def_Destroy();
+}
+
+void mock_nrf_sd_def_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_sd_def.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_sd_def.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_sd_def.h  1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_sd_def.h   2018-04-24 08:48:28.898152900 +0200
@@ -0,0 +1,26 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_NRF_SD_DEF_H
+#define _MOCK_NRF_SD_DEF_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <nrf_sd_def.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_nrf_sd_def_Init(void);
+void mock_nrf_sd_def_Destroy(void);
+void mock_nrf_sd_def_Verify(void);
+
+
+
+
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_sdm.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_sdm.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_sdm.c 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_sdm.c  2018-04-24 08:48:28.908153100 +0200
@@ -0,0 +1,465 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_nrf_sdm.h"
+
+typedef struct _CMOCK_sd_softdevice_enable_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  nrf_clock_lf_cfg_t const* Expected_p_clock_lf_cfg;
+  nrf_fault_handler_t Expected_fault_handler;
+  int Expected_p_clock_lf_cfg_Depth;
+  int ReturnThruPtr_p_clock_lf_cfg_Used;
+  nrf_clock_lf_cfg_t const* ReturnThruPtr_p_clock_lf_cfg_Val;
+  int ReturnThruPtr_p_clock_lf_cfg_Size;
+  int IgnoreArg_p_clock_lf_cfg;
+  int IgnoreArg_fault_handler;
+
+} CMOCK_sd_softdevice_enable_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_softdevice_disable_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+
+} CMOCK_sd_softdevice_disable_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t* Expected_p_softdevice_enabled;
+  int Expected_p_softdevice_enabled_Depth;
+  int ReturnThruPtr_p_softdevice_enabled_Used;
+  uint8_t* ReturnThruPtr_p_softdevice_enabled_Val;
+  int ReturnThruPtr_p_softdevice_enabled_Size;
+  int IgnoreArg_p_softdevice_enabled;
+
+} CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_softdevice_vector_table_base_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t Expected_address;
+  int IgnoreArg_address;
+
+} CMOCK_sd_softdevice_vector_table_base_set_CALL_INSTANCE;
+
+static struct mock_nrf_sdmInstance
+{
+  int sd_softdevice_enable_IgnoreBool;
+  uint32_t sd_softdevice_enable_FinalReturn;
+  CMOCK_sd_softdevice_enable_CALLBACK sd_softdevice_enable_CallbackFunctionPointer;
+  int sd_softdevice_enable_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_softdevice_enable_CallInstance;
+  int sd_softdevice_disable_IgnoreBool;
+  uint32_t sd_softdevice_disable_FinalReturn;
+  CMOCK_sd_softdevice_disable_CALLBACK sd_softdevice_disable_CallbackFunctionPointer;
+  int sd_softdevice_disable_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_softdevice_disable_CallInstance;
+  int sd_softdevice_is_enabled_IgnoreBool;
+  uint32_t sd_softdevice_is_enabled_FinalReturn;
+  CMOCK_sd_softdevice_is_enabled_CALLBACK sd_softdevice_is_enabled_CallbackFunctionPointer;
+  int sd_softdevice_is_enabled_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_softdevice_is_enabled_CallInstance;
+  int sd_softdevice_vector_table_base_set_IgnoreBool;
+  uint32_t sd_softdevice_vector_table_base_set_FinalReturn;
+  CMOCK_sd_softdevice_vector_table_base_set_CALLBACK sd_softdevice_vector_table_base_set_CallbackFunctionPointer;
+  int sd_softdevice_vector_table_base_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_softdevice_vector_table_base_set_CallInstance;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_nrf_sdm_Verify(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_softdevice_enable_CallInstance, cmock_line, "Function 'sd_softdevice_enable' called less times than expected.");
+  if (Mock.sd_softdevice_enable_CallbackFunctionPointer != NULL)
+    Mock.sd_softdevice_enable_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_softdevice_disable_CallInstance, cmock_line, "Function 'sd_softdevice_disable' called less times than expected.");
+  if (Mock.sd_softdevice_disable_CallbackFunctionPointer != NULL)
+    Mock.sd_softdevice_disable_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_softdevice_is_enabled_CallInstance, cmock_line, "Function 'sd_softdevice_is_enabled' called less times than expected.");
+  if (Mock.sd_softdevice_is_enabled_CallbackFunctionPointer != NULL)
+    Mock.sd_softdevice_is_enabled_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_softdevice_vector_table_base_set_CallInstance, cmock_line, "Function 'sd_softdevice_vector_table_base_set' called less times than expected.");
+  if (Mock.sd_softdevice_vector_table_base_set_CallbackFunctionPointer != NULL)
+    Mock.sd_softdevice_vector_table_base_set_CallInstance = CMOCK_GUTS_NONE;
+}
+
+void mock_nrf_sdm_Init(void)
+{
+  mock_nrf_sdm_Destroy();
+}
+
+void mock_nrf_sdm_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  Mock.sd_softdevice_enable_CallbackFunctionPointer = NULL;
+  Mock.sd_softdevice_enable_CallbackCalls = 0;
+  Mock.sd_softdevice_disable_CallbackFunctionPointer = NULL;
+  Mock.sd_softdevice_disable_CallbackCalls = 0;
+  Mock.sd_softdevice_is_enabled_CallbackFunctionPointer = NULL;
+  Mock.sd_softdevice_is_enabled_CallbackCalls = 0;
+  Mock.sd_softdevice_vector_table_base_set_CallbackFunctionPointer = NULL;
+  Mock.sd_softdevice_vector_table_base_set_CallbackCalls = 0;
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+uint32_t sd_softdevice_enable(nrf_clock_lf_cfg_t const* p_clock_lf_cfg, nrf_fault_handler_t fault_handler)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_softdevice_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_softdevice_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_softdevice_enable_CallInstance);
+  Mock.sd_softdevice_enable_CallInstance = CMock_Guts_MemNext(Mock.sd_softdevice_enable_CallInstance);
+  if (Mock.sd_softdevice_enable_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_softdevice_enable_FinalReturn;
+    Mock.sd_softdevice_enable_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_softdevice_enable_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_softdevice_enable_CallbackFunctionPointer(p_clock_lf_cfg, fault_handler, Mock.sd_softdevice_enable_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_softdevice_enable' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_softdevice_enable' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_softdevice_enable' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_clock_lf_cfg)
+  {
+    if (cmock_call_instance->Expected_p_clock_lf_cfg == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_clock_lf_cfg, cmock_line, "Expected NULL. Function 'sd_softdevice_enable' called with unexpected value for argument 'p_clock_lf_cfg'."); }
+    else if (cmock_call_instance->Expected_p_clock_lf_cfg_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_clock_lf_cfg, p_clock_lf_cfg, cmock_line, "Function 'sd_softdevice_enable' called with unexpected value for argument 'p_clock_lf_cfg'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_clock_lf_cfg), (void*)(p_clock_lf_cfg), sizeof(nrf_clock_lf_cfg_t), cmock_call_instance->Expected_p_clock_lf_cfg_Depth, cmock_line, "Function 'sd_softdevice_enable' called with unexpected value for argument 'p_clock_lf_cfg'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_fault_handler)
+  {
+    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_fault_handler), (void*)(&fault_handler), sizeof(nrf_fault_handler_t), cmock_line, "Function 'sd_softdevice_enable' called with unexpected value for argument 'fault_handler'.");
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_clock_lf_cfg_Used)
+  {
+    memcpy((void*)p_clock_lf_cfg, (void*)cmock_call_instance->ReturnThruPtr_p_clock_lf_cfg_Val,
+      cmock_call_instance->ReturnThruPtr_p_clock_lf_cfg_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_softdevice_enable(CMOCK_sd_softdevice_enable_CALL_INSTANCE* cmock_call_instance, nrf_clock_lf_cfg_t const* p_clock_lf_cfg, int p_clock_lf_cfg_Depth, nrf_fault_handler_t fault_handler)
+{
+  cmock_call_instance->Expected_p_clock_lf_cfg = p_clock_lf_cfg;
+  cmock_call_instance->Expected_p_clock_lf_cfg_Depth = p_clock_lf_cfg_Depth;
+  cmock_call_instance->IgnoreArg_p_clock_lf_cfg = 0;
+  cmock_call_instance->ReturnThruPtr_p_clock_lf_cfg_Used = 0;
+  memcpy(&cmock_call_instance->Expected_fault_handler, &fault_handler, sizeof(nrf_fault_handler_t));
+  cmock_call_instance->IgnoreArg_fault_handler = 0;
+}
+
+void sd_softdevice_enable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_softdevice_enable_CALL_INSTANCE));
+  CMOCK_sd_softdevice_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_softdevice_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_softdevice_enable_CallInstance = CMock_Guts_MemChain(Mock.sd_softdevice_enable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_softdevice_enable_IgnoreBool = (int)1;
+}
+
+void sd_softdevice_enable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nrf_clock_lf_cfg_t const* p_clock_lf_cfg, nrf_fault_handler_t fault_handler, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_softdevice_enable_CALL_INSTANCE));
+  CMOCK_sd_softdevice_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_softdevice_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_softdevice_enable_CallInstance = CMock_Guts_MemChain(Mock.sd_softdevice_enable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_softdevice_enable(cmock_call_instance, p_clock_lf_cfg, 0, fault_handler);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_softdevice_enable_StubWithCallback(CMOCK_sd_softdevice_enable_CALLBACK Callback)
+{
+  Mock.sd_softdevice_enable_CallbackFunctionPointer = Callback;
+}
+
+void sd_softdevice_enable_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, nrf_clock_lf_cfg_t const* p_clock_lf_cfg, int p_clock_lf_cfg_Depth, nrf_fault_handler_t fault_handler, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_softdevice_enable_CALL_INSTANCE));
+  CMOCK_sd_softdevice_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_softdevice_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_softdevice_enable_CallInstance = CMock_Guts_MemChain(Mock.sd_softdevice_enable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_softdevice_enable(cmock_call_instance, p_clock_lf_cfg, p_clock_lf_cfg_Depth, fault_handler);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_softdevice_enable_CMockReturnMemThruPtr_p_clock_lf_cfg(UNITY_LINE_TYPE cmock_line, nrf_clock_lf_cfg_t const* p_clock_lf_cfg, int cmock_size)
+{
+  CMOCK_sd_softdevice_enable_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_softdevice_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_softdevice_enable_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_clock_lf_cfg ReturnThruPtr called before Expect on 'sd_softdevice_enable'.");
+  cmock_call_instance->ReturnThruPtr_p_clock_lf_cfg_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_clock_lf_cfg_Val = p_clock_lf_cfg;
+  cmock_call_instance->ReturnThruPtr_p_clock_lf_cfg_Size = cmock_size;
+}
+
+void sd_softdevice_enable_CMockIgnoreArg_p_clock_lf_cfg(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_softdevice_enable_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_softdevice_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_softdevice_enable_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_clock_lf_cfg IgnoreArg called before Expect on 'sd_softdevice_enable'.");
+  cmock_call_instance->IgnoreArg_p_clock_lf_cfg = 1;
+}
+
+void sd_softdevice_enable_CMockIgnoreArg_fault_handler(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_softdevice_enable_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_softdevice_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_softdevice_enable_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "fault_handler IgnoreArg called before Expect on 'sd_softdevice_enable'.");
+  cmock_call_instance->IgnoreArg_fault_handler = 1;
+}
+
+uint32_t sd_softdevice_disable(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_softdevice_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_softdevice_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_softdevice_disable_CallInstance);
+  Mock.sd_softdevice_disable_CallInstance = CMock_Guts_MemNext(Mock.sd_softdevice_disable_CallInstance);
+  if (Mock.sd_softdevice_disable_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_softdevice_disable_FinalReturn;
+    Mock.sd_softdevice_disable_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_softdevice_disable_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_softdevice_disable_CallbackFunctionPointer(Mock.sd_softdevice_disable_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_softdevice_disable' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_softdevice_disable' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_softdevice_disable' called later than expected.");
+  return cmock_call_instance->ReturnVal;
+}
+
+void sd_softdevice_disable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_softdevice_disable_CALL_INSTANCE));
+  CMOCK_sd_softdevice_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_softdevice_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_softdevice_disable_CallInstance = CMock_Guts_MemChain(Mock.sd_softdevice_disable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_softdevice_disable_IgnoreBool = (int)1;
+}
+
+void sd_softdevice_disable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_softdevice_disable_CALL_INSTANCE));
+  CMOCK_sd_softdevice_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_softdevice_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_softdevice_disable_CallInstance = CMock_Guts_MemChain(Mock.sd_softdevice_disable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_softdevice_disable_StubWithCallback(CMOCK_sd_softdevice_disable_CALLBACK Callback)
+{
+  Mock.sd_softdevice_disable_CallbackFunctionPointer = Callback;
+}
+
+uint32_t sd_softdevice_is_enabled(uint8_t* p_softdevice_enabled)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_softdevice_is_enabled_CallInstance);
+  Mock.sd_softdevice_is_enabled_CallInstance = CMock_Guts_MemNext(Mock.sd_softdevice_is_enabled_CallInstance);
+  if (Mock.sd_softdevice_is_enabled_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_softdevice_is_enabled_FinalReturn;
+    Mock.sd_softdevice_is_enabled_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_softdevice_is_enabled_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_softdevice_is_enabled_CallbackFunctionPointer(p_softdevice_enabled, Mock.sd_softdevice_is_enabled_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_softdevice_is_enabled' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_softdevice_is_enabled' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_softdevice_is_enabled' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_softdevice_enabled)
+  {
+    if (cmock_call_instance->Expected_p_softdevice_enabled == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_softdevice_enabled, cmock_line, "Expected NULL. Function 'sd_softdevice_is_enabled' called with unexpected value for argument 'p_softdevice_enabled'."); }
+    else if (cmock_call_instance->Expected_p_softdevice_enabled_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_softdevice_enabled, p_softdevice_enabled, cmock_line, "Function 'sd_softdevice_is_enabled' called with unexpected value for argument 'p_softdevice_enabled'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_softdevice_enabled, p_softdevice_enabled, cmock_call_instance->Expected_p_softdevice_enabled_Depth, cmock_line, "Function 'sd_softdevice_is_enabled' called with unexpected value for argument 'p_softdevice_enabled'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_softdevice_enabled_Used)
+  {
+    memcpy((void*)p_softdevice_enabled, (void*)cmock_call_instance->ReturnThruPtr_p_softdevice_enabled_Val,
+      cmock_call_instance->ReturnThruPtr_p_softdevice_enabled_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_softdevice_is_enabled(CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE* cmock_call_instance, uint8_t* p_softdevice_enabled, int p_softdevice_enabled_Depth)
+{
+  cmock_call_instance->Expected_p_softdevice_enabled = p_softdevice_enabled;
+  cmock_call_instance->Expected_p_softdevice_enabled_Depth = p_softdevice_enabled_Depth;
+  cmock_call_instance->IgnoreArg_p_softdevice_enabled = 0;
+  cmock_call_instance->ReturnThruPtr_p_softdevice_enabled_Used = 0;
+}
+
+void sd_softdevice_is_enabled_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE));
+  CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_softdevice_is_enabled_CallInstance = CMock_Guts_MemChain(Mock.sd_softdevice_is_enabled_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_softdevice_is_enabled_IgnoreBool = (int)1;
+}
+
+void sd_softdevice_is_enabled_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_softdevice_enabled, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE));
+  CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_softdevice_is_enabled_CallInstance = CMock_Guts_MemChain(Mock.sd_softdevice_is_enabled_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_softdevice_is_enabled(cmock_call_instance, p_softdevice_enabled, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_softdevice_is_enabled_StubWithCallback(CMOCK_sd_softdevice_is_enabled_CALLBACK Callback)
+{
+  Mock.sd_softdevice_is_enabled_CallbackFunctionPointer = Callback;
+}
+
+void sd_softdevice_is_enabled_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_softdevice_enabled, int p_softdevice_enabled_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE));
+  CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_softdevice_is_enabled_CallInstance = CMock_Guts_MemChain(Mock.sd_softdevice_is_enabled_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_softdevice_is_enabled(cmock_call_instance, p_softdevice_enabled, p_softdevice_enabled_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_softdevice_is_enabled_CMockReturnMemThruPtr_p_softdevice_enabled(UNITY_LINE_TYPE cmock_line, uint8_t* p_softdevice_enabled, int cmock_size)
+{
+  CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_softdevice_is_enabled_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_softdevice_enabled ReturnThruPtr called before Expect on 'sd_softdevice_is_enabled'.");
+  cmock_call_instance->ReturnThruPtr_p_softdevice_enabled_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_softdevice_enabled_Val = p_softdevice_enabled;
+  cmock_call_instance->ReturnThruPtr_p_softdevice_enabled_Size = cmock_size;
+}
+
+void sd_softdevice_is_enabled_CMockIgnoreArg_p_softdevice_enabled(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_softdevice_is_enabled_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_softdevice_is_enabled_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_softdevice_enabled IgnoreArg called before Expect on 'sd_softdevice_is_enabled'.");
+  cmock_call_instance->IgnoreArg_p_softdevice_enabled = 1;
+}
+
+uint32_t sd_softdevice_vector_table_base_set(uint32_t address)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_softdevice_vector_table_base_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_softdevice_vector_table_base_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_softdevice_vector_table_base_set_CallInstance);
+  Mock.sd_softdevice_vector_table_base_set_CallInstance = CMock_Guts_MemNext(Mock.sd_softdevice_vector_table_base_set_CallInstance);
+  if (Mock.sd_softdevice_vector_table_base_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_softdevice_vector_table_base_set_FinalReturn;
+    Mock.sd_softdevice_vector_table_base_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_softdevice_vector_table_base_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_softdevice_vector_table_base_set_CallbackFunctionPointer(address, Mock.sd_softdevice_vector_table_base_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_softdevice_vector_table_base_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_softdevice_vector_table_base_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_softdevice_vector_table_base_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_address)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_address, address, cmock_line, "Function 'sd_softdevice_vector_table_base_set' called with unexpected value for argument 'address'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_softdevice_vector_table_base_set(CMOCK_sd_softdevice_vector_table_base_set_CALL_INSTANCE* cmock_call_instance, uint32_t address)
+{
+  cmock_call_instance->Expected_address = address;
+  cmock_call_instance->IgnoreArg_address = 0;
+}
+
+void sd_softdevice_vector_table_base_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_softdevice_vector_table_base_set_CALL_INSTANCE));
+  CMOCK_sd_softdevice_vector_table_base_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_softdevice_vector_table_base_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_softdevice_vector_table_base_set_CallInstance = CMock_Guts_MemChain(Mock.sd_softdevice_vector_table_base_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_softdevice_vector_table_base_set_IgnoreBool = (int)1;
+}
+
+void sd_softdevice_vector_table_base_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t address, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_softdevice_vector_table_base_set_CALL_INSTANCE));
+  CMOCK_sd_softdevice_vector_table_base_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_softdevice_vector_table_base_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_softdevice_vector_table_base_set_CallInstance = CMock_Guts_MemChain(Mock.sd_softdevice_vector_table_base_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_softdevice_vector_table_base_set(cmock_call_instance, address);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_softdevice_vector_table_base_set_StubWithCallback(CMOCK_sd_softdevice_vector_table_base_set_CALLBACK Callback)
+{
+  Mock.sd_softdevice_vector_table_base_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_softdevice_vector_table_base_set_CMockIgnoreArg_address(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_softdevice_vector_table_base_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_softdevice_vector_table_base_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_softdevice_vector_table_base_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "address IgnoreArg called before Expect on 'sd_softdevice_vector_table_base_set'.");
+  cmock_call_instance->IgnoreArg_address = 1;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_sdm.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_sdm.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_sdm.h 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_sdm.h  2018-04-24 08:48:28.908153100 +0200
@@ -0,0 +1,70 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_NRF_SDM_H
+#define _MOCK_NRF_SDM_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <nrf_sdm.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_nrf_sdm_Init(void);
+void mock_nrf_sdm_Destroy(void);
+void mock_nrf_sdm_Verify(void);
+
+
+
+
+#define sd_softdevice_enable_IgnoreAndReturn(cmock_retval) sd_softdevice_enable_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_softdevice_enable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_softdevice_enable_ExpectAndReturn(p_clock_lf_cfg, fault_handler, cmock_retval) sd_softdevice_enable_CMockExpectAndReturn(__LINE__, p_clock_lf_cfg, fault_handler, cmock_retval)
+void sd_softdevice_enable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nrf_clock_lf_cfg_t const* p_clock_lf_cfg, nrf_fault_handler_t fault_handler, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_softdevice_enable_CALLBACK)(nrf_clock_lf_cfg_t const* p_clock_lf_cfg, nrf_fault_handler_t fault_handler, int cmock_num_calls);
+void sd_softdevice_enable_StubWithCallback(CMOCK_sd_softdevice_enable_CALLBACK Callback);
+#define sd_softdevice_enable_ExpectWithArrayAndReturn(p_clock_lf_cfg, p_clock_lf_cfg_Depth, fault_handler, cmock_retval) sd_softdevice_enable_CMockExpectWithArrayAndReturn(__LINE__, p_clock_lf_cfg, p_clock_lf_cfg_Depth, fault_handler, cmock_retval)
+void sd_softdevice_enable_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, nrf_clock_lf_cfg_t const* p_clock_lf_cfg, int p_clock_lf_cfg_Depth, nrf_fault_handler_t fault_handler, uint32_t cmock_to_return);
+#define sd_softdevice_enable_ReturnThruPtr_p_clock_lf_cfg(p_clock_lf_cfg) sd_softdevice_enable_CMockReturnMemThruPtr_p_clock_lf_cfg(__LINE__, p_clock_lf_cfg, sizeof(*p_clock_lf_cfg))
+#define sd_softdevice_enable_ReturnArrayThruPtr_p_clock_lf_cfg(p_clock_lf_cfg, cmock_len) sd_softdevice_enable_CMockReturnMemThruPtr_p_clock_lf_cfg(__LINE__, p_clock_lf_cfg, cmock_len * sizeof(*p_clock_lf_cfg))
+#define sd_softdevice_enable_ReturnMemThruPtr_p_clock_lf_cfg(p_clock_lf_cfg, cmock_size) sd_softdevice_enable_CMockReturnMemThruPtr_p_clock_lf_cfg(__LINE__, p_clock_lf_cfg, cmock_size)
+void sd_softdevice_enable_CMockReturnMemThruPtr_p_clock_lf_cfg(UNITY_LINE_TYPE cmock_line, nrf_clock_lf_cfg_t const* p_clock_lf_cfg, int cmock_size);
+#define sd_softdevice_enable_IgnoreArg_p_clock_lf_cfg() sd_softdevice_enable_CMockIgnoreArg_p_clock_lf_cfg(__LINE__)
+void sd_softdevice_enable_CMockIgnoreArg_p_clock_lf_cfg(UNITY_LINE_TYPE cmock_line);
+#define sd_softdevice_enable_IgnoreArg_fault_handler() sd_softdevice_enable_CMockIgnoreArg_fault_handler(__LINE__)
+void sd_softdevice_enable_CMockIgnoreArg_fault_handler(UNITY_LINE_TYPE cmock_line);
+#define sd_softdevice_disable_IgnoreAndReturn(cmock_retval) sd_softdevice_disable_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_softdevice_disable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_softdevice_disable_ExpectAndReturn(cmock_retval) sd_softdevice_disable_CMockExpectAndReturn(__LINE__, cmock_retval)
+void sd_softdevice_disable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_softdevice_disable_CALLBACK)(int cmock_num_calls);
+void sd_softdevice_disable_StubWithCallback(CMOCK_sd_softdevice_disable_CALLBACK Callback);
+#define sd_softdevice_is_enabled_IgnoreAndReturn(cmock_retval) sd_softdevice_is_enabled_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_softdevice_is_enabled_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_softdevice_is_enabled_ExpectAndReturn(p_softdevice_enabled, cmock_retval) sd_softdevice_is_enabled_CMockExpectAndReturn(__LINE__, p_softdevice_enabled, cmock_retval)
+void sd_softdevice_is_enabled_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_softdevice_enabled, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_softdevice_is_enabled_CALLBACK)(uint8_t* p_softdevice_enabled, int cmock_num_calls);
+void sd_softdevice_is_enabled_StubWithCallback(CMOCK_sd_softdevice_is_enabled_CALLBACK Callback);
+#define sd_softdevice_is_enabled_ExpectWithArrayAndReturn(p_softdevice_enabled, p_softdevice_enabled_Depth, cmock_retval) sd_softdevice_is_enabled_CMockExpectWithArrayAndReturn(__LINE__, p_softdevice_enabled, p_softdevice_enabled_Depth, cmock_retval)
+void sd_softdevice_is_enabled_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_softdevice_enabled, int p_softdevice_enabled_Depth, uint32_t cmock_to_return);
+#define sd_softdevice_is_enabled_ReturnThruPtr_p_softdevice_enabled(p_softdevice_enabled) sd_softdevice_is_enabled_CMockReturnMemThruPtr_p_softdevice_enabled(__LINE__, p_softdevice_enabled, sizeof(*p_softdevice_enabled))
+#define sd_softdevice_is_enabled_ReturnArrayThruPtr_p_softdevice_enabled(p_softdevice_enabled, cmock_len) sd_softdevice_is_enabled_CMockReturnMemThruPtr_p_softdevice_enabled(__LINE__, p_softdevice_enabled, cmock_len * sizeof(*p_softdevice_enabled))
+#define sd_softdevice_is_enabled_ReturnMemThruPtr_p_softdevice_enabled(p_softdevice_enabled, cmock_size) sd_softdevice_is_enabled_CMockReturnMemThruPtr_p_softdevice_enabled(__LINE__, p_softdevice_enabled, cmock_size)
+void sd_softdevice_is_enabled_CMockReturnMemThruPtr_p_softdevice_enabled(UNITY_LINE_TYPE cmock_line, uint8_t* p_softdevice_enabled, int cmock_size);
+#define sd_softdevice_is_enabled_IgnoreArg_p_softdevice_enabled() sd_softdevice_is_enabled_CMockIgnoreArg_p_softdevice_enabled(__LINE__)
+void sd_softdevice_is_enabled_CMockIgnoreArg_p_softdevice_enabled(UNITY_LINE_TYPE cmock_line);
+#define sd_softdevice_vector_table_base_set_IgnoreAndReturn(cmock_retval) sd_softdevice_vector_table_base_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_softdevice_vector_table_base_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_softdevice_vector_table_base_set_ExpectAndReturn(address, cmock_retval) sd_softdevice_vector_table_base_set_CMockExpectAndReturn(__LINE__, address, cmock_retval)
+void sd_softdevice_vector_table_base_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t address, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_softdevice_vector_table_base_set_CALLBACK)(uint32_t address, int cmock_num_calls);
+void sd_softdevice_vector_table_base_set_StubWithCallback(CMOCK_sd_softdevice_vector_table_base_set_CALLBACK Callback);
+#define sd_softdevice_vector_table_base_set_IgnoreArg_address() sd_softdevice_vector_table_base_set_CMockIgnoreArg_address(__LINE__)
+void sd_softdevice_vector_table_base_set_CMockIgnoreArg_address(UNITY_LINE_TYPE cmock_line);
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_soc.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_soc.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_soc.c 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_soc.c  2018-04-24 08:48:28.938153700 +0200
@@ -0,0 +1,4658 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_nrf_soc.h"
+
+typedef struct _CMOCK_sd_mutex_new_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  nrf_mutex_t* Expected_p_mutex;
+  int Expected_p_mutex_Depth;
+  int ReturnThruPtr_p_mutex_Used;
+  nrf_mutex_t* ReturnThruPtr_p_mutex_Val;
+  int ReturnThruPtr_p_mutex_Size;
+  int IgnoreArg_p_mutex;
+
+} CMOCK_sd_mutex_new_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_mutex_acquire_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  nrf_mutex_t* Expected_p_mutex;
+  int Expected_p_mutex_Depth;
+  int ReturnThruPtr_p_mutex_Used;
+  nrf_mutex_t* ReturnThruPtr_p_mutex_Val;
+  int ReturnThruPtr_p_mutex_Size;
+  int IgnoreArg_p_mutex;
+
+} CMOCK_sd_mutex_acquire_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_mutex_release_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  nrf_mutex_t* Expected_p_mutex;
+  int Expected_p_mutex_Depth;
+  int ReturnThruPtr_p_mutex_Used;
+  nrf_mutex_t* ReturnThruPtr_p_mutex_Val;
+  int ReturnThruPtr_p_mutex_Size;
+  int IgnoreArg_p_mutex;
+
+} CMOCK_sd_mutex_release_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t* Expected_p_pool_capacity;
+  int Expected_p_pool_capacity_Depth;
+  int ReturnThruPtr_p_pool_capacity_Used;
+  uint8_t* ReturnThruPtr_p_pool_capacity_Val;
+  int ReturnThruPtr_p_pool_capacity_Size;
+  int IgnoreArg_p_pool_capacity;
+
+} CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t* Expected_p_bytes_available;
+  int Expected_p_bytes_available_Depth;
+  int ReturnThruPtr_p_bytes_available_Used;
+  uint8_t* ReturnThruPtr_p_bytes_available_Val;
+  int ReturnThruPtr_p_bytes_available_Size;
+  int IgnoreArg_p_bytes_available;
+
+} CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_rand_application_vector_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t* Expected_p_buff;
+  uint8_t Expected_length;
+  int Expected_p_buff_Depth;
+  int ReturnThruPtr_p_buff_Used;
+  uint8_t* ReturnThruPtr_p_buff_Val;
+  int ReturnThruPtr_p_buff_Size;
+  int IgnoreArg_p_buff;
+  int IgnoreArg_length;
+
+} CMOCK_sd_rand_application_vector_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_power_reset_reason_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t* Expected_p_reset_reason;
+  int Expected_p_reset_reason_Depth;
+  int ReturnThruPtr_p_reset_reason_Used;
+  uint32_t* ReturnThruPtr_p_reset_reason_Val;
+  int ReturnThruPtr_p_reset_reason_Size;
+  int IgnoreArg_p_reset_reason;
+
+} CMOCK_sd_power_reset_reason_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_power_reset_reason_clr_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t Expected_reset_reason_clr_msk;
+  int IgnoreArg_reset_reason_clr_msk;
+
+} CMOCK_sd_power_reset_reason_clr_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_power_mode_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t Expected_power_mode;
+  int IgnoreArg_power_mode;
+
+} CMOCK_sd_power_mode_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_power_system_off_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+
+} CMOCK_sd_power_system_off_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_power_pof_enable_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t Expected_pof_enable;
+  int IgnoreArg_pof_enable;
+
+} CMOCK_sd_power_pof_enable_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_power_pof_threshold_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t Expected_threshold;
+  int IgnoreArg_threshold;
+
+} CMOCK_sd_power_pof_threshold_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_power_ramon_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t Expected_ramon;
+  int IgnoreArg_ramon;
+
+} CMOCK_sd_power_ramon_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_power_ramon_clr_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t Expected_ramon;
+  int IgnoreArg_ramon;
+
+} CMOCK_sd_power_ramon_clr_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_power_ramon_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t* Expected_p_ramon;
+  int Expected_p_ramon_Depth;
+  int ReturnThruPtr_p_ramon_Used;
+  uint32_t* ReturnThruPtr_p_ramon_Val;
+  int ReturnThruPtr_p_ramon_Size;
+  int IgnoreArg_p_ramon;
+
+} CMOCK_sd_power_ramon_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_power_gpregret_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t Expected_gpregret_id;
+  uint32_t Expected_gpregret_msk;
+  int IgnoreArg_gpregret_id;
+  int IgnoreArg_gpregret_msk;
+
+} CMOCK_sd_power_gpregret_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_power_gpregret_clr_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t Expected_gpregret_id;
+  uint32_t Expected_gpregret_msk;
+  int IgnoreArg_gpregret_id;
+  int IgnoreArg_gpregret_msk;
+
+} CMOCK_sd_power_gpregret_clr_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_power_gpregret_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t Expected_gpregret_id;
+  uint32_t* Expected_p_gpregret;
+  int Expected_p_gpregret_Depth;
+  int ReturnThruPtr_p_gpregret_Used;
+  uint32_t* ReturnThruPtr_p_gpregret_Val;
+  int ReturnThruPtr_p_gpregret_Size;
+  int IgnoreArg_gpregret_id;
+  int IgnoreArg_p_gpregret;
+
+} CMOCK_sd_power_gpregret_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_power_dcdc_mode_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t Expected_dcdc_mode;
+  int IgnoreArg_dcdc_mode;
+
+} CMOCK_sd_power_dcdc_mode_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_clock_hfclk_request_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+
+} CMOCK_sd_clock_hfclk_request_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_clock_hfclk_release_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+
+} CMOCK_sd_clock_hfclk_release_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t* Expected_p_is_running;
+  int Expected_p_is_running_Depth;
+  int ReturnThruPtr_p_is_running_Used;
+  uint32_t* ReturnThruPtr_p_is_running_Val;
+  int ReturnThruPtr_p_is_running_Size;
+  int IgnoreArg_p_is_running;
+
+} CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_app_evt_wait_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+
+} CMOCK_sd_app_evt_wait_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t* Expected_p_channel_enable;
+  int Expected_p_channel_enable_Depth;
+  int ReturnThruPtr_p_channel_enable_Used;
+  uint32_t* ReturnThruPtr_p_channel_enable_Val;
+  int ReturnThruPtr_p_channel_enable_Size;
+  int IgnoreArg_p_channel_enable;
+
+} CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ppi_channel_enable_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t Expected_channel_enable_set_msk;
+  int IgnoreArg_channel_enable_set_msk;
+
+} CMOCK_sd_ppi_channel_enable_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ppi_channel_enable_clr_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t Expected_channel_enable_clr_msk;
+  int IgnoreArg_channel_enable_clr_msk;
+
+} CMOCK_sd_ppi_channel_enable_clr_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ppi_channel_assign_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t Expected_channel_num;
+  volatile void* Expected_evt_endpoint;
+  volatile void* Expected_task_endpoint;
+  int Expected_evt_endpoint_Depth;
+  int Expected_task_endpoint_Depth;
+  int IgnoreArg_channel_num;
+  int IgnoreArg_evt_endpoint;
+  int IgnoreArg_task_endpoint;
+
+} CMOCK_sd_ppi_channel_assign_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ppi_group_task_enable_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t Expected_group_num;
+  int IgnoreArg_group_num;
+
+} CMOCK_sd_ppi_group_task_enable_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ppi_group_task_disable_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t Expected_group_num;
+  int IgnoreArg_group_num;
+
+} CMOCK_sd_ppi_group_task_disable_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ppi_group_assign_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t Expected_group_num;
+  uint32_t Expected_channel_msk;
+  int IgnoreArg_group_num;
+  int IgnoreArg_channel_msk;
+
+} CMOCK_sd_ppi_group_assign_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ppi_group_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t Expected_group_num;
+  uint32_t* Expected_p_channel_msk;
+  int Expected_p_channel_msk_Depth;
+  int ReturnThruPtr_p_channel_msk_Used;
+  uint32_t* ReturnThruPtr_p_channel_msk_Val;
+  int ReturnThruPtr_p_channel_msk_Size;
+  int IgnoreArg_group_num;
+  int IgnoreArg_p_channel_msk;
+
+} CMOCK_sd_ppi_group_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_radio_notification_cfg_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t Expected_type;
+  uint8_t Expected_distance;
+  int IgnoreArg_type;
+  int IgnoreArg_distance;
+
+} CMOCK_sd_radio_notification_cfg_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  nrf_ecb_hal_data_t* Expected_p_ecb_data;
+  int Expected_p_ecb_data_Depth;
+  int ReturnThruPtr_p_ecb_data_Used;
+  nrf_ecb_hal_data_t* ReturnThruPtr_p_ecb_data_Val;
+  int ReturnThruPtr_p_ecb_data_Size;
+  int IgnoreArg_p_ecb_data;
+
+} CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t Expected_block_count;
+  nrf_ecb_hal_data_block_t* Expected_p_data_blocks;
+  int Expected_p_data_blocks_Depth;
+  int ReturnThruPtr_p_data_blocks_Used;
+  nrf_ecb_hal_data_block_t* ReturnThruPtr_p_data_blocks_Val;
+  int ReturnThruPtr_p_data_blocks_Size;
+  int IgnoreArg_block_count;
+  int IgnoreArg_p_data_blocks;
+
+} CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_evt_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t* Expected_p_evt_id;
+  int Expected_p_evt_id_Depth;
+  int ReturnThruPtr_p_evt_id_Used;
+  uint32_t* ReturnThruPtr_p_evt_id_Val;
+  int ReturnThruPtr_p_evt_id_Size;
+  int IgnoreArg_p_evt_id;
+
+} CMOCK_sd_evt_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_temp_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  int32_t* Expected_p_temp;
+  int Expected_p_temp_Depth;
+  int ReturnThruPtr_p_temp_Used;
+  int32_t* ReturnThruPtr_p_temp_Val;
+  int ReturnThruPtr_p_temp_Size;
+  int IgnoreArg_p_temp;
+
+} CMOCK_sd_temp_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_flash_write_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t* Expected_p_dst;
+  uint32_t const* Expected_p_src;
+  uint32_t Expected_size;
+  int Expected_p_dst_Depth;
+  int Expected_p_src_Depth;
+  int ReturnThruPtr_p_dst_Used;
+  uint32_t* ReturnThruPtr_p_dst_Val;
+  int ReturnThruPtr_p_dst_Size;
+  int ReturnThruPtr_p_src_Used;
+  uint32_t const* ReturnThruPtr_p_src_Val;
+  int ReturnThruPtr_p_src_Size;
+  int IgnoreArg_p_dst;
+  int IgnoreArg_p_src;
+  int IgnoreArg_size;
+
+} CMOCK_sd_flash_write_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_flash_page_erase_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t Expected_page_number;
+  int IgnoreArg_page_number;
+
+} CMOCK_sd_flash_page_erase_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_flash_protect_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint32_t Expected_block_cfg0;
+  uint32_t Expected_block_cfg1;
+  uint32_t Expected_block_cfg2;
+  uint32_t Expected_block_cfg3;
+  int IgnoreArg_block_cfg0;
+  int IgnoreArg_block_cfg1;
+  int IgnoreArg_block_cfg2;
+  int IgnoreArg_block_cfg3;
+
+} CMOCK_sd_flash_protect_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_radio_session_open_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  nrf_radio_signal_callback_t Expected_p_radio_signal_callback;
+  int IgnoreArg_p_radio_signal_callback;
+
+} CMOCK_sd_radio_session_open_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_radio_session_close_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+
+} CMOCK_sd_radio_session_close_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_radio_request_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  nrf_radio_request_t* Expected_p_request;
+  int Expected_p_request_Depth;
+  int ReturnThruPtr_p_request_Used;
+  nrf_radio_request_t* ReturnThruPtr_p_request_Val;
+  int ReturnThruPtr_p_request_Size;
+  int IgnoreArg_p_request;
+
+} CMOCK_sd_radio_request_CALL_INSTANCE;
+
+static struct mock_nrf_socInstance
+{
+  int sd_mutex_new_IgnoreBool;
+  uint32_t sd_mutex_new_FinalReturn;
+  CMOCK_sd_mutex_new_CALLBACK sd_mutex_new_CallbackFunctionPointer;
+  int sd_mutex_new_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_mutex_new_CallInstance;
+  int sd_mutex_acquire_IgnoreBool;
+  uint32_t sd_mutex_acquire_FinalReturn;
+  CMOCK_sd_mutex_acquire_CALLBACK sd_mutex_acquire_CallbackFunctionPointer;
+  int sd_mutex_acquire_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_mutex_acquire_CallInstance;
+  int sd_mutex_release_IgnoreBool;
+  uint32_t sd_mutex_release_FinalReturn;
+  CMOCK_sd_mutex_release_CALLBACK sd_mutex_release_CallbackFunctionPointer;
+  int sd_mutex_release_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_mutex_release_CallInstance;
+  int sd_rand_application_pool_capacity_get_IgnoreBool;
+  uint32_t sd_rand_application_pool_capacity_get_FinalReturn;
+  CMOCK_sd_rand_application_pool_capacity_get_CALLBACK sd_rand_application_pool_capacity_get_CallbackFunctionPointer;
+  int sd_rand_application_pool_capacity_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_rand_application_pool_capacity_get_CallInstance;
+  int sd_rand_application_bytes_available_get_IgnoreBool;
+  uint32_t sd_rand_application_bytes_available_get_FinalReturn;
+  CMOCK_sd_rand_application_bytes_available_get_CALLBACK sd_rand_application_bytes_available_get_CallbackFunctionPointer;
+  int sd_rand_application_bytes_available_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_rand_application_bytes_available_get_CallInstance;
+  int sd_rand_application_vector_get_IgnoreBool;
+  uint32_t sd_rand_application_vector_get_FinalReturn;
+  CMOCK_sd_rand_application_vector_get_CALLBACK sd_rand_application_vector_get_CallbackFunctionPointer;
+  int sd_rand_application_vector_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_rand_application_vector_get_CallInstance;
+  int sd_power_reset_reason_get_IgnoreBool;
+  uint32_t sd_power_reset_reason_get_FinalReturn;
+  CMOCK_sd_power_reset_reason_get_CALLBACK sd_power_reset_reason_get_CallbackFunctionPointer;
+  int sd_power_reset_reason_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_power_reset_reason_get_CallInstance;
+  int sd_power_reset_reason_clr_IgnoreBool;
+  uint32_t sd_power_reset_reason_clr_FinalReturn;
+  CMOCK_sd_power_reset_reason_clr_CALLBACK sd_power_reset_reason_clr_CallbackFunctionPointer;
+  int sd_power_reset_reason_clr_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_power_reset_reason_clr_CallInstance;
+  int sd_power_mode_set_IgnoreBool;
+  uint32_t sd_power_mode_set_FinalReturn;
+  CMOCK_sd_power_mode_set_CALLBACK sd_power_mode_set_CallbackFunctionPointer;
+  int sd_power_mode_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_power_mode_set_CallInstance;
+  int sd_power_system_off_IgnoreBool;
+  uint32_t sd_power_system_off_FinalReturn;
+  CMOCK_sd_power_system_off_CALLBACK sd_power_system_off_CallbackFunctionPointer;
+  int sd_power_system_off_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_power_system_off_CallInstance;
+  int sd_power_pof_enable_IgnoreBool;
+  uint32_t sd_power_pof_enable_FinalReturn;
+  CMOCK_sd_power_pof_enable_CALLBACK sd_power_pof_enable_CallbackFunctionPointer;
+  int sd_power_pof_enable_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_power_pof_enable_CallInstance;
+  int sd_power_pof_threshold_set_IgnoreBool;
+  uint32_t sd_power_pof_threshold_set_FinalReturn;
+  CMOCK_sd_power_pof_threshold_set_CALLBACK sd_power_pof_threshold_set_CallbackFunctionPointer;
+  int sd_power_pof_threshold_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_power_pof_threshold_set_CallInstance;
+  int sd_power_ramon_set_IgnoreBool;
+  uint32_t sd_power_ramon_set_FinalReturn;
+  CMOCK_sd_power_ramon_set_CALLBACK sd_power_ramon_set_CallbackFunctionPointer;
+  int sd_power_ramon_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_power_ramon_set_CallInstance;
+  int sd_power_ramon_clr_IgnoreBool;
+  uint32_t sd_power_ramon_clr_FinalReturn;
+  CMOCK_sd_power_ramon_clr_CALLBACK sd_power_ramon_clr_CallbackFunctionPointer;
+  int sd_power_ramon_clr_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_power_ramon_clr_CallInstance;
+  int sd_power_ramon_get_IgnoreBool;
+  uint32_t sd_power_ramon_get_FinalReturn;
+  CMOCK_sd_power_ramon_get_CALLBACK sd_power_ramon_get_CallbackFunctionPointer;
+  int sd_power_ramon_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_power_ramon_get_CallInstance;
+  int sd_power_gpregret_set_IgnoreBool;
+  uint32_t sd_power_gpregret_set_FinalReturn;
+  CMOCK_sd_power_gpregret_set_CALLBACK sd_power_gpregret_set_CallbackFunctionPointer;
+  int sd_power_gpregret_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_power_gpregret_set_CallInstance;
+  int sd_power_gpregret_clr_IgnoreBool;
+  uint32_t sd_power_gpregret_clr_FinalReturn;
+  CMOCK_sd_power_gpregret_clr_CALLBACK sd_power_gpregret_clr_CallbackFunctionPointer;
+  int sd_power_gpregret_clr_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_power_gpregret_clr_CallInstance;
+  int sd_power_gpregret_get_IgnoreBool;
+  uint32_t sd_power_gpregret_get_FinalReturn;
+  CMOCK_sd_power_gpregret_get_CALLBACK sd_power_gpregret_get_CallbackFunctionPointer;
+  int sd_power_gpregret_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_power_gpregret_get_CallInstance;
+  int sd_power_dcdc_mode_set_IgnoreBool;
+  uint32_t sd_power_dcdc_mode_set_FinalReturn;
+  CMOCK_sd_power_dcdc_mode_set_CALLBACK sd_power_dcdc_mode_set_CallbackFunctionPointer;
+  int sd_power_dcdc_mode_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_power_dcdc_mode_set_CallInstance;
+  int sd_clock_hfclk_request_IgnoreBool;
+  uint32_t sd_clock_hfclk_request_FinalReturn;
+  CMOCK_sd_clock_hfclk_request_CALLBACK sd_clock_hfclk_request_CallbackFunctionPointer;
+  int sd_clock_hfclk_request_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_clock_hfclk_request_CallInstance;
+  int sd_clock_hfclk_release_IgnoreBool;
+  uint32_t sd_clock_hfclk_release_FinalReturn;
+  CMOCK_sd_clock_hfclk_release_CALLBACK sd_clock_hfclk_release_CallbackFunctionPointer;
+  int sd_clock_hfclk_release_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_clock_hfclk_release_CallInstance;
+  int sd_clock_hfclk_is_running_IgnoreBool;
+  uint32_t sd_clock_hfclk_is_running_FinalReturn;
+  CMOCK_sd_clock_hfclk_is_running_CALLBACK sd_clock_hfclk_is_running_CallbackFunctionPointer;
+  int sd_clock_hfclk_is_running_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_clock_hfclk_is_running_CallInstance;
+  int sd_app_evt_wait_IgnoreBool;
+  uint32_t sd_app_evt_wait_FinalReturn;
+  CMOCK_sd_app_evt_wait_CALLBACK sd_app_evt_wait_CallbackFunctionPointer;
+  int sd_app_evt_wait_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_app_evt_wait_CallInstance;
+  int sd_ppi_channel_enable_get_IgnoreBool;
+  uint32_t sd_ppi_channel_enable_get_FinalReturn;
+  CMOCK_sd_ppi_channel_enable_get_CALLBACK sd_ppi_channel_enable_get_CallbackFunctionPointer;
+  int sd_ppi_channel_enable_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ppi_channel_enable_get_CallInstance;
+  int sd_ppi_channel_enable_set_IgnoreBool;
+  uint32_t sd_ppi_channel_enable_set_FinalReturn;
+  CMOCK_sd_ppi_channel_enable_set_CALLBACK sd_ppi_channel_enable_set_CallbackFunctionPointer;
+  int sd_ppi_channel_enable_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ppi_channel_enable_set_CallInstance;
+  int sd_ppi_channel_enable_clr_IgnoreBool;
+  uint32_t sd_ppi_channel_enable_clr_FinalReturn;
+  CMOCK_sd_ppi_channel_enable_clr_CALLBACK sd_ppi_channel_enable_clr_CallbackFunctionPointer;
+  int sd_ppi_channel_enable_clr_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ppi_channel_enable_clr_CallInstance;
+  int sd_ppi_channel_assign_IgnoreBool;
+  uint32_t sd_ppi_channel_assign_FinalReturn;
+  CMOCK_sd_ppi_channel_assign_CALLBACK sd_ppi_channel_assign_CallbackFunctionPointer;
+  int sd_ppi_channel_assign_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ppi_channel_assign_CallInstance;
+  int sd_ppi_group_task_enable_IgnoreBool;
+  uint32_t sd_ppi_group_task_enable_FinalReturn;
+  CMOCK_sd_ppi_group_task_enable_CALLBACK sd_ppi_group_task_enable_CallbackFunctionPointer;
+  int sd_ppi_group_task_enable_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ppi_group_task_enable_CallInstance;
+  int sd_ppi_group_task_disable_IgnoreBool;
+  uint32_t sd_ppi_group_task_disable_FinalReturn;
+  CMOCK_sd_ppi_group_task_disable_CALLBACK sd_ppi_group_task_disable_CallbackFunctionPointer;
+  int sd_ppi_group_task_disable_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ppi_group_task_disable_CallInstance;
+  int sd_ppi_group_assign_IgnoreBool;
+  uint32_t sd_ppi_group_assign_FinalReturn;
+  CMOCK_sd_ppi_group_assign_CALLBACK sd_ppi_group_assign_CallbackFunctionPointer;
+  int sd_ppi_group_assign_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ppi_group_assign_CallInstance;
+  int sd_ppi_group_get_IgnoreBool;
+  uint32_t sd_ppi_group_get_FinalReturn;
+  CMOCK_sd_ppi_group_get_CALLBACK sd_ppi_group_get_CallbackFunctionPointer;
+  int sd_ppi_group_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ppi_group_get_CallInstance;
+  int sd_radio_notification_cfg_set_IgnoreBool;
+  uint32_t sd_radio_notification_cfg_set_FinalReturn;
+  CMOCK_sd_radio_notification_cfg_set_CALLBACK sd_radio_notification_cfg_set_CallbackFunctionPointer;
+  int sd_radio_notification_cfg_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_radio_notification_cfg_set_CallInstance;
+  int sd_ecb_block_encrypt_IgnoreBool;
+  uint32_t sd_ecb_block_encrypt_FinalReturn;
+  CMOCK_sd_ecb_block_encrypt_CALLBACK sd_ecb_block_encrypt_CallbackFunctionPointer;
+  int sd_ecb_block_encrypt_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ecb_block_encrypt_CallInstance;
+  int sd_ecb_blocks_encrypt_IgnoreBool;
+  uint32_t sd_ecb_blocks_encrypt_FinalReturn;
+  CMOCK_sd_ecb_blocks_encrypt_CALLBACK sd_ecb_blocks_encrypt_CallbackFunctionPointer;
+  int sd_ecb_blocks_encrypt_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ecb_blocks_encrypt_CallInstance;
+  int sd_evt_get_IgnoreBool;
+  uint32_t sd_evt_get_FinalReturn;
+  CMOCK_sd_evt_get_CALLBACK sd_evt_get_CallbackFunctionPointer;
+  int sd_evt_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_evt_get_CallInstance;
+  int sd_temp_get_IgnoreBool;
+  uint32_t sd_temp_get_FinalReturn;
+  CMOCK_sd_temp_get_CALLBACK sd_temp_get_CallbackFunctionPointer;
+  int sd_temp_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_temp_get_CallInstance;
+  int sd_flash_write_IgnoreBool;
+  uint32_t sd_flash_write_FinalReturn;
+  CMOCK_sd_flash_write_CALLBACK sd_flash_write_CallbackFunctionPointer;
+  int sd_flash_write_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_flash_write_CallInstance;
+  int sd_flash_page_erase_IgnoreBool;
+  uint32_t sd_flash_page_erase_FinalReturn;
+  CMOCK_sd_flash_page_erase_CALLBACK sd_flash_page_erase_CallbackFunctionPointer;
+  int sd_flash_page_erase_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_flash_page_erase_CallInstance;
+  int sd_flash_protect_IgnoreBool;
+  uint32_t sd_flash_protect_FinalReturn;
+  CMOCK_sd_flash_protect_CALLBACK sd_flash_protect_CallbackFunctionPointer;
+  int sd_flash_protect_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_flash_protect_CallInstance;
+  int sd_radio_session_open_IgnoreBool;
+  uint32_t sd_radio_session_open_FinalReturn;
+  CMOCK_sd_radio_session_open_CALLBACK sd_radio_session_open_CallbackFunctionPointer;
+  int sd_radio_session_open_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_radio_session_open_CallInstance;
+  int sd_radio_session_close_IgnoreBool;
+  uint32_t sd_radio_session_close_FinalReturn;
+  CMOCK_sd_radio_session_close_CALLBACK sd_radio_session_close_CallbackFunctionPointer;
+  int sd_radio_session_close_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_radio_session_close_CallInstance;
+  int sd_radio_request_IgnoreBool;
+  uint32_t sd_radio_request_FinalReturn;
+  CMOCK_sd_radio_request_CALLBACK sd_radio_request_CallbackFunctionPointer;
+  int sd_radio_request_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_radio_request_CallInstance;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_nrf_soc_Verify(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_mutex_new_CallInstance, cmock_line, "Function 'sd_mutex_new' called less times than expected.");
+  if (Mock.sd_mutex_new_CallbackFunctionPointer != NULL)
+    Mock.sd_mutex_new_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_mutex_acquire_CallInstance, cmock_line, "Function 'sd_mutex_acquire' called less times than expected.");
+  if (Mock.sd_mutex_acquire_CallbackFunctionPointer != NULL)
+    Mock.sd_mutex_acquire_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_mutex_release_CallInstance, cmock_line, "Function 'sd_mutex_release' called less times than expected.");
+  if (Mock.sd_mutex_release_CallbackFunctionPointer != NULL)
+    Mock.sd_mutex_release_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_rand_application_pool_capacity_get_CallInstance, cmock_line, "Function 'sd_rand_application_pool_capacity_get' called less times than expected.");
+  if (Mock.sd_rand_application_pool_capacity_get_CallbackFunctionPointer != NULL)
+    Mock.sd_rand_application_pool_capacity_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_rand_application_bytes_available_get_CallInstance, cmock_line, "Function 'sd_rand_application_bytes_available_get' called less times than expected.");
+  if (Mock.sd_rand_application_bytes_available_get_CallbackFunctionPointer != NULL)
+    Mock.sd_rand_application_bytes_available_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_rand_application_vector_get_CallInstance, cmock_line, "Function 'sd_rand_application_vector_get' called less times than expected.");
+  if (Mock.sd_rand_application_vector_get_CallbackFunctionPointer != NULL)
+    Mock.sd_rand_application_vector_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_power_reset_reason_get_CallInstance, cmock_line, "Function 'sd_power_reset_reason_get' called less times than expected.");
+  if (Mock.sd_power_reset_reason_get_CallbackFunctionPointer != NULL)
+    Mock.sd_power_reset_reason_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_power_reset_reason_clr_CallInstance, cmock_line, "Function 'sd_power_reset_reason_clr' called less times than expected.");
+  if (Mock.sd_power_reset_reason_clr_CallbackFunctionPointer != NULL)
+    Mock.sd_power_reset_reason_clr_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_power_mode_set_CallInstance, cmock_line, "Function 'sd_power_mode_set' called less times than expected.");
+  if (Mock.sd_power_mode_set_CallbackFunctionPointer != NULL)
+    Mock.sd_power_mode_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_power_system_off_CallInstance, cmock_line, "Function 'sd_power_system_off' called less times than expected.");
+  if (Mock.sd_power_system_off_CallbackFunctionPointer != NULL)
+    Mock.sd_power_system_off_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_power_pof_enable_CallInstance, cmock_line, "Function 'sd_power_pof_enable' called less times than expected.");
+  if (Mock.sd_power_pof_enable_CallbackFunctionPointer != NULL)
+    Mock.sd_power_pof_enable_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_power_pof_threshold_set_CallInstance, cmock_line, "Function 'sd_power_pof_threshold_set' called less times than expected.");
+  if (Mock.sd_power_pof_threshold_set_CallbackFunctionPointer != NULL)
+    Mock.sd_power_pof_threshold_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_power_ramon_set_CallInstance, cmock_line, "Function 'sd_power_ramon_set' called less times than expected.");
+  if (Mock.sd_power_ramon_set_CallbackFunctionPointer != NULL)
+    Mock.sd_power_ramon_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_power_ramon_clr_CallInstance, cmock_line, "Function 'sd_power_ramon_clr' called less times than expected.");
+  if (Mock.sd_power_ramon_clr_CallbackFunctionPointer != NULL)
+    Mock.sd_power_ramon_clr_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_power_ramon_get_CallInstance, cmock_line, "Function 'sd_power_ramon_get' called less times than expected.");
+  if (Mock.sd_power_ramon_get_CallbackFunctionPointer != NULL)
+    Mock.sd_power_ramon_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_power_gpregret_set_CallInstance, cmock_line, "Function 'sd_power_gpregret_set' called less times than expected.");
+  if (Mock.sd_power_gpregret_set_CallbackFunctionPointer != NULL)
+    Mock.sd_power_gpregret_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_power_gpregret_clr_CallInstance, cmock_line, "Function 'sd_power_gpregret_clr' called less times than expected.");
+  if (Mock.sd_power_gpregret_clr_CallbackFunctionPointer != NULL)
+    Mock.sd_power_gpregret_clr_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_power_gpregret_get_CallInstance, cmock_line, "Function 'sd_power_gpregret_get' called less times than expected.");
+  if (Mock.sd_power_gpregret_get_CallbackFunctionPointer != NULL)
+    Mock.sd_power_gpregret_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_power_dcdc_mode_set_CallInstance, cmock_line, "Function 'sd_power_dcdc_mode_set' called less times than expected.");
+  if (Mock.sd_power_dcdc_mode_set_CallbackFunctionPointer != NULL)
+    Mock.sd_power_dcdc_mode_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_clock_hfclk_request_CallInstance, cmock_line, "Function 'sd_clock_hfclk_request' called less times than expected.");
+  if (Mock.sd_clock_hfclk_request_CallbackFunctionPointer != NULL)
+    Mock.sd_clock_hfclk_request_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_clock_hfclk_release_CallInstance, cmock_line, "Function 'sd_clock_hfclk_release' called less times than expected.");
+  if (Mock.sd_clock_hfclk_release_CallbackFunctionPointer != NULL)
+    Mock.sd_clock_hfclk_release_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_clock_hfclk_is_running_CallInstance, cmock_line, "Function 'sd_clock_hfclk_is_running' called less times than expected.");
+  if (Mock.sd_clock_hfclk_is_running_CallbackFunctionPointer != NULL)
+    Mock.sd_clock_hfclk_is_running_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_app_evt_wait_CallInstance, cmock_line, "Function 'sd_app_evt_wait' called less times than expected.");
+  if (Mock.sd_app_evt_wait_CallbackFunctionPointer != NULL)
+    Mock.sd_app_evt_wait_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ppi_channel_enable_get_CallInstance, cmock_line, "Function 'sd_ppi_channel_enable_get' called less times than expected.");
+  if (Mock.sd_ppi_channel_enable_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ppi_channel_enable_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ppi_channel_enable_set_CallInstance, cmock_line, "Function 'sd_ppi_channel_enable_set' called less times than expected.");
+  if (Mock.sd_ppi_channel_enable_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ppi_channel_enable_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ppi_channel_enable_clr_CallInstance, cmock_line, "Function 'sd_ppi_channel_enable_clr' called less times than expected.");
+  if (Mock.sd_ppi_channel_enable_clr_CallbackFunctionPointer != NULL)
+    Mock.sd_ppi_channel_enable_clr_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ppi_channel_assign_CallInstance, cmock_line, "Function 'sd_ppi_channel_assign' called less times than expected.");
+  if (Mock.sd_ppi_channel_assign_CallbackFunctionPointer != NULL)
+    Mock.sd_ppi_channel_assign_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ppi_group_task_enable_CallInstance, cmock_line, "Function 'sd_ppi_group_task_enable' called less times than expected.");
+  if (Mock.sd_ppi_group_task_enable_CallbackFunctionPointer != NULL)
+    Mock.sd_ppi_group_task_enable_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ppi_group_task_disable_CallInstance, cmock_line, "Function 'sd_ppi_group_task_disable' called less times than expected.");
+  if (Mock.sd_ppi_group_task_disable_CallbackFunctionPointer != NULL)
+    Mock.sd_ppi_group_task_disable_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ppi_group_assign_CallInstance, cmock_line, "Function 'sd_ppi_group_assign' called less times than expected.");
+  if (Mock.sd_ppi_group_assign_CallbackFunctionPointer != NULL)
+    Mock.sd_ppi_group_assign_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ppi_group_get_CallInstance, cmock_line, "Function 'sd_ppi_group_get' called less times than expected.");
+  if (Mock.sd_ppi_group_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ppi_group_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_radio_notification_cfg_set_CallInstance, cmock_line, "Function 'sd_radio_notification_cfg_set' called less times than expected.");
+  if (Mock.sd_radio_notification_cfg_set_CallbackFunctionPointer != NULL)
+    Mock.sd_radio_notification_cfg_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ecb_block_encrypt_CallInstance, cmock_line, "Function 'sd_ecb_block_encrypt' called less times than expected.");
+  if (Mock.sd_ecb_block_encrypt_CallbackFunctionPointer != NULL)
+    Mock.sd_ecb_block_encrypt_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ecb_blocks_encrypt_CallInstance, cmock_line, "Function 'sd_ecb_blocks_encrypt' called less times than expected.");
+  if (Mock.sd_ecb_blocks_encrypt_CallbackFunctionPointer != NULL)
+    Mock.sd_ecb_blocks_encrypt_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_evt_get_CallInstance, cmock_line, "Function 'sd_evt_get' called less times than expected.");
+  if (Mock.sd_evt_get_CallbackFunctionPointer != NULL)
+    Mock.sd_evt_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_temp_get_CallInstance, cmock_line, "Function 'sd_temp_get' called less times than expected.");
+  if (Mock.sd_temp_get_CallbackFunctionPointer != NULL)
+    Mock.sd_temp_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_flash_write_CallInstance, cmock_line, "Function 'sd_flash_write' called less times than expected.");
+  if (Mock.sd_flash_write_CallbackFunctionPointer != NULL)
+    Mock.sd_flash_write_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_flash_page_erase_CallInstance, cmock_line, "Function 'sd_flash_page_erase' called less times than expected.");
+  if (Mock.sd_flash_page_erase_CallbackFunctionPointer != NULL)
+    Mock.sd_flash_page_erase_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_flash_protect_CallInstance, cmock_line, "Function 'sd_flash_protect' called less times than expected.");
+  if (Mock.sd_flash_protect_CallbackFunctionPointer != NULL)
+    Mock.sd_flash_protect_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_radio_session_open_CallInstance, cmock_line, "Function 'sd_radio_session_open' called less times than expected.");
+  if (Mock.sd_radio_session_open_CallbackFunctionPointer != NULL)
+    Mock.sd_radio_session_open_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_radio_session_close_CallInstance, cmock_line, "Function 'sd_radio_session_close' called less times than expected.");
+  if (Mock.sd_radio_session_close_CallbackFunctionPointer != NULL)
+    Mock.sd_radio_session_close_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_radio_request_CallInstance, cmock_line, "Function 'sd_radio_request' called less times than expected.");
+  if (Mock.sd_radio_request_CallbackFunctionPointer != NULL)
+    Mock.sd_radio_request_CallInstance = CMOCK_GUTS_NONE;
+}
+
+void mock_nrf_soc_Init(void)
+{
+  mock_nrf_soc_Destroy();
+}
+
+void mock_nrf_soc_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  Mock.sd_mutex_new_CallbackFunctionPointer = NULL;
+  Mock.sd_mutex_new_CallbackCalls = 0;
+  Mock.sd_mutex_acquire_CallbackFunctionPointer = NULL;
+  Mock.sd_mutex_acquire_CallbackCalls = 0;
+  Mock.sd_mutex_release_CallbackFunctionPointer = NULL;
+  Mock.sd_mutex_release_CallbackCalls = 0;
+  Mock.sd_rand_application_pool_capacity_get_CallbackFunctionPointer = NULL;
+  Mock.sd_rand_application_pool_capacity_get_CallbackCalls = 0;
+  Mock.sd_rand_application_bytes_available_get_CallbackFunctionPointer = NULL;
+  Mock.sd_rand_application_bytes_available_get_CallbackCalls = 0;
+  Mock.sd_rand_application_vector_get_CallbackFunctionPointer = NULL;
+  Mock.sd_rand_application_vector_get_CallbackCalls = 0;
+  Mock.sd_power_reset_reason_get_CallbackFunctionPointer = NULL;
+  Mock.sd_power_reset_reason_get_CallbackCalls = 0;
+  Mock.sd_power_reset_reason_clr_CallbackFunctionPointer = NULL;
+  Mock.sd_power_reset_reason_clr_CallbackCalls = 0;
+  Mock.sd_power_mode_set_CallbackFunctionPointer = NULL;
+  Mock.sd_power_mode_set_CallbackCalls = 0;
+  Mock.sd_power_system_off_CallbackFunctionPointer = NULL;
+  Mock.sd_power_system_off_CallbackCalls = 0;
+  Mock.sd_power_pof_enable_CallbackFunctionPointer = NULL;
+  Mock.sd_power_pof_enable_CallbackCalls = 0;
+  Mock.sd_power_pof_threshold_set_CallbackFunctionPointer = NULL;
+  Mock.sd_power_pof_threshold_set_CallbackCalls = 0;
+  Mock.sd_power_ramon_set_CallbackFunctionPointer = NULL;
+  Mock.sd_power_ramon_set_CallbackCalls = 0;
+  Mock.sd_power_ramon_clr_CallbackFunctionPointer = NULL;
+  Mock.sd_power_ramon_clr_CallbackCalls = 0;
+  Mock.sd_power_ramon_get_CallbackFunctionPointer = NULL;
+  Mock.sd_power_ramon_get_CallbackCalls = 0;
+  Mock.sd_power_gpregret_set_CallbackFunctionPointer = NULL;
+  Mock.sd_power_gpregret_set_CallbackCalls = 0;
+  Mock.sd_power_gpregret_clr_CallbackFunctionPointer = NULL;
+  Mock.sd_power_gpregret_clr_CallbackCalls = 0;
+  Mock.sd_power_gpregret_get_CallbackFunctionPointer = NULL;
+  Mock.sd_power_gpregret_get_CallbackCalls = 0;
+  Mock.sd_power_dcdc_mode_set_CallbackFunctionPointer = NULL;
+  Mock.sd_power_dcdc_mode_set_CallbackCalls = 0;
+  Mock.sd_clock_hfclk_request_CallbackFunctionPointer = NULL;
+  Mock.sd_clock_hfclk_request_CallbackCalls = 0;
+  Mock.sd_clock_hfclk_release_CallbackFunctionPointer = NULL;
+  Mock.sd_clock_hfclk_release_CallbackCalls = 0;
+  Mock.sd_clock_hfclk_is_running_CallbackFunctionPointer = NULL;
+  Mock.sd_clock_hfclk_is_running_CallbackCalls = 0;
+  Mock.sd_app_evt_wait_CallbackFunctionPointer = NULL;
+  Mock.sd_app_evt_wait_CallbackCalls = 0;
+  Mock.sd_ppi_channel_enable_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ppi_channel_enable_get_CallbackCalls = 0;
+  Mock.sd_ppi_channel_enable_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ppi_channel_enable_set_CallbackCalls = 0;
+  Mock.sd_ppi_channel_enable_clr_CallbackFunctionPointer = NULL;
+  Mock.sd_ppi_channel_enable_clr_CallbackCalls = 0;
+  Mock.sd_ppi_channel_assign_CallbackFunctionPointer = NULL;
+  Mock.sd_ppi_channel_assign_CallbackCalls = 0;
+  Mock.sd_ppi_group_task_enable_CallbackFunctionPointer = NULL;
+  Mock.sd_ppi_group_task_enable_CallbackCalls = 0;
+  Mock.sd_ppi_group_task_disable_CallbackFunctionPointer = NULL;
+  Mock.sd_ppi_group_task_disable_CallbackCalls = 0;
+  Mock.sd_ppi_group_assign_CallbackFunctionPointer = NULL;
+  Mock.sd_ppi_group_assign_CallbackCalls = 0;
+  Mock.sd_ppi_group_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ppi_group_get_CallbackCalls = 0;
+  Mock.sd_radio_notification_cfg_set_CallbackFunctionPointer = NULL;
+  Mock.sd_radio_notification_cfg_set_CallbackCalls = 0;
+  Mock.sd_ecb_block_encrypt_CallbackFunctionPointer = NULL;
+  Mock.sd_ecb_block_encrypt_CallbackCalls = 0;
+  Mock.sd_ecb_blocks_encrypt_CallbackFunctionPointer = NULL;
+  Mock.sd_ecb_blocks_encrypt_CallbackCalls = 0;
+  Mock.sd_evt_get_CallbackFunctionPointer = NULL;
+  Mock.sd_evt_get_CallbackCalls = 0;
+  Mock.sd_temp_get_CallbackFunctionPointer = NULL;
+  Mock.sd_temp_get_CallbackCalls = 0;
+  Mock.sd_flash_write_CallbackFunctionPointer = NULL;
+  Mock.sd_flash_write_CallbackCalls = 0;
+  Mock.sd_flash_page_erase_CallbackFunctionPointer = NULL;
+  Mock.sd_flash_page_erase_CallbackCalls = 0;
+  Mock.sd_flash_protect_CallbackFunctionPointer = NULL;
+  Mock.sd_flash_protect_CallbackCalls = 0;
+  Mock.sd_radio_session_open_CallbackFunctionPointer = NULL;
+  Mock.sd_radio_session_open_CallbackCalls = 0;
+  Mock.sd_radio_session_close_CallbackFunctionPointer = NULL;
+  Mock.sd_radio_session_close_CallbackCalls = 0;
+  Mock.sd_radio_request_CallbackFunctionPointer = NULL;
+  Mock.sd_radio_request_CallbackCalls = 0;
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+uint32_t sd_mutex_new(nrf_mutex_t* p_mutex)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_mutex_new_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_mutex_new_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_mutex_new_CallInstance);
+  Mock.sd_mutex_new_CallInstance = CMock_Guts_MemNext(Mock.sd_mutex_new_CallInstance);
+  if (Mock.sd_mutex_new_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_mutex_new_FinalReturn;
+    Mock.sd_mutex_new_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_mutex_new_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_mutex_new_CallbackFunctionPointer(p_mutex, Mock.sd_mutex_new_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_mutex_new' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_mutex_new' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_mutex_new' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_mutex)
+  {
+    if (cmock_call_instance->Expected_p_mutex == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_mutex, cmock_line, "Expected NULL. Function 'sd_mutex_new' called with unexpected value for argument 'p_mutex'."); }
+    else if (cmock_call_instance->Expected_p_mutex_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_mutex, p_mutex, cmock_line, "Function 'sd_mutex_new' called with unexpected value for argument 'p_mutex'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_mutex), (void*)(p_mutex), sizeof(nrf_mutex_t), cmock_call_instance->Expected_p_mutex_Depth, cmock_line, "Function 'sd_mutex_new' called with unexpected value for argument 'p_mutex'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_mutex_Used)
+  {
+    memcpy((void*)p_mutex, (void*)cmock_call_instance->ReturnThruPtr_p_mutex_Val,
+      cmock_call_instance->ReturnThruPtr_p_mutex_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_mutex_new(CMOCK_sd_mutex_new_CALL_INSTANCE* cmock_call_instance, nrf_mutex_t* p_mutex, int p_mutex_Depth)
+{
+  cmock_call_instance->Expected_p_mutex = p_mutex;
+  cmock_call_instance->Expected_p_mutex_Depth = p_mutex_Depth;
+  cmock_call_instance->IgnoreArg_p_mutex = 0;
+  cmock_call_instance->ReturnThruPtr_p_mutex_Used = 0;
+}
+
+void sd_mutex_new_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_mutex_new_CALL_INSTANCE));
+  CMOCK_sd_mutex_new_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_mutex_new_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_mutex_new_CallInstance = CMock_Guts_MemChain(Mock.sd_mutex_new_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_mutex_new_IgnoreBool = (int)1;
+}
+
+void sd_mutex_new_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_mutex_new_CALL_INSTANCE));
+  CMOCK_sd_mutex_new_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_mutex_new_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_mutex_new_CallInstance = CMock_Guts_MemChain(Mock.sd_mutex_new_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_mutex_new(cmock_call_instance, p_mutex, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_mutex_new_StubWithCallback(CMOCK_sd_mutex_new_CALLBACK Callback)
+{
+  Mock.sd_mutex_new_CallbackFunctionPointer = Callback;
+}
+
+void sd_mutex_new_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, int p_mutex_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_mutex_new_CALL_INSTANCE));
+  CMOCK_sd_mutex_new_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_mutex_new_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_mutex_new_CallInstance = CMock_Guts_MemChain(Mock.sd_mutex_new_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_mutex_new(cmock_call_instance, p_mutex, p_mutex_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_mutex_new_CMockReturnMemThruPtr_p_mutex(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, int cmock_size)
+{
+  CMOCK_sd_mutex_new_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_mutex_new_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_mutex_new_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_mutex ReturnThruPtr called before Expect on 'sd_mutex_new'.");
+  cmock_call_instance->ReturnThruPtr_p_mutex_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_mutex_Val = p_mutex;
+  cmock_call_instance->ReturnThruPtr_p_mutex_Size = cmock_size;
+}
+
+void sd_mutex_new_CMockIgnoreArg_p_mutex(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_mutex_new_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_mutex_new_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_mutex_new_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_mutex IgnoreArg called before Expect on 'sd_mutex_new'.");
+  cmock_call_instance->IgnoreArg_p_mutex = 1;
+}
+
+uint32_t sd_mutex_acquire(nrf_mutex_t* p_mutex)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_mutex_acquire_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_mutex_acquire_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_mutex_acquire_CallInstance);
+  Mock.sd_mutex_acquire_CallInstance = CMock_Guts_MemNext(Mock.sd_mutex_acquire_CallInstance);
+  if (Mock.sd_mutex_acquire_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_mutex_acquire_FinalReturn;
+    Mock.sd_mutex_acquire_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_mutex_acquire_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_mutex_acquire_CallbackFunctionPointer(p_mutex, Mock.sd_mutex_acquire_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_mutex_acquire' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_mutex_acquire' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_mutex_acquire' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_mutex)
+  {
+    if (cmock_call_instance->Expected_p_mutex == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_mutex, cmock_line, "Expected NULL. Function 'sd_mutex_acquire' called with unexpected value for argument 'p_mutex'."); }
+    else if (cmock_call_instance->Expected_p_mutex_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_mutex, p_mutex, cmock_line, "Function 'sd_mutex_acquire' called with unexpected value for argument 'p_mutex'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_mutex), (void*)(p_mutex), sizeof(nrf_mutex_t), cmock_call_instance->Expected_p_mutex_Depth, cmock_line, "Function 'sd_mutex_acquire' called with unexpected value for argument 'p_mutex'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_mutex_Used)
+  {
+    memcpy((void*)p_mutex, (void*)cmock_call_instance->ReturnThruPtr_p_mutex_Val,
+      cmock_call_instance->ReturnThruPtr_p_mutex_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_mutex_acquire(CMOCK_sd_mutex_acquire_CALL_INSTANCE* cmock_call_instance, nrf_mutex_t* p_mutex, int p_mutex_Depth)
+{
+  cmock_call_instance->Expected_p_mutex = p_mutex;
+  cmock_call_instance->Expected_p_mutex_Depth = p_mutex_Depth;
+  cmock_call_instance->IgnoreArg_p_mutex = 0;
+  cmock_call_instance->ReturnThruPtr_p_mutex_Used = 0;
+}
+
+void sd_mutex_acquire_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_mutex_acquire_CALL_INSTANCE));
+  CMOCK_sd_mutex_acquire_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_mutex_acquire_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_mutex_acquire_CallInstance = CMock_Guts_MemChain(Mock.sd_mutex_acquire_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_mutex_acquire_IgnoreBool = (int)1;
+}
+
+void sd_mutex_acquire_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_mutex_acquire_CALL_INSTANCE));
+  CMOCK_sd_mutex_acquire_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_mutex_acquire_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_mutex_acquire_CallInstance = CMock_Guts_MemChain(Mock.sd_mutex_acquire_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_mutex_acquire(cmock_call_instance, p_mutex, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_mutex_acquire_StubWithCallback(CMOCK_sd_mutex_acquire_CALLBACK Callback)
+{
+  Mock.sd_mutex_acquire_CallbackFunctionPointer = Callback;
+}
+
+void sd_mutex_acquire_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, int p_mutex_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_mutex_acquire_CALL_INSTANCE));
+  CMOCK_sd_mutex_acquire_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_mutex_acquire_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_mutex_acquire_CallInstance = CMock_Guts_MemChain(Mock.sd_mutex_acquire_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_mutex_acquire(cmock_call_instance, p_mutex, p_mutex_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_mutex_acquire_CMockReturnMemThruPtr_p_mutex(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, int cmock_size)
+{
+  CMOCK_sd_mutex_acquire_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_mutex_acquire_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_mutex_acquire_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_mutex ReturnThruPtr called before Expect on 'sd_mutex_acquire'.");
+  cmock_call_instance->ReturnThruPtr_p_mutex_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_mutex_Val = p_mutex;
+  cmock_call_instance->ReturnThruPtr_p_mutex_Size = cmock_size;
+}
+
+void sd_mutex_acquire_CMockIgnoreArg_p_mutex(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_mutex_acquire_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_mutex_acquire_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_mutex_acquire_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_mutex IgnoreArg called before Expect on 'sd_mutex_acquire'.");
+  cmock_call_instance->IgnoreArg_p_mutex = 1;
+}
+
+uint32_t sd_mutex_release(nrf_mutex_t* p_mutex)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_mutex_release_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_mutex_release_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_mutex_release_CallInstance);
+  Mock.sd_mutex_release_CallInstance = CMock_Guts_MemNext(Mock.sd_mutex_release_CallInstance);
+  if (Mock.sd_mutex_release_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_mutex_release_FinalReturn;
+    Mock.sd_mutex_release_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_mutex_release_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_mutex_release_CallbackFunctionPointer(p_mutex, Mock.sd_mutex_release_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_mutex_release' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_mutex_release' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_mutex_release' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_mutex)
+  {
+    if (cmock_call_instance->Expected_p_mutex == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_mutex, cmock_line, "Expected NULL. Function 'sd_mutex_release' called with unexpected value for argument 'p_mutex'."); }
+    else if (cmock_call_instance->Expected_p_mutex_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_mutex, p_mutex, cmock_line, "Function 'sd_mutex_release' called with unexpected value for argument 'p_mutex'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_mutex), (void*)(p_mutex), sizeof(nrf_mutex_t), cmock_call_instance->Expected_p_mutex_Depth, cmock_line, "Function 'sd_mutex_release' called with unexpected value for argument 'p_mutex'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_mutex_Used)
+  {
+    memcpy((void*)p_mutex, (void*)cmock_call_instance->ReturnThruPtr_p_mutex_Val,
+      cmock_call_instance->ReturnThruPtr_p_mutex_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_mutex_release(CMOCK_sd_mutex_release_CALL_INSTANCE* cmock_call_instance, nrf_mutex_t* p_mutex, int p_mutex_Depth)
+{
+  cmock_call_instance->Expected_p_mutex = p_mutex;
+  cmock_call_instance->Expected_p_mutex_Depth = p_mutex_Depth;
+  cmock_call_instance->IgnoreArg_p_mutex = 0;
+  cmock_call_instance->ReturnThruPtr_p_mutex_Used = 0;
+}
+
+void sd_mutex_release_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_mutex_release_CALL_INSTANCE));
+  CMOCK_sd_mutex_release_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_mutex_release_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_mutex_release_CallInstance = CMock_Guts_MemChain(Mock.sd_mutex_release_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_mutex_release_IgnoreBool = (int)1;
+}
+
+void sd_mutex_release_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_mutex_release_CALL_INSTANCE));
+  CMOCK_sd_mutex_release_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_mutex_release_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_mutex_release_CallInstance = CMock_Guts_MemChain(Mock.sd_mutex_release_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_mutex_release(cmock_call_instance, p_mutex, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_mutex_release_StubWithCallback(CMOCK_sd_mutex_release_CALLBACK Callback)
+{
+  Mock.sd_mutex_release_CallbackFunctionPointer = Callback;
+}
+
+void sd_mutex_release_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, int p_mutex_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_mutex_release_CALL_INSTANCE));
+  CMOCK_sd_mutex_release_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_mutex_release_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_mutex_release_CallInstance = CMock_Guts_MemChain(Mock.sd_mutex_release_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_mutex_release(cmock_call_instance, p_mutex, p_mutex_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_mutex_release_CMockReturnMemThruPtr_p_mutex(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, int cmock_size)
+{
+  CMOCK_sd_mutex_release_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_mutex_release_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_mutex_release_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_mutex ReturnThruPtr called before Expect on 'sd_mutex_release'.");
+  cmock_call_instance->ReturnThruPtr_p_mutex_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_mutex_Val = p_mutex;
+  cmock_call_instance->ReturnThruPtr_p_mutex_Size = cmock_size;
+}
+
+void sd_mutex_release_CMockIgnoreArg_p_mutex(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_mutex_release_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_mutex_release_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_mutex_release_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_mutex IgnoreArg called before Expect on 'sd_mutex_release'.");
+  cmock_call_instance->IgnoreArg_p_mutex = 1;
+}
+
+uint32_t sd_rand_application_pool_capacity_get(uint8_t* p_pool_capacity)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_rand_application_pool_capacity_get_CallInstance);
+  Mock.sd_rand_application_pool_capacity_get_CallInstance = CMock_Guts_MemNext(Mock.sd_rand_application_pool_capacity_get_CallInstance);
+  if (Mock.sd_rand_application_pool_capacity_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_rand_application_pool_capacity_get_FinalReturn;
+    Mock.sd_rand_application_pool_capacity_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_rand_application_pool_capacity_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_rand_application_pool_capacity_get_CallbackFunctionPointer(p_pool_capacity, Mock.sd_rand_application_pool_capacity_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_rand_application_pool_capacity_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_rand_application_pool_capacity_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_rand_application_pool_capacity_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_pool_capacity)
+  {
+    if (cmock_call_instance->Expected_p_pool_capacity == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_pool_capacity, cmock_line, "Expected NULL. Function 'sd_rand_application_pool_capacity_get' called with unexpected value for argument 'p_pool_capacity'."); }
+    else if (cmock_call_instance->Expected_p_pool_capacity_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_pool_capacity, p_pool_capacity, cmock_line, "Function 'sd_rand_application_pool_capacity_get' called with unexpected value for argument 'p_pool_capacity'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_pool_capacity, p_pool_capacity, cmock_call_instance->Expected_p_pool_capacity_Depth, cmock_line, "Function 'sd_rand_application_pool_capacity_get' called with unexpected value for argument 'p_pool_capacity'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_pool_capacity_Used)
+  {
+    memcpy((void*)p_pool_capacity, (void*)cmock_call_instance->ReturnThruPtr_p_pool_capacity_Val,
+      cmock_call_instance->ReturnThruPtr_p_pool_capacity_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_rand_application_pool_capacity_get(CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE* cmock_call_instance, uint8_t* p_pool_capacity, int p_pool_capacity_Depth)
+{
+  cmock_call_instance->Expected_p_pool_capacity = p_pool_capacity;
+  cmock_call_instance->Expected_p_pool_capacity_Depth = p_pool_capacity_Depth;
+  cmock_call_instance->IgnoreArg_p_pool_capacity = 0;
+  cmock_call_instance->ReturnThruPtr_p_pool_capacity_Used = 0;
+}
+
+void sd_rand_application_pool_capacity_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE));
+  CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_rand_application_pool_capacity_get_CallInstance = CMock_Guts_MemChain(Mock.sd_rand_application_pool_capacity_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_rand_application_pool_capacity_get_IgnoreBool = (int)1;
+}
+
+void sd_rand_application_pool_capacity_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_pool_capacity, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE));
+  CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_rand_application_pool_capacity_get_CallInstance = CMock_Guts_MemChain(Mock.sd_rand_application_pool_capacity_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_rand_application_pool_capacity_get(cmock_call_instance, p_pool_capacity, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_rand_application_pool_capacity_get_StubWithCallback(CMOCK_sd_rand_application_pool_capacity_get_CALLBACK Callback)
+{
+  Mock.sd_rand_application_pool_capacity_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_rand_application_pool_capacity_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_pool_capacity, int p_pool_capacity_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE));
+  CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_rand_application_pool_capacity_get_CallInstance = CMock_Guts_MemChain(Mock.sd_rand_application_pool_capacity_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_rand_application_pool_capacity_get(cmock_call_instance, p_pool_capacity, p_pool_capacity_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_rand_application_pool_capacity_get_CMockReturnMemThruPtr_p_pool_capacity(UNITY_LINE_TYPE cmock_line, uint8_t* p_pool_capacity, int cmock_size)
+{
+  CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_rand_application_pool_capacity_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_pool_capacity ReturnThruPtr called before Expect on 'sd_rand_application_pool_capacity_get'.");
+  cmock_call_instance->ReturnThruPtr_p_pool_capacity_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_pool_capacity_Val = p_pool_capacity;
+  cmock_call_instance->ReturnThruPtr_p_pool_capacity_Size = cmock_size;
+}
+
+void sd_rand_application_pool_capacity_get_CMockIgnoreArg_p_pool_capacity(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_rand_application_pool_capacity_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_rand_application_pool_capacity_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_pool_capacity IgnoreArg called before Expect on 'sd_rand_application_pool_capacity_get'.");
+  cmock_call_instance->IgnoreArg_p_pool_capacity = 1;
+}
+
+uint32_t sd_rand_application_bytes_available_get(uint8_t* p_bytes_available)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_rand_application_bytes_available_get_CallInstance);
+  Mock.sd_rand_application_bytes_available_get_CallInstance = CMock_Guts_MemNext(Mock.sd_rand_application_bytes_available_get_CallInstance);
+  if (Mock.sd_rand_application_bytes_available_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_rand_application_bytes_available_get_FinalReturn;
+    Mock.sd_rand_application_bytes_available_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_rand_application_bytes_available_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_rand_application_bytes_available_get_CallbackFunctionPointer(p_bytes_available, Mock.sd_rand_application_bytes_available_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_rand_application_bytes_available_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_rand_application_bytes_available_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_rand_application_bytes_available_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_bytes_available)
+  {
+    if (cmock_call_instance->Expected_p_bytes_available == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_bytes_available, cmock_line, "Expected NULL. Function 'sd_rand_application_bytes_available_get' called with unexpected value for argument 'p_bytes_available'."); }
+    else if (cmock_call_instance->Expected_p_bytes_available_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_bytes_available, p_bytes_available, cmock_line, "Function 'sd_rand_application_bytes_available_get' called with unexpected value for argument 'p_bytes_available'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_bytes_available, p_bytes_available, cmock_call_instance->Expected_p_bytes_available_Depth, cmock_line, "Function 'sd_rand_application_bytes_available_get' called with unexpected value for argument 'p_bytes_available'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_bytes_available_Used)
+  {
+    memcpy((void*)p_bytes_available, (void*)cmock_call_instance->ReturnThruPtr_p_bytes_available_Val,
+      cmock_call_instance->ReturnThruPtr_p_bytes_available_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_rand_application_bytes_available_get(CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE* cmock_call_instance, uint8_t* p_bytes_available, int p_bytes_available_Depth)
+{
+  cmock_call_instance->Expected_p_bytes_available = p_bytes_available;
+  cmock_call_instance->Expected_p_bytes_available_Depth = p_bytes_available_Depth;
+  cmock_call_instance->IgnoreArg_p_bytes_available = 0;
+  cmock_call_instance->ReturnThruPtr_p_bytes_available_Used = 0;
+}
+
+void sd_rand_application_bytes_available_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE));
+  CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_rand_application_bytes_available_get_CallInstance = CMock_Guts_MemChain(Mock.sd_rand_application_bytes_available_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_rand_application_bytes_available_get_IgnoreBool = (int)1;
+}
+
+void sd_rand_application_bytes_available_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_bytes_available, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE));
+  CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_rand_application_bytes_available_get_CallInstance = CMock_Guts_MemChain(Mock.sd_rand_application_bytes_available_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_rand_application_bytes_available_get(cmock_call_instance, p_bytes_available, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_rand_application_bytes_available_get_StubWithCallback(CMOCK_sd_rand_application_bytes_available_get_CALLBACK Callback)
+{
+  Mock.sd_rand_application_bytes_available_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_rand_application_bytes_available_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_bytes_available, int p_bytes_available_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE));
+  CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_rand_application_bytes_available_get_CallInstance = CMock_Guts_MemChain(Mock.sd_rand_application_bytes_available_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_rand_application_bytes_available_get(cmock_call_instance, p_bytes_available, p_bytes_available_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_rand_application_bytes_available_get_CMockReturnMemThruPtr_p_bytes_available(UNITY_LINE_TYPE cmock_line, uint8_t* p_bytes_available, int cmock_size)
+{
+  CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_rand_application_bytes_available_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_bytes_available ReturnThruPtr called before Expect on 'sd_rand_application_bytes_available_get'.");
+  cmock_call_instance->ReturnThruPtr_p_bytes_available_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_bytes_available_Val = p_bytes_available;
+  cmock_call_instance->ReturnThruPtr_p_bytes_available_Size = cmock_size;
+}
+
+void sd_rand_application_bytes_available_get_CMockIgnoreArg_p_bytes_available(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_rand_application_bytes_available_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_rand_application_bytes_available_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_bytes_available IgnoreArg called before Expect on 'sd_rand_application_bytes_available_get'.");
+  cmock_call_instance->IgnoreArg_p_bytes_available = 1;
+}
+
+uint32_t sd_rand_application_vector_get(uint8_t* p_buff, uint8_t length)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_rand_application_vector_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_rand_application_vector_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_rand_application_vector_get_CallInstance);
+  Mock.sd_rand_application_vector_get_CallInstance = CMock_Guts_MemNext(Mock.sd_rand_application_vector_get_CallInstance);
+  if (Mock.sd_rand_application_vector_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_rand_application_vector_get_FinalReturn;
+    Mock.sd_rand_application_vector_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_rand_application_vector_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_rand_application_vector_get_CallbackFunctionPointer(p_buff, length, Mock.sd_rand_application_vector_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_rand_application_vector_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_rand_application_vector_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_rand_application_vector_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_buff)
+  {
+    if (cmock_call_instance->Expected_p_buff == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_buff, cmock_line, "Expected NULL. Function 'sd_rand_application_vector_get' called with unexpected value for argument 'p_buff'."); }
+    else if (cmock_call_instance->Expected_p_buff_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_buff, p_buff, cmock_line, "Function 'sd_rand_application_vector_get' called with unexpected value for argument 'p_buff'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_buff, p_buff, cmock_call_instance->Expected_p_buff_Depth, cmock_line, "Function 'sd_rand_application_vector_get' called with unexpected value for argument 'p_buff'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_length)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_length, length, cmock_line, "Function 'sd_rand_application_vector_get' called with unexpected value for argument 'length'.");
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_buff_Used)
+  {
+    memcpy((void*)p_buff, (void*)cmock_call_instance->ReturnThruPtr_p_buff_Val,
+      cmock_call_instance->ReturnThruPtr_p_buff_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_rand_application_vector_get(CMOCK_sd_rand_application_vector_get_CALL_INSTANCE* cmock_call_instance, uint8_t* p_buff, int p_buff_Depth, uint8_t length)
+{
+  cmock_call_instance->Expected_p_buff = p_buff;
+  cmock_call_instance->Expected_p_buff_Depth = p_buff_Depth;
+  cmock_call_instance->IgnoreArg_p_buff = 0;
+  cmock_call_instance->ReturnThruPtr_p_buff_Used = 0;
+  cmock_call_instance->Expected_length = length;
+  cmock_call_instance->IgnoreArg_length = 0;
+}
+
+void sd_rand_application_vector_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_rand_application_vector_get_CALL_INSTANCE));
+  CMOCK_sd_rand_application_vector_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_rand_application_vector_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_rand_application_vector_get_CallInstance = CMock_Guts_MemChain(Mock.sd_rand_application_vector_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_rand_application_vector_get_IgnoreBool = (int)1;
+}
+
+void sd_rand_application_vector_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_buff, uint8_t length, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_rand_application_vector_get_CALL_INSTANCE));
+  CMOCK_sd_rand_application_vector_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_rand_application_vector_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_rand_application_vector_get_CallInstance = CMock_Guts_MemChain(Mock.sd_rand_application_vector_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_rand_application_vector_get(cmock_call_instance, p_buff, 0, length);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_rand_application_vector_get_StubWithCallback(CMOCK_sd_rand_application_vector_get_CALLBACK Callback)
+{
+  Mock.sd_rand_application_vector_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_rand_application_vector_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_buff, int p_buff_Depth, uint8_t length, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_rand_application_vector_get_CALL_INSTANCE));
+  CMOCK_sd_rand_application_vector_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_rand_application_vector_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_rand_application_vector_get_CallInstance = CMock_Guts_MemChain(Mock.sd_rand_application_vector_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_rand_application_vector_get(cmock_call_instance, p_buff, p_buff_Depth, length);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_rand_application_vector_get_CMockReturnMemThruPtr_p_buff(UNITY_LINE_TYPE cmock_line, uint8_t* p_buff, int cmock_size)
+{
+  CMOCK_sd_rand_application_vector_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_rand_application_vector_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_rand_application_vector_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_buff ReturnThruPtr called before Expect on 'sd_rand_application_vector_get'.");
+  cmock_call_instance->ReturnThruPtr_p_buff_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_buff_Val = p_buff;
+  cmock_call_instance->ReturnThruPtr_p_buff_Size = cmock_size;
+}
+
+void sd_rand_application_vector_get_CMockIgnoreArg_p_buff(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_rand_application_vector_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_rand_application_vector_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_rand_application_vector_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_buff IgnoreArg called before Expect on 'sd_rand_application_vector_get'.");
+  cmock_call_instance->IgnoreArg_p_buff = 1;
+}
+
+void sd_rand_application_vector_get_CMockIgnoreArg_length(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_rand_application_vector_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_rand_application_vector_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_rand_application_vector_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "length IgnoreArg called before Expect on 'sd_rand_application_vector_get'.");
+  cmock_call_instance->IgnoreArg_length = 1;
+}
+
+uint32_t sd_power_reset_reason_get(uint32_t* p_reset_reason)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_power_reset_reason_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_reset_reason_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_power_reset_reason_get_CallInstance);
+  Mock.sd_power_reset_reason_get_CallInstance = CMock_Guts_MemNext(Mock.sd_power_reset_reason_get_CallInstance);
+  if (Mock.sd_power_reset_reason_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_power_reset_reason_get_FinalReturn;
+    Mock.sd_power_reset_reason_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_power_reset_reason_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_power_reset_reason_get_CallbackFunctionPointer(p_reset_reason, Mock.sd_power_reset_reason_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_power_reset_reason_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_reset_reason_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_reset_reason_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_reset_reason)
+  {
+    if (cmock_call_instance->Expected_p_reset_reason == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_reset_reason, cmock_line, "Expected NULL. Function 'sd_power_reset_reason_get' called with unexpected value for argument 'p_reset_reason'."); }
+    else if (cmock_call_instance->Expected_p_reset_reason_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_reset_reason, p_reset_reason, cmock_line, "Function 'sd_power_reset_reason_get' called with unexpected value for argument 'p_reset_reason'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_p_reset_reason, p_reset_reason, cmock_call_instance->Expected_p_reset_reason_Depth, cmock_line, "Function 'sd_power_reset_reason_get' called with unexpected value for argument 'p_reset_reason'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_reset_reason_Used)
+  {
+    memcpy((void*)p_reset_reason, (void*)cmock_call_instance->ReturnThruPtr_p_reset_reason_Val,
+      cmock_call_instance->ReturnThruPtr_p_reset_reason_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_power_reset_reason_get(CMOCK_sd_power_reset_reason_get_CALL_INSTANCE* cmock_call_instance, uint32_t* p_reset_reason, int p_reset_reason_Depth)
+{
+  cmock_call_instance->Expected_p_reset_reason = p_reset_reason;
+  cmock_call_instance->Expected_p_reset_reason_Depth = p_reset_reason_Depth;
+  cmock_call_instance->IgnoreArg_p_reset_reason = 0;
+  cmock_call_instance->ReturnThruPtr_p_reset_reason_Used = 0;
+}
+
+void sd_power_reset_reason_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_reset_reason_get_CALL_INSTANCE));
+  CMOCK_sd_power_reset_reason_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_reset_reason_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_reset_reason_get_CallInstance = CMock_Guts_MemChain(Mock.sd_power_reset_reason_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_power_reset_reason_get_IgnoreBool = (int)1;
+}
+
+void sd_power_reset_reason_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_reset_reason, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_reset_reason_get_CALL_INSTANCE));
+  CMOCK_sd_power_reset_reason_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_reset_reason_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_reset_reason_get_CallInstance = CMock_Guts_MemChain(Mock.sd_power_reset_reason_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_power_reset_reason_get(cmock_call_instance, p_reset_reason, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_power_reset_reason_get_StubWithCallback(CMOCK_sd_power_reset_reason_get_CALLBACK Callback)
+{
+  Mock.sd_power_reset_reason_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_power_reset_reason_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_reset_reason, int p_reset_reason_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_reset_reason_get_CALL_INSTANCE));
+  CMOCK_sd_power_reset_reason_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_reset_reason_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_reset_reason_get_CallInstance = CMock_Guts_MemChain(Mock.sd_power_reset_reason_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_power_reset_reason_get(cmock_call_instance, p_reset_reason, p_reset_reason_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_power_reset_reason_get_CMockReturnMemThruPtr_p_reset_reason(UNITY_LINE_TYPE cmock_line, uint32_t* p_reset_reason, int cmock_size)
+{
+  CMOCK_sd_power_reset_reason_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_reset_reason_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_reset_reason_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_reset_reason ReturnThruPtr called before Expect on 'sd_power_reset_reason_get'.");
+  cmock_call_instance->ReturnThruPtr_p_reset_reason_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_reset_reason_Val = p_reset_reason;
+  cmock_call_instance->ReturnThruPtr_p_reset_reason_Size = cmock_size;
+}
+
+void sd_power_reset_reason_get_CMockIgnoreArg_p_reset_reason(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_power_reset_reason_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_reset_reason_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_reset_reason_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_reset_reason IgnoreArg called before Expect on 'sd_power_reset_reason_get'.");
+  cmock_call_instance->IgnoreArg_p_reset_reason = 1;
+}
+
+uint32_t sd_power_reset_reason_clr(uint32_t reset_reason_clr_msk)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_power_reset_reason_clr_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_reset_reason_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_power_reset_reason_clr_CallInstance);
+  Mock.sd_power_reset_reason_clr_CallInstance = CMock_Guts_MemNext(Mock.sd_power_reset_reason_clr_CallInstance);
+  if (Mock.sd_power_reset_reason_clr_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_power_reset_reason_clr_FinalReturn;
+    Mock.sd_power_reset_reason_clr_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_power_reset_reason_clr_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_power_reset_reason_clr_CallbackFunctionPointer(reset_reason_clr_msk, Mock.sd_power_reset_reason_clr_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_power_reset_reason_clr' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_reset_reason_clr' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_reset_reason_clr' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_reset_reason_clr_msk)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_reset_reason_clr_msk, reset_reason_clr_msk, cmock_line, "Function 'sd_power_reset_reason_clr' called with unexpected value for argument 'reset_reason_clr_msk'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_power_reset_reason_clr(CMOCK_sd_power_reset_reason_clr_CALL_INSTANCE* cmock_call_instance, uint32_t reset_reason_clr_msk)
+{
+  cmock_call_instance->Expected_reset_reason_clr_msk = reset_reason_clr_msk;
+  cmock_call_instance->IgnoreArg_reset_reason_clr_msk = 0;
+}
+
+void sd_power_reset_reason_clr_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_reset_reason_clr_CALL_INSTANCE));
+  CMOCK_sd_power_reset_reason_clr_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_reset_reason_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_reset_reason_clr_CallInstance = CMock_Guts_MemChain(Mock.sd_power_reset_reason_clr_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_power_reset_reason_clr_IgnoreBool = (int)1;
+}
+
+void sd_power_reset_reason_clr_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t reset_reason_clr_msk, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_reset_reason_clr_CALL_INSTANCE));
+  CMOCK_sd_power_reset_reason_clr_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_reset_reason_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_reset_reason_clr_CallInstance = CMock_Guts_MemChain(Mock.sd_power_reset_reason_clr_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_power_reset_reason_clr(cmock_call_instance, reset_reason_clr_msk);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_power_reset_reason_clr_StubWithCallback(CMOCK_sd_power_reset_reason_clr_CALLBACK Callback)
+{
+  Mock.sd_power_reset_reason_clr_CallbackFunctionPointer = Callback;
+}
+
+void sd_power_reset_reason_clr_CMockIgnoreArg_reset_reason_clr_msk(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_power_reset_reason_clr_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_reset_reason_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_reset_reason_clr_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "reset_reason_clr_msk IgnoreArg called before Expect on 'sd_power_reset_reason_clr'.");
+  cmock_call_instance->IgnoreArg_reset_reason_clr_msk = 1;
+}
+
+uint32_t sd_power_mode_set(uint8_t power_mode)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_power_mode_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_mode_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_power_mode_set_CallInstance);
+  Mock.sd_power_mode_set_CallInstance = CMock_Guts_MemNext(Mock.sd_power_mode_set_CallInstance);
+  if (Mock.sd_power_mode_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_power_mode_set_FinalReturn;
+    Mock.sd_power_mode_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_power_mode_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_power_mode_set_CallbackFunctionPointer(power_mode, Mock.sd_power_mode_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_power_mode_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_mode_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_mode_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_power_mode)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_power_mode, power_mode, cmock_line, "Function 'sd_power_mode_set' called with unexpected value for argument 'power_mode'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_power_mode_set(CMOCK_sd_power_mode_set_CALL_INSTANCE* cmock_call_instance, uint8_t power_mode)
+{
+  cmock_call_instance->Expected_power_mode = power_mode;
+  cmock_call_instance->IgnoreArg_power_mode = 0;
+}
+
+void sd_power_mode_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_mode_set_CALL_INSTANCE));
+  CMOCK_sd_power_mode_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_mode_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_mode_set_CallInstance = CMock_Guts_MemChain(Mock.sd_power_mode_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_power_mode_set_IgnoreBool = (int)1;
+}
+
+void sd_power_mode_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t power_mode, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_mode_set_CALL_INSTANCE));
+  CMOCK_sd_power_mode_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_mode_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_mode_set_CallInstance = CMock_Guts_MemChain(Mock.sd_power_mode_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_power_mode_set(cmock_call_instance, power_mode);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_power_mode_set_StubWithCallback(CMOCK_sd_power_mode_set_CALLBACK Callback)
+{
+  Mock.sd_power_mode_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_power_mode_set_CMockIgnoreArg_power_mode(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_power_mode_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_mode_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_mode_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "power_mode IgnoreArg called before Expect on 'sd_power_mode_set'.");
+  cmock_call_instance->IgnoreArg_power_mode = 1;
+}
+
+uint32_t sd_power_system_off(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_power_system_off_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_system_off_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_power_system_off_CallInstance);
+  Mock.sd_power_system_off_CallInstance = CMock_Guts_MemNext(Mock.sd_power_system_off_CallInstance);
+  if (Mock.sd_power_system_off_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_power_system_off_FinalReturn;
+    Mock.sd_power_system_off_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_power_system_off_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_power_system_off_CallbackFunctionPointer(Mock.sd_power_system_off_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_power_system_off' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_system_off' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_system_off' called later than expected.");
+  return cmock_call_instance->ReturnVal;
+}
+
+void sd_power_system_off_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_system_off_CALL_INSTANCE));
+  CMOCK_sd_power_system_off_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_system_off_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_system_off_CallInstance = CMock_Guts_MemChain(Mock.sd_power_system_off_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_power_system_off_IgnoreBool = (int)1;
+}
+
+void sd_power_system_off_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_system_off_CALL_INSTANCE));
+  CMOCK_sd_power_system_off_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_system_off_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_system_off_CallInstance = CMock_Guts_MemChain(Mock.sd_power_system_off_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_power_system_off_StubWithCallback(CMOCK_sd_power_system_off_CALLBACK Callback)
+{
+  Mock.sd_power_system_off_CallbackFunctionPointer = Callback;
+}
+
+uint32_t sd_power_pof_enable(uint8_t pof_enable)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_power_pof_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_pof_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_power_pof_enable_CallInstance);
+  Mock.sd_power_pof_enable_CallInstance = CMock_Guts_MemNext(Mock.sd_power_pof_enable_CallInstance);
+  if (Mock.sd_power_pof_enable_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_power_pof_enable_FinalReturn;
+    Mock.sd_power_pof_enable_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_power_pof_enable_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_power_pof_enable_CallbackFunctionPointer(pof_enable, Mock.sd_power_pof_enable_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_power_pof_enable' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_pof_enable' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_pof_enable' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_pof_enable)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_pof_enable, pof_enable, cmock_line, "Function 'sd_power_pof_enable' called with unexpected value for argument 'pof_enable'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_power_pof_enable(CMOCK_sd_power_pof_enable_CALL_INSTANCE* cmock_call_instance, uint8_t pof_enable)
+{
+  cmock_call_instance->Expected_pof_enable = pof_enable;
+  cmock_call_instance->IgnoreArg_pof_enable = 0;
+}
+
+void sd_power_pof_enable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_pof_enable_CALL_INSTANCE));
+  CMOCK_sd_power_pof_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_pof_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_pof_enable_CallInstance = CMock_Guts_MemChain(Mock.sd_power_pof_enable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_power_pof_enable_IgnoreBool = (int)1;
+}
+
+void sd_power_pof_enable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t pof_enable, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_pof_enable_CALL_INSTANCE));
+  CMOCK_sd_power_pof_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_pof_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_pof_enable_CallInstance = CMock_Guts_MemChain(Mock.sd_power_pof_enable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_power_pof_enable(cmock_call_instance, pof_enable);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_power_pof_enable_StubWithCallback(CMOCK_sd_power_pof_enable_CALLBACK Callback)
+{
+  Mock.sd_power_pof_enable_CallbackFunctionPointer = Callback;
+}
+
+void sd_power_pof_enable_CMockIgnoreArg_pof_enable(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_power_pof_enable_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_pof_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_pof_enable_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "pof_enable IgnoreArg called before Expect on 'sd_power_pof_enable'.");
+  cmock_call_instance->IgnoreArg_pof_enable = 1;
+}
+
+uint32_t sd_power_pof_threshold_set(uint8_t threshold)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_power_pof_threshold_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_pof_threshold_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_power_pof_threshold_set_CallInstance);
+  Mock.sd_power_pof_threshold_set_CallInstance = CMock_Guts_MemNext(Mock.sd_power_pof_threshold_set_CallInstance);
+  if (Mock.sd_power_pof_threshold_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_power_pof_threshold_set_FinalReturn;
+    Mock.sd_power_pof_threshold_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_power_pof_threshold_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_power_pof_threshold_set_CallbackFunctionPointer(threshold, Mock.sd_power_pof_threshold_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_power_pof_threshold_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_pof_threshold_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_pof_threshold_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_threshold)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_threshold, threshold, cmock_line, "Function 'sd_power_pof_threshold_set' called with unexpected value for argument 'threshold'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_power_pof_threshold_set(CMOCK_sd_power_pof_threshold_set_CALL_INSTANCE* cmock_call_instance, uint8_t threshold)
+{
+  cmock_call_instance->Expected_threshold = threshold;
+  cmock_call_instance->IgnoreArg_threshold = 0;
+}
+
+void sd_power_pof_threshold_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_pof_threshold_set_CALL_INSTANCE));
+  CMOCK_sd_power_pof_threshold_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_pof_threshold_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_pof_threshold_set_CallInstance = CMock_Guts_MemChain(Mock.sd_power_pof_threshold_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_power_pof_threshold_set_IgnoreBool = (int)1;
+}
+
+void sd_power_pof_threshold_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t threshold, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_pof_threshold_set_CALL_INSTANCE));
+  CMOCK_sd_power_pof_threshold_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_pof_threshold_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_pof_threshold_set_CallInstance = CMock_Guts_MemChain(Mock.sd_power_pof_threshold_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_power_pof_threshold_set(cmock_call_instance, threshold);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_power_pof_threshold_set_StubWithCallback(CMOCK_sd_power_pof_threshold_set_CALLBACK Callback)
+{
+  Mock.sd_power_pof_threshold_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_power_pof_threshold_set_CMockIgnoreArg_threshold(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_power_pof_threshold_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_pof_threshold_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_pof_threshold_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "threshold IgnoreArg called before Expect on 'sd_power_pof_threshold_set'.");
+  cmock_call_instance->IgnoreArg_threshold = 1;
+}
+
+uint32_t sd_power_ramon_set(uint32_t ramon)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_power_ramon_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_ramon_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_power_ramon_set_CallInstance);
+  Mock.sd_power_ramon_set_CallInstance = CMock_Guts_MemNext(Mock.sd_power_ramon_set_CallInstance);
+  if (Mock.sd_power_ramon_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_power_ramon_set_FinalReturn;
+    Mock.sd_power_ramon_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_power_ramon_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_power_ramon_set_CallbackFunctionPointer(ramon, Mock.sd_power_ramon_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_power_ramon_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_ramon_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_ramon_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_ramon)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ramon, ramon, cmock_line, "Function 'sd_power_ramon_set' called with unexpected value for argument 'ramon'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_power_ramon_set(CMOCK_sd_power_ramon_set_CALL_INSTANCE* cmock_call_instance, uint32_t ramon)
+{
+  cmock_call_instance->Expected_ramon = ramon;
+  cmock_call_instance->IgnoreArg_ramon = 0;
+}
+
+void sd_power_ramon_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_ramon_set_CALL_INSTANCE));
+  CMOCK_sd_power_ramon_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_ramon_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_ramon_set_CallInstance = CMock_Guts_MemChain(Mock.sd_power_ramon_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_power_ramon_set_IgnoreBool = (int)1;
+}
+
+void sd_power_ramon_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t ramon, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_ramon_set_CALL_INSTANCE));
+  CMOCK_sd_power_ramon_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_ramon_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_ramon_set_CallInstance = CMock_Guts_MemChain(Mock.sd_power_ramon_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_power_ramon_set(cmock_call_instance, ramon);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_power_ramon_set_StubWithCallback(CMOCK_sd_power_ramon_set_CALLBACK Callback)
+{
+  Mock.sd_power_ramon_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_power_ramon_set_CMockIgnoreArg_ramon(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_power_ramon_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_ramon_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_ramon_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "ramon IgnoreArg called before Expect on 'sd_power_ramon_set'.");
+  cmock_call_instance->IgnoreArg_ramon = 1;
+}
+
+uint32_t sd_power_ramon_clr(uint32_t ramon)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_power_ramon_clr_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_ramon_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_power_ramon_clr_CallInstance);
+  Mock.sd_power_ramon_clr_CallInstance = CMock_Guts_MemNext(Mock.sd_power_ramon_clr_CallInstance);
+  if (Mock.sd_power_ramon_clr_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_power_ramon_clr_FinalReturn;
+    Mock.sd_power_ramon_clr_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_power_ramon_clr_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_power_ramon_clr_CallbackFunctionPointer(ramon, Mock.sd_power_ramon_clr_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_power_ramon_clr' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_ramon_clr' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_ramon_clr' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_ramon)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ramon, ramon, cmock_line, "Function 'sd_power_ramon_clr' called with unexpected value for argument 'ramon'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_power_ramon_clr(CMOCK_sd_power_ramon_clr_CALL_INSTANCE* cmock_call_instance, uint32_t ramon)
+{
+  cmock_call_instance->Expected_ramon = ramon;
+  cmock_call_instance->IgnoreArg_ramon = 0;
+}
+
+void sd_power_ramon_clr_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_ramon_clr_CALL_INSTANCE));
+  CMOCK_sd_power_ramon_clr_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_ramon_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_ramon_clr_CallInstance = CMock_Guts_MemChain(Mock.sd_power_ramon_clr_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_power_ramon_clr_IgnoreBool = (int)1;
+}
+
+void sd_power_ramon_clr_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t ramon, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_ramon_clr_CALL_INSTANCE));
+  CMOCK_sd_power_ramon_clr_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_ramon_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_ramon_clr_CallInstance = CMock_Guts_MemChain(Mock.sd_power_ramon_clr_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_power_ramon_clr(cmock_call_instance, ramon);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_power_ramon_clr_StubWithCallback(CMOCK_sd_power_ramon_clr_CALLBACK Callback)
+{
+  Mock.sd_power_ramon_clr_CallbackFunctionPointer = Callback;
+}
+
+void sd_power_ramon_clr_CMockIgnoreArg_ramon(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_power_ramon_clr_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_ramon_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_ramon_clr_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "ramon IgnoreArg called before Expect on 'sd_power_ramon_clr'.");
+  cmock_call_instance->IgnoreArg_ramon = 1;
+}
+
+uint32_t sd_power_ramon_get(uint32_t* p_ramon)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_power_ramon_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_ramon_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_power_ramon_get_CallInstance);
+  Mock.sd_power_ramon_get_CallInstance = CMock_Guts_MemNext(Mock.sd_power_ramon_get_CallInstance);
+  if (Mock.sd_power_ramon_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_power_ramon_get_FinalReturn;
+    Mock.sd_power_ramon_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_power_ramon_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_power_ramon_get_CallbackFunctionPointer(p_ramon, Mock.sd_power_ramon_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_power_ramon_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_ramon_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_ramon_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_ramon)
+  {
+    if (cmock_call_instance->Expected_p_ramon == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_ramon, cmock_line, "Expected NULL. Function 'sd_power_ramon_get' called with unexpected value for argument 'p_ramon'."); }
+    else if (cmock_call_instance->Expected_p_ramon_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_ramon, p_ramon, cmock_line, "Function 'sd_power_ramon_get' called with unexpected value for argument 'p_ramon'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_p_ramon, p_ramon, cmock_call_instance->Expected_p_ramon_Depth, cmock_line, "Function 'sd_power_ramon_get' called with unexpected value for argument 'p_ramon'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_ramon_Used)
+  {
+    memcpy((void*)p_ramon, (void*)cmock_call_instance->ReturnThruPtr_p_ramon_Val,
+      cmock_call_instance->ReturnThruPtr_p_ramon_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_power_ramon_get(CMOCK_sd_power_ramon_get_CALL_INSTANCE* cmock_call_instance, uint32_t* p_ramon, int p_ramon_Depth)
+{
+  cmock_call_instance->Expected_p_ramon = p_ramon;
+  cmock_call_instance->Expected_p_ramon_Depth = p_ramon_Depth;
+  cmock_call_instance->IgnoreArg_p_ramon = 0;
+  cmock_call_instance->ReturnThruPtr_p_ramon_Used = 0;
+}
+
+void sd_power_ramon_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_ramon_get_CALL_INSTANCE));
+  CMOCK_sd_power_ramon_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_ramon_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_ramon_get_CallInstance = CMock_Guts_MemChain(Mock.sd_power_ramon_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_power_ramon_get_IgnoreBool = (int)1;
+}
+
+void sd_power_ramon_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_ramon, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_ramon_get_CALL_INSTANCE));
+  CMOCK_sd_power_ramon_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_ramon_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_ramon_get_CallInstance = CMock_Guts_MemChain(Mock.sd_power_ramon_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_power_ramon_get(cmock_call_instance, p_ramon, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_power_ramon_get_StubWithCallback(CMOCK_sd_power_ramon_get_CALLBACK Callback)
+{
+  Mock.sd_power_ramon_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_power_ramon_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_ramon, int p_ramon_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_ramon_get_CALL_INSTANCE));
+  CMOCK_sd_power_ramon_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_ramon_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_ramon_get_CallInstance = CMock_Guts_MemChain(Mock.sd_power_ramon_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_power_ramon_get(cmock_call_instance, p_ramon, p_ramon_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_power_ramon_get_CMockReturnMemThruPtr_p_ramon(UNITY_LINE_TYPE cmock_line, uint32_t* p_ramon, int cmock_size)
+{
+  CMOCK_sd_power_ramon_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_ramon_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_ramon_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_ramon ReturnThruPtr called before Expect on 'sd_power_ramon_get'.");
+  cmock_call_instance->ReturnThruPtr_p_ramon_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_ramon_Val = p_ramon;
+  cmock_call_instance->ReturnThruPtr_p_ramon_Size = cmock_size;
+}
+
+void sd_power_ramon_get_CMockIgnoreArg_p_ramon(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_power_ramon_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_ramon_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_ramon_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_ramon IgnoreArg called before Expect on 'sd_power_ramon_get'.");
+  cmock_call_instance->IgnoreArg_p_ramon = 1;
+}
+
+uint32_t sd_power_gpregret_set(uint32_t gpregret_id, uint32_t gpregret_msk)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_power_gpregret_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_gpregret_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_power_gpregret_set_CallInstance);
+  Mock.sd_power_gpregret_set_CallInstance = CMock_Guts_MemNext(Mock.sd_power_gpregret_set_CallInstance);
+  if (Mock.sd_power_gpregret_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_power_gpregret_set_FinalReturn;
+    Mock.sd_power_gpregret_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_power_gpregret_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_power_gpregret_set_CallbackFunctionPointer(gpregret_id, gpregret_msk, Mock.sd_power_gpregret_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_power_gpregret_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_gpregret_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_gpregret_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_gpregret_id)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_gpregret_id, gpregret_id, cmock_line, "Function 'sd_power_gpregret_set' called with unexpected value for argument 'gpregret_id'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_gpregret_msk)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_gpregret_msk, gpregret_msk, cmock_line, "Function 'sd_power_gpregret_set' called with unexpected value for argument 'gpregret_msk'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_power_gpregret_set(CMOCK_sd_power_gpregret_set_CALL_INSTANCE* cmock_call_instance, uint32_t gpregret_id, uint32_t gpregret_msk)
+{
+  cmock_call_instance->Expected_gpregret_id = gpregret_id;
+  cmock_call_instance->IgnoreArg_gpregret_id = 0;
+  cmock_call_instance->Expected_gpregret_msk = gpregret_msk;
+  cmock_call_instance->IgnoreArg_gpregret_msk = 0;
+}
+
+void sd_power_gpregret_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_gpregret_set_CALL_INSTANCE));
+  CMOCK_sd_power_gpregret_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_gpregret_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_gpregret_set_CallInstance = CMock_Guts_MemChain(Mock.sd_power_gpregret_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_power_gpregret_set_IgnoreBool = (int)1;
+}
+
+void sd_power_gpregret_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t gpregret_id, uint32_t gpregret_msk, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_gpregret_set_CALL_INSTANCE));
+  CMOCK_sd_power_gpregret_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_gpregret_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_gpregret_set_CallInstance = CMock_Guts_MemChain(Mock.sd_power_gpregret_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_power_gpregret_set(cmock_call_instance, gpregret_id, gpregret_msk);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_power_gpregret_set_StubWithCallback(CMOCK_sd_power_gpregret_set_CALLBACK Callback)
+{
+  Mock.sd_power_gpregret_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_power_gpregret_set_CMockIgnoreArg_gpregret_id(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_power_gpregret_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_gpregret_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_gpregret_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "gpregret_id IgnoreArg called before Expect on 'sd_power_gpregret_set'.");
+  cmock_call_instance->IgnoreArg_gpregret_id = 1;
+}
+
+void sd_power_gpregret_set_CMockIgnoreArg_gpregret_msk(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_power_gpregret_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_gpregret_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_gpregret_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "gpregret_msk IgnoreArg called before Expect on 'sd_power_gpregret_set'.");
+  cmock_call_instance->IgnoreArg_gpregret_msk = 1;
+}
+
+uint32_t sd_power_gpregret_clr(uint32_t gpregret_id, uint32_t gpregret_msk)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_power_gpregret_clr_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_gpregret_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_power_gpregret_clr_CallInstance);
+  Mock.sd_power_gpregret_clr_CallInstance = CMock_Guts_MemNext(Mock.sd_power_gpregret_clr_CallInstance);
+  if (Mock.sd_power_gpregret_clr_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_power_gpregret_clr_FinalReturn;
+    Mock.sd_power_gpregret_clr_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_power_gpregret_clr_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_power_gpregret_clr_CallbackFunctionPointer(gpregret_id, gpregret_msk, Mock.sd_power_gpregret_clr_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_power_gpregret_clr' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_gpregret_clr' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_gpregret_clr' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_gpregret_id)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_gpregret_id, gpregret_id, cmock_line, "Function 'sd_power_gpregret_clr' called with unexpected value for argument 'gpregret_id'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_gpregret_msk)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_gpregret_msk, gpregret_msk, cmock_line, "Function 'sd_power_gpregret_clr' called with unexpected value for argument 'gpregret_msk'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_power_gpregret_clr(CMOCK_sd_power_gpregret_clr_CALL_INSTANCE* cmock_call_instance, uint32_t gpregret_id, uint32_t gpregret_msk)
+{
+  cmock_call_instance->Expected_gpregret_id = gpregret_id;
+  cmock_call_instance->IgnoreArg_gpregret_id = 0;
+  cmock_call_instance->Expected_gpregret_msk = gpregret_msk;
+  cmock_call_instance->IgnoreArg_gpregret_msk = 0;
+}
+
+void sd_power_gpregret_clr_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_gpregret_clr_CALL_INSTANCE));
+  CMOCK_sd_power_gpregret_clr_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_gpregret_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_gpregret_clr_CallInstance = CMock_Guts_MemChain(Mock.sd_power_gpregret_clr_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_power_gpregret_clr_IgnoreBool = (int)1;
+}
+
+void sd_power_gpregret_clr_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t gpregret_id, uint32_t gpregret_msk, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_gpregret_clr_CALL_INSTANCE));
+  CMOCK_sd_power_gpregret_clr_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_gpregret_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_gpregret_clr_CallInstance = CMock_Guts_MemChain(Mock.sd_power_gpregret_clr_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_power_gpregret_clr(cmock_call_instance, gpregret_id, gpregret_msk);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_power_gpregret_clr_StubWithCallback(CMOCK_sd_power_gpregret_clr_CALLBACK Callback)
+{
+  Mock.sd_power_gpregret_clr_CallbackFunctionPointer = Callback;
+}
+
+void sd_power_gpregret_clr_CMockIgnoreArg_gpregret_id(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_power_gpregret_clr_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_gpregret_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_gpregret_clr_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "gpregret_id IgnoreArg called before Expect on 'sd_power_gpregret_clr'.");
+  cmock_call_instance->IgnoreArg_gpregret_id = 1;
+}
+
+void sd_power_gpregret_clr_CMockIgnoreArg_gpregret_msk(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_power_gpregret_clr_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_gpregret_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_gpregret_clr_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "gpregret_msk IgnoreArg called before Expect on 'sd_power_gpregret_clr'.");
+  cmock_call_instance->IgnoreArg_gpregret_msk = 1;
+}
+
+uint32_t sd_power_gpregret_get(uint32_t gpregret_id, uint32_t* p_gpregret)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_power_gpregret_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_gpregret_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_power_gpregret_get_CallInstance);
+  Mock.sd_power_gpregret_get_CallInstance = CMock_Guts_MemNext(Mock.sd_power_gpregret_get_CallInstance);
+  if (Mock.sd_power_gpregret_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_power_gpregret_get_FinalReturn;
+    Mock.sd_power_gpregret_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_power_gpregret_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_power_gpregret_get_CallbackFunctionPointer(gpregret_id, p_gpregret, Mock.sd_power_gpregret_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_power_gpregret_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_gpregret_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_gpregret_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_gpregret_id)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_gpregret_id, gpregret_id, cmock_line, "Function 'sd_power_gpregret_get' called with unexpected value for argument 'gpregret_id'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_gpregret)
+  {
+    if (cmock_call_instance->Expected_p_gpregret == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_gpregret, cmock_line, "Expected NULL. Function 'sd_power_gpregret_get' called with unexpected value for argument 'p_gpregret'."); }
+    else if (cmock_call_instance->Expected_p_gpregret_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_gpregret, p_gpregret, cmock_line, "Function 'sd_power_gpregret_get' called with unexpected value for argument 'p_gpregret'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_p_gpregret, p_gpregret, cmock_call_instance->Expected_p_gpregret_Depth, cmock_line, "Function 'sd_power_gpregret_get' called with unexpected value for argument 'p_gpregret'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_gpregret_Used)
+  {
+    memcpy((void*)p_gpregret, (void*)cmock_call_instance->ReturnThruPtr_p_gpregret_Val,
+      cmock_call_instance->ReturnThruPtr_p_gpregret_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_power_gpregret_get(CMOCK_sd_power_gpregret_get_CALL_INSTANCE* cmock_call_instance, uint32_t gpregret_id, uint32_t* p_gpregret, int p_gpregret_Depth)
+{
+  cmock_call_instance->Expected_gpregret_id = gpregret_id;
+  cmock_call_instance->IgnoreArg_gpregret_id = 0;
+  cmock_call_instance->Expected_p_gpregret = p_gpregret;
+  cmock_call_instance->Expected_p_gpregret_Depth = p_gpregret_Depth;
+  cmock_call_instance->IgnoreArg_p_gpregret = 0;
+  cmock_call_instance->ReturnThruPtr_p_gpregret_Used = 0;
+}
+
+void sd_power_gpregret_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_gpregret_get_CALL_INSTANCE));
+  CMOCK_sd_power_gpregret_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_gpregret_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_gpregret_get_CallInstance = CMock_Guts_MemChain(Mock.sd_power_gpregret_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_power_gpregret_get_IgnoreBool = (int)1;
+}
+
+void sd_power_gpregret_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t gpregret_id, uint32_t* p_gpregret, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_gpregret_get_CALL_INSTANCE));
+  CMOCK_sd_power_gpregret_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_gpregret_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_gpregret_get_CallInstance = CMock_Guts_MemChain(Mock.sd_power_gpregret_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_power_gpregret_get(cmock_call_instance, gpregret_id, p_gpregret, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_power_gpregret_get_StubWithCallback(CMOCK_sd_power_gpregret_get_CALLBACK Callback)
+{
+  Mock.sd_power_gpregret_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_power_gpregret_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t gpregret_id, uint32_t* p_gpregret, int p_gpregret_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_gpregret_get_CALL_INSTANCE));
+  CMOCK_sd_power_gpregret_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_gpregret_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_gpregret_get_CallInstance = CMock_Guts_MemChain(Mock.sd_power_gpregret_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_power_gpregret_get(cmock_call_instance, gpregret_id, p_gpregret, p_gpregret_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_power_gpregret_get_CMockReturnMemThruPtr_p_gpregret(UNITY_LINE_TYPE cmock_line, uint32_t* p_gpregret, int cmock_size)
+{
+  CMOCK_sd_power_gpregret_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_gpregret_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_gpregret_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_gpregret ReturnThruPtr called before Expect on 'sd_power_gpregret_get'.");
+  cmock_call_instance->ReturnThruPtr_p_gpregret_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_gpregret_Val = p_gpregret;
+  cmock_call_instance->ReturnThruPtr_p_gpregret_Size = cmock_size;
+}
+
+void sd_power_gpregret_get_CMockIgnoreArg_gpregret_id(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_power_gpregret_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_gpregret_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_gpregret_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "gpregret_id IgnoreArg called before Expect on 'sd_power_gpregret_get'.");
+  cmock_call_instance->IgnoreArg_gpregret_id = 1;
+}
+
+void sd_power_gpregret_get_CMockIgnoreArg_p_gpregret(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_power_gpregret_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_gpregret_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_gpregret_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_gpregret IgnoreArg called before Expect on 'sd_power_gpregret_get'.");
+  cmock_call_instance->IgnoreArg_p_gpregret = 1;
+}
+
+uint32_t sd_power_dcdc_mode_set(uint8_t dcdc_mode)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_power_dcdc_mode_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_dcdc_mode_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_power_dcdc_mode_set_CallInstance);
+  Mock.sd_power_dcdc_mode_set_CallInstance = CMock_Guts_MemNext(Mock.sd_power_dcdc_mode_set_CallInstance);
+  if (Mock.sd_power_dcdc_mode_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_power_dcdc_mode_set_FinalReturn;
+    Mock.sd_power_dcdc_mode_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_power_dcdc_mode_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_power_dcdc_mode_set_CallbackFunctionPointer(dcdc_mode, Mock.sd_power_dcdc_mode_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_power_dcdc_mode_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_dcdc_mode_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_power_dcdc_mode_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_dcdc_mode)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_dcdc_mode, dcdc_mode, cmock_line, "Function 'sd_power_dcdc_mode_set' called with unexpected value for argument 'dcdc_mode'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_power_dcdc_mode_set(CMOCK_sd_power_dcdc_mode_set_CALL_INSTANCE* cmock_call_instance, uint8_t dcdc_mode)
+{
+  cmock_call_instance->Expected_dcdc_mode = dcdc_mode;
+  cmock_call_instance->IgnoreArg_dcdc_mode = 0;
+}
+
+void sd_power_dcdc_mode_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_dcdc_mode_set_CALL_INSTANCE));
+  CMOCK_sd_power_dcdc_mode_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_dcdc_mode_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_dcdc_mode_set_CallInstance = CMock_Guts_MemChain(Mock.sd_power_dcdc_mode_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_power_dcdc_mode_set_IgnoreBool = (int)1;
+}
+
+void sd_power_dcdc_mode_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t dcdc_mode, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_power_dcdc_mode_set_CALL_INSTANCE));
+  CMOCK_sd_power_dcdc_mode_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_power_dcdc_mode_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_power_dcdc_mode_set_CallInstance = CMock_Guts_MemChain(Mock.sd_power_dcdc_mode_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_power_dcdc_mode_set(cmock_call_instance, dcdc_mode);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_power_dcdc_mode_set_StubWithCallback(CMOCK_sd_power_dcdc_mode_set_CALLBACK Callback)
+{
+  Mock.sd_power_dcdc_mode_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_power_dcdc_mode_set_CMockIgnoreArg_dcdc_mode(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_power_dcdc_mode_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_power_dcdc_mode_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_power_dcdc_mode_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "dcdc_mode IgnoreArg called before Expect on 'sd_power_dcdc_mode_set'.");
+  cmock_call_instance->IgnoreArg_dcdc_mode = 1;
+}
+
+uint32_t sd_clock_hfclk_request(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_clock_hfclk_request_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_clock_hfclk_request_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_clock_hfclk_request_CallInstance);
+  Mock.sd_clock_hfclk_request_CallInstance = CMock_Guts_MemNext(Mock.sd_clock_hfclk_request_CallInstance);
+  if (Mock.sd_clock_hfclk_request_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_clock_hfclk_request_FinalReturn;
+    Mock.sd_clock_hfclk_request_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_clock_hfclk_request_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_clock_hfclk_request_CallbackFunctionPointer(Mock.sd_clock_hfclk_request_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_clock_hfclk_request' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_clock_hfclk_request' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_clock_hfclk_request' called later than expected.");
+  return cmock_call_instance->ReturnVal;
+}
+
+void sd_clock_hfclk_request_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_clock_hfclk_request_CALL_INSTANCE));
+  CMOCK_sd_clock_hfclk_request_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_clock_hfclk_request_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_clock_hfclk_request_CallInstance = CMock_Guts_MemChain(Mock.sd_clock_hfclk_request_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_clock_hfclk_request_IgnoreBool = (int)1;
+}
+
+void sd_clock_hfclk_request_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_clock_hfclk_request_CALL_INSTANCE));
+  CMOCK_sd_clock_hfclk_request_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_clock_hfclk_request_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_clock_hfclk_request_CallInstance = CMock_Guts_MemChain(Mock.sd_clock_hfclk_request_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_clock_hfclk_request_StubWithCallback(CMOCK_sd_clock_hfclk_request_CALLBACK Callback)
+{
+  Mock.sd_clock_hfclk_request_CallbackFunctionPointer = Callback;
+}
+
+uint32_t sd_clock_hfclk_release(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_clock_hfclk_release_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_clock_hfclk_release_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_clock_hfclk_release_CallInstance);
+  Mock.sd_clock_hfclk_release_CallInstance = CMock_Guts_MemNext(Mock.sd_clock_hfclk_release_CallInstance);
+  if (Mock.sd_clock_hfclk_release_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_clock_hfclk_release_FinalReturn;
+    Mock.sd_clock_hfclk_release_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_clock_hfclk_release_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_clock_hfclk_release_CallbackFunctionPointer(Mock.sd_clock_hfclk_release_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_clock_hfclk_release' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_clock_hfclk_release' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_clock_hfclk_release' called later than expected.");
+  return cmock_call_instance->ReturnVal;
+}
+
+void sd_clock_hfclk_release_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_clock_hfclk_release_CALL_INSTANCE));
+  CMOCK_sd_clock_hfclk_release_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_clock_hfclk_release_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_clock_hfclk_release_CallInstance = CMock_Guts_MemChain(Mock.sd_clock_hfclk_release_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_clock_hfclk_release_IgnoreBool = (int)1;
+}
+
+void sd_clock_hfclk_release_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_clock_hfclk_release_CALL_INSTANCE));
+  CMOCK_sd_clock_hfclk_release_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_clock_hfclk_release_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_clock_hfclk_release_CallInstance = CMock_Guts_MemChain(Mock.sd_clock_hfclk_release_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_clock_hfclk_release_StubWithCallback(CMOCK_sd_clock_hfclk_release_CALLBACK Callback)
+{
+  Mock.sd_clock_hfclk_release_CallbackFunctionPointer = Callback;
+}
+
+uint32_t sd_clock_hfclk_is_running(uint32_t* p_is_running)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_clock_hfclk_is_running_CallInstance);
+  Mock.sd_clock_hfclk_is_running_CallInstance = CMock_Guts_MemNext(Mock.sd_clock_hfclk_is_running_CallInstance);
+  if (Mock.sd_clock_hfclk_is_running_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_clock_hfclk_is_running_FinalReturn;
+    Mock.sd_clock_hfclk_is_running_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_clock_hfclk_is_running_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_clock_hfclk_is_running_CallbackFunctionPointer(p_is_running, Mock.sd_clock_hfclk_is_running_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_clock_hfclk_is_running' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_clock_hfclk_is_running' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_clock_hfclk_is_running' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_is_running)
+  {
+    if (cmock_call_instance->Expected_p_is_running == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_is_running, cmock_line, "Expected NULL. Function 'sd_clock_hfclk_is_running' called with unexpected value for argument 'p_is_running'."); }
+    else if (cmock_call_instance->Expected_p_is_running_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_is_running, p_is_running, cmock_line, "Function 'sd_clock_hfclk_is_running' called with unexpected value for argument 'p_is_running'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_p_is_running, p_is_running, cmock_call_instance->Expected_p_is_running_Depth, cmock_line, "Function 'sd_clock_hfclk_is_running' called with unexpected value for argument 'p_is_running'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_is_running_Used)
+  {
+    memcpy((void*)p_is_running, (void*)cmock_call_instance->ReturnThruPtr_p_is_running_Val,
+      cmock_call_instance->ReturnThruPtr_p_is_running_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_clock_hfclk_is_running(CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE* cmock_call_instance, uint32_t* p_is_running, int p_is_running_Depth)
+{
+  cmock_call_instance->Expected_p_is_running = p_is_running;
+  cmock_call_instance->Expected_p_is_running_Depth = p_is_running_Depth;
+  cmock_call_instance->IgnoreArg_p_is_running = 0;
+  cmock_call_instance->ReturnThruPtr_p_is_running_Used = 0;
+}
+
+void sd_clock_hfclk_is_running_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE));
+  CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_clock_hfclk_is_running_CallInstance = CMock_Guts_MemChain(Mock.sd_clock_hfclk_is_running_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_clock_hfclk_is_running_IgnoreBool = (int)1;
+}
+
+void sd_clock_hfclk_is_running_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_is_running, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE));
+  CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_clock_hfclk_is_running_CallInstance = CMock_Guts_MemChain(Mock.sd_clock_hfclk_is_running_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_clock_hfclk_is_running(cmock_call_instance, p_is_running, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_clock_hfclk_is_running_StubWithCallback(CMOCK_sd_clock_hfclk_is_running_CALLBACK Callback)
+{
+  Mock.sd_clock_hfclk_is_running_CallbackFunctionPointer = Callback;
+}
+
+void sd_clock_hfclk_is_running_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_is_running, int p_is_running_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE));
+  CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_clock_hfclk_is_running_CallInstance = CMock_Guts_MemChain(Mock.sd_clock_hfclk_is_running_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_clock_hfclk_is_running(cmock_call_instance, p_is_running, p_is_running_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_clock_hfclk_is_running_CMockReturnMemThruPtr_p_is_running(UNITY_LINE_TYPE cmock_line, uint32_t* p_is_running, int cmock_size)
+{
+  CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_clock_hfclk_is_running_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_is_running ReturnThruPtr called before Expect on 'sd_clock_hfclk_is_running'.");
+  cmock_call_instance->ReturnThruPtr_p_is_running_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_is_running_Val = p_is_running;
+  cmock_call_instance->ReturnThruPtr_p_is_running_Size = cmock_size;
+}
+
+void sd_clock_hfclk_is_running_CMockIgnoreArg_p_is_running(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_clock_hfclk_is_running_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_clock_hfclk_is_running_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_is_running IgnoreArg called before Expect on 'sd_clock_hfclk_is_running'.");
+  cmock_call_instance->IgnoreArg_p_is_running = 1;
+}
+
+uint32_t sd_app_evt_wait(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_app_evt_wait_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_app_evt_wait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_app_evt_wait_CallInstance);
+  Mock.sd_app_evt_wait_CallInstance = CMock_Guts_MemNext(Mock.sd_app_evt_wait_CallInstance);
+  if (Mock.sd_app_evt_wait_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_app_evt_wait_FinalReturn;
+    Mock.sd_app_evt_wait_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_app_evt_wait_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_app_evt_wait_CallbackFunctionPointer(Mock.sd_app_evt_wait_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_app_evt_wait' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_app_evt_wait' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_app_evt_wait' called later than expected.");
+  return cmock_call_instance->ReturnVal;
+}
+
+void sd_app_evt_wait_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_app_evt_wait_CALL_INSTANCE));
+  CMOCK_sd_app_evt_wait_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_app_evt_wait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_app_evt_wait_CallInstance = CMock_Guts_MemChain(Mock.sd_app_evt_wait_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_app_evt_wait_IgnoreBool = (int)1;
+}
+
+void sd_app_evt_wait_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_app_evt_wait_CALL_INSTANCE));
+  CMOCK_sd_app_evt_wait_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_app_evt_wait_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_app_evt_wait_CallInstance = CMock_Guts_MemChain(Mock.sd_app_evt_wait_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_app_evt_wait_StubWithCallback(CMOCK_sd_app_evt_wait_CALLBACK Callback)
+{
+  Mock.sd_app_evt_wait_CallbackFunctionPointer = Callback;
+}
+
+uint32_t sd_ppi_channel_enable_get(uint32_t* p_channel_enable)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ppi_channel_enable_get_CallInstance);
+  Mock.sd_ppi_channel_enable_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ppi_channel_enable_get_CallInstance);
+  if (Mock.sd_ppi_channel_enable_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ppi_channel_enable_get_FinalReturn;
+    Mock.sd_ppi_channel_enable_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ppi_channel_enable_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ppi_channel_enable_get_CallbackFunctionPointer(p_channel_enable, Mock.sd_ppi_channel_enable_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ppi_channel_enable_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ppi_channel_enable_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ppi_channel_enable_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_channel_enable)
+  {
+    if (cmock_call_instance->Expected_p_channel_enable == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_channel_enable, cmock_line, "Expected NULL. Function 'sd_ppi_channel_enable_get' called with unexpected value for argument 'p_channel_enable'."); }
+    else if (cmock_call_instance->Expected_p_channel_enable_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_channel_enable, p_channel_enable, cmock_line, "Function 'sd_ppi_channel_enable_get' called with unexpected value for argument 'p_channel_enable'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_p_channel_enable, p_channel_enable, cmock_call_instance->Expected_p_channel_enable_Depth, cmock_line, "Function 'sd_ppi_channel_enable_get' called with unexpected value for argument 'p_channel_enable'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_channel_enable_Used)
+  {
+    memcpy((void*)p_channel_enable, (void*)cmock_call_instance->ReturnThruPtr_p_channel_enable_Val,
+      cmock_call_instance->ReturnThruPtr_p_channel_enable_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ppi_channel_enable_get(CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE* cmock_call_instance, uint32_t* p_channel_enable, int p_channel_enable_Depth)
+{
+  cmock_call_instance->Expected_p_channel_enable = p_channel_enable;
+  cmock_call_instance->Expected_p_channel_enable_Depth = p_channel_enable_Depth;
+  cmock_call_instance->IgnoreArg_p_channel_enable = 0;
+  cmock_call_instance->ReturnThruPtr_p_channel_enable_Used = 0;
+}
+
+void sd_ppi_channel_enable_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE));
+  CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_channel_enable_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_channel_enable_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ppi_channel_enable_get_IgnoreBool = (int)1;
+}
+
+void sd_ppi_channel_enable_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_channel_enable, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE));
+  CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_channel_enable_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_channel_enable_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ppi_channel_enable_get(cmock_call_instance, p_channel_enable, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ppi_channel_enable_get_StubWithCallback(CMOCK_sd_ppi_channel_enable_get_CALLBACK Callback)
+{
+  Mock.sd_ppi_channel_enable_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ppi_channel_enable_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_channel_enable, int p_channel_enable_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE));
+  CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_channel_enable_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_channel_enable_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ppi_channel_enable_get(cmock_call_instance, p_channel_enable, p_channel_enable_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ppi_channel_enable_get_CMockReturnMemThruPtr_p_channel_enable(UNITY_LINE_TYPE cmock_line, uint32_t* p_channel_enable, int cmock_size)
+{
+  CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ppi_channel_enable_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_channel_enable ReturnThruPtr called before Expect on 'sd_ppi_channel_enable_get'.");
+  cmock_call_instance->ReturnThruPtr_p_channel_enable_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_channel_enable_Val = p_channel_enable;
+  cmock_call_instance->ReturnThruPtr_p_channel_enable_Size = cmock_size;
+}
+
+void sd_ppi_channel_enable_get_CMockIgnoreArg_p_channel_enable(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ppi_channel_enable_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ppi_channel_enable_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_channel_enable IgnoreArg called before Expect on 'sd_ppi_channel_enable_get'.");
+  cmock_call_instance->IgnoreArg_p_channel_enable = 1;
+}
+
+uint32_t sd_ppi_channel_enable_set(uint32_t channel_enable_set_msk)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ppi_channel_enable_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_channel_enable_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ppi_channel_enable_set_CallInstance);
+  Mock.sd_ppi_channel_enable_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ppi_channel_enable_set_CallInstance);
+  if (Mock.sd_ppi_channel_enable_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ppi_channel_enable_set_FinalReturn;
+    Mock.sd_ppi_channel_enable_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ppi_channel_enable_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ppi_channel_enable_set_CallbackFunctionPointer(channel_enable_set_msk, Mock.sd_ppi_channel_enable_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ppi_channel_enable_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ppi_channel_enable_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ppi_channel_enable_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_channel_enable_set_msk)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_channel_enable_set_msk, channel_enable_set_msk, cmock_line, "Function 'sd_ppi_channel_enable_set' called with unexpected value for argument 'channel_enable_set_msk'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ppi_channel_enable_set(CMOCK_sd_ppi_channel_enable_set_CALL_INSTANCE* cmock_call_instance, uint32_t channel_enable_set_msk)
+{
+  cmock_call_instance->Expected_channel_enable_set_msk = channel_enable_set_msk;
+  cmock_call_instance->IgnoreArg_channel_enable_set_msk = 0;
+}
+
+void sd_ppi_channel_enable_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_channel_enable_set_CALL_INSTANCE));
+  CMOCK_sd_ppi_channel_enable_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_channel_enable_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_channel_enable_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_channel_enable_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ppi_channel_enable_set_IgnoreBool = (int)1;
+}
+
+void sd_ppi_channel_enable_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t channel_enable_set_msk, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_channel_enable_set_CALL_INSTANCE));
+  CMOCK_sd_ppi_channel_enable_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_channel_enable_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_channel_enable_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_channel_enable_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ppi_channel_enable_set(cmock_call_instance, channel_enable_set_msk);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ppi_channel_enable_set_StubWithCallback(CMOCK_sd_ppi_channel_enable_set_CALLBACK Callback)
+{
+  Mock.sd_ppi_channel_enable_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ppi_channel_enable_set_CMockIgnoreArg_channel_enable_set_msk(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ppi_channel_enable_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ppi_channel_enable_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ppi_channel_enable_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "channel_enable_set_msk IgnoreArg called before Expect on 'sd_ppi_channel_enable_set'.");
+  cmock_call_instance->IgnoreArg_channel_enable_set_msk = 1;
+}
+
+uint32_t sd_ppi_channel_enable_clr(uint32_t channel_enable_clr_msk)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ppi_channel_enable_clr_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_channel_enable_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ppi_channel_enable_clr_CallInstance);
+  Mock.sd_ppi_channel_enable_clr_CallInstance = CMock_Guts_MemNext(Mock.sd_ppi_channel_enable_clr_CallInstance);
+  if (Mock.sd_ppi_channel_enable_clr_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ppi_channel_enable_clr_FinalReturn;
+    Mock.sd_ppi_channel_enable_clr_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ppi_channel_enable_clr_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ppi_channel_enable_clr_CallbackFunctionPointer(channel_enable_clr_msk, Mock.sd_ppi_channel_enable_clr_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ppi_channel_enable_clr' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ppi_channel_enable_clr' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ppi_channel_enable_clr' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_channel_enable_clr_msk)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_channel_enable_clr_msk, channel_enable_clr_msk, cmock_line, "Function 'sd_ppi_channel_enable_clr' called with unexpected value for argument 'channel_enable_clr_msk'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ppi_channel_enable_clr(CMOCK_sd_ppi_channel_enable_clr_CALL_INSTANCE* cmock_call_instance, uint32_t channel_enable_clr_msk)
+{
+  cmock_call_instance->Expected_channel_enable_clr_msk = channel_enable_clr_msk;
+  cmock_call_instance->IgnoreArg_channel_enable_clr_msk = 0;
+}
+
+void sd_ppi_channel_enable_clr_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_channel_enable_clr_CALL_INSTANCE));
+  CMOCK_sd_ppi_channel_enable_clr_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_channel_enable_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_channel_enable_clr_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_channel_enable_clr_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ppi_channel_enable_clr_IgnoreBool = (int)1;
+}
+
+void sd_ppi_channel_enable_clr_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t channel_enable_clr_msk, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_channel_enable_clr_CALL_INSTANCE));
+  CMOCK_sd_ppi_channel_enable_clr_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_channel_enable_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_channel_enable_clr_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_channel_enable_clr_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ppi_channel_enable_clr(cmock_call_instance, channel_enable_clr_msk);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ppi_channel_enable_clr_StubWithCallback(CMOCK_sd_ppi_channel_enable_clr_CALLBACK Callback)
+{
+  Mock.sd_ppi_channel_enable_clr_CallbackFunctionPointer = Callback;
+}
+
+void sd_ppi_channel_enable_clr_CMockIgnoreArg_channel_enable_clr_msk(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ppi_channel_enable_clr_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ppi_channel_enable_clr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ppi_channel_enable_clr_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "channel_enable_clr_msk IgnoreArg called before Expect on 'sd_ppi_channel_enable_clr'.");
+  cmock_call_instance->IgnoreArg_channel_enable_clr_msk = 1;
+}
+
+uint32_t sd_ppi_channel_assign(uint8_t channel_num, const volatile void* evt_endpoint, const volatile void* task_endpoint)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ppi_channel_assign_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_channel_assign_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ppi_channel_assign_CallInstance);
+  Mock.sd_ppi_channel_assign_CallInstance = CMock_Guts_MemNext(Mock.sd_ppi_channel_assign_CallInstance);
+  if (Mock.sd_ppi_channel_assign_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ppi_channel_assign_FinalReturn;
+    Mock.sd_ppi_channel_assign_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ppi_channel_assign_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ppi_channel_assign_CallbackFunctionPointer(channel_num, evt_endpoint, task_endpoint, Mock.sd_ppi_channel_assign_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ppi_channel_assign' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ppi_channel_assign' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ppi_channel_assign' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_channel_num)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_channel_num, channel_num, cmock_line, "Function 'sd_ppi_channel_assign' called with unexpected value for argument 'channel_num'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_evt_endpoint)
+  {
+    if (cmock_call_instance->Expected_evt_endpoint == NULL)
+      { UNITY_TEST_ASSERT_NULL(evt_endpoint, cmock_line, "Expected NULL. Function 'sd_ppi_channel_assign' called with unexpected value for argument 'evt_endpoint'."); }
+    else if (cmock_call_instance->Expected_evt_endpoint_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_evt_endpoint, evt_endpoint, cmock_line, "Function 'sd_ppi_channel_assign' called with unexpected value for argument 'evt_endpoint'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_evt_endpoint), (void*)(evt_endpoint), sizeof(uint8_t), cmock_call_instance->Expected_evt_endpoint_Depth, cmock_line, "Function 'sd_ppi_channel_assign' called with unexpected value for argument 'evt_endpoint'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_task_endpoint)
+  {
+    if (cmock_call_instance->Expected_task_endpoint == NULL)
+      { UNITY_TEST_ASSERT_NULL(task_endpoint, cmock_line, "Expected NULL. Function 'sd_ppi_channel_assign' called with unexpected value for argument 'task_endpoint'."); }
+    else if (cmock_call_instance->Expected_task_endpoint_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_task_endpoint, task_endpoint, cmock_line, "Function 'sd_ppi_channel_assign' called with unexpected value for argument 'task_endpoint'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_task_endpoint), (void*)(task_endpoint), sizeof(uint8_t), cmock_call_instance->Expected_task_endpoint_Depth, cmock_line, "Function 'sd_ppi_channel_assign' called with unexpected value for argument 'task_endpoint'."); }
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ppi_channel_assign(CMOCK_sd_ppi_channel_assign_CALL_INSTANCE* cmock_call_instance, uint8_t channel_num, const volatile void* evt_endpoint, int evt_endpoint_Depth, const volatile void* task_endpoint, int task_endpoint_Depth)
+{
+  cmock_call_instance->Expected_channel_num = channel_num;
+  cmock_call_instance->IgnoreArg_channel_num = 0;
+  cmock_call_instance->Expected_evt_endpoint = (volatile void*)evt_endpoint;
+  cmock_call_instance->Expected_evt_endpoint_Depth = evt_endpoint_Depth;
+  cmock_call_instance->IgnoreArg_evt_endpoint = 0;
+  cmock_call_instance->Expected_task_endpoint = (volatile void*)task_endpoint;
+  cmock_call_instance->Expected_task_endpoint_Depth = task_endpoint_Depth;
+  cmock_call_instance->IgnoreArg_task_endpoint = 0;
+}
+
+void sd_ppi_channel_assign_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_channel_assign_CALL_INSTANCE));
+  CMOCK_sd_ppi_channel_assign_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_channel_assign_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_channel_assign_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_channel_assign_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ppi_channel_assign_IgnoreBool = (int)1;
+}
+
+void sd_ppi_channel_assign_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t channel_num, const volatile void* evt_endpoint, const volatile void* task_endpoint, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_channel_assign_CALL_INSTANCE));
+  CMOCK_sd_ppi_channel_assign_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_channel_assign_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_channel_assign_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_channel_assign_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ppi_channel_assign(cmock_call_instance, channel_num, evt_endpoint, 0, task_endpoint, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ppi_channel_assign_StubWithCallback(CMOCK_sd_ppi_channel_assign_CALLBACK Callback)
+{
+  Mock.sd_ppi_channel_assign_CallbackFunctionPointer = Callback;
+}
+
+void sd_ppi_channel_assign_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t channel_num, volatile void* evt_endpoint, int evt_endpoint_Depth, volatile void* task_endpoint, int task_endpoint_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_channel_assign_CALL_INSTANCE));
+  CMOCK_sd_ppi_channel_assign_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_channel_assign_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_channel_assign_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_channel_assign_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ppi_channel_assign(cmock_call_instance, channel_num, evt_endpoint, evt_endpoint_Depth, task_endpoint, task_endpoint_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ppi_channel_assign_CMockIgnoreArg_channel_num(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ppi_channel_assign_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ppi_channel_assign_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ppi_channel_assign_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "channel_num IgnoreArg called before Expect on 'sd_ppi_channel_assign'.");
+  cmock_call_instance->IgnoreArg_channel_num = 1;
+}
+
+void sd_ppi_channel_assign_CMockIgnoreArg_evt_endpoint(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ppi_channel_assign_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ppi_channel_assign_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ppi_channel_assign_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "evt_endpoint IgnoreArg called before Expect on 'sd_ppi_channel_assign'.");
+  cmock_call_instance->IgnoreArg_evt_endpoint = 1;
+}
+
+void sd_ppi_channel_assign_CMockIgnoreArg_task_endpoint(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ppi_channel_assign_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ppi_channel_assign_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ppi_channel_assign_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "task_endpoint IgnoreArg called before Expect on 'sd_ppi_channel_assign'.");
+  cmock_call_instance->IgnoreArg_task_endpoint = 1;
+}
+
+uint32_t sd_ppi_group_task_enable(uint8_t group_num)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ppi_group_task_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_group_task_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ppi_group_task_enable_CallInstance);
+  Mock.sd_ppi_group_task_enable_CallInstance = CMock_Guts_MemNext(Mock.sd_ppi_group_task_enable_CallInstance);
+  if (Mock.sd_ppi_group_task_enable_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ppi_group_task_enable_FinalReturn;
+    Mock.sd_ppi_group_task_enable_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ppi_group_task_enable_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ppi_group_task_enable_CallbackFunctionPointer(group_num, Mock.sd_ppi_group_task_enable_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ppi_group_task_enable' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ppi_group_task_enable' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ppi_group_task_enable' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_group_num)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_group_num, group_num, cmock_line, "Function 'sd_ppi_group_task_enable' called with unexpected value for argument 'group_num'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ppi_group_task_enable(CMOCK_sd_ppi_group_task_enable_CALL_INSTANCE* cmock_call_instance, uint8_t group_num)
+{
+  cmock_call_instance->Expected_group_num = group_num;
+  cmock_call_instance->IgnoreArg_group_num = 0;
+}
+
+void sd_ppi_group_task_enable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_group_task_enable_CALL_INSTANCE));
+  CMOCK_sd_ppi_group_task_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_group_task_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_group_task_enable_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_group_task_enable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ppi_group_task_enable_IgnoreBool = (int)1;
+}
+
+void sd_ppi_group_task_enable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t group_num, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_group_task_enable_CALL_INSTANCE));
+  CMOCK_sd_ppi_group_task_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_group_task_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_group_task_enable_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_group_task_enable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ppi_group_task_enable(cmock_call_instance, group_num);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ppi_group_task_enable_StubWithCallback(CMOCK_sd_ppi_group_task_enable_CALLBACK Callback)
+{
+  Mock.sd_ppi_group_task_enable_CallbackFunctionPointer = Callback;
+}
+
+void sd_ppi_group_task_enable_CMockIgnoreArg_group_num(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ppi_group_task_enable_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ppi_group_task_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ppi_group_task_enable_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "group_num IgnoreArg called before Expect on 'sd_ppi_group_task_enable'.");
+  cmock_call_instance->IgnoreArg_group_num = 1;
+}
+
+uint32_t sd_ppi_group_task_disable(uint8_t group_num)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ppi_group_task_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_group_task_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ppi_group_task_disable_CallInstance);
+  Mock.sd_ppi_group_task_disable_CallInstance = CMock_Guts_MemNext(Mock.sd_ppi_group_task_disable_CallInstance);
+  if (Mock.sd_ppi_group_task_disable_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ppi_group_task_disable_FinalReturn;
+    Mock.sd_ppi_group_task_disable_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ppi_group_task_disable_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ppi_group_task_disable_CallbackFunctionPointer(group_num, Mock.sd_ppi_group_task_disable_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ppi_group_task_disable' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ppi_group_task_disable' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ppi_group_task_disable' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_group_num)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_group_num, group_num, cmock_line, "Function 'sd_ppi_group_task_disable' called with unexpected value for argument 'group_num'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ppi_group_task_disable(CMOCK_sd_ppi_group_task_disable_CALL_INSTANCE* cmock_call_instance, uint8_t group_num)
+{
+  cmock_call_instance->Expected_group_num = group_num;
+  cmock_call_instance->IgnoreArg_group_num = 0;
+}
+
+void sd_ppi_group_task_disable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_group_task_disable_CALL_INSTANCE));
+  CMOCK_sd_ppi_group_task_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_group_task_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_group_task_disable_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_group_task_disable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ppi_group_task_disable_IgnoreBool = (int)1;
+}
+
+void sd_ppi_group_task_disable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t group_num, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_group_task_disable_CALL_INSTANCE));
+  CMOCK_sd_ppi_group_task_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_group_task_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_group_task_disable_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_group_task_disable_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ppi_group_task_disable(cmock_call_instance, group_num);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ppi_group_task_disable_StubWithCallback(CMOCK_sd_ppi_group_task_disable_CALLBACK Callback)
+{
+  Mock.sd_ppi_group_task_disable_CallbackFunctionPointer = Callback;
+}
+
+void sd_ppi_group_task_disable_CMockIgnoreArg_group_num(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ppi_group_task_disable_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ppi_group_task_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ppi_group_task_disable_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "group_num IgnoreArg called before Expect on 'sd_ppi_group_task_disable'.");
+  cmock_call_instance->IgnoreArg_group_num = 1;
+}
+
+uint32_t sd_ppi_group_assign(uint8_t group_num, uint32_t channel_msk)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ppi_group_assign_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_group_assign_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ppi_group_assign_CallInstance);
+  Mock.sd_ppi_group_assign_CallInstance = CMock_Guts_MemNext(Mock.sd_ppi_group_assign_CallInstance);
+  if (Mock.sd_ppi_group_assign_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ppi_group_assign_FinalReturn;
+    Mock.sd_ppi_group_assign_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ppi_group_assign_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ppi_group_assign_CallbackFunctionPointer(group_num, channel_msk, Mock.sd_ppi_group_assign_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ppi_group_assign' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ppi_group_assign' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ppi_group_assign' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_group_num)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_group_num, group_num, cmock_line, "Function 'sd_ppi_group_assign' called with unexpected value for argument 'group_num'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_channel_msk)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_channel_msk, channel_msk, cmock_line, "Function 'sd_ppi_group_assign' called with unexpected value for argument 'channel_msk'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ppi_group_assign(CMOCK_sd_ppi_group_assign_CALL_INSTANCE* cmock_call_instance, uint8_t group_num, uint32_t channel_msk)
+{
+  cmock_call_instance->Expected_group_num = group_num;
+  cmock_call_instance->IgnoreArg_group_num = 0;
+  cmock_call_instance->Expected_channel_msk = channel_msk;
+  cmock_call_instance->IgnoreArg_channel_msk = 0;
+}
+
+void sd_ppi_group_assign_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_group_assign_CALL_INSTANCE));
+  CMOCK_sd_ppi_group_assign_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_group_assign_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_group_assign_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_group_assign_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ppi_group_assign_IgnoreBool = (int)1;
+}
+
+void sd_ppi_group_assign_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t group_num, uint32_t channel_msk, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_group_assign_CALL_INSTANCE));
+  CMOCK_sd_ppi_group_assign_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_group_assign_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_group_assign_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_group_assign_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ppi_group_assign(cmock_call_instance, group_num, channel_msk);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ppi_group_assign_StubWithCallback(CMOCK_sd_ppi_group_assign_CALLBACK Callback)
+{
+  Mock.sd_ppi_group_assign_CallbackFunctionPointer = Callback;
+}
+
+void sd_ppi_group_assign_CMockIgnoreArg_group_num(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ppi_group_assign_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ppi_group_assign_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ppi_group_assign_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "group_num IgnoreArg called before Expect on 'sd_ppi_group_assign'.");
+  cmock_call_instance->IgnoreArg_group_num = 1;
+}
+
+void sd_ppi_group_assign_CMockIgnoreArg_channel_msk(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ppi_group_assign_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ppi_group_assign_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ppi_group_assign_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "channel_msk IgnoreArg called before Expect on 'sd_ppi_group_assign'.");
+  cmock_call_instance->IgnoreArg_channel_msk = 1;
+}
+
+uint32_t sd_ppi_group_get(uint8_t group_num, uint32_t* p_channel_msk)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ppi_group_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_group_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ppi_group_get_CallInstance);
+  Mock.sd_ppi_group_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ppi_group_get_CallInstance);
+  if (Mock.sd_ppi_group_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ppi_group_get_FinalReturn;
+    Mock.sd_ppi_group_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ppi_group_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ppi_group_get_CallbackFunctionPointer(group_num, p_channel_msk, Mock.sd_ppi_group_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ppi_group_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ppi_group_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ppi_group_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_group_num)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_group_num, group_num, cmock_line, "Function 'sd_ppi_group_get' called with unexpected value for argument 'group_num'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_channel_msk)
+  {
+    if (cmock_call_instance->Expected_p_channel_msk == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_channel_msk, cmock_line, "Expected NULL. Function 'sd_ppi_group_get' called with unexpected value for argument 'p_channel_msk'."); }
+    else if (cmock_call_instance->Expected_p_channel_msk_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_channel_msk, p_channel_msk, cmock_line, "Function 'sd_ppi_group_get' called with unexpected value for argument 'p_channel_msk'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_p_channel_msk, p_channel_msk, cmock_call_instance->Expected_p_channel_msk_Depth, cmock_line, "Function 'sd_ppi_group_get' called with unexpected value for argument 'p_channel_msk'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_channel_msk_Used)
+  {
+    memcpy((void*)p_channel_msk, (void*)cmock_call_instance->ReturnThruPtr_p_channel_msk_Val,
+      cmock_call_instance->ReturnThruPtr_p_channel_msk_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ppi_group_get(CMOCK_sd_ppi_group_get_CALL_INSTANCE* cmock_call_instance, uint8_t group_num, uint32_t* p_channel_msk, int p_channel_msk_Depth)
+{
+  cmock_call_instance->Expected_group_num = group_num;
+  cmock_call_instance->IgnoreArg_group_num = 0;
+  cmock_call_instance->Expected_p_channel_msk = p_channel_msk;
+  cmock_call_instance->Expected_p_channel_msk_Depth = p_channel_msk_Depth;
+  cmock_call_instance->IgnoreArg_p_channel_msk = 0;
+  cmock_call_instance->ReturnThruPtr_p_channel_msk_Used = 0;
+}
+
+void sd_ppi_group_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_group_get_CALL_INSTANCE));
+  CMOCK_sd_ppi_group_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_group_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_group_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_group_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ppi_group_get_IgnoreBool = (int)1;
+}
+
+void sd_ppi_group_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t group_num, uint32_t* p_channel_msk, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_group_get_CALL_INSTANCE));
+  CMOCK_sd_ppi_group_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_group_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_group_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_group_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ppi_group_get(cmock_call_instance, group_num, p_channel_msk, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ppi_group_get_StubWithCallback(CMOCK_sd_ppi_group_get_CALLBACK Callback)
+{
+  Mock.sd_ppi_group_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ppi_group_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t group_num, uint32_t* p_channel_msk, int p_channel_msk_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ppi_group_get_CALL_INSTANCE));
+  CMOCK_sd_ppi_group_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ppi_group_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ppi_group_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ppi_group_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ppi_group_get(cmock_call_instance, group_num, p_channel_msk, p_channel_msk_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ppi_group_get_CMockReturnMemThruPtr_p_channel_msk(UNITY_LINE_TYPE cmock_line, uint32_t* p_channel_msk, int cmock_size)
+{
+  CMOCK_sd_ppi_group_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ppi_group_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ppi_group_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_channel_msk ReturnThruPtr called before Expect on 'sd_ppi_group_get'.");
+  cmock_call_instance->ReturnThruPtr_p_channel_msk_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_channel_msk_Val = p_channel_msk;
+  cmock_call_instance->ReturnThruPtr_p_channel_msk_Size = cmock_size;
+}
+
+void sd_ppi_group_get_CMockIgnoreArg_group_num(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ppi_group_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ppi_group_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ppi_group_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "group_num IgnoreArg called before Expect on 'sd_ppi_group_get'.");
+  cmock_call_instance->IgnoreArg_group_num = 1;
+}
+
+void sd_ppi_group_get_CMockIgnoreArg_p_channel_msk(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ppi_group_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ppi_group_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ppi_group_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_channel_msk IgnoreArg called before Expect on 'sd_ppi_group_get'.");
+  cmock_call_instance->IgnoreArg_p_channel_msk = 1;
+}
+
+uint32_t sd_radio_notification_cfg_set(uint8_t type, uint8_t distance)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_radio_notification_cfg_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_radio_notification_cfg_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_radio_notification_cfg_set_CallInstance);
+  Mock.sd_radio_notification_cfg_set_CallInstance = CMock_Guts_MemNext(Mock.sd_radio_notification_cfg_set_CallInstance);
+  if (Mock.sd_radio_notification_cfg_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_radio_notification_cfg_set_FinalReturn;
+    Mock.sd_radio_notification_cfg_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_radio_notification_cfg_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_radio_notification_cfg_set_CallbackFunctionPointer(type, distance, Mock.sd_radio_notification_cfg_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_radio_notification_cfg_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_radio_notification_cfg_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_radio_notification_cfg_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_type)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_type, type, cmock_line, "Function 'sd_radio_notification_cfg_set' called with unexpected value for argument 'type'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_distance)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_distance, distance, cmock_line, "Function 'sd_radio_notification_cfg_set' called with unexpected value for argument 'distance'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_radio_notification_cfg_set(CMOCK_sd_radio_notification_cfg_set_CALL_INSTANCE* cmock_call_instance, uint8_t type, uint8_t distance)
+{
+  cmock_call_instance->Expected_type = type;
+  cmock_call_instance->IgnoreArg_type = 0;
+  cmock_call_instance->Expected_distance = distance;
+  cmock_call_instance->IgnoreArg_distance = 0;
+}
+
+void sd_radio_notification_cfg_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_radio_notification_cfg_set_CALL_INSTANCE));
+  CMOCK_sd_radio_notification_cfg_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_radio_notification_cfg_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_radio_notification_cfg_set_CallInstance = CMock_Guts_MemChain(Mock.sd_radio_notification_cfg_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_radio_notification_cfg_set_IgnoreBool = (int)1;
+}
+
+void sd_radio_notification_cfg_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t type, uint8_t distance, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_radio_notification_cfg_set_CALL_INSTANCE));
+  CMOCK_sd_radio_notification_cfg_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_radio_notification_cfg_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_radio_notification_cfg_set_CallInstance = CMock_Guts_MemChain(Mock.sd_radio_notification_cfg_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_radio_notification_cfg_set(cmock_call_instance, type, distance);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_radio_notification_cfg_set_StubWithCallback(CMOCK_sd_radio_notification_cfg_set_CALLBACK Callback)
+{
+  Mock.sd_radio_notification_cfg_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_radio_notification_cfg_set_CMockIgnoreArg_type(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_radio_notification_cfg_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_radio_notification_cfg_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_radio_notification_cfg_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "type IgnoreArg called before Expect on 'sd_radio_notification_cfg_set'.");
+  cmock_call_instance->IgnoreArg_type = 1;
+}
+
+void sd_radio_notification_cfg_set_CMockIgnoreArg_distance(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_radio_notification_cfg_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_radio_notification_cfg_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_radio_notification_cfg_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "distance IgnoreArg called before Expect on 'sd_radio_notification_cfg_set'.");
+  cmock_call_instance->IgnoreArg_distance = 1;
+}
+
+uint32_t sd_ecb_block_encrypt(nrf_ecb_hal_data_t* p_ecb_data)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ecb_block_encrypt_CallInstance);
+  Mock.sd_ecb_block_encrypt_CallInstance = CMock_Guts_MemNext(Mock.sd_ecb_block_encrypt_CallInstance);
+  if (Mock.sd_ecb_block_encrypt_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ecb_block_encrypt_FinalReturn;
+    Mock.sd_ecb_block_encrypt_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ecb_block_encrypt_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ecb_block_encrypt_CallbackFunctionPointer(p_ecb_data, Mock.sd_ecb_block_encrypt_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ecb_block_encrypt' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ecb_block_encrypt' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ecb_block_encrypt' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_ecb_data)
+  {
+    if (cmock_call_instance->Expected_p_ecb_data == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_ecb_data, cmock_line, "Expected NULL. Function 'sd_ecb_block_encrypt' called with unexpected value for argument 'p_ecb_data'."); }
+    else if (cmock_call_instance->Expected_p_ecb_data_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_ecb_data, p_ecb_data, cmock_line, "Function 'sd_ecb_block_encrypt' called with unexpected value for argument 'p_ecb_data'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_ecb_data), (void*)(p_ecb_data), sizeof(nrf_ecb_hal_data_t), cmock_call_instance->Expected_p_ecb_data_Depth, cmock_line, "Function 'sd_ecb_block_encrypt' called with unexpected value for argument 'p_ecb_data'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_ecb_data_Used)
+  {
+    memcpy((void*)p_ecb_data, (void*)cmock_call_instance->ReturnThruPtr_p_ecb_data_Val,
+      cmock_call_instance->ReturnThruPtr_p_ecb_data_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ecb_block_encrypt(CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE* cmock_call_instance, nrf_ecb_hal_data_t* p_ecb_data, int p_ecb_data_Depth)
+{
+  cmock_call_instance->Expected_p_ecb_data = p_ecb_data;
+  cmock_call_instance->Expected_p_ecb_data_Depth = p_ecb_data_Depth;
+  cmock_call_instance->IgnoreArg_p_ecb_data = 0;
+  cmock_call_instance->ReturnThruPtr_p_ecb_data_Used = 0;
+}
+
+void sd_ecb_block_encrypt_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE));
+  CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ecb_block_encrypt_CallInstance = CMock_Guts_MemChain(Mock.sd_ecb_block_encrypt_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ecb_block_encrypt_IgnoreBool = (int)1;
+}
+
+void sd_ecb_block_encrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nrf_ecb_hal_data_t* p_ecb_data, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE));
+  CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ecb_block_encrypt_CallInstance = CMock_Guts_MemChain(Mock.sd_ecb_block_encrypt_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ecb_block_encrypt(cmock_call_instance, p_ecb_data, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ecb_block_encrypt_StubWithCallback(CMOCK_sd_ecb_block_encrypt_CALLBACK Callback)
+{
+  Mock.sd_ecb_block_encrypt_CallbackFunctionPointer = Callback;
+}
+
+void sd_ecb_block_encrypt_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, nrf_ecb_hal_data_t* p_ecb_data, int p_ecb_data_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE));
+  CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ecb_block_encrypt_CallInstance = CMock_Guts_MemChain(Mock.sd_ecb_block_encrypt_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ecb_block_encrypt(cmock_call_instance, p_ecb_data, p_ecb_data_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ecb_block_encrypt_CMockReturnMemThruPtr_p_ecb_data(UNITY_LINE_TYPE cmock_line, nrf_ecb_hal_data_t* p_ecb_data, int cmock_size)
+{
+  CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ecb_block_encrypt_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_ecb_data ReturnThruPtr called before Expect on 'sd_ecb_block_encrypt'.");
+  cmock_call_instance->ReturnThruPtr_p_ecb_data_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_ecb_data_Val = p_ecb_data;
+  cmock_call_instance->ReturnThruPtr_p_ecb_data_Size = cmock_size;
+}
+
+void sd_ecb_block_encrypt_CMockIgnoreArg_p_ecb_data(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ecb_block_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ecb_block_encrypt_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_ecb_data IgnoreArg called before Expect on 'sd_ecb_block_encrypt'.");
+  cmock_call_instance->IgnoreArg_p_ecb_data = 1;
+}
+
+uint32_t sd_ecb_blocks_encrypt(uint8_t block_count, nrf_ecb_hal_data_block_t* p_data_blocks)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ecb_blocks_encrypt_CallInstance);
+  Mock.sd_ecb_blocks_encrypt_CallInstance = CMock_Guts_MemNext(Mock.sd_ecb_blocks_encrypt_CallInstance);
+  if (Mock.sd_ecb_blocks_encrypt_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ecb_blocks_encrypt_FinalReturn;
+    Mock.sd_ecb_blocks_encrypt_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ecb_blocks_encrypt_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ecb_blocks_encrypt_CallbackFunctionPointer(block_count, p_data_blocks, Mock.sd_ecb_blocks_encrypt_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ecb_blocks_encrypt' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ecb_blocks_encrypt' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ecb_blocks_encrypt' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_block_count)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_block_count, block_count, cmock_line, "Function 'sd_ecb_blocks_encrypt' called with unexpected value for argument 'block_count'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_data_blocks)
+  {
+    if (cmock_call_instance->Expected_p_data_blocks == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_data_blocks, cmock_line, "Expected NULL. Function 'sd_ecb_blocks_encrypt' called with unexpected value for argument 'p_data_blocks'."); }
+    else if (cmock_call_instance->Expected_p_data_blocks_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_data_blocks, p_data_blocks, cmock_line, "Function 'sd_ecb_blocks_encrypt' called with unexpected value for argument 'p_data_blocks'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_data_blocks), (void*)(p_data_blocks), sizeof(nrf_ecb_hal_data_block_t), cmock_call_instance->Expected_p_data_blocks_Depth, cmock_line, "Function 'sd_ecb_blocks_encrypt' called with unexpected value for argument 'p_data_blocks'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_data_blocks_Used)
+  {
+    memcpy((void*)p_data_blocks, (void*)cmock_call_instance->ReturnThruPtr_p_data_blocks_Val,
+      cmock_call_instance->ReturnThruPtr_p_data_blocks_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ecb_blocks_encrypt(CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE* cmock_call_instance, uint8_t block_count, nrf_ecb_hal_data_block_t* p_data_blocks, int p_data_blocks_Depth)
+{
+  cmock_call_instance->Expected_block_count = block_count;
+  cmock_call_instance->IgnoreArg_block_count = 0;
+  cmock_call_instance->Expected_p_data_blocks = p_data_blocks;
+  cmock_call_instance->Expected_p_data_blocks_Depth = p_data_blocks_Depth;
+  cmock_call_instance->IgnoreArg_p_data_blocks = 0;
+  cmock_call_instance->ReturnThruPtr_p_data_blocks_Used = 0;
+}
+
+void sd_ecb_blocks_encrypt_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE));
+  CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ecb_blocks_encrypt_CallInstance = CMock_Guts_MemChain(Mock.sd_ecb_blocks_encrypt_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ecb_blocks_encrypt_IgnoreBool = (int)1;
+}
+
+void sd_ecb_blocks_encrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t block_count, nrf_ecb_hal_data_block_t* p_data_blocks, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE));
+  CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ecb_blocks_encrypt_CallInstance = CMock_Guts_MemChain(Mock.sd_ecb_blocks_encrypt_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ecb_blocks_encrypt(cmock_call_instance, block_count, p_data_blocks, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ecb_blocks_encrypt_StubWithCallback(CMOCK_sd_ecb_blocks_encrypt_CALLBACK Callback)
+{
+  Mock.sd_ecb_blocks_encrypt_CallbackFunctionPointer = Callback;
+}
+
+void sd_ecb_blocks_encrypt_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t block_count, nrf_ecb_hal_data_block_t* p_data_blocks, int p_data_blocks_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE));
+  CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ecb_blocks_encrypt_CallInstance = CMock_Guts_MemChain(Mock.sd_ecb_blocks_encrypt_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ecb_blocks_encrypt(cmock_call_instance, block_count, p_data_blocks, p_data_blocks_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ecb_blocks_encrypt_CMockReturnMemThruPtr_p_data_blocks(UNITY_LINE_TYPE cmock_line, nrf_ecb_hal_data_block_t* p_data_blocks, int cmock_size)
+{
+  CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ecb_blocks_encrypt_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_data_blocks ReturnThruPtr called before Expect on 'sd_ecb_blocks_encrypt'.");
+  cmock_call_instance->ReturnThruPtr_p_data_blocks_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_data_blocks_Val = p_data_blocks;
+  cmock_call_instance->ReturnThruPtr_p_data_blocks_Size = cmock_size;
+}
+
+void sd_ecb_blocks_encrypt_CMockIgnoreArg_block_count(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ecb_blocks_encrypt_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "block_count IgnoreArg called before Expect on 'sd_ecb_blocks_encrypt'.");
+  cmock_call_instance->IgnoreArg_block_count = 1;
+}
+
+void sd_ecb_blocks_encrypt_CMockIgnoreArg_p_data_blocks(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ecb_blocks_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ecb_blocks_encrypt_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_data_blocks IgnoreArg called before Expect on 'sd_ecb_blocks_encrypt'.");
+  cmock_call_instance->IgnoreArg_p_data_blocks = 1;
+}
+
+uint32_t sd_evt_get(uint32_t* p_evt_id)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_evt_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_evt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_evt_get_CallInstance);
+  Mock.sd_evt_get_CallInstance = CMock_Guts_MemNext(Mock.sd_evt_get_CallInstance);
+  if (Mock.sd_evt_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_evt_get_FinalReturn;
+    Mock.sd_evt_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_evt_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_evt_get_CallbackFunctionPointer(p_evt_id, Mock.sd_evt_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_evt_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_evt_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_evt_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_evt_id)
+  {
+    if (cmock_call_instance->Expected_p_evt_id == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_evt_id, cmock_line, "Expected NULL. Function 'sd_evt_get' called with unexpected value for argument 'p_evt_id'."); }
+    else if (cmock_call_instance->Expected_p_evt_id_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_evt_id, p_evt_id, cmock_line, "Function 'sd_evt_get' called with unexpected value for argument 'p_evt_id'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_p_evt_id, p_evt_id, cmock_call_instance->Expected_p_evt_id_Depth, cmock_line, "Function 'sd_evt_get' called with unexpected value for argument 'p_evt_id'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_evt_id_Used)
+  {
+    memcpy((void*)p_evt_id, (void*)cmock_call_instance->ReturnThruPtr_p_evt_id_Val,
+      cmock_call_instance->ReturnThruPtr_p_evt_id_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_evt_get(CMOCK_sd_evt_get_CALL_INSTANCE* cmock_call_instance, uint32_t* p_evt_id, int p_evt_id_Depth)
+{
+  cmock_call_instance->Expected_p_evt_id = p_evt_id;
+  cmock_call_instance->Expected_p_evt_id_Depth = p_evt_id_Depth;
+  cmock_call_instance->IgnoreArg_p_evt_id = 0;
+  cmock_call_instance->ReturnThruPtr_p_evt_id_Used = 0;
+}
+
+void sd_evt_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_evt_get_CALL_INSTANCE));
+  CMOCK_sd_evt_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_evt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_evt_get_CallInstance = CMock_Guts_MemChain(Mock.sd_evt_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_evt_get_IgnoreBool = (int)1;
+}
+
+void sd_evt_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_evt_id, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_evt_get_CALL_INSTANCE));
+  CMOCK_sd_evt_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_evt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_evt_get_CallInstance = CMock_Guts_MemChain(Mock.sd_evt_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_evt_get(cmock_call_instance, p_evt_id, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_evt_get_StubWithCallback(CMOCK_sd_evt_get_CALLBACK Callback)
+{
+  Mock.sd_evt_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_evt_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_evt_id, int p_evt_id_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_evt_get_CALL_INSTANCE));
+  CMOCK_sd_evt_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_evt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_evt_get_CallInstance = CMock_Guts_MemChain(Mock.sd_evt_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_evt_get(cmock_call_instance, p_evt_id, p_evt_id_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_evt_get_CMockReturnMemThruPtr_p_evt_id(UNITY_LINE_TYPE cmock_line, uint32_t* p_evt_id, int cmock_size)
+{
+  CMOCK_sd_evt_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_evt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_evt_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_evt_id ReturnThruPtr called before Expect on 'sd_evt_get'.");
+  cmock_call_instance->ReturnThruPtr_p_evt_id_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_evt_id_Val = p_evt_id;
+  cmock_call_instance->ReturnThruPtr_p_evt_id_Size = cmock_size;
+}
+
+void sd_evt_get_CMockIgnoreArg_p_evt_id(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_evt_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_evt_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_evt_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_evt_id IgnoreArg called before Expect on 'sd_evt_get'.");
+  cmock_call_instance->IgnoreArg_p_evt_id = 1;
+}
+
+uint32_t sd_temp_get(int32_t* p_temp)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_temp_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_temp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_temp_get_CallInstance);
+  Mock.sd_temp_get_CallInstance = CMock_Guts_MemNext(Mock.sd_temp_get_CallInstance);
+  if (Mock.sd_temp_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_temp_get_FinalReturn;
+    Mock.sd_temp_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_temp_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_temp_get_CallbackFunctionPointer(p_temp, Mock.sd_temp_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_temp_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_temp_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_temp_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_temp)
+  {
+    if (cmock_call_instance->Expected_p_temp == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_temp, cmock_line, "Expected NULL. Function 'sd_temp_get' called with unexpected value for argument 'p_temp'."); }
+    else if (cmock_call_instance->Expected_p_temp_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_temp, p_temp, cmock_line, "Function 'sd_temp_get' called with unexpected value for argument 'p_temp'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_p_temp, p_temp, cmock_call_instance->Expected_p_temp_Depth, cmock_line, "Function 'sd_temp_get' called with unexpected value for argument 'p_temp'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_temp_Used)
+  {
+    memcpy((void*)p_temp, (void*)cmock_call_instance->ReturnThruPtr_p_temp_Val,
+      cmock_call_instance->ReturnThruPtr_p_temp_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_temp_get(CMOCK_sd_temp_get_CALL_INSTANCE* cmock_call_instance, int32_t* p_temp, int p_temp_Depth)
+{
+  cmock_call_instance->Expected_p_temp = p_temp;
+  cmock_call_instance->Expected_p_temp_Depth = p_temp_Depth;
+  cmock_call_instance->IgnoreArg_p_temp = 0;
+  cmock_call_instance->ReturnThruPtr_p_temp_Used = 0;
+}
+
+void sd_temp_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_temp_get_CALL_INSTANCE));
+  CMOCK_sd_temp_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_temp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_temp_get_CallInstance = CMock_Guts_MemChain(Mock.sd_temp_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_temp_get_IgnoreBool = (int)1;
+}
+
+void sd_temp_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int32_t* p_temp, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_temp_get_CALL_INSTANCE));
+  CMOCK_sd_temp_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_temp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_temp_get_CallInstance = CMock_Guts_MemChain(Mock.sd_temp_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_temp_get(cmock_call_instance, p_temp, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_temp_get_StubWithCallback(CMOCK_sd_temp_get_CALLBACK Callback)
+{
+  Mock.sd_temp_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_temp_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, int32_t* p_temp, int p_temp_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_temp_get_CALL_INSTANCE));
+  CMOCK_sd_temp_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_temp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_temp_get_CallInstance = CMock_Guts_MemChain(Mock.sd_temp_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_temp_get(cmock_call_instance, p_temp, p_temp_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_temp_get_CMockReturnMemThruPtr_p_temp(UNITY_LINE_TYPE cmock_line, int32_t* p_temp, int cmock_size)
+{
+  CMOCK_sd_temp_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_temp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_temp_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_temp ReturnThruPtr called before Expect on 'sd_temp_get'.");
+  cmock_call_instance->ReturnThruPtr_p_temp_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_temp_Val = p_temp;
+  cmock_call_instance->ReturnThruPtr_p_temp_Size = cmock_size;
+}
+
+void sd_temp_get_CMockIgnoreArg_p_temp(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_temp_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_temp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_temp_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_temp IgnoreArg called before Expect on 'sd_temp_get'.");
+  cmock_call_instance->IgnoreArg_p_temp = 1;
+}
+
+uint32_t sd_flash_write(uint32_t* const p_dst, uint32_t const* const p_src, uint32_t size)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_flash_write_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_flash_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_flash_write_CallInstance);
+  Mock.sd_flash_write_CallInstance = CMock_Guts_MemNext(Mock.sd_flash_write_CallInstance);
+  if (Mock.sd_flash_write_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_flash_write_FinalReturn;
+    Mock.sd_flash_write_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_flash_write_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_flash_write_CallbackFunctionPointer(p_dst, p_src, size, Mock.sd_flash_write_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_flash_write' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_flash_write' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_flash_write' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_dst)
+  {
+    if (cmock_call_instance->Expected_p_dst == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_dst, cmock_line, "Expected NULL. Function 'sd_flash_write' called with unexpected value for argument 'p_dst'."); }
+    else if (cmock_call_instance->Expected_p_dst_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_dst, p_dst, cmock_line, "Function 'sd_flash_write' called with unexpected value for argument 'p_dst'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_p_dst, p_dst, cmock_call_instance->Expected_p_dst_Depth, cmock_line, "Function 'sd_flash_write' called with unexpected value for argument 'p_dst'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_src)
+  {
+    if (cmock_call_instance->Expected_p_src == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_src, cmock_line, "Expected NULL. Function 'sd_flash_write' called with unexpected value for argument 'p_src'."); }
+    else if (cmock_call_instance->Expected_p_src_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_src, p_src, cmock_line, "Function 'sd_flash_write' called with unexpected value for argument 'p_src'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_p_src, p_src, cmock_call_instance->Expected_p_src_Depth, cmock_line, "Function 'sd_flash_write' called with unexpected value for argument 'p_src'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_size)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_size, size, cmock_line, "Function 'sd_flash_write' called with unexpected value for argument 'size'.");
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_dst_Used)
+  {
+    memcpy((void*)p_dst, (void*)cmock_call_instance->ReturnThruPtr_p_dst_Val,
+      cmock_call_instance->ReturnThruPtr_p_dst_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_src_Used)
+  {
+    memcpy((void*)p_src, (void*)cmock_call_instance->ReturnThruPtr_p_src_Val,
+      cmock_call_instance->ReturnThruPtr_p_src_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_flash_write(CMOCK_sd_flash_write_CALL_INSTANCE* cmock_call_instance, uint32_t* p_dst, int p_dst_Depth, uint32_t const* p_src, int p_src_Depth, uint32_t size)
+{
+  cmock_call_instance->Expected_p_dst = p_dst;
+  cmock_call_instance->Expected_p_dst_Depth = p_dst_Depth;
+  cmock_call_instance->IgnoreArg_p_dst = 0;
+  cmock_call_instance->ReturnThruPtr_p_dst_Used = 0;
+  cmock_call_instance->Expected_p_src = p_src;
+  cmock_call_instance->Expected_p_src_Depth = p_src_Depth;
+  cmock_call_instance->IgnoreArg_p_src = 0;
+  cmock_call_instance->ReturnThruPtr_p_src_Used = 0;
+  cmock_call_instance->Expected_size = size;
+  cmock_call_instance->IgnoreArg_size = 0;
+}
+
+void sd_flash_write_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_flash_write_CALL_INSTANCE));
+  CMOCK_sd_flash_write_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_flash_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_flash_write_CallInstance = CMock_Guts_MemChain(Mock.sd_flash_write_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_flash_write_IgnoreBool = (int)1;
+}
+
+void sd_flash_write_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* const p_dst, uint32_t const* const p_src, uint32_t size, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_flash_write_CALL_INSTANCE));
+  CMOCK_sd_flash_write_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_flash_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_flash_write_CallInstance = CMock_Guts_MemChain(Mock.sd_flash_write_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_flash_write(cmock_call_instance, p_dst, 0, p_src, 0, size);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_flash_write_StubWithCallback(CMOCK_sd_flash_write_CALLBACK Callback)
+{
+  Mock.sd_flash_write_CallbackFunctionPointer = Callback;
+}
+
+void sd_flash_write_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_dst, int p_dst_Depth, uint32_t const* p_src, int p_src_Depth, uint32_t size, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_flash_write_CALL_INSTANCE));
+  CMOCK_sd_flash_write_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_flash_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_flash_write_CallInstance = CMock_Guts_MemChain(Mock.sd_flash_write_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_flash_write(cmock_call_instance, p_dst, p_dst_Depth, p_src, p_src_Depth, size);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_flash_write_CMockReturnMemThruPtr_p_dst(UNITY_LINE_TYPE cmock_line, uint32_t* p_dst, int cmock_size)
+{
+  CMOCK_sd_flash_write_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_flash_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_flash_write_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_dst ReturnThruPtr called before Expect on 'sd_flash_write'.");
+  cmock_call_instance->ReturnThruPtr_p_dst_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_dst_Val = p_dst;
+  cmock_call_instance->ReturnThruPtr_p_dst_Size = cmock_size;
+}
+
+void sd_flash_write_CMockReturnMemThruPtr_p_src(UNITY_LINE_TYPE cmock_line, uint32_t const* p_src, int cmock_size)
+{
+  CMOCK_sd_flash_write_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_flash_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_flash_write_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_src ReturnThruPtr called before Expect on 'sd_flash_write'.");
+  cmock_call_instance->ReturnThruPtr_p_src_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_src_Val = p_src;
+  cmock_call_instance->ReturnThruPtr_p_src_Size = cmock_size;
+}
+
+void sd_flash_write_CMockIgnoreArg_p_dst(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_flash_write_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_flash_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_flash_write_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_dst IgnoreArg called before Expect on 'sd_flash_write'.");
+  cmock_call_instance->IgnoreArg_p_dst = 1;
+}
+
+void sd_flash_write_CMockIgnoreArg_p_src(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_flash_write_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_flash_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_flash_write_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_src IgnoreArg called before Expect on 'sd_flash_write'.");
+  cmock_call_instance->IgnoreArg_p_src = 1;
+}
+
+void sd_flash_write_CMockIgnoreArg_size(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_flash_write_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_flash_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_flash_write_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "size IgnoreArg called before Expect on 'sd_flash_write'.");
+  cmock_call_instance->IgnoreArg_size = 1;
+}
+
+uint32_t sd_flash_page_erase(uint32_t page_number)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_flash_page_erase_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_flash_page_erase_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_flash_page_erase_CallInstance);
+  Mock.sd_flash_page_erase_CallInstance = CMock_Guts_MemNext(Mock.sd_flash_page_erase_CallInstance);
+  if (Mock.sd_flash_page_erase_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_flash_page_erase_FinalReturn;
+    Mock.sd_flash_page_erase_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_flash_page_erase_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_flash_page_erase_CallbackFunctionPointer(page_number, Mock.sd_flash_page_erase_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_flash_page_erase' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_flash_page_erase' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_flash_page_erase' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_page_number)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_page_number, page_number, cmock_line, "Function 'sd_flash_page_erase' called with unexpected value for argument 'page_number'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_flash_page_erase(CMOCK_sd_flash_page_erase_CALL_INSTANCE* cmock_call_instance, uint32_t page_number)
+{
+  cmock_call_instance->Expected_page_number = page_number;
+  cmock_call_instance->IgnoreArg_page_number = 0;
+}
+
+void sd_flash_page_erase_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_flash_page_erase_CALL_INSTANCE));
+  CMOCK_sd_flash_page_erase_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_flash_page_erase_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_flash_page_erase_CallInstance = CMock_Guts_MemChain(Mock.sd_flash_page_erase_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_flash_page_erase_IgnoreBool = (int)1;
+}
+
+void sd_flash_page_erase_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t page_number, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_flash_page_erase_CALL_INSTANCE));
+  CMOCK_sd_flash_page_erase_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_flash_page_erase_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_flash_page_erase_CallInstance = CMock_Guts_MemChain(Mock.sd_flash_page_erase_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_flash_page_erase(cmock_call_instance, page_number);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_flash_page_erase_StubWithCallback(CMOCK_sd_flash_page_erase_CALLBACK Callback)
+{
+  Mock.sd_flash_page_erase_CallbackFunctionPointer = Callback;
+}
+
+void sd_flash_page_erase_CMockIgnoreArg_page_number(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_flash_page_erase_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_flash_page_erase_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_flash_page_erase_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "page_number IgnoreArg called before Expect on 'sd_flash_page_erase'.");
+  cmock_call_instance->IgnoreArg_page_number = 1;
+}
+
+uint32_t sd_flash_protect(uint32_t block_cfg0, uint32_t block_cfg1, uint32_t block_cfg2, uint32_t block_cfg3)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_flash_protect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_flash_protect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_flash_protect_CallInstance);
+  Mock.sd_flash_protect_CallInstance = CMock_Guts_MemNext(Mock.sd_flash_protect_CallInstance);
+  if (Mock.sd_flash_protect_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_flash_protect_FinalReturn;
+    Mock.sd_flash_protect_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_flash_protect_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_flash_protect_CallbackFunctionPointer(block_cfg0, block_cfg1, block_cfg2, block_cfg3, Mock.sd_flash_protect_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_flash_protect' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_flash_protect' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_flash_protect' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_block_cfg0)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_block_cfg0, block_cfg0, cmock_line, "Function 'sd_flash_protect' called with unexpected value for argument 'block_cfg0'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_block_cfg1)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_block_cfg1, block_cfg1, cmock_line, "Function 'sd_flash_protect' called with unexpected value for argument 'block_cfg1'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_block_cfg2)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_block_cfg2, block_cfg2, cmock_line, "Function 'sd_flash_protect' called with unexpected value for argument 'block_cfg2'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_block_cfg3)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_block_cfg3, block_cfg3, cmock_line, "Function 'sd_flash_protect' called with unexpected value for argument 'block_cfg3'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_flash_protect(CMOCK_sd_flash_protect_CALL_INSTANCE* cmock_call_instance, uint32_t block_cfg0, uint32_t block_cfg1, uint32_t block_cfg2, uint32_t block_cfg3)
+{
+  cmock_call_instance->Expected_block_cfg0 = block_cfg0;
+  cmock_call_instance->IgnoreArg_block_cfg0 = 0;
+  cmock_call_instance->Expected_block_cfg1 = block_cfg1;
+  cmock_call_instance->IgnoreArg_block_cfg1 = 0;
+  cmock_call_instance->Expected_block_cfg2 = block_cfg2;
+  cmock_call_instance->IgnoreArg_block_cfg2 = 0;
+  cmock_call_instance->Expected_block_cfg3 = block_cfg3;
+  cmock_call_instance->IgnoreArg_block_cfg3 = 0;
+}
+
+void sd_flash_protect_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_flash_protect_CALL_INSTANCE));
+  CMOCK_sd_flash_protect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_flash_protect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_flash_protect_CallInstance = CMock_Guts_MemChain(Mock.sd_flash_protect_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_flash_protect_IgnoreBool = (int)1;
+}
+
+void sd_flash_protect_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t block_cfg0, uint32_t block_cfg1, uint32_t block_cfg2, uint32_t block_cfg3, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_flash_protect_CALL_INSTANCE));
+  CMOCK_sd_flash_protect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_flash_protect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_flash_protect_CallInstance = CMock_Guts_MemChain(Mock.sd_flash_protect_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_flash_protect(cmock_call_instance, block_cfg0, block_cfg1, block_cfg2, block_cfg3);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_flash_protect_StubWithCallback(CMOCK_sd_flash_protect_CALLBACK Callback)
+{
+  Mock.sd_flash_protect_CallbackFunctionPointer = Callback;
+}
+
+void sd_flash_protect_CMockIgnoreArg_block_cfg0(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_flash_protect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_flash_protect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_flash_protect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "block_cfg0 IgnoreArg called before Expect on 'sd_flash_protect'.");
+  cmock_call_instance->IgnoreArg_block_cfg0 = 1;
+}
+
+void sd_flash_protect_CMockIgnoreArg_block_cfg1(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_flash_protect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_flash_protect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_flash_protect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "block_cfg1 IgnoreArg called before Expect on 'sd_flash_protect'.");
+  cmock_call_instance->IgnoreArg_block_cfg1 = 1;
+}
+
+void sd_flash_protect_CMockIgnoreArg_block_cfg2(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_flash_protect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_flash_protect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_flash_protect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "block_cfg2 IgnoreArg called before Expect on 'sd_flash_protect'.");
+  cmock_call_instance->IgnoreArg_block_cfg2 = 1;
+}
+
+void sd_flash_protect_CMockIgnoreArg_block_cfg3(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_flash_protect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_flash_protect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_flash_protect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "block_cfg3 IgnoreArg called before Expect on 'sd_flash_protect'.");
+  cmock_call_instance->IgnoreArg_block_cfg3 = 1;
+}
+
+uint32_t sd_radio_session_open(nrf_radio_signal_callback_t p_radio_signal_callback)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_radio_session_open_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_radio_session_open_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_radio_session_open_CallInstance);
+  Mock.sd_radio_session_open_CallInstance = CMock_Guts_MemNext(Mock.sd_radio_session_open_CallInstance);
+  if (Mock.sd_radio_session_open_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_radio_session_open_FinalReturn;
+    Mock.sd_radio_session_open_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_radio_session_open_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_radio_session_open_CallbackFunctionPointer(p_radio_signal_callback, Mock.sd_radio_session_open_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_radio_session_open' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_radio_session_open' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_radio_session_open' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_radio_signal_callback)
+  {
+    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_p_radio_signal_callback), (void*)(&p_radio_signal_callback), sizeof(nrf_radio_signal_callback_t), cmock_line, "Function 'sd_radio_session_open' called with unexpected value for argument 'p_radio_signal_callback'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_radio_session_open(CMOCK_sd_radio_session_open_CALL_INSTANCE* cmock_call_instance, nrf_radio_signal_callback_t p_radio_signal_callback)
+{
+  memcpy(&cmock_call_instance->Expected_p_radio_signal_callback, &p_radio_signal_callback, sizeof(nrf_radio_signal_callback_t));
+  cmock_call_instance->IgnoreArg_p_radio_signal_callback = 0;
+}
+
+void sd_radio_session_open_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_radio_session_open_CALL_INSTANCE));
+  CMOCK_sd_radio_session_open_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_radio_session_open_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_radio_session_open_CallInstance = CMock_Guts_MemChain(Mock.sd_radio_session_open_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_radio_session_open_IgnoreBool = (int)1;
+}
+
+void sd_radio_session_open_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nrf_radio_signal_callback_t p_radio_signal_callback, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_radio_session_open_CALL_INSTANCE));
+  CMOCK_sd_radio_session_open_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_radio_session_open_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_radio_session_open_CallInstance = CMock_Guts_MemChain(Mock.sd_radio_session_open_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_radio_session_open(cmock_call_instance, p_radio_signal_callback);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_radio_session_open_StubWithCallback(CMOCK_sd_radio_session_open_CALLBACK Callback)
+{
+  Mock.sd_radio_session_open_CallbackFunctionPointer = Callback;
+}
+
+void sd_radio_session_open_CMockIgnoreArg_p_radio_signal_callback(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_radio_session_open_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_radio_session_open_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_radio_session_open_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_radio_signal_callback IgnoreArg called before Expect on 'sd_radio_session_open'.");
+  cmock_call_instance->IgnoreArg_p_radio_signal_callback = 1;
+}
+
+uint32_t sd_radio_session_close(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_radio_session_close_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_radio_session_close_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_radio_session_close_CallInstance);
+  Mock.sd_radio_session_close_CallInstance = CMock_Guts_MemNext(Mock.sd_radio_session_close_CallInstance);
+  if (Mock.sd_radio_session_close_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_radio_session_close_FinalReturn;
+    Mock.sd_radio_session_close_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_radio_session_close_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_radio_session_close_CallbackFunctionPointer(Mock.sd_radio_session_close_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_radio_session_close' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_radio_session_close' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_radio_session_close' called later than expected.");
+  return cmock_call_instance->ReturnVal;
+}
+
+void sd_radio_session_close_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_radio_session_close_CALL_INSTANCE));
+  CMOCK_sd_radio_session_close_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_radio_session_close_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_radio_session_close_CallInstance = CMock_Guts_MemChain(Mock.sd_radio_session_close_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_radio_session_close_IgnoreBool = (int)1;
+}
+
+void sd_radio_session_close_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_radio_session_close_CALL_INSTANCE));
+  CMOCK_sd_radio_session_close_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_radio_session_close_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_radio_session_close_CallInstance = CMock_Guts_MemChain(Mock.sd_radio_session_close_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_radio_session_close_StubWithCallback(CMOCK_sd_radio_session_close_CALLBACK Callback)
+{
+  Mock.sd_radio_session_close_CallbackFunctionPointer = Callback;
+}
+
+uint32_t sd_radio_request(nrf_radio_request_t* p_request)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_radio_request_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_radio_request_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_radio_request_CallInstance);
+  Mock.sd_radio_request_CallInstance = CMock_Guts_MemNext(Mock.sd_radio_request_CallInstance);
+  if (Mock.sd_radio_request_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_radio_request_FinalReturn;
+    Mock.sd_radio_request_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_radio_request_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_radio_request_CallbackFunctionPointer(p_request, Mock.sd_radio_request_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_radio_request' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_radio_request' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_radio_request' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_request)
+  {
+    if (cmock_call_instance->Expected_p_request == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_request, cmock_line, "Expected NULL. Function 'sd_radio_request' called with unexpected value for argument 'p_request'."); }
+    else if (cmock_call_instance->Expected_p_request_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_request, p_request, cmock_line, "Function 'sd_radio_request' called with unexpected value for argument 'p_request'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_request), (void*)(p_request), sizeof(nrf_radio_request_t), cmock_call_instance->Expected_p_request_Depth, cmock_line, "Function 'sd_radio_request' called with unexpected value for argument 'p_request'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_request_Used)
+  {
+    memcpy((void*)p_request, (void*)cmock_call_instance->ReturnThruPtr_p_request_Val,
+      cmock_call_instance->ReturnThruPtr_p_request_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_radio_request(CMOCK_sd_radio_request_CALL_INSTANCE* cmock_call_instance, nrf_radio_request_t* p_request, int p_request_Depth)
+{
+  cmock_call_instance->Expected_p_request = p_request;
+  cmock_call_instance->Expected_p_request_Depth = p_request_Depth;
+  cmock_call_instance->IgnoreArg_p_request = 0;
+  cmock_call_instance->ReturnThruPtr_p_request_Used = 0;
+}
+
+void sd_radio_request_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_radio_request_CALL_INSTANCE));
+  CMOCK_sd_radio_request_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_radio_request_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_radio_request_CallInstance = CMock_Guts_MemChain(Mock.sd_radio_request_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_radio_request_IgnoreBool = (int)1;
+}
+
+void sd_radio_request_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nrf_radio_request_t* p_request, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_radio_request_CALL_INSTANCE));
+  CMOCK_sd_radio_request_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_radio_request_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_radio_request_CallInstance = CMock_Guts_MemChain(Mock.sd_radio_request_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_radio_request(cmock_call_instance, p_request, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_radio_request_StubWithCallback(CMOCK_sd_radio_request_CALLBACK Callback)
+{
+  Mock.sd_radio_request_CallbackFunctionPointer = Callback;
+}
+
+void sd_radio_request_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, nrf_radio_request_t* p_request, int p_request_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_radio_request_CALL_INSTANCE));
+  CMOCK_sd_radio_request_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_radio_request_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_radio_request_CallInstance = CMock_Guts_MemChain(Mock.sd_radio_request_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_radio_request(cmock_call_instance, p_request, p_request_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_radio_request_CMockReturnMemThruPtr_p_request(UNITY_LINE_TYPE cmock_line, nrf_radio_request_t* p_request, int cmock_size)
+{
+  CMOCK_sd_radio_request_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_radio_request_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_radio_request_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_request ReturnThruPtr called before Expect on 'sd_radio_request'.");
+  cmock_call_instance->ReturnThruPtr_p_request_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_request_Val = p_request;
+  cmock_call_instance->ReturnThruPtr_p_request_Size = cmock_size;
+}
+
+void sd_radio_request_CMockIgnoreArg_p_request(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_radio_request_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_radio_request_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_radio_request_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_request IgnoreArg called before Expect on 'sd_radio_request'.");
+  cmock_call_instance->IgnoreArg_p_request = 1;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_soc.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_soc.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_soc.h 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_soc.h  2018-04-24 08:48:28.938153700 +0200
@@ -0,0 +1,496 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_NRF_SOC_H
+#define _MOCK_NRF_SOC_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <nrf_soc.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_nrf_soc_Init(void);
+void mock_nrf_soc_Destroy(void);
+void mock_nrf_soc_Verify(void);
+
+
+
+
+#define sd_mutex_new_IgnoreAndReturn(cmock_retval) sd_mutex_new_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_mutex_new_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_mutex_new_ExpectAndReturn(p_mutex, cmock_retval) sd_mutex_new_CMockExpectAndReturn(__LINE__, p_mutex, cmock_retval)
+void sd_mutex_new_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_mutex_new_CALLBACK)(nrf_mutex_t* p_mutex, int cmock_num_calls);
+void sd_mutex_new_StubWithCallback(CMOCK_sd_mutex_new_CALLBACK Callback);
+#define sd_mutex_new_ExpectWithArrayAndReturn(p_mutex, p_mutex_Depth, cmock_retval) sd_mutex_new_CMockExpectWithArrayAndReturn(__LINE__, p_mutex, p_mutex_Depth, cmock_retval)
+void sd_mutex_new_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, int p_mutex_Depth, uint32_t cmock_to_return);
+#define sd_mutex_new_ReturnThruPtr_p_mutex(p_mutex) sd_mutex_new_CMockReturnMemThruPtr_p_mutex(__LINE__, p_mutex, sizeof(*p_mutex))
+#define sd_mutex_new_ReturnArrayThruPtr_p_mutex(p_mutex, cmock_len) sd_mutex_new_CMockReturnMemThruPtr_p_mutex(__LINE__, p_mutex, cmock_len * sizeof(*p_mutex))
+#define sd_mutex_new_ReturnMemThruPtr_p_mutex(p_mutex, cmock_size) sd_mutex_new_CMockReturnMemThruPtr_p_mutex(__LINE__, p_mutex, cmock_size)
+void sd_mutex_new_CMockReturnMemThruPtr_p_mutex(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, int cmock_size);
+#define sd_mutex_new_IgnoreArg_p_mutex() sd_mutex_new_CMockIgnoreArg_p_mutex(__LINE__)
+void sd_mutex_new_CMockIgnoreArg_p_mutex(UNITY_LINE_TYPE cmock_line);
+#define sd_mutex_acquire_IgnoreAndReturn(cmock_retval) sd_mutex_acquire_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_mutex_acquire_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_mutex_acquire_ExpectAndReturn(p_mutex, cmock_retval) sd_mutex_acquire_CMockExpectAndReturn(__LINE__, p_mutex, cmock_retval)
+void sd_mutex_acquire_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_mutex_acquire_CALLBACK)(nrf_mutex_t* p_mutex, int cmock_num_calls);
+void sd_mutex_acquire_StubWithCallback(CMOCK_sd_mutex_acquire_CALLBACK Callback);
+#define sd_mutex_acquire_ExpectWithArrayAndReturn(p_mutex, p_mutex_Depth, cmock_retval) sd_mutex_acquire_CMockExpectWithArrayAndReturn(__LINE__, p_mutex, p_mutex_Depth, cmock_retval)
+void sd_mutex_acquire_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, int p_mutex_Depth, uint32_t cmock_to_return);
+#define sd_mutex_acquire_ReturnThruPtr_p_mutex(p_mutex) sd_mutex_acquire_CMockReturnMemThruPtr_p_mutex(__LINE__, p_mutex, sizeof(*p_mutex))
+#define sd_mutex_acquire_ReturnArrayThruPtr_p_mutex(p_mutex, cmock_len) sd_mutex_acquire_CMockReturnMemThruPtr_p_mutex(__LINE__, p_mutex, cmock_len * sizeof(*p_mutex))
+#define sd_mutex_acquire_ReturnMemThruPtr_p_mutex(p_mutex, cmock_size) sd_mutex_acquire_CMockReturnMemThruPtr_p_mutex(__LINE__, p_mutex, cmock_size)
+void sd_mutex_acquire_CMockReturnMemThruPtr_p_mutex(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, int cmock_size);
+#define sd_mutex_acquire_IgnoreArg_p_mutex() sd_mutex_acquire_CMockIgnoreArg_p_mutex(__LINE__)
+void sd_mutex_acquire_CMockIgnoreArg_p_mutex(UNITY_LINE_TYPE cmock_line);
+#define sd_mutex_release_IgnoreAndReturn(cmock_retval) sd_mutex_release_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_mutex_release_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_mutex_release_ExpectAndReturn(p_mutex, cmock_retval) sd_mutex_release_CMockExpectAndReturn(__LINE__, p_mutex, cmock_retval)
+void sd_mutex_release_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_mutex_release_CALLBACK)(nrf_mutex_t* p_mutex, int cmock_num_calls);
+void sd_mutex_release_StubWithCallback(CMOCK_sd_mutex_release_CALLBACK Callback);
+#define sd_mutex_release_ExpectWithArrayAndReturn(p_mutex, p_mutex_Depth, cmock_retval) sd_mutex_release_CMockExpectWithArrayAndReturn(__LINE__, p_mutex, p_mutex_Depth, cmock_retval)
+void sd_mutex_release_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, int p_mutex_Depth, uint32_t cmock_to_return);
+#define sd_mutex_release_ReturnThruPtr_p_mutex(p_mutex) sd_mutex_release_CMockReturnMemThruPtr_p_mutex(__LINE__, p_mutex, sizeof(*p_mutex))
+#define sd_mutex_release_ReturnArrayThruPtr_p_mutex(p_mutex, cmock_len) sd_mutex_release_CMockReturnMemThruPtr_p_mutex(__LINE__, p_mutex, cmock_len * sizeof(*p_mutex))
+#define sd_mutex_release_ReturnMemThruPtr_p_mutex(p_mutex, cmock_size) sd_mutex_release_CMockReturnMemThruPtr_p_mutex(__LINE__, p_mutex, cmock_size)
+void sd_mutex_release_CMockReturnMemThruPtr_p_mutex(UNITY_LINE_TYPE cmock_line, nrf_mutex_t* p_mutex, int cmock_size);
+#define sd_mutex_release_IgnoreArg_p_mutex() sd_mutex_release_CMockIgnoreArg_p_mutex(__LINE__)
+void sd_mutex_release_CMockIgnoreArg_p_mutex(UNITY_LINE_TYPE cmock_line);
+#define sd_rand_application_pool_capacity_get_IgnoreAndReturn(cmock_retval) sd_rand_application_pool_capacity_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_rand_application_pool_capacity_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_rand_application_pool_capacity_get_ExpectAndReturn(p_pool_capacity, cmock_retval) sd_rand_application_pool_capacity_get_CMockExpectAndReturn(__LINE__, p_pool_capacity, cmock_retval)
+void sd_rand_application_pool_capacity_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_pool_capacity, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_rand_application_pool_capacity_get_CALLBACK)(uint8_t* p_pool_capacity, int cmock_num_calls);
+void sd_rand_application_pool_capacity_get_StubWithCallback(CMOCK_sd_rand_application_pool_capacity_get_CALLBACK Callback);
+#define sd_rand_application_pool_capacity_get_ExpectWithArrayAndReturn(p_pool_capacity, p_pool_capacity_Depth, cmock_retval) sd_rand_application_pool_capacity_get_CMockExpectWithArrayAndReturn(__LINE__, p_pool_capacity, p_pool_capacity_Depth, cmock_retval)
+void sd_rand_application_pool_capacity_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_pool_capacity, int p_pool_capacity_Depth, uint32_t cmock_to_return);
+#define sd_rand_application_pool_capacity_get_ReturnThruPtr_p_pool_capacity(p_pool_capacity) sd_rand_application_pool_capacity_get_CMockReturnMemThruPtr_p_pool_capacity(__LINE__, p_pool_capacity, sizeof(*p_pool_capacity))
+#define sd_rand_application_pool_capacity_get_ReturnArrayThruPtr_p_pool_capacity(p_pool_capacity, cmock_len) sd_rand_application_pool_capacity_get_CMockReturnMemThruPtr_p_pool_capacity(__LINE__, p_pool_capacity, cmock_len * sizeof(*p_pool_capacity))
+#define sd_rand_application_pool_capacity_get_ReturnMemThruPtr_p_pool_capacity(p_pool_capacity, cmock_size) sd_rand_application_pool_capacity_get_CMockReturnMemThruPtr_p_pool_capacity(__LINE__, p_pool_capacity, cmock_size)
+void sd_rand_application_pool_capacity_get_CMockReturnMemThruPtr_p_pool_capacity(UNITY_LINE_TYPE cmock_line, uint8_t* p_pool_capacity, int cmock_size);
+#define sd_rand_application_pool_capacity_get_IgnoreArg_p_pool_capacity() sd_rand_application_pool_capacity_get_CMockIgnoreArg_p_pool_capacity(__LINE__)
+void sd_rand_application_pool_capacity_get_CMockIgnoreArg_p_pool_capacity(UNITY_LINE_TYPE cmock_line);
+#define sd_rand_application_bytes_available_get_IgnoreAndReturn(cmock_retval) sd_rand_application_bytes_available_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_rand_application_bytes_available_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_rand_application_bytes_available_get_ExpectAndReturn(p_bytes_available, cmock_retval) sd_rand_application_bytes_available_get_CMockExpectAndReturn(__LINE__, p_bytes_available, cmock_retval)
+void sd_rand_application_bytes_available_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_bytes_available, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_rand_application_bytes_available_get_CALLBACK)(uint8_t* p_bytes_available, int cmock_num_calls);
+void sd_rand_application_bytes_available_get_StubWithCallback(CMOCK_sd_rand_application_bytes_available_get_CALLBACK Callback);
+#define sd_rand_application_bytes_available_get_ExpectWithArrayAndReturn(p_bytes_available, p_bytes_available_Depth, cmock_retval) sd_rand_application_bytes_available_get_CMockExpectWithArrayAndReturn(__LINE__, p_bytes_available, p_bytes_available_Depth, cmock_retval)
+void sd_rand_application_bytes_available_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_bytes_available, int p_bytes_available_Depth, uint32_t cmock_to_return);
+#define sd_rand_application_bytes_available_get_ReturnThruPtr_p_bytes_available(p_bytes_available) sd_rand_application_bytes_available_get_CMockReturnMemThruPtr_p_bytes_available(__LINE__, p_bytes_available, sizeof(*p_bytes_available))
+#define sd_rand_application_bytes_available_get_ReturnArrayThruPtr_p_bytes_available(p_bytes_available, cmock_len) sd_rand_application_bytes_available_get_CMockReturnMemThruPtr_p_bytes_available(__LINE__, p_bytes_available, cmock_len * sizeof(*p_bytes_available))
+#define sd_rand_application_bytes_available_get_ReturnMemThruPtr_p_bytes_available(p_bytes_available, cmock_size) sd_rand_application_bytes_available_get_CMockReturnMemThruPtr_p_bytes_available(__LINE__, p_bytes_available, cmock_size)
+void sd_rand_application_bytes_available_get_CMockReturnMemThruPtr_p_bytes_available(UNITY_LINE_TYPE cmock_line, uint8_t* p_bytes_available, int cmock_size);
+#define sd_rand_application_bytes_available_get_IgnoreArg_p_bytes_available() sd_rand_application_bytes_available_get_CMockIgnoreArg_p_bytes_available(__LINE__)
+void sd_rand_application_bytes_available_get_CMockIgnoreArg_p_bytes_available(UNITY_LINE_TYPE cmock_line);
+#define sd_rand_application_vector_get_IgnoreAndReturn(cmock_retval) sd_rand_application_vector_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_rand_application_vector_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_rand_application_vector_get_ExpectAndReturn(p_buff, length, cmock_retval) sd_rand_application_vector_get_CMockExpectAndReturn(__LINE__, p_buff, length, cmock_retval)
+void sd_rand_application_vector_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_buff, uint8_t length, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_rand_application_vector_get_CALLBACK)(uint8_t* p_buff, uint8_t length, int cmock_num_calls);
+void sd_rand_application_vector_get_StubWithCallback(CMOCK_sd_rand_application_vector_get_CALLBACK Callback);
+#define sd_rand_application_vector_get_ExpectWithArrayAndReturn(p_buff, p_buff_Depth, length, cmock_retval) sd_rand_application_vector_get_CMockExpectWithArrayAndReturn(__LINE__, p_buff, p_buff_Depth, length, cmock_retval)
+void sd_rand_application_vector_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_buff, int p_buff_Depth, uint8_t length, uint32_t cmock_to_return);
+#define sd_rand_application_vector_get_ReturnThruPtr_p_buff(p_buff) sd_rand_application_vector_get_CMockReturnMemThruPtr_p_buff(__LINE__, p_buff, sizeof(*p_buff))
+#define sd_rand_application_vector_get_ReturnArrayThruPtr_p_buff(p_buff, cmock_len) sd_rand_application_vector_get_CMockReturnMemThruPtr_p_buff(__LINE__, p_buff, cmock_len * sizeof(*p_buff))
+#define sd_rand_application_vector_get_ReturnMemThruPtr_p_buff(p_buff, cmock_size) sd_rand_application_vector_get_CMockReturnMemThruPtr_p_buff(__LINE__, p_buff, cmock_size)
+void sd_rand_application_vector_get_CMockReturnMemThruPtr_p_buff(UNITY_LINE_TYPE cmock_line, uint8_t* p_buff, int cmock_size);
+#define sd_rand_application_vector_get_IgnoreArg_p_buff() sd_rand_application_vector_get_CMockIgnoreArg_p_buff(__LINE__)
+void sd_rand_application_vector_get_CMockIgnoreArg_p_buff(UNITY_LINE_TYPE cmock_line);
+#define sd_rand_application_vector_get_IgnoreArg_length() sd_rand_application_vector_get_CMockIgnoreArg_length(__LINE__)
+void sd_rand_application_vector_get_CMockIgnoreArg_length(UNITY_LINE_TYPE cmock_line);
+#define sd_power_reset_reason_get_IgnoreAndReturn(cmock_retval) sd_power_reset_reason_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_power_reset_reason_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_power_reset_reason_get_ExpectAndReturn(p_reset_reason, cmock_retval) sd_power_reset_reason_get_CMockExpectAndReturn(__LINE__, p_reset_reason, cmock_retval)
+void sd_power_reset_reason_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_reset_reason, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_power_reset_reason_get_CALLBACK)(uint32_t* p_reset_reason, int cmock_num_calls);
+void sd_power_reset_reason_get_StubWithCallback(CMOCK_sd_power_reset_reason_get_CALLBACK Callback);
+#define sd_power_reset_reason_get_ExpectWithArrayAndReturn(p_reset_reason, p_reset_reason_Depth, cmock_retval) sd_power_reset_reason_get_CMockExpectWithArrayAndReturn(__LINE__, p_reset_reason, p_reset_reason_Depth, cmock_retval)
+void sd_power_reset_reason_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_reset_reason, int p_reset_reason_Depth, uint32_t cmock_to_return);
+#define sd_power_reset_reason_get_ReturnThruPtr_p_reset_reason(p_reset_reason) sd_power_reset_reason_get_CMockReturnMemThruPtr_p_reset_reason(__LINE__, p_reset_reason, sizeof(*p_reset_reason))
+#define sd_power_reset_reason_get_ReturnArrayThruPtr_p_reset_reason(p_reset_reason, cmock_len) sd_power_reset_reason_get_CMockReturnMemThruPtr_p_reset_reason(__LINE__, p_reset_reason, cmock_len * sizeof(*p_reset_reason))
+#define sd_power_reset_reason_get_ReturnMemThruPtr_p_reset_reason(p_reset_reason, cmock_size) sd_power_reset_reason_get_CMockReturnMemThruPtr_p_reset_reason(__LINE__, p_reset_reason, cmock_size)
+void sd_power_reset_reason_get_CMockReturnMemThruPtr_p_reset_reason(UNITY_LINE_TYPE cmock_line, uint32_t* p_reset_reason, int cmock_size);
+#define sd_power_reset_reason_get_IgnoreArg_p_reset_reason() sd_power_reset_reason_get_CMockIgnoreArg_p_reset_reason(__LINE__)
+void sd_power_reset_reason_get_CMockIgnoreArg_p_reset_reason(UNITY_LINE_TYPE cmock_line);
+#define sd_power_reset_reason_clr_IgnoreAndReturn(cmock_retval) sd_power_reset_reason_clr_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_power_reset_reason_clr_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_power_reset_reason_clr_ExpectAndReturn(reset_reason_clr_msk, cmock_retval) sd_power_reset_reason_clr_CMockExpectAndReturn(__LINE__, reset_reason_clr_msk, cmock_retval)
+void sd_power_reset_reason_clr_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t reset_reason_clr_msk, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_power_reset_reason_clr_CALLBACK)(uint32_t reset_reason_clr_msk, int cmock_num_calls);
+void sd_power_reset_reason_clr_StubWithCallback(CMOCK_sd_power_reset_reason_clr_CALLBACK Callback);
+#define sd_power_reset_reason_clr_IgnoreArg_reset_reason_clr_msk() sd_power_reset_reason_clr_CMockIgnoreArg_reset_reason_clr_msk(__LINE__)
+void sd_power_reset_reason_clr_CMockIgnoreArg_reset_reason_clr_msk(UNITY_LINE_TYPE cmock_line);
+#define sd_power_mode_set_IgnoreAndReturn(cmock_retval) sd_power_mode_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_power_mode_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_power_mode_set_ExpectAndReturn(power_mode, cmock_retval) sd_power_mode_set_CMockExpectAndReturn(__LINE__, power_mode, cmock_retval)
+void sd_power_mode_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t power_mode, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_power_mode_set_CALLBACK)(uint8_t power_mode, int cmock_num_calls);
+void sd_power_mode_set_StubWithCallback(CMOCK_sd_power_mode_set_CALLBACK Callback);
+#define sd_power_mode_set_IgnoreArg_power_mode() sd_power_mode_set_CMockIgnoreArg_power_mode(__LINE__)
+void sd_power_mode_set_CMockIgnoreArg_power_mode(UNITY_LINE_TYPE cmock_line);
+#define sd_power_system_off_IgnoreAndReturn(cmock_retval) sd_power_system_off_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_power_system_off_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_power_system_off_ExpectAndReturn(cmock_retval) sd_power_system_off_CMockExpectAndReturn(__LINE__, cmock_retval)
+void sd_power_system_off_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_power_system_off_CALLBACK)(int cmock_num_calls);
+void sd_power_system_off_StubWithCallback(CMOCK_sd_power_system_off_CALLBACK Callback);
+#define sd_power_pof_enable_IgnoreAndReturn(cmock_retval) sd_power_pof_enable_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_power_pof_enable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_power_pof_enable_ExpectAndReturn(pof_enable, cmock_retval) sd_power_pof_enable_CMockExpectAndReturn(__LINE__, pof_enable, cmock_retval)
+void sd_power_pof_enable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t pof_enable, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_power_pof_enable_CALLBACK)(uint8_t pof_enable, int cmock_num_calls);
+void sd_power_pof_enable_StubWithCallback(CMOCK_sd_power_pof_enable_CALLBACK Callback);
+#define sd_power_pof_enable_IgnoreArg_pof_enable() sd_power_pof_enable_CMockIgnoreArg_pof_enable(__LINE__)
+void sd_power_pof_enable_CMockIgnoreArg_pof_enable(UNITY_LINE_TYPE cmock_line);
+#define sd_power_pof_threshold_set_IgnoreAndReturn(cmock_retval) sd_power_pof_threshold_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_power_pof_threshold_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_power_pof_threshold_set_ExpectAndReturn(threshold, cmock_retval) sd_power_pof_threshold_set_CMockExpectAndReturn(__LINE__, threshold, cmock_retval)
+void sd_power_pof_threshold_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t threshold, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_power_pof_threshold_set_CALLBACK)(uint8_t threshold, int cmock_num_calls);
+void sd_power_pof_threshold_set_StubWithCallback(CMOCK_sd_power_pof_threshold_set_CALLBACK Callback);
+#define sd_power_pof_threshold_set_IgnoreArg_threshold() sd_power_pof_threshold_set_CMockIgnoreArg_threshold(__LINE__)
+void sd_power_pof_threshold_set_CMockIgnoreArg_threshold(UNITY_LINE_TYPE cmock_line);
+#define sd_power_ramon_set_IgnoreAndReturn(cmock_retval) sd_power_ramon_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_power_ramon_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_power_ramon_set_ExpectAndReturn(ramon, cmock_retval) sd_power_ramon_set_CMockExpectAndReturn(__LINE__, ramon, cmock_retval)
+void sd_power_ramon_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t ramon, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_power_ramon_set_CALLBACK)(uint32_t ramon, int cmock_num_calls);
+void sd_power_ramon_set_StubWithCallback(CMOCK_sd_power_ramon_set_CALLBACK Callback);
+#define sd_power_ramon_set_IgnoreArg_ramon() sd_power_ramon_set_CMockIgnoreArg_ramon(__LINE__)
+void sd_power_ramon_set_CMockIgnoreArg_ramon(UNITY_LINE_TYPE cmock_line);
+#define sd_power_ramon_clr_IgnoreAndReturn(cmock_retval) sd_power_ramon_clr_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_power_ramon_clr_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_power_ramon_clr_ExpectAndReturn(ramon, cmock_retval) sd_power_ramon_clr_CMockExpectAndReturn(__LINE__, ramon, cmock_retval)
+void sd_power_ramon_clr_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t ramon, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_power_ramon_clr_CALLBACK)(uint32_t ramon, int cmock_num_calls);
+void sd_power_ramon_clr_StubWithCallback(CMOCK_sd_power_ramon_clr_CALLBACK Callback);
+#define sd_power_ramon_clr_IgnoreArg_ramon() sd_power_ramon_clr_CMockIgnoreArg_ramon(__LINE__)
+void sd_power_ramon_clr_CMockIgnoreArg_ramon(UNITY_LINE_TYPE cmock_line);
+#define sd_power_ramon_get_IgnoreAndReturn(cmock_retval) sd_power_ramon_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_power_ramon_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_power_ramon_get_ExpectAndReturn(p_ramon, cmock_retval) sd_power_ramon_get_CMockExpectAndReturn(__LINE__, p_ramon, cmock_retval)
+void sd_power_ramon_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_ramon, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_power_ramon_get_CALLBACK)(uint32_t* p_ramon, int cmock_num_calls);
+void sd_power_ramon_get_StubWithCallback(CMOCK_sd_power_ramon_get_CALLBACK Callback);
+#define sd_power_ramon_get_ExpectWithArrayAndReturn(p_ramon, p_ramon_Depth, cmock_retval) sd_power_ramon_get_CMockExpectWithArrayAndReturn(__LINE__, p_ramon, p_ramon_Depth, cmock_retval)
+void sd_power_ramon_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_ramon, int p_ramon_Depth, uint32_t cmock_to_return);
+#define sd_power_ramon_get_ReturnThruPtr_p_ramon(p_ramon) sd_power_ramon_get_CMockReturnMemThruPtr_p_ramon(__LINE__, p_ramon, sizeof(*p_ramon))
+#define sd_power_ramon_get_ReturnArrayThruPtr_p_ramon(p_ramon, cmock_len) sd_power_ramon_get_CMockReturnMemThruPtr_p_ramon(__LINE__, p_ramon, cmock_len * sizeof(*p_ramon))
+#define sd_power_ramon_get_ReturnMemThruPtr_p_ramon(p_ramon, cmock_size) sd_power_ramon_get_CMockReturnMemThruPtr_p_ramon(__LINE__, p_ramon, cmock_size)
+void sd_power_ramon_get_CMockReturnMemThruPtr_p_ramon(UNITY_LINE_TYPE cmock_line, uint32_t* p_ramon, int cmock_size);
+#define sd_power_ramon_get_IgnoreArg_p_ramon() sd_power_ramon_get_CMockIgnoreArg_p_ramon(__LINE__)
+void sd_power_ramon_get_CMockIgnoreArg_p_ramon(UNITY_LINE_TYPE cmock_line);
+#define sd_power_gpregret_set_IgnoreAndReturn(cmock_retval) sd_power_gpregret_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_power_gpregret_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_power_gpregret_set_ExpectAndReturn(gpregret_id, gpregret_msk, cmock_retval) sd_power_gpregret_set_CMockExpectAndReturn(__LINE__, gpregret_id, gpregret_msk, cmock_retval)
+void sd_power_gpregret_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t gpregret_id, uint32_t gpregret_msk, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_power_gpregret_set_CALLBACK)(uint32_t gpregret_id, uint32_t gpregret_msk, int cmock_num_calls);
+void sd_power_gpregret_set_StubWithCallback(CMOCK_sd_power_gpregret_set_CALLBACK Callback);
+#define sd_power_gpregret_set_IgnoreArg_gpregret_id() sd_power_gpregret_set_CMockIgnoreArg_gpregret_id(__LINE__)
+void sd_power_gpregret_set_CMockIgnoreArg_gpregret_id(UNITY_LINE_TYPE cmock_line);
+#define sd_power_gpregret_set_IgnoreArg_gpregret_msk() sd_power_gpregret_set_CMockIgnoreArg_gpregret_msk(__LINE__)
+void sd_power_gpregret_set_CMockIgnoreArg_gpregret_msk(UNITY_LINE_TYPE cmock_line);
+#define sd_power_gpregret_clr_IgnoreAndReturn(cmock_retval) sd_power_gpregret_clr_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_power_gpregret_clr_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_power_gpregret_clr_ExpectAndReturn(gpregret_id, gpregret_msk, cmock_retval) sd_power_gpregret_clr_CMockExpectAndReturn(__LINE__, gpregret_id, gpregret_msk, cmock_retval)
+void sd_power_gpregret_clr_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t gpregret_id, uint32_t gpregret_msk, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_power_gpregret_clr_CALLBACK)(uint32_t gpregret_id, uint32_t gpregret_msk, int cmock_num_calls);
+void sd_power_gpregret_clr_StubWithCallback(CMOCK_sd_power_gpregret_clr_CALLBACK Callback);
+#define sd_power_gpregret_clr_IgnoreArg_gpregret_id() sd_power_gpregret_clr_CMockIgnoreArg_gpregret_id(__LINE__)
+void sd_power_gpregret_clr_CMockIgnoreArg_gpregret_id(UNITY_LINE_TYPE cmock_line);
+#define sd_power_gpregret_clr_IgnoreArg_gpregret_msk() sd_power_gpregret_clr_CMockIgnoreArg_gpregret_msk(__LINE__)
+void sd_power_gpregret_clr_CMockIgnoreArg_gpregret_msk(UNITY_LINE_TYPE cmock_line);
+#define sd_power_gpregret_get_IgnoreAndReturn(cmock_retval) sd_power_gpregret_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_power_gpregret_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_power_gpregret_get_ExpectAndReturn(gpregret_id, p_gpregret, cmock_retval) sd_power_gpregret_get_CMockExpectAndReturn(__LINE__, gpregret_id, p_gpregret, cmock_retval)
+void sd_power_gpregret_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t gpregret_id, uint32_t* p_gpregret, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_power_gpregret_get_CALLBACK)(uint32_t gpregret_id, uint32_t* p_gpregret, int cmock_num_calls);
+void sd_power_gpregret_get_StubWithCallback(CMOCK_sd_power_gpregret_get_CALLBACK Callback);
+#define sd_power_gpregret_get_ExpectWithArrayAndReturn(gpregret_id, p_gpregret, p_gpregret_Depth, cmock_retval) sd_power_gpregret_get_CMockExpectWithArrayAndReturn(__LINE__, gpregret_id, p_gpregret, p_gpregret_Depth, cmock_retval)
+void sd_power_gpregret_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t gpregret_id, uint32_t* p_gpregret, int p_gpregret_Depth, uint32_t cmock_to_return);
+#define sd_power_gpregret_get_ReturnThruPtr_p_gpregret(p_gpregret) sd_power_gpregret_get_CMockReturnMemThruPtr_p_gpregret(__LINE__, p_gpregret, sizeof(*p_gpregret))
+#define sd_power_gpregret_get_ReturnArrayThruPtr_p_gpregret(p_gpregret, cmock_len) sd_power_gpregret_get_CMockReturnMemThruPtr_p_gpregret(__LINE__, p_gpregret, cmock_len * sizeof(*p_gpregret))
+#define sd_power_gpregret_get_ReturnMemThruPtr_p_gpregret(p_gpregret, cmock_size) sd_power_gpregret_get_CMockReturnMemThruPtr_p_gpregret(__LINE__, p_gpregret, cmock_size)
+void sd_power_gpregret_get_CMockReturnMemThruPtr_p_gpregret(UNITY_LINE_TYPE cmock_line, uint32_t* p_gpregret, int cmock_size);
+#define sd_power_gpregret_get_IgnoreArg_gpregret_id() sd_power_gpregret_get_CMockIgnoreArg_gpregret_id(__LINE__)
+void sd_power_gpregret_get_CMockIgnoreArg_gpregret_id(UNITY_LINE_TYPE cmock_line);
+#define sd_power_gpregret_get_IgnoreArg_p_gpregret() sd_power_gpregret_get_CMockIgnoreArg_p_gpregret(__LINE__)
+void sd_power_gpregret_get_CMockIgnoreArg_p_gpregret(UNITY_LINE_TYPE cmock_line);
+#define sd_power_dcdc_mode_set_IgnoreAndReturn(cmock_retval) sd_power_dcdc_mode_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_power_dcdc_mode_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_power_dcdc_mode_set_ExpectAndReturn(dcdc_mode, cmock_retval) sd_power_dcdc_mode_set_CMockExpectAndReturn(__LINE__, dcdc_mode, cmock_retval)
+void sd_power_dcdc_mode_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t dcdc_mode, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_power_dcdc_mode_set_CALLBACK)(uint8_t dcdc_mode, int cmock_num_calls);
+void sd_power_dcdc_mode_set_StubWithCallback(CMOCK_sd_power_dcdc_mode_set_CALLBACK Callback);
+#define sd_power_dcdc_mode_set_IgnoreArg_dcdc_mode() sd_power_dcdc_mode_set_CMockIgnoreArg_dcdc_mode(__LINE__)
+void sd_power_dcdc_mode_set_CMockIgnoreArg_dcdc_mode(UNITY_LINE_TYPE cmock_line);
+#define sd_clock_hfclk_request_IgnoreAndReturn(cmock_retval) sd_clock_hfclk_request_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_clock_hfclk_request_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_clock_hfclk_request_ExpectAndReturn(cmock_retval) sd_clock_hfclk_request_CMockExpectAndReturn(__LINE__, cmock_retval)
+void sd_clock_hfclk_request_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_clock_hfclk_request_CALLBACK)(int cmock_num_calls);
+void sd_clock_hfclk_request_StubWithCallback(CMOCK_sd_clock_hfclk_request_CALLBACK Callback);
+#define sd_clock_hfclk_release_IgnoreAndReturn(cmock_retval) sd_clock_hfclk_release_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_clock_hfclk_release_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_clock_hfclk_release_ExpectAndReturn(cmock_retval) sd_clock_hfclk_release_CMockExpectAndReturn(__LINE__, cmock_retval)
+void sd_clock_hfclk_release_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_clock_hfclk_release_CALLBACK)(int cmock_num_calls);
+void sd_clock_hfclk_release_StubWithCallback(CMOCK_sd_clock_hfclk_release_CALLBACK Callback);
+#define sd_clock_hfclk_is_running_IgnoreAndReturn(cmock_retval) sd_clock_hfclk_is_running_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_clock_hfclk_is_running_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_clock_hfclk_is_running_ExpectAndReturn(p_is_running, cmock_retval) sd_clock_hfclk_is_running_CMockExpectAndReturn(__LINE__, p_is_running, cmock_retval)
+void sd_clock_hfclk_is_running_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_is_running, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_clock_hfclk_is_running_CALLBACK)(uint32_t* p_is_running, int cmock_num_calls);
+void sd_clock_hfclk_is_running_StubWithCallback(CMOCK_sd_clock_hfclk_is_running_CALLBACK Callback);
+#define sd_clock_hfclk_is_running_ExpectWithArrayAndReturn(p_is_running, p_is_running_Depth, cmock_retval) sd_clock_hfclk_is_running_CMockExpectWithArrayAndReturn(__LINE__, p_is_running, p_is_running_Depth, cmock_retval)
+void sd_clock_hfclk_is_running_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_is_running, int p_is_running_Depth, uint32_t cmock_to_return);
+#define sd_clock_hfclk_is_running_ReturnThruPtr_p_is_running(p_is_running) sd_clock_hfclk_is_running_CMockReturnMemThruPtr_p_is_running(__LINE__, p_is_running, sizeof(*p_is_running))
+#define sd_clock_hfclk_is_running_ReturnArrayThruPtr_p_is_running(p_is_running, cmock_len) sd_clock_hfclk_is_running_CMockReturnMemThruPtr_p_is_running(__LINE__, p_is_running, cmock_len * sizeof(*p_is_running))
+#define sd_clock_hfclk_is_running_ReturnMemThruPtr_p_is_running(p_is_running, cmock_size) sd_clock_hfclk_is_running_CMockReturnMemThruPtr_p_is_running(__LINE__, p_is_running, cmock_size)
+void sd_clock_hfclk_is_running_CMockReturnMemThruPtr_p_is_running(UNITY_LINE_TYPE cmock_line, uint32_t* p_is_running, int cmock_size);
+#define sd_clock_hfclk_is_running_IgnoreArg_p_is_running() sd_clock_hfclk_is_running_CMockIgnoreArg_p_is_running(__LINE__)
+void sd_clock_hfclk_is_running_CMockIgnoreArg_p_is_running(UNITY_LINE_TYPE cmock_line);
+#define sd_app_evt_wait_IgnoreAndReturn(cmock_retval) sd_app_evt_wait_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_app_evt_wait_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_app_evt_wait_ExpectAndReturn(cmock_retval) sd_app_evt_wait_CMockExpectAndReturn(__LINE__, cmock_retval)
+void sd_app_evt_wait_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_app_evt_wait_CALLBACK)(int cmock_num_calls);
+void sd_app_evt_wait_StubWithCallback(CMOCK_sd_app_evt_wait_CALLBACK Callback);
+#define sd_ppi_channel_enable_get_IgnoreAndReturn(cmock_retval) sd_ppi_channel_enable_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ppi_channel_enable_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ppi_channel_enable_get_ExpectAndReturn(p_channel_enable, cmock_retval) sd_ppi_channel_enable_get_CMockExpectAndReturn(__LINE__, p_channel_enable, cmock_retval)
+void sd_ppi_channel_enable_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_channel_enable, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ppi_channel_enable_get_CALLBACK)(uint32_t* p_channel_enable, int cmock_num_calls);
+void sd_ppi_channel_enable_get_StubWithCallback(CMOCK_sd_ppi_channel_enable_get_CALLBACK Callback);
+#define sd_ppi_channel_enable_get_ExpectWithArrayAndReturn(p_channel_enable, p_channel_enable_Depth, cmock_retval) sd_ppi_channel_enable_get_CMockExpectWithArrayAndReturn(__LINE__, p_channel_enable, p_channel_enable_Depth, cmock_retval)
+void sd_ppi_channel_enable_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_channel_enable, int p_channel_enable_Depth, uint32_t cmock_to_return);
+#define sd_ppi_channel_enable_get_ReturnThruPtr_p_channel_enable(p_channel_enable) sd_ppi_channel_enable_get_CMockReturnMemThruPtr_p_channel_enable(__LINE__, p_channel_enable, sizeof(*p_channel_enable))
+#define sd_ppi_channel_enable_get_ReturnArrayThruPtr_p_channel_enable(p_channel_enable, cmock_len) sd_ppi_channel_enable_get_CMockReturnMemThruPtr_p_channel_enable(__LINE__, p_channel_enable, cmock_len * sizeof(*p_channel_enable))
+#define sd_ppi_channel_enable_get_ReturnMemThruPtr_p_channel_enable(p_channel_enable, cmock_size) sd_ppi_channel_enable_get_CMockReturnMemThruPtr_p_channel_enable(__LINE__, p_channel_enable, cmock_size)
+void sd_ppi_channel_enable_get_CMockReturnMemThruPtr_p_channel_enable(UNITY_LINE_TYPE cmock_line, uint32_t* p_channel_enable, int cmock_size);
+#define sd_ppi_channel_enable_get_IgnoreArg_p_channel_enable() sd_ppi_channel_enable_get_CMockIgnoreArg_p_channel_enable(__LINE__)
+void sd_ppi_channel_enable_get_CMockIgnoreArg_p_channel_enable(UNITY_LINE_TYPE cmock_line);
+#define sd_ppi_channel_enable_set_IgnoreAndReturn(cmock_retval) sd_ppi_channel_enable_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ppi_channel_enable_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ppi_channel_enable_set_ExpectAndReturn(channel_enable_set_msk, cmock_retval) sd_ppi_channel_enable_set_CMockExpectAndReturn(__LINE__, channel_enable_set_msk, cmock_retval)
+void sd_ppi_channel_enable_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t channel_enable_set_msk, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ppi_channel_enable_set_CALLBACK)(uint32_t channel_enable_set_msk, int cmock_num_calls);
+void sd_ppi_channel_enable_set_StubWithCallback(CMOCK_sd_ppi_channel_enable_set_CALLBACK Callback);
+#define sd_ppi_channel_enable_set_IgnoreArg_channel_enable_set_msk() sd_ppi_channel_enable_set_CMockIgnoreArg_channel_enable_set_msk(__LINE__)
+void sd_ppi_channel_enable_set_CMockIgnoreArg_channel_enable_set_msk(UNITY_LINE_TYPE cmock_line);
+#define sd_ppi_channel_enable_clr_IgnoreAndReturn(cmock_retval) sd_ppi_channel_enable_clr_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ppi_channel_enable_clr_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ppi_channel_enable_clr_ExpectAndReturn(channel_enable_clr_msk, cmock_retval) sd_ppi_channel_enable_clr_CMockExpectAndReturn(__LINE__, channel_enable_clr_msk, cmock_retval)
+void sd_ppi_channel_enable_clr_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t channel_enable_clr_msk, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ppi_channel_enable_clr_CALLBACK)(uint32_t channel_enable_clr_msk, int cmock_num_calls);
+void sd_ppi_channel_enable_clr_StubWithCallback(CMOCK_sd_ppi_channel_enable_clr_CALLBACK Callback);
+#define sd_ppi_channel_enable_clr_IgnoreArg_channel_enable_clr_msk() sd_ppi_channel_enable_clr_CMockIgnoreArg_channel_enable_clr_msk(__LINE__)
+void sd_ppi_channel_enable_clr_CMockIgnoreArg_channel_enable_clr_msk(UNITY_LINE_TYPE cmock_line);
+#define sd_ppi_channel_assign_IgnoreAndReturn(cmock_retval) sd_ppi_channel_assign_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ppi_channel_assign_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ppi_channel_assign_ExpectAndReturn(channel_num, evt_endpoint, task_endpoint, cmock_retval) sd_ppi_channel_assign_CMockExpectAndReturn(__LINE__, channel_num, evt_endpoint, task_endpoint, cmock_retval)
+void sd_ppi_channel_assign_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t channel_num, const volatile void* evt_endpoint, const volatile void* task_endpoint, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ppi_channel_assign_CALLBACK)(uint8_t channel_num, const volatile void* evt_endpoint, const volatile void* task_endpoint, int cmock_num_calls);
+void sd_ppi_channel_assign_StubWithCallback(CMOCK_sd_ppi_channel_assign_CALLBACK Callback);
+#define sd_ppi_channel_assign_ExpectWithArrayAndReturn(channel_num, evt_endpoint, evt_endpoint_Depth, task_endpoint, task_endpoint_Depth, cmock_retval) sd_ppi_channel_assign_CMockExpectWithArrayAndReturn(__LINE__, channel_num, evt_endpoint, evt_endpoint_Depth, task_endpoint, task_endpoint_Depth, cmock_retval)
+void sd_ppi_channel_assign_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t channel_num, volatile void* evt_endpoint, int evt_endpoint_Depth, volatile void* task_endpoint, int task_endpoint_Depth, uint32_t cmock_to_return);
+#define sd_ppi_channel_assign_IgnoreArg_channel_num() sd_ppi_channel_assign_CMockIgnoreArg_channel_num(__LINE__)
+void sd_ppi_channel_assign_CMockIgnoreArg_channel_num(UNITY_LINE_TYPE cmock_line);
+#define sd_ppi_channel_assign_IgnoreArg_evt_endpoint() sd_ppi_channel_assign_CMockIgnoreArg_evt_endpoint(__LINE__)
+void sd_ppi_channel_assign_CMockIgnoreArg_evt_endpoint(UNITY_LINE_TYPE cmock_line);
+#define sd_ppi_channel_assign_IgnoreArg_task_endpoint() sd_ppi_channel_assign_CMockIgnoreArg_task_endpoint(__LINE__)
+void sd_ppi_channel_assign_CMockIgnoreArg_task_endpoint(UNITY_LINE_TYPE cmock_line);
+#define sd_ppi_group_task_enable_IgnoreAndReturn(cmock_retval) sd_ppi_group_task_enable_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ppi_group_task_enable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ppi_group_task_enable_ExpectAndReturn(group_num, cmock_retval) sd_ppi_group_task_enable_CMockExpectAndReturn(__LINE__, group_num, cmock_retval)
+void sd_ppi_group_task_enable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t group_num, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ppi_group_task_enable_CALLBACK)(uint8_t group_num, int cmock_num_calls);
+void sd_ppi_group_task_enable_StubWithCallback(CMOCK_sd_ppi_group_task_enable_CALLBACK Callback);
+#define sd_ppi_group_task_enable_IgnoreArg_group_num() sd_ppi_group_task_enable_CMockIgnoreArg_group_num(__LINE__)
+void sd_ppi_group_task_enable_CMockIgnoreArg_group_num(UNITY_LINE_TYPE cmock_line);
+#define sd_ppi_group_task_disable_IgnoreAndReturn(cmock_retval) sd_ppi_group_task_disable_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ppi_group_task_disable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ppi_group_task_disable_ExpectAndReturn(group_num, cmock_retval) sd_ppi_group_task_disable_CMockExpectAndReturn(__LINE__, group_num, cmock_retval)
+void sd_ppi_group_task_disable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t group_num, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ppi_group_task_disable_CALLBACK)(uint8_t group_num, int cmock_num_calls);
+void sd_ppi_group_task_disable_StubWithCallback(CMOCK_sd_ppi_group_task_disable_CALLBACK Callback);
+#define sd_ppi_group_task_disable_IgnoreArg_group_num() sd_ppi_group_task_disable_CMockIgnoreArg_group_num(__LINE__)
+void sd_ppi_group_task_disable_CMockIgnoreArg_group_num(UNITY_LINE_TYPE cmock_line);
+#define sd_ppi_group_assign_IgnoreAndReturn(cmock_retval) sd_ppi_group_assign_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ppi_group_assign_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ppi_group_assign_ExpectAndReturn(group_num, channel_msk, cmock_retval) sd_ppi_group_assign_CMockExpectAndReturn(__LINE__, group_num, channel_msk, cmock_retval)
+void sd_ppi_group_assign_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t group_num, uint32_t channel_msk, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ppi_group_assign_CALLBACK)(uint8_t group_num, uint32_t channel_msk, int cmock_num_calls);
+void sd_ppi_group_assign_StubWithCallback(CMOCK_sd_ppi_group_assign_CALLBACK Callback);
+#define sd_ppi_group_assign_IgnoreArg_group_num() sd_ppi_group_assign_CMockIgnoreArg_group_num(__LINE__)
+void sd_ppi_group_assign_CMockIgnoreArg_group_num(UNITY_LINE_TYPE cmock_line);
+#define sd_ppi_group_assign_IgnoreArg_channel_msk() sd_ppi_group_assign_CMockIgnoreArg_channel_msk(__LINE__)
+void sd_ppi_group_assign_CMockIgnoreArg_channel_msk(UNITY_LINE_TYPE cmock_line);
+#define sd_ppi_group_get_IgnoreAndReturn(cmock_retval) sd_ppi_group_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ppi_group_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ppi_group_get_ExpectAndReturn(group_num, p_channel_msk, cmock_retval) sd_ppi_group_get_CMockExpectAndReturn(__LINE__, group_num, p_channel_msk, cmock_retval)
+void sd_ppi_group_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t group_num, uint32_t* p_channel_msk, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ppi_group_get_CALLBACK)(uint8_t group_num, uint32_t* p_channel_msk, int cmock_num_calls);
+void sd_ppi_group_get_StubWithCallback(CMOCK_sd_ppi_group_get_CALLBACK Callback);
+#define sd_ppi_group_get_ExpectWithArrayAndReturn(group_num, p_channel_msk, p_channel_msk_Depth, cmock_retval) sd_ppi_group_get_CMockExpectWithArrayAndReturn(__LINE__, group_num, p_channel_msk, p_channel_msk_Depth, cmock_retval)
+void sd_ppi_group_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t group_num, uint32_t* p_channel_msk, int p_channel_msk_Depth, uint32_t cmock_to_return);
+#define sd_ppi_group_get_ReturnThruPtr_p_channel_msk(p_channel_msk) sd_ppi_group_get_CMockReturnMemThruPtr_p_channel_msk(__LINE__, p_channel_msk, sizeof(*p_channel_msk))
+#define sd_ppi_group_get_ReturnArrayThruPtr_p_channel_msk(p_channel_msk, cmock_len) sd_ppi_group_get_CMockReturnMemThruPtr_p_channel_msk(__LINE__, p_channel_msk, cmock_len * sizeof(*p_channel_msk))
+#define sd_ppi_group_get_ReturnMemThruPtr_p_channel_msk(p_channel_msk, cmock_size) sd_ppi_group_get_CMockReturnMemThruPtr_p_channel_msk(__LINE__, p_channel_msk, cmock_size)
+void sd_ppi_group_get_CMockReturnMemThruPtr_p_channel_msk(UNITY_LINE_TYPE cmock_line, uint32_t* p_channel_msk, int cmock_size);
+#define sd_ppi_group_get_IgnoreArg_group_num() sd_ppi_group_get_CMockIgnoreArg_group_num(__LINE__)
+void sd_ppi_group_get_CMockIgnoreArg_group_num(UNITY_LINE_TYPE cmock_line);
+#define sd_ppi_group_get_IgnoreArg_p_channel_msk() sd_ppi_group_get_CMockIgnoreArg_p_channel_msk(__LINE__)
+void sd_ppi_group_get_CMockIgnoreArg_p_channel_msk(UNITY_LINE_TYPE cmock_line);
+#define sd_radio_notification_cfg_set_IgnoreAndReturn(cmock_retval) sd_radio_notification_cfg_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_radio_notification_cfg_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_radio_notification_cfg_set_ExpectAndReturn(type, distance, cmock_retval) sd_radio_notification_cfg_set_CMockExpectAndReturn(__LINE__, type, distance, cmock_retval)
+void sd_radio_notification_cfg_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t type, uint8_t distance, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_radio_notification_cfg_set_CALLBACK)(uint8_t type, uint8_t distance, int cmock_num_calls);
+void sd_radio_notification_cfg_set_StubWithCallback(CMOCK_sd_radio_notification_cfg_set_CALLBACK Callback);
+#define sd_radio_notification_cfg_set_IgnoreArg_type() sd_radio_notification_cfg_set_CMockIgnoreArg_type(__LINE__)
+void sd_radio_notification_cfg_set_CMockIgnoreArg_type(UNITY_LINE_TYPE cmock_line);
+#define sd_radio_notification_cfg_set_IgnoreArg_distance() sd_radio_notification_cfg_set_CMockIgnoreArg_distance(__LINE__)
+void sd_radio_notification_cfg_set_CMockIgnoreArg_distance(UNITY_LINE_TYPE cmock_line);
+#define sd_ecb_block_encrypt_IgnoreAndReturn(cmock_retval) sd_ecb_block_encrypt_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ecb_block_encrypt_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ecb_block_encrypt_ExpectAndReturn(p_ecb_data, cmock_retval) sd_ecb_block_encrypt_CMockExpectAndReturn(__LINE__, p_ecb_data, cmock_retval)
+void sd_ecb_block_encrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nrf_ecb_hal_data_t* p_ecb_data, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ecb_block_encrypt_CALLBACK)(nrf_ecb_hal_data_t* p_ecb_data, int cmock_num_calls);
+void sd_ecb_block_encrypt_StubWithCallback(CMOCK_sd_ecb_block_encrypt_CALLBACK Callback);
+#define sd_ecb_block_encrypt_ExpectWithArrayAndReturn(p_ecb_data, p_ecb_data_Depth, cmock_retval) sd_ecb_block_encrypt_CMockExpectWithArrayAndReturn(__LINE__, p_ecb_data, p_ecb_data_Depth, cmock_retval)
+void sd_ecb_block_encrypt_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, nrf_ecb_hal_data_t* p_ecb_data, int p_ecb_data_Depth, uint32_t cmock_to_return);
+#define sd_ecb_block_encrypt_ReturnThruPtr_p_ecb_data(p_ecb_data) sd_ecb_block_encrypt_CMockReturnMemThruPtr_p_ecb_data(__LINE__, p_ecb_data, sizeof(*p_ecb_data))
+#define sd_ecb_block_encrypt_ReturnArrayThruPtr_p_ecb_data(p_ecb_data, cmock_len) sd_ecb_block_encrypt_CMockReturnMemThruPtr_p_ecb_data(__LINE__, p_ecb_data, cmock_len * sizeof(*p_ecb_data))
+#define sd_ecb_block_encrypt_ReturnMemThruPtr_p_ecb_data(p_ecb_data, cmock_size) sd_ecb_block_encrypt_CMockReturnMemThruPtr_p_ecb_data(__LINE__, p_ecb_data, cmock_size)
+void sd_ecb_block_encrypt_CMockReturnMemThruPtr_p_ecb_data(UNITY_LINE_TYPE cmock_line, nrf_ecb_hal_data_t* p_ecb_data, int cmock_size);
+#define sd_ecb_block_encrypt_IgnoreArg_p_ecb_data() sd_ecb_block_encrypt_CMockIgnoreArg_p_ecb_data(__LINE__)
+void sd_ecb_block_encrypt_CMockIgnoreArg_p_ecb_data(UNITY_LINE_TYPE cmock_line);
+#define sd_ecb_blocks_encrypt_IgnoreAndReturn(cmock_retval) sd_ecb_blocks_encrypt_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ecb_blocks_encrypt_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ecb_blocks_encrypt_ExpectAndReturn(block_count, p_data_blocks, cmock_retval) sd_ecb_blocks_encrypt_CMockExpectAndReturn(__LINE__, block_count, p_data_blocks, cmock_retval)
+void sd_ecb_blocks_encrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t block_count, nrf_ecb_hal_data_block_t* p_data_blocks, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ecb_blocks_encrypt_CALLBACK)(uint8_t block_count, nrf_ecb_hal_data_block_t* p_data_blocks, int cmock_num_calls);
+void sd_ecb_blocks_encrypt_StubWithCallback(CMOCK_sd_ecb_blocks_encrypt_CALLBACK Callback);
+#define sd_ecb_blocks_encrypt_ExpectWithArrayAndReturn(block_count, p_data_blocks, p_data_blocks_Depth, cmock_retval) sd_ecb_blocks_encrypt_CMockExpectWithArrayAndReturn(__LINE__, block_count, p_data_blocks, p_data_blocks_Depth, cmock_retval)
+void sd_ecb_blocks_encrypt_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t block_count, nrf_ecb_hal_data_block_t* p_data_blocks, int p_data_blocks_Depth, uint32_t cmock_to_return);
+#define sd_ecb_blocks_encrypt_ReturnThruPtr_p_data_blocks(p_data_blocks) sd_ecb_blocks_encrypt_CMockReturnMemThruPtr_p_data_blocks(__LINE__, p_data_blocks, sizeof(*p_data_blocks))
+#define sd_ecb_blocks_encrypt_ReturnArrayThruPtr_p_data_blocks(p_data_blocks, cmock_len) sd_ecb_blocks_encrypt_CMockReturnMemThruPtr_p_data_blocks(__LINE__, p_data_blocks, cmock_len * sizeof(*p_data_blocks))
+#define sd_ecb_blocks_encrypt_ReturnMemThruPtr_p_data_blocks(p_data_blocks, cmock_size) sd_ecb_blocks_encrypt_CMockReturnMemThruPtr_p_data_blocks(__LINE__, p_data_blocks, cmock_size)
+void sd_ecb_blocks_encrypt_CMockReturnMemThruPtr_p_data_blocks(UNITY_LINE_TYPE cmock_line, nrf_ecb_hal_data_block_t* p_data_blocks, int cmock_size);
+#define sd_ecb_blocks_encrypt_IgnoreArg_block_count() sd_ecb_blocks_encrypt_CMockIgnoreArg_block_count(__LINE__)
+void sd_ecb_blocks_encrypt_CMockIgnoreArg_block_count(UNITY_LINE_TYPE cmock_line);
+#define sd_ecb_blocks_encrypt_IgnoreArg_p_data_blocks() sd_ecb_blocks_encrypt_CMockIgnoreArg_p_data_blocks(__LINE__)
+void sd_ecb_blocks_encrypt_CMockIgnoreArg_p_data_blocks(UNITY_LINE_TYPE cmock_line);
+#define sd_evt_get_IgnoreAndReturn(cmock_retval) sd_evt_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_evt_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_evt_get_ExpectAndReturn(p_evt_id, cmock_retval) sd_evt_get_CMockExpectAndReturn(__LINE__, p_evt_id, cmock_retval)
+void sd_evt_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_evt_id, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_evt_get_CALLBACK)(uint32_t* p_evt_id, int cmock_num_calls);
+void sd_evt_get_StubWithCallback(CMOCK_sd_evt_get_CALLBACK Callback);
+#define sd_evt_get_ExpectWithArrayAndReturn(p_evt_id, p_evt_id_Depth, cmock_retval) sd_evt_get_CMockExpectWithArrayAndReturn(__LINE__, p_evt_id, p_evt_id_Depth, cmock_retval)
+void sd_evt_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_evt_id, int p_evt_id_Depth, uint32_t cmock_to_return);
+#define sd_evt_get_ReturnThruPtr_p_evt_id(p_evt_id) sd_evt_get_CMockReturnMemThruPtr_p_evt_id(__LINE__, p_evt_id, sizeof(*p_evt_id))
+#define sd_evt_get_ReturnArrayThruPtr_p_evt_id(p_evt_id, cmock_len) sd_evt_get_CMockReturnMemThruPtr_p_evt_id(__LINE__, p_evt_id, cmock_len * sizeof(*p_evt_id))
+#define sd_evt_get_ReturnMemThruPtr_p_evt_id(p_evt_id, cmock_size) sd_evt_get_CMockReturnMemThruPtr_p_evt_id(__LINE__, p_evt_id, cmock_size)
+void sd_evt_get_CMockReturnMemThruPtr_p_evt_id(UNITY_LINE_TYPE cmock_line, uint32_t* p_evt_id, int cmock_size);
+#define sd_evt_get_IgnoreArg_p_evt_id() sd_evt_get_CMockIgnoreArg_p_evt_id(__LINE__)
+void sd_evt_get_CMockIgnoreArg_p_evt_id(UNITY_LINE_TYPE cmock_line);
+#define sd_temp_get_IgnoreAndReturn(cmock_retval) sd_temp_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_temp_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_temp_get_ExpectAndReturn(p_temp, cmock_retval) sd_temp_get_CMockExpectAndReturn(__LINE__, p_temp, cmock_retval)
+void sd_temp_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int32_t* p_temp, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_temp_get_CALLBACK)(int32_t* p_temp, int cmock_num_calls);
+void sd_temp_get_StubWithCallback(CMOCK_sd_temp_get_CALLBACK Callback);
+#define sd_temp_get_ExpectWithArrayAndReturn(p_temp, p_temp_Depth, cmock_retval) sd_temp_get_CMockExpectWithArrayAndReturn(__LINE__, p_temp, p_temp_Depth, cmock_retval)
+void sd_temp_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, int32_t* p_temp, int p_temp_Depth, uint32_t cmock_to_return);
+#define sd_temp_get_ReturnThruPtr_p_temp(p_temp) sd_temp_get_CMockReturnMemThruPtr_p_temp(__LINE__, p_temp, sizeof(*p_temp))
+#define sd_temp_get_ReturnArrayThruPtr_p_temp(p_temp, cmock_len) sd_temp_get_CMockReturnMemThruPtr_p_temp(__LINE__, p_temp, cmock_len * sizeof(*p_temp))
+#define sd_temp_get_ReturnMemThruPtr_p_temp(p_temp, cmock_size) sd_temp_get_CMockReturnMemThruPtr_p_temp(__LINE__, p_temp, cmock_size)
+void sd_temp_get_CMockReturnMemThruPtr_p_temp(UNITY_LINE_TYPE cmock_line, int32_t* p_temp, int cmock_size);
+#define sd_temp_get_IgnoreArg_p_temp() sd_temp_get_CMockIgnoreArg_p_temp(__LINE__)
+void sd_temp_get_CMockIgnoreArg_p_temp(UNITY_LINE_TYPE cmock_line);
+#define sd_flash_write_IgnoreAndReturn(cmock_retval) sd_flash_write_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_flash_write_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_flash_write_ExpectAndReturn(p_dst, p_src, size, cmock_retval) sd_flash_write_CMockExpectAndReturn(__LINE__, p_dst, p_src, size, cmock_retval)
+void sd_flash_write_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* const p_dst, uint32_t const* const p_src, uint32_t size, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_flash_write_CALLBACK)(uint32_t* const p_dst, uint32_t const* const p_src, uint32_t size, int cmock_num_calls);
+void sd_flash_write_StubWithCallback(CMOCK_sd_flash_write_CALLBACK Callback);
+#define sd_flash_write_ExpectWithArrayAndReturn(p_dst, p_dst_Depth, p_src, p_src_Depth, size, cmock_retval) sd_flash_write_CMockExpectWithArrayAndReturn(__LINE__, p_dst, p_dst_Depth, p_src, p_src_Depth, size, cmock_retval)
+void sd_flash_write_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* p_dst, int p_dst_Depth, uint32_t const* p_src, int p_src_Depth, uint32_t size, uint32_t cmock_to_return);
+#define sd_flash_write_ReturnThruPtr_p_dst(p_dst) sd_flash_write_CMockReturnMemThruPtr_p_dst(__LINE__, p_dst, sizeof(*p_dst))
+#define sd_flash_write_ReturnArrayThruPtr_p_dst(p_dst, cmock_len) sd_flash_write_CMockReturnMemThruPtr_p_dst(__LINE__, p_dst, cmock_len * sizeof(*p_dst))
+#define sd_flash_write_ReturnMemThruPtr_p_dst(p_dst, cmock_size) sd_flash_write_CMockReturnMemThruPtr_p_dst(__LINE__, p_dst, cmock_size)
+void sd_flash_write_CMockReturnMemThruPtr_p_dst(UNITY_LINE_TYPE cmock_line, uint32_t* p_dst, int cmock_size);
+#define sd_flash_write_ReturnThruPtr_p_src(p_src) sd_flash_write_CMockReturnMemThruPtr_p_src(__LINE__, p_src, sizeof(*p_src))
+#define sd_flash_write_ReturnArrayThruPtr_p_src(p_src, cmock_len) sd_flash_write_CMockReturnMemThruPtr_p_src(__LINE__, p_src, cmock_len * sizeof(*p_src))
+#define sd_flash_write_ReturnMemThruPtr_p_src(p_src, cmock_size) sd_flash_write_CMockReturnMemThruPtr_p_src(__LINE__, p_src, cmock_size)
+void sd_flash_write_CMockReturnMemThruPtr_p_src(UNITY_LINE_TYPE cmock_line, uint32_t const* p_src, int cmock_size);
+#define sd_flash_write_IgnoreArg_p_dst() sd_flash_write_CMockIgnoreArg_p_dst(__LINE__)
+void sd_flash_write_CMockIgnoreArg_p_dst(UNITY_LINE_TYPE cmock_line);
+#define sd_flash_write_IgnoreArg_p_src() sd_flash_write_CMockIgnoreArg_p_src(__LINE__)
+void sd_flash_write_CMockIgnoreArg_p_src(UNITY_LINE_TYPE cmock_line);
+#define sd_flash_write_IgnoreArg_size() sd_flash_write_CMockIgnoreArg_size(__LINE__)
+void sd_flash_write_CMockIgnoreArg_size(UNITY_LINE_TYPE cmock_line);
+#define sd_flash_page_erase_IgnoreAndReturn(cmock_retval) sd_flash_page_erase_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_flash_page_erase_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_flash_page_erase_ExpectAndReturn(page_number, cmock_retval) sd_flash_page_erase_CMockExpectAndReturn(__LINE__, page_number, cmock_retval)
+void sd_flash_page_erase_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t page_number, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_flash_page_erase_CALLBACK)(uint32_t page_number, int cmock_num_calls);
+void sd_flash_page_erase_StubWithCallback(CMOCK_sd_flash_page_erase_CALLBACK Callback);
+#define sd_flash_page_erase_IgnoreArg_page_number() sd_flash_page_erase_CMockIgnoreArg_page_number(__LINE__)
+void sd_flash_page_erase_CMockIgnoreArg_page_number(UNITY_LINE_TYPE cmock_line);
+#define sd_flash_protect_IgnoreAndReturn(cmock_retval) sd_flash_protect_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_flash_protect_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_flash_protect_ExpectAndReturn(block_cfg0, block_cfg1, block_cfg2, block_cfg3, cmock_retval) sd_flash_protect_CMockExpectAndReturn(__LINE__, block_cfg0, block_cfg1, block_cfg2, block_cfg3, cmock_retval)
+void sd_flash_protect_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t block_cfg0, uint32_t block_cfg1, uint32_t block_cfg2, uint32_t block_cfg3, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_flash_protect_CALLBACK)(uint32_t block_cfg0, uint32_t block_cfg1, uint32_t block_cfg2, uint32_t block_cfg3, int cmock_num_calls);
+void sd_flash_protect_StubWithCallback(CMOCK_sd_flash_protect_CALLBACK Callback);
+#define sd_flash_protect_IgnoreArg_block_cfg0() sd_flash_protect_CMockIgnoreArg_block_cfg0(__LINE__)
+void sd_flash_protect_CMockIgnoreArg_block_cfg0(UNITY_LINE_TYPE cmock_line);
+#define sd_flash_protect_IgnoreArg_block_cfg1() sd_flash_protect_CMockIgnoreArg_block_cfg1(__LINE__)
+void sd_flash_protect_CMockIgnoreArg_block_cfg1(UNITY_LINE_TYPE cmock_line);
+#define sd_flash_protect_IgnoreArg_block_cfg2() sd_flash_protect_CMockIgnoreArg_block_cfg2(__LINE__)
+void sd_flash_protect_CMockIgnoreArg_block_cfg2(UNITY_LINE_TYPE cmock_line);
+#define sd_flash_protect_IgnoreArg_block_cfg3() sd_flash_protect_CMockIgnoreArg_block_cfg3(__LINE__)
+void sd_flash_protect_CMockIgnoreArg_block_cfg3(UNITY_LINE_TYPE cmock_line);
+#define sd_radio_session_open_IgnoreAndReturn(cmock_retval) sd_radio_session_open_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_radio_session_open_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_radio_session_open_ExpectAndReturn(p_radio_signal_callback, cmock_retval) sd_radio_session_open_CMockExpectAndReturn(__LINE__, p_radio_signal_callback, cmock_retval)
+void sd_radio_session_open_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nrf_radio_signal_callback_t p_radio_signal_callback, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_radio_session_open_CALLBACK)(nrf_radio_signal_callback_t p_radio_signal_callback, int cmock_num_calls);
+void sd_radio_session_open_StubWithCallback(CMOCK_sd_radio_session_open_CALLBACK Callback);
+#define sd_radio_session_open_IgnoreArg_p_radio_signal_callback() sd_radio_session_open_CMockIgnoreArg_p_radio_signal_callback(__LINE__)
+void sd_radio_session_open_CMockIgnoreArg_p_radio_signal_callback(UNITY_LINE_TYPE cmock_line);
+#define sd_radio_session_close_IgnoreAndReturn(cmock_retval) sd_radio_session_close_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_radio_session_close_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_radio_session_close_ExpectAndReturn(cmock_retval) sd_radio_session_close_CMockExpectAndReturn(__LINE__, cmock_retval)
+void sd_radio_session_close_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_radio_session_close_CALLBACK)(int cmock_num_calls);
+void sd_radio_session_close_StubWithCallback(CMOCK_sd_radio_session_close_CALLBACK Callback);
+#define sd_radio_request_IgnoreAndReturn(cmock_retval) sd_radio_request_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_radio_request_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_radio_request_ExpectAndReturn(p_request, cmock_retval) sd_radio_request_CMockExpectAndReturn(__LINE__, p_request, cmock_retval)
+void sd_radio_request_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nrf_radio_request_t* p_request, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_radio_request_CALLBACK)(nrf_radio_request_t* p_request, int cmock_num_calls);
+void sd_radio_request_StubWithCallback(CMOCK_sd_radio_request_CALLBACK Callback);
+#define sd_radio_request_ExpectWithArrayAndReturn(p_request, p_request_Depth, cmock_retval) sd_radio_request_CMockExpectWithArrayAndReturn(__LINE__, p_request, p_request_Depth, cmock_retval)
+void sd_radio_request_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, nrf_radio_request_t* p_request, int p_request_Depth, uint32_t cmock_to_return);
+#define sd_radio_request_ReturnThruPtr_p_request(p_request) sd_radio_request_CMockReturnMemThruPtr_p_request(__LINE__, p_request, sizeof(*p_request))
+#define sd_radio_request_ReturnArrayThruPtr_p_request(p_request, cmock_len) sd_radio_request_CMockReturnMemThruPtr_p_request(__LINE__, p_request, cmock_len * sizeof(*p_request))
+#define sd_radio_request_ReturnMemThruPtr_p_request(p_request, cmock_size) sd_radio_request_CMockReturnMemThruPtr_p_request(__LINE__, p_request, cmock_size)
+void sd_radio_request_CMockReturnMemThruPtr_p_request(UNITY_LINE_TYPE cmock_line, nrf_radio_request_t* p_request, int cmock_size);
+#define sd_radio_request_IgnoreArg_p_request() sd_radio_request_CMockIgnoreArg_p_request(__LINE__)
+void sd_radio_request_CMockIgnoreArg_p_request(UNITY_LINE_TYPE cmock_line);
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_svc.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_svc.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_svc.c 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_svc.c  2018-04-24 08:48:28.948153900 +0200
@@ -0,0 +1,36 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_nrf_svc.h"
+
+static struct mock_nrf_svcInstance
+{
+  unsigned char placeHolder;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_nrf_svc_Verify(void)
+{
+}
+
+void mock_nrf_svc_Init(void)
+{
+  mock_nrf_svc_Destroy();
+}
+
+void mock_nrf_svc_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_svc.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_svc.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/cmock/mock_nrf_svc.h 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/cmock/mock_nrf_svc.h  2018-04-24 08:48:28.948153900 +0200
@@ -0,0 +1,26 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_NRF_SVC_H
+#define _MOCK_NRF_SVC_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include <nrf_svc.h>
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_nrf_svc_Init(void);
+void mock_nrf_svc_Destroy(void);
+void mock_nrf_svc_Verify(void);
+
+
+
+
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble.h    1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble.h 2018-04-24 08:48:28.958154100 +0200
@@ -0,0 +1,681 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @addtogroup BLE_COMMON BLE SoftDevice Common
+  @{
+  @defgroup ble_api Events, type definitions and API calls
+  @{
+
+  @brief Module independent events, type definitions and API calls for the BLE SoftDevice.
+
+ */
+
+#ifndef BLE_H__
+#define BLE_H__
+
+#include "ble_ranges.h"
+#include "ble_types.h"
+#include "ble_gap.h"
+#include "ble_l2cap.h"
+#include "ble_gatt.h"
+#include "ble_gattc.h"
+#include "ble_gatts.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup BLE_COMMON_ENUMERATIONS Enumerations
+ * @{ */
+
+/**
+ * @brief Common API SVC numbers.
+ */
+enum BLE_COMMON_SVCS
+{
+  SD_BLE_ENABLE = BLE_SVC_BASE,         /**< Enable and initialize the BLE stack */
+  SD_BLE_EVT_GET,                       /**< Get an event from the pending events queue. */
+  SD_BLE_TX_PACKET_COUNT_GET,           /**< Get the total number of available application transmission packets for a particular connection. */
+  SD_BLE_UUID_VS_ADD,                   /**< Add a Vendor Specific UUID. */
+  SD_BLE_UUID_DECODE,                   /**< Decode UUID bytes. */
+  SD_BLE_UUID_ENCODE,                   /**< Encode UUID bytes. */
+  SD_BLE_VERSION_GET,                   /**< Get the local version information (company id, Link Layer Version, Link Layer Subversion). */
+  SD_BLE_USER_MEM_REPLY,                /**< User Memory Reply. */
+  SD_BLE_OPT_SET,                       /**< Set a BLE option. */
+  SD_BLE_OPT_GET,                       /**< Get a BLE option. */
+};
+
+  /**
+   * @brief BLE Module Independent Event IDs.
+   */
+enum BLE_COMMON_EVTS
+{
+  BLE_EVT_TX_COMPLETE  = BLE_EVT_BASE,  /**< Transmission Complete. @ref ble_evt_tx_complete_t */
+  BLE_EVT_USER_MEM_REQUEST,             /**< User Memory request. @ref ble_evt_user_mem_request_t */
+  BLE_EVT_USER_MEM_RELEASE,             /**< User Memory release. @ref ble_evt_user_mem_release_t */
+  BLE_EVT_DATA_LENGTH_CHANGED           /**< Link layer PDU length changed. @ref ble_evt_data_length_changed_t. */
+};
+
+/**@brief BLE connection bandwidth types.
+ * Bandwidth types supported by the SoftDevice. The bandwidth type dictates the maximum number of full length packets per connection interval.
+ */
+enum BLE_CONN_BWS
+{
+  BLE_CONN_BW_INVALID = 0,              /**< Invalid connection bandwidth. */
+  BLE_CONN_BW_LOW,                      /**< Low connection bandwidth. */
+  BLE_CONN_BW_MID,                      /**< Medium connection bandwidth. */
+  BLE_CONN_BW_HIGH                      /**< High connection bandwidth. */
+};
+
+/**@brief Common Option IDs.
+ * IDs that uniquely identify a common option.
+ */
+enum BLE_COMMON_OPTS
+{
+  BLE_COMMON_OPT_CONN_BW = BLE_OPT_BASE,     /**< Bandwidth configuration @ref ble_common_opt_conn_bw_t */
+  BLE_COMMON_OPT_PA_LNA,                     /**< PA and LNA options */
+  BLE_COMMON_OPT_CONN_EVT_EXT,               /**< Extended connection events option */
+};
+
+/** @} */
+
+/** @addtogroup BLE_COMMON_DEFINES Defines
+ * @{ */
+
+/** @brief  Required pointer alignment for BLE Events.
+*/
+#define BLE_EVTS_PTR_ALIGNMENT    4
+
+/** @brief  Maximum possible length for BLE Events.
+ * @note Value of @ref ble_gatt_enable_params_t::att_mtu shall be used as a parameter.
+ * If that value is set to 0 then @ref GATT_MTU_SIZE_DEFAULT must be used instead.
+*/
+#define BLE_EVTS_LEN_MAX(ATT_MTU) (MAX( \
+  sizeof(ble_evt_t), \
+  MAX( \
+    offsetof(ble_evt_t, evt.gattc_evt.params.rel_disc_rsp.includes) + ((ATT_MTU) - 2) / 6 * sizeof(ble_gattc_include_t), \
+    offsetof(ble_evt_t, evt.gattc_evt.params.attr_info_disc_rsp.info.attr_info16) + ((ATT_MTU) - 2) / 4 * sizeof(ble_gattc_attr_info16_t) \
+  ) \
+))
+
+/** @defgroup BLE_USER_MEM_TYPES User Memory Types
+ * @{ */
+#define BLE_USER_MEM_TYPE_INVALID               0x00  /**< Invalid User Memory Types. */
+#define BLE_USER_MEM_TYPE_GATTS_QUEUED_WRITES   0x01  /**< User Memory for GATTS queued writes. */
+/** @} */
+
+/** @defgroup BLE_UUID_VS_COUNTS Vendor Specific UUID counts
+ * @{
+ */
+#define BLE_UUID_VS_COUNT_MIN         1    /**< Minimum VS UUID count. */
+#define BLE_UUID_VS_COUNT_DEFAULT     0    /**< Use the default VS UUID count (10 for this version of the SoftDevice). */
+/** @} */
+
+/** @} */
+
+/** @addtogroup BLE_COMMON_STRUCTURES Structures
+ * @{ */
+
+/**@brief User Memory Block. */
+typedef struct
+{
+  uint8_t          *p_mem;      /**< Pointer to the start of the user memory block. */
+  uint16_t          len;        /**< Length in bytes of the user memory block. */
+} ble_user_mem_block_t;
+
+/**
+ * @brief Event structure for @ref BLE_EVT_TX_COMPLETE.
+ */
+typedef struct
+{
+  uint8_t count;                        /**< Number of packets transmitted. */
+} ble_evt_tx_complete_t;
+
+/**@brief Event structure for @ref BLE_EVT_USER_MEM_REQUEST. */
+typedef struct
+{
+  uint8_t                     type;     /**< User memory type, see @ref BLE_USER_MEM_TYPES. */
+} ble_evt_user_mem_request_t;
+
+/**@brief Event structure for @ref BLE_EVT_USER_MEM_RELEASE. */
+typedef struct
+{
+  uint8_t                     type;       /**< User memory type, see @ref BLE_USER_MEM_TYPES. */
+  ble_user_mem_block_t        mem_block;  /**< User memory block */
+} ble_evt_user_mem_release_t;
+
+/**@brief Event structure for @ref BLE_EVT_DATA_LENGTH_CHANGED. */
+typedef struct
+{
+  uint16_t max_tx_octets;                 /**< The maximum number of payload octets in a Link Layer Data Channel PDU that the local Controller will send. Range: 27-251 */
+  uint16_t max_tx_time;                   /**< The maximum time (in microseconds) that the local Controller will take to send a Link Layer Data Channel PDU. Range: 328-2120  */
+  uint16_t max_rx_octets;                 /**< The maximum number of payload octets in a Link Layer Data Channel PDU that the local controller expects to receive. Range: 27-251 */
+  uint16_t max_rx_time;                   /**< The maximum time (in microseconds) that the local Controller expects to take to receive a Link Layer Data Channel PDU. Range: 328-2120 */
+} ble_evt_data_length_changed_t;
+
+/**@brief Event structure for events not associated with a specific function module. */
+typedef struct
+{
+  uint16_t conn_handle;                                 /**< Connection Handle on which this event occurred. */
+  union
+  {
+    ble_evt_tx_complete_t           tx_complete;         /**< Transmission Complete. */
+    ble_evt_user_mem_request_t      user_mem_request;    /**< User Memory Request Event Parameters. */
+    ble_evt_user_mem_release_t      user_mem_release;    /**< User Memory Release Event Parameters. */
+    ble_evt_data_length_changed_t   data_length_changed; /**< Data Length Changed Event Parameters. */
+  } params;                                              /**< Event parameter union. */
+} ble_common_evt_t;
+
+/**@brief BLE Event header. */
+typedef struct
+{
+  uint16_t evt_id;                /**< Value from a BLE_<module>_EVT series. */
+  uint16_t evt_len;               /**< Length in octets including this header. */
+} ble_evt_hdr_t;
+
+/**@brief Common BLE Event type, wrapping the module specific event reports. */
+typedef struct
+{
+  ble_evt_hdr_t header;           /**< Event header. */
+  union
+  {
+    ble_common_evt_t  common_evt; /**< Common Event, evt_id in BLE_EVT_* series. */
+    ble_gap_evt_t     gap_evt;    /**< GAP originated event, evt_id in BLE_GAP_EVT_* series. */
+    ble_l2cap_evt_t   l2cap_evt;  /**< L2CAP originated event, evt_id in BLE_L2CAP_EVT* series. */
+    ble_gattc_evt_t   gattc_evt;  /**< GATT client originated event, evt_id in BLE_GATTC_EVT* series. */
+    ble_gatts_evt_t   gatts_evt;  /**< GATT server originated event, evt_id in BLE_GATTS_EVT* series. */
+  } evt;                          /**< Event union. */
+} ble_evt_t;
+
+
+/**
+ * @brief Version Information.
+ */
+typedef struct
+{
+  uint8_t   version_number;    /**< Link Layer Version number for BT 4.1 spec is 7 (https://www.bluetooth.org/en-us/specification/assigned-numbers/link-layer). */
+  uint16_t  company_id;        /**< Company ID, Nordic Semiconductor's company ID is 89 (0x0059) (https://www.bluetooth.org/apps/content/Default.aspx?doc_id=49708). */
+  uint16_t  subversion_number; /**< Link Layer Sub Version number, corresponds to the SoftDevice Config ID or Firmware ID (FWID). */
+} ble_version_t;
+
+/**
+ * @brief Configuration parameters for the PA and LNA.
+ */
+typedef struct
+{
+     uint8_t enable :1;      /**< Enable toggling for this amplifier */
+     uint8_t active_high :1; /**< Set the pin to be active high */
+     uint8_t gpio_pin :6;    /**< The GPIO pin to toggle for this amplifier */
+} ble_pa_lna_cfg_t;
+
+/**
+ * @brief PA & LNA GPIO toggle configuration
+ *
+ * This option configures the SoftDevice to toggle pins when the radio is active for use with a power amplifier and/or
+ * a low noise amplifier.
+ *
+ * Toggling the pins is achieved by using two PPI channels and a GPIOTE channel. The hardware channel IDs are provided
+ * by the application and should be regarded as reserved as long as any PA/LNA toggling is enabled.
+ *
+ * @note  @ref sd_ble_opt_get is not supported for this option.
+ * @note  This feature is only supported for nRF52, on nRF51 @ref NRF_ERROR_NOT_SUPPORTED will always be returned.
+ * @note  Setting this option while the radio is in use (i.e. any of the roles are active) may have undefined consequences
+ * and must be avoided by the application.
+ */
+typedef struct
+{
+   ble_pa_lna_cfg_t pa_cfg;   /**< Power Amplifier configuration */
+   ble_pa_lna_cfg_t lna_cfg;  /**< Low Noise Amplifier configuration */
+
+   uint8_t ppi_ch_id_set;     /**< PPI channel used for radio pin setting */
+   uint8_t ppi_ch_id_clr;     /**< PPI channel used for radio pin clearing */
+   uint8_t gpiote_ch_id;      /**< GPIOTE channel used for radio pin toggling */
+} ble_common_opt_pa_lna_t;
+
+/**
+ * @brief BLE connection bandwidth configuration parameters
+ */
+typedef struct
+{
+  uint8_t conn_bw_tx;   /**< Connection bandwidth configuration for transmission, see @ref BLE_CONN_BWS.*/
+  uint8_t conn_bw_rx;   /**< Connection bandwidth configuration for reception, see @ref BLE_CONN_BWS.*/
+} ble_conn_bw_t;
+
+/**@brief BLE connection specific bandwidth configuration parameters.
+ *
+ * This can be used with @ref sd_ble_opt_set to set the bandwidth configuration to be used when creating connections.
+ *
+ * Call @ref sd_ble_opt_set with this option prior to calling @ref sd_ble_gap_adv_start or @ref sd_ble_gap_connect.
+ *
+ * The bandwidth configurations set via @ref sd_ble_opt_set are maintained separately for central and peripheral
+ * connections. The given configurations are used for all future connections of the role indicated in this structure
+ * unless they are changed by subsequent @ref sd_ble_opt_set calls.
+ *
+ * @note When this option is not used, the SoftDevice will use the default options:
+ * - @ref BLE_CONN_BW_HIGH for @ref BLE_GAP_ROLE_PERIPH connections (both transmission and reception).
+ * - @ref BLE_CONN_BW_MID for @ref BLE_GAP_ROLE_CENTRAL connections (both transmisison and reception).
+ * This option allows the application to selectively override these defaults for each role.
+ *
+ * @note The global memory pool configuration can be set with the @ref ble_conn_bw_counts_t configuration parameter, which
+ * is provided to @ref sd_ble_enable.
+ *
+ * @note @ref sd_ble_opt_get is not supported for this option.
+ * @note Please refer to SoftDevice Specification for more information on bandwidth configuration.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_COMMON_CONF_BW}
+ * @endmscs
+ *
+ * @retval ::NRF_SUCCESS Set successfully.
+ * @retval ::BLE_ERROR_INVALID_ROLE The role is invalid.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid bandwidth configuration parameters.
+ * @retval ::NRF_ERROR_NOT_SUPPORTED If the combination of role and bandwidth configuration is not supported.
+ */
+typedef struct
+{
+  uint8_t            role;     /**< BLE role of the connection, see @ref BLE_GAP_ROLES. */
+  ble_conn_bw_t      conn_bw;  /**< Bandwidth configuration parameters. */
+} ble_common_opt_conn_bw_t;
+
+/**
+ * @brief Configuration of extended BLE connection events.
+ *
+ * When enabled the SoftDevice will dynamically extend the connection event when possible.
+ *
+ * The connection event length is controlled by the bandwidth configuration as set by @ref ble_common_opt_conn_bw_t.
+ * The connection event can be extended if there is time to send another packet pair before the start of the next connection interval,
+ * and if there are no conflicts with other BLE roles requesting radio time.
+ *
+ * @note @ref sd_ble_opt_get is not supported for this option.
+ */
+typedef struct
+{
+   uint8_t enable : 1; /**< Enable extended BLE connection events, disabled by default. */
+} ble_common_opt_conn_evt_ext_t;
+
+/**@brief Option structure for common options. */
+typedef union
+{
+  ble_common_opt_conn_bw_t      conn_bw;       /**< Parameters for the connection bandwidth option. */
+  ble_common_opt_pa_lna_t       pa_lna;        /**< Parameters for controlling PA and LNA pin toggling. */
+  ble_common_opt_conn_evt_ext_t conn_evt_ext;  /**< Parameters for enabling extended connection events. */
+} ble_common_opt_t;
+
+/**@brief Common BLE Option type, wrapping the module specific options. */
+typedef union
+{
+  ble_common_opt_t  common_opt;         /**< COMMON options, opt_id in @ref BLE_COMMON_OPTS series. */
+  ble_gap_opt_t     gap_opt;            /**< GAP option, opt_id in @ref BLE_GAP_OPTS series. */
+} ble_opt_t;
+
+/**
+ * @brief BLE bandwidth count parameters
+ *
+ * These parameters are used to configure the memory pools allocated within the SoftDevice for application packets
+ * (both transmission and reception) for all connections.
+ *
+ * @note The sum of all three counts must add up to the sum of @ref ble_gap_enable_params_t::central_conn_count and
+ * @ref ble_gap_enable_params_t::periph_conn_count in @ref ble_gap_enable_params_t.
+ */
+typedef struct {
+  uint8_t high_count;   /**< Total number of high bandwidth TX or RX memory pools available to the application at runtime for all active connections. */
+  uint8_t mid_count;    /**< Total number of medium bandwidth TX or RX memory pools available to the application at runtime for all active connections. */
+  uint8_t low_count;    /**< Total number of low bandwidth TX or RX memory pools available to the application at runtime for all active connections. */
+} ble_conn_bw_count_t;
+
+/**
+ * @brief BLE bandwidth global memory pool configuration parameters
+ *
+ * These configuration parameters are used to set the amount of memory dedicated to application packets for
+ * all connections. The application should specify the most demanding configuration for the intended use.
+ *
+ * Please refer to the SoftDevice Specification for more information on bandwidth configuration.
+ *
+ * @note Each connection created at runtime requires both a TX and an RX memory pool. By the use of these configuration
+ * parameters, the application can decide the size and total number of the global memory pools that will be later
+ * available for connection creation.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_COMMON_CONF_BW}
+ * @endmscs
+ *
+ */
+typedef struct {
+  ble_conn_bw_count_t tx_counts;   /**< Global memory pool configuration for transmission.*/
+  ble_conn_bw_count_t rx_counts;   /**< Global memory pool configuration for reception.*/
+} ble_conn_bw_counts_t;
+
+/**
+ * @brief BLE Common Initialization parameters.
+ *
+ * @note If @ref p_conn_bw_counts is NULL the SoftDevice will assume default bandwidth configuration for all connections.
+ * To fit a custom bandwidth configuration requirement, the application developer may have to specify a custom memory
+ * pool configuration here. See @ref ble_common_opt_conn_bw_t for bandwidth configuration of individual connections.
+ * Please refer to the SoftDevice Specification for more information on bandwidth configuration.
+ */
+typedef struct
+{
+  uint16_t                  vs_uuid_count;     /**< Maximum number of 128-bit, Vendor Specific UUID bases to allocate. */
+  ble_conn_bw_counts_t      *p_conn_bw_counts; /**< Bandwidth configuration parameters or NULL for defaults. */
+} ble_common_enable_params_t;
+
+/**
+ * @brief BLE Initialization parameters.
+ */
+typedef struct
+{
+  ble_common_enable_params_t        common_enable_params;  /**< Common init parameters @ref ble_common_enable_params_t. */
+  ble_gap_enable_params_t           gap_enable_params;     /**< GAP init parameters @ref ble_gap_enable_params_t. */
+  ble_gatt_enable_params_t          gatt_enable_params;    /**< GATT init parameters @ref ble_gatt_enable_params_t. */
+  ble_gatts_enable_params_t         gatts_enable_params;   /**< GATTS init parameters @ref ble_gatts_enable_params_t. */
+} ble_enable_params_t;
+
+/** @} */
+
+/** @addtogroup BLE_COMMON_FUNCTIONS Functions
+ * @{ */
+
+/**@brief Enable the BLE stack
+ *
+ * @param[in, out] p_ble_enable_params Pointer to ble_enable_params_t
+ * @param[in, out] p_app_ram_base      Pointer to a variable containing the start address of the application RAM region
+ * (APP_RAM_BASE). On return, this will contain the minimum start address of the application RAM region required by the
+ * SoftDevice for this configuration. Calling @ref sd_ble_enable() with *p_app_ram_base set to 0 can be used during
+ * development to find out how much memory a specific configuration will need.
+ *
+ * @note The memory requirement for a specific configuration will not increase between SoftDevices with the same major
+ * version number.
+ *
+ * @note At runtime the IC's RAM is split into 2 regions: The SoftDevice RAM region is located between 0x20000000 and
+ *       APP_RAM_BASE-1 and the application's RAM region is located between APP_RAM_BASE and the start of the call stack.
+ *
+ * @details This call initializes the BLE stack, no other BLE related function can be called before this one.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_COMMON_ENABLE}
+ * @endmscs
+ *
+ * @retval ::NRF_SUCCESS              The BLE stack has been initialized successfully.
+ * @retval ::NRF_ERROR_INVALID_STATE  The BLE stack had already been initialized and cannot be reinitialized.
+ * @retval ::NRF_ERROR_INVALID_ADDR   Invalid or not sufficiently aligned pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_LENGTH One or more of the following is true:
+ *                                    - The specified Attribute Table size is too small.
+ *                                      The minimum acceptable size is defined by @ref BLE_GATTS_ATTR_TAB_SIZE_MIN.
+ *                                    - The specified Attribute Table size is not a multiple of 4.
+ *                                    - The device name length is invalid (must be between 0 and @ref BLE_GAP_DEVNAME_MAX_LEN).
+ *                                    - The device name length is too long for the given Attribute Table.
+ * @retval ::NRF_ERROR_INVALID_PARAM  One or more of the following is true:
+ *                                    - Incorrectly configured VS UUID count.
+ *                                    - Invalid connection count parameters.
+ *                                    - Invalid device name location (vloc).
+ *                                    - Invalid device name security mode.
+ *                                    - Invalid maximum ATT_MTU size, see @ref ble_gatt_enable_params_t::att_mtu.
+ * @retval ::NRF_ERROR_NOT_SUPPORTED  Device name security mode is not supported.
+ * @retval ::NRF_ERROR_NO_MEM         The amount of memory assigned to the SoftDevice by *p_app_ram_base is not
+ *                                    large enough to fit this configuration's memory requirement. Check *p_app_ram_base
+ *                                    and set the start address of the application RAM region accordingly.
+ * @retval ::NRF_ERROR_CONN_COUNT     The requested number of connections exceeds the maximum supported by the SoftDevice.
+ *                                    Please refer to the SoftDevice Specification for more information on role configuration.
+ */
+SVCALL(SD_BLE_ENABLE, uint32_t, sd_ble_enable(ble_enable_params_t * p_ble_enable_params, uint32_t * p_app_ram_base));
+
+/**@brief Get an event from the pending events queue.
+ *
+ * @param[out] p_dest Pointer to buffer to be filled in with an event, or NULL to retrieve the event length.
+ *                    This buffer <b>must be aligned to the extend defined by @ref BLE_EVTS_PTR_ALIGNMENT</b>.
+ * @param[in, out] p_len Pointer the length of the buffer, on return it is filled with the event length.
+ *
+ * @details This call allows the application to pull a BLE event from the BLE stack. The application is signaled that
+ * an event is available from the BLE stack by the triggering of the SD_EVT_IRQn interrupt.
+ * The application is free to choose whether to call this function from thread mode (main context) or directly from the
+ * Interrupt Service Routine that maps to SD_EVT_IRQn. In any case however, and because the BLE stack runs at a higher
+ * priority than the application, this function should be called in a loop (until @ref NRF_ERROR_NOT_FOUND is returned)
+ * every time SD_EVT_IRQn is raised to ensure that all available events are pulled from the BLE stack. Failure to do so
+ * could potentially leave events in the internal queue without the application being aware of this fact. Sizing the
+ * p_dest buffer is equally important, since the application needs to provide all the memory necessary for the event to
+ * be copied into application memory. If the buffer provided is not large enough to fit the entire contents of the event,
+ * @ref NRF_ERROR_DATA_SIZE will be returned and the application can then call again with a larger buffer size.
+ * The maximum possible event length is defined by @ref BLE_EVTS_LEN_MAX. The application may also "peek" the event length
+ * by providing p_dest as a NULL pointer and inspecting the value of *p_len upon return:
+ *
+ *     \code
+ *     uint16_t len;
+ *     errcode = sd_ble_evt_get(NULL, &len);
+ *     \endcode
+ *
+ * @mscs
+ * @mmsc{@ref BLE_COMMON_IRQ_EVT_MSC}
+ * @mmsc{@ref BLE_COMMON_THREAD_EVT_MSC}
+ * @endmscs
+ *
+ * @retval ::NRF_SUCCESS Event pulled and stored into the supplied buffer.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid or not sufficiently aligned pointer supplied.
+ * @retval ::NRF_ERROR_NOT_FOUND No events ready to be pulled.
+ * @retval ::NRF_ERROR_DATA_SIZE Event ready but could not fit into the supplied buffer.
+ */
+SVCALL(SD_BLE_EVT_GET, uint32_t, sd_ble_evt_get(uint8_t *p_dest, uint16_t *p_len));
+
+
+/**@brief Get the total number of available guaranteed application transmission packets for a particular connection.
+ *
+ * @details This call allows the application to obtain the total number of guaranteed application transmission packets
+ * available for a connection. Please note that this does not return the number of free packets, but rather the total
+ * amount of them for that particular connection. The application has two options to handle transmitting application packets:
+ * - Use a simple arithmetic calculation: after connection creation time the application should use this function to
+ * find out the total amount of guaranteed packets available to it and store it in a variable.
+ * Every time a packet is successfully queued for a transmission on this connection using any of the exposed functions in
+ * this  BLE API, the application should decrement that variable. Conversely, whenever a @ref BLE_EVT_TX_COMPLETE event
+ * with the conn_handle matching the particular connection is received by the application, it should retrieve the count
+ * field in such event and add that number to the same variable storing the number of available guaranteed packets. This
+ * mechanism allows the application to be aware at any time of the number of guaranteed application packets available for
+ * each of the active connections, and therefore it can know with certainty whether it is possible to send more data or
+ * it has to wait for a @ref BLE_EVT_TX_COMPLETE event before it proceeds.
+ * The application can still pursue transmissions when the number of guaranteed application packets available is smaller
+ * than or equal to zero, but successful queuing of the tranmsission is not guaranteed.
+ * - Choose to simply not keep track of available packets at all, and instead handle the @ref BLE_ERROR_NO_TX_PACKETS error
+ * by queueing the packet to be transmitted and try again as soon as a @ref BLE_EVT_TX_COMPLETE event arrives.
+ *
+ * The API functions that <b>may</b> consume an application packet depending on the parameters supplied to them can be found below:
+ * - @ref sd_ble_gattc_write (write without response only)
+ * - @ref sd_ble_gatts_hvx (notifications only)
+ * - @ref sd_ble_l2cap_tx (all packets)
+ *
+ * @param[in]  conn_handle Connection handle.
+ * @param[out] p_count Pointer to a uint8_t which will contain the number of application transmission packets upon
+ *                     successful return.
+ * @mscs
+ * @mmsc{@ref BLE_COMMON_APP_BUFF_MSC}
+ * @endmscs
+ *
+ * @retval ::NRF_SUCCESS Number of application transmission packets retrieved successfully.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ */
+SVCALL(SD_BLE_TX_PACKET_COUNT_GET, uint32_t, sd_ble_tx_packet_count_get(uint16_t conn_handle, uint8_t *p_count));
+
+
+/**@brief Add a Vendor Specific base UUID.
+ *
+ * @details This call enables the application to add a vendor specific base UUID to the BLE stack's table, for later
+ * use with all other modules and APIs. This then allows the application to use the shorter, 24-bit @ref ble_uuid_t
+ * format when dealing with both 16-bit and 128-bit UUIDs without having to check for lengths and having split code
+ * paths. This is accomplished by extending the grouping mechanism that the Bluetooth SIG standard base UUID uses
+ * for all other 128-bit UUIDs. The type field in the @ref ble_uuid_t structure is an index (relative to
+ * @ref BLE_UUID_TYPE_VENDOR_BEGIN) to the table populated by multiple calls to this function, and the uuid field
+ * in the same structure contains the 2 bytes at indices 12 and 13. The number of possible 128-bit UUIDs available to
+ * the application is therefore the number of Vendor Specific UUIDs added with the help of this function times 65536,
+ * although restricted to modifying bytes 12 and 13 for each of the entries in the supplied array.
+ *
+ * @note Bytes 12 and 13 of the provided UUID will not be used internally, since those are always replaced by
+ * the 16-bit uuid field in @ref ble_uuid_t.
+ *
+ * @note If a UUID is already present in the BLE stack's internal table, the corresponding index will be returned in
+ * p_uuid_type along with an NRF_SUCCESS error code.
+ *
+ * @param[in]  p_vs_uuid    Pointer to a 16-octet (128-bit) little endian Vendor Specific UUID disregarding
+ *                          bytes 12 and 13.
+ * @param[out] p_uuid_type  Pointer to a uint8_t where the type field in @ref ble_uuid_t corresponding to this UUID will be stored.
+ *
+ * @retval ::NRF_SUCCESS Successfully added the Vendor Specific UUID.
+ * @retval ::NRF_ERROR_INVALID_ADDR If p_vs_uuid or p_uuid_type is NULL or invalid.
+ * @retval ::NRF_ERROR_NO_MEM If there are no more free slots for VS UUIDs.
+ */
+SVCALL(SD_BLE_UUID_VS_ADD, uint32_t, sd_ble_uuid_vs_add(ble_uuid128_t const *p_vs_uuid, uint8_t *p_uuid_type));
+
+
+/** @brief Decode little endian raw UUID bytes (16-bit or 128-bit) into a 24 bit @ref ble_uuid_t structure.
+ *
+ * @details The raw UUID bytes excluding bytes 12 and 13 (i.e. bytes 0-11 and 14-15) of p_uuid_le are compared
+ * to the corresponding ones in each entry of the table of vendor specific UUIDs populated with @ref sd_ble_uuid_vs_add
+ * to look for a match. If there is such a match, bytes 12 and 13 are returned as p_uuid->uuid and the index
+ * relative to @ref BLE_UUID_TYPE_VENDOR_BEGIN as p_uuid->type.
+ *
+ * @note If the UUID length supplied is 2, then the type set by this call will always be @ref BLE_UUID_TYPE_BLE.
+ *
+ * @param[in]   uuid_le_len Length in bytes of the buffer pointed to by p_uuid_le (must be 2 or 16 bytes).
+ * @param[in]   p_uuid_le   Pointer pointing to little endian raw UUID bytes.
+ * @param[out]  p_uuid      Pointer to a @ref ble_uuid_t structure to be filled in.
+ *
+ * @retval ::NRF_SUCCESS Successfully decoded into the @ref ble_uuid_t structure.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_LENGTH Invalid UUID length.
+ * @retval ::NRF_ERROR_NOT_FOUND For a 128-bit UUID, no match in the populated table of UUIDs.
+ */
+SVCALL(SD_BLE_UUID_DECODE, uint32_t, sd_ble_uuid_decode(uint8_t uuid_le_len, uint8_t const *p_uuid_le, ble_uuid_t *p_uuid));
+
+
+/** @brief Encode a @ref ble_uuid_t structure into little endian raw UUID bytes (16-bit or 128-bit).
+ *
+ * @note The pointer to the destination buffer p_uuid_le may be NULL, in which case only the validity and size of p_uuid is computed.
+ *
+ * @param[in]   p_uuid        Pointer to a @ref ble_uuid_t structure that will be encoded into bytes.
+ * @param[out]  p_uuid_le_len Pointer to a uint8_t that will be filled with the encoded length (2 or 16 bytes).
+ * @param[out]  p_uuid_le     Pointer to a buffer where the little endian raw UUID bytes (2 or 16) will be stored.
+ *
+ * @retval ::NRF_SUCCESS Successfully encoded into the buffer.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid UUID type.
+ */
+SVCALL(SD_BLE_UUID_ENCODE, uint32_t, sd_ble_uuid_encode(ble_uuid_t const *p_uuid, uint8_t *p_uuid_le_len, uint8_t *p_uuid_le));
+
+
+/**@brief Get Version Information.
+ *
+ * @details This call allows the application to get the BLE stack version information.
+ *
+ * @param[out] p_version Pointer to a ble_version_t structure to be filled in.
+ *
+ * @retval ::NRF_SUCCESS  Version information stored successfully.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_BUSY The BLE stack is busy (typically doing a locally-initiated disconnection procedure).
+ */
+SVCALL(SD_BLE_VERSION_GET, uint32_t, sd_ble_version_get(ble_version_t *p_version));
+
+
+/**@brief Provide a user memory block.
+ *
+ * @note This call can only be used as a response to a @ref BLE_EVT_USER_MEM_REQUEST event issued to the application.
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in,out] p_block Pointer to a user memory block structure.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_PEER_CANCEL_MSC}
+ * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_AUTH_MSC}
+ * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_NOAUTH_MSC}
+ * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_BUF_AUTH_MSC}
+ * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_BUF_NOAUTH_MSC}
+ * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_QUEUE_FULL_MSC}
+ * @endmscs
+ *
+ * @retval ::NRF_SUCCESS Successfully queued a response to the peer.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection state or no execute write request pending.
+ * @retval ::NRF_ERROR_BUSY The BLE stack is busy. Retry at later time.
+ */
+SVCALL(SD_BLE_USER_MEM_REPLY, uint32_t, sd_ble_user_mem_reply(uint16_t conn_handle, ble_user_mem_block_t const *p_block));
+
+/**@brief Set a BLE option.
+ *
+ * @details This call allows the application to set the value of an option.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_BONDING_STATIC_PK_MSC}
+ * @mmsc{@ref BLE_COMMON_CONF_BW}
+ * @endmscs
+ *
+ * @param[in] opt_id Option ID, see @ref BLE_COMMON_OPTS and @ref BLE_GAP_OPTS.
+ * @param[in] p_opt Pointer to a ble_opt_t structure containing the option value.
+ *
+ * @retval ::NRF_SUCCESS  Option set successfully.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check parameter limits and constraints.
+ * @retval ::NRF_ERROR_INVALID_STATE Unable to set the parameter at this time.
+ * @retval ::NRF_ERROR_BUSY The BLE stack is busy or the previous procedure has not completed.
+ */
+SVCALL(SD_BLE_OPT_SET, uint32_t, sd_ble_opt_set(uint32_t opt_id, ble_opt_t const *p_opt));
+
+
+/**@brief Get a BLE option.
+ *
+ * @details This call allows the application to retrieve the value of an option.
+ *
+ * @param[in] opt_id Option ID, see @ref BLE_COMMON_OPTS and @ref BLE_GAP_OPTS.
+ * @param[out] p_opt Pointer to a ble_opt_t structure to be filled in.
+ *
+ * @retval ::NRF_SUCCESS  Option retrieved successfully.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check parameter limits and constraints.
+ * @retval ::NRF_ERROR_INVALID_STATE Unable to retrieve the parameter at this time.
+ * @retval ::NRF_ERROR_BUSY The BLE stack is busy or the previous procedure has not completed.
+ * @retval ::NRF_ERROR_NOT_SUPPORTED This option is not supported.
+ *
+ */
+SVCALL(SD_BLE_OPT_GET, uint32_t, sd_ble_opt_get(uint32_t opt_id, ble_opt_t *p_opt));
+
+/** @} */
+#ifdef __cplusplus
+}
+#endif
+#endif /* BLE_H__ */
+
+/**
+  @}
+  @}
+*/
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_err.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_err.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_err.h    1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_err.h 2018-04-24 08:48:28.958154100 +0200
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @addtogroup BLE_COMMON
+  @{
+  @addtogroup  nrf_error
+  @{
+    @ingroup BLE_COMMON
+  @}
+
+  @defgroup ble_err General error codes
+  @{
+
+  @brief General error code definitions for the BLE API.
+
+  @ingroup BLE_COMMON
+*/
+#ifndef NRF_BLE_ERR_H__
+#define NRF_BLE_ERR_H__
+
+#include "nrf_error.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* @defgroup BLE_ERRORS Error Codes
+ * @{ */
+#define BLE_ERROR_NOT_ENABLED            (NRF_ERROR_STK_BASE_NUM+0x001) /**< @ref sd_ble_enable has not been called. */
+#define BLE_ERROR_INVALID_CONN_HANDLE    (NRF_ERROR_STK_BASE_NUM+0x002) /**< Invalid connection handle. */
+#define BLE_ERROR_INVALID_ATTR_HANDLE    (NRF_ERROR_STK_BASE_NUM+0x003) /**< Invalid attribute handle. */
+#define BLE_ERROR_NO_TX_PACKETS          (NRF_ERROR_STK_BASE_NUM+0x004) /**< Not enough application packets available on this connection. */
+#define BLE_ERROR_INVALID_ROLE           (NRF_ERROR_STK_BASE_NUM+0x005) /**< Invalid role. */
+/** @} */
+
+
+/** @defgroup BLE_ERROR_SUBRANGES Module specific error code subranges
+ *  @brief Assignment of subranges for module specific error codes.
+ *  @note For specific error codes, see ble_<module>.h or ble_error_<module>.h.
+ * @{ */
+#define NRF_L2CAP_ERR_BASE             (NRF_ERROR_STK_BASE_NUM+0x100) /**< L2CAP specific errors. */
+#define NRF_GAP_ERR_BASE               (NRF_ERROR_STK_BASE_NUM+0x200) /**< GAP specific errors. */
+#define NRF_GATTC_ERR_BASE             (NRF_ERROR_STK_BASE_NUM+0x300) /**< GATT client specific errors. */
+#define NRF_GATTS_ERR_BASE             (NRF_ERROR_STK_BASE_NUM+0x400) /**< GATT server specific errors. */
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
+
+/**
+  @}
+  @}
+*/
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_gap.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_gap.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_gap.h    1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_gap.h 2018-04-24 08:48:28.968154300 +0200
@@ -0,0 +1,1917 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @addtogroup BLE_GAP Generic Access Profile (GAP)
+  @{
+  @brief Definitions and prototypes for the GAP interface.
+ */
+
+#ifndef BLE_GAP_H__
+#define BLE_GAP_H__
+
+#include "ble_types.h"
+#include "ble_ranges.h"
+#include "nrf_svc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**@addtogroup BLE_GAP_ENUMERATIONS Enumerations
+ * @{ */
+
+/**@brief GAP API SVC numbers.
+ */
+enum BLE_GAP_SVCS
+{
+  SD_BLE_GAP_ADDR_SET = BLE_GAP_SVC_BASE,       /**< Set own Bluetooth Address. */
+  SD_BLE_GAP_ADDR_GET,                          /**< Get own Bluetooth Address. */
+  SD_BLE_GAP_WHITELIST_SET,                     /**< Set active whitelist. */
+  SD_BLE_GAP_DEVICE_IDENTITIES_SET,             /**< Set device identity list. */
+  SD_BLE_GAP_PRIVACY_SET,                       /**< Set Privacy settings*/
+  SD_BLE_GAP_PRIVACY_GET,                       /**< Get Privacy settings*/
+  SD_BLE_GAP_ADV_DATA_SET,                      /**< Set Advertising Data. */
+  SD_BLE_GAP_ADV_START,                         /**< Start Advertising. */
+  SD_BLE_GAP_ADV_STOP,                          /**< Stop Advertising. */
+  SD_BLE_GAP_CONN_PARAM_UPDATE,                 /**< Connection Parameter Update. */
+  SD_BLE_GAP_DISCONNECT,                        /**< Disconnect. */
+  SD_BLE_GAP_TX_POWER_SET,                      /**< Set TX Power. */
+  SD_BLE_GAP_APPEARANCE_SET,                    /**< Set Appearance. */
+  SD_BLE_GAP_APPEARANCE_GET,                    /**< Get Appearance. */
+  SD_BLE_GAP_PPCP_SET,                          /**< Set PPCP. */
+  SD_BLE_GAP_PPCP_GET,                          /**< Get PPCP. */
+  SD_BLE_GAP_DEVICE_NAME_SET,                   /**< Set Device Name. */
+  SD_BLE_GAP_DEVICE_NAME_GET,                   /**< Get Device Name. */
+  SD_BLE_GAP_AUTHENTICATE,                      /**< Initiate Pairing/Bonding. */
+  SD_BLE_GAP_SEC_PARAMS_REPLY,                  /**< Reply with Security Parameters. */
+  SD_BLE_GAP_AUTH_KEY_REPLY,                    /**< Reply with an authentication key. */
+  SD_BLE_GAP_LESC_DHKEY_REPLY,                  /**< Reply with an LE Secure Connections DHKey. */
+  SD_BLE_GAP_KEYPRESS_NOTIFY,                   /**< Notify of a keypress during an authentication procedure. */
+  SD_BLE_GAP_LESC_OOB_DATA_GET,                 /**< Get the local LE Secure Connections OOB data. */
+  SD_BLE_GAP_LESC_OOB_DATA_SET,                 /**< Set the remote LE Secure Connections OOB data. */
+  SD_BLE_GAP_ENCRYPT,                           /**< Initiate encryption procedure. */
+  SD_BLE_GAP_SEC_INFO_REPLY,                    /**< Reply with Security Information. */
+  SD_BLE_GAP_CONN_SEC_GET,                      /**< Obtain connection security level. */
+  SD_BLE_GAP_RSSI_START,                        /**< Start reporting of changes in RSSI. */
+  SD_BLE_GAP_RSSI_STOP,                         /**< Stop reporting of changes in RSSI. */
+  SD_BLE_GAP_SCAN_START,                        /**< Start Scanning. */
+  SD_BLE_GAP_SCAN_STOP,                         /**< Stop Scanning. */
+  SD_BLE_GAP_CONNECT,                           /**< Connect. */
+  SD_BLE_GAP_CONNECT_CANCEL,                    /**< Cancel ongoing connection procedure. */
+  SD_BLE_GAP_RSSI_GET,                          /**< Get the last RSSI sample. */
+};
+
+/**@brief GAP Event IDs.
+ * IDs that uniquely identify an event coming from the stack to the application.
+ */
+enum BLE_GAP_EVTS
+{
+  BLE_GAP_EVT_CONNECTED  = BLE_GAP_EVT_BASE,    /**< Connection established.                         \n See @ref ble_gap_evt_connected_t.            */
+  BLE_GAP_EVT_DISCONNECTED,                     /**< Disconnected from peer.                         \n See @ref ble_gap_evt_disconnected_t.         */
+  BLE_GAP_EVT_CONN_PARAM_UPDATE,                /**< Connection Parameters updated.                  \n See @ref ble_gap_evt_conn_param_update_t.    */
+  BLE_GAP_EVT_SEC_PARAMS_REQUEST,               /**< Request to provide security parameters.         \n Reply with @ref sd_ble_gap_sec_params_reply.  \n See @ref ble_gap_evt_sec_params_request_t. */
+  BLE_GAP_EVT_SEC_INFO_REQUEST,                 /**< Request to provide security information.        \n Reply with @ref sd_ble_gap_sec_info_reply.    \n See @ref ble_gap_evt_sec_info_request_t.   */
+  BLE_GAP_EVT_PASSKEY_DISPLAY,                  /**< Request to display a passkey to the user.       \n In LESC Numeric Comparison, reply with @ref sd_ble_gap_auth_key_reply. \n See @ref ble_gap_evt_passkey_display_t. */
+  BLE_GAP_EVT_KEY_PRESSED,                      /**< Notification of a keypress on the remote device.\n See @ref ble_gap_evt_key_pressed_t           */
+  BLE_GAP_EVT_AUTH_KEY_REQUEST,                 /**< Request to provide an authentication key.       \n Reply with @ref sd_ble_gap_auth_key_reply.    \n See @ref ble_gap_evt_auth_key_request_t.   */
+  BLE_GAP_EVT_LESC_DHKEY_REQUEST,               /**< Request to calculate an LE Secure Connections DHKey. \n Reply with @ref sd_ble_gap_lesc_dhkey_reply.  \n See @ref ble_gap_evt_lesc_dhkey_request_t */
+  BLE_GAP_EVT_AUTH_STATUS,                      /**< Authentication procedure completed with status. \n See @ref ble_gap_evt_auth_status_t.          */
+  BLE_GAP_EVT_CONN_SEC_UPDATE,                  /**< Connection security updated.                    \n See @ref ble_gap_evt_conn_sec_update_t.      */
+  BLE_GAP_EVT_TIMEOUT,                          /**< Timeout expired.                                \n See @ref ble_gap_evt_timeout_t.              */
+  BLE_GAP_EVT_RSSI_CHANGED,                     /**< RSSI report.                                    \n See @ref ble_gap_evt_rssi_changed_t.         */
+  BLE_GAP_EVT_ADV_REPORT,                       /**< Advertising report.                             \n See @ref ble_gap_evt_adv_report_t.           */
+  BLE_GAP_EVT_SEC_REQUEST,                      /**< Security Request.                               \n See @ref ble_gap_evt_sec_request_t.          */
+  BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST,        /**< Connection Parameter Update Request.            \n Reply with @ref sd_ble_gap_conn_param_update. \n See @ref ble_gap_evt_conn_param_update_request_t. */
+  BLE_GAP_EVT_SCAN_REQ_REPORT,                  /**< Scan request report.                            \n See @ref ble_gap_evt_scan_req_report_t.      */
+};
+
+/**@brief GAP Option IDs.
+ * IDs that uniquely identify a GAP option.
+ */
+enum BLE_GAP_OPTS
+{
+  BLE_GAP_OPT_CH_MAP  = BLE_GAP_OPT_BASE,       /**< Channel Map. @ref ble_gap_opt_ch_map_t  */
+  BLE_GAP_OPT_LOCAL_CONN_LATENCY,               /**< Local connection latency. @ref ble_gap_opt_local_conn_latency_t */
+  BLE_GAP_OPT_PASSKEY,                          /**< Set passkey. @ref ble_gap_opt_passkey_t */
+  BLE_GAP_OPT_SCAN_REQ_REPORT,                  /**< Scan request report. @ref ble_gap_opt_scan_req_report_t */
+  BLE_GAP_OPT_COMPAT_MODE,                      /**< Compatibility mode. @ref ble_gap_opt_compat_mode_t */
+  BLE_GAP_OPT_AUTH_PAYLOAD_TIMEOUT,             /**< Set Authenticated payload timeout. @ref ble_gap_opt_auth_payload_timeout_t */
+  BLE_GAP_OPT_EXT_LEN,                          /**< Extended length packets. @ref ble_gap_opt_ext_len_t */
+};
+
+/** @} */
+
+/**@addtogroup BLE_GAP_DEFINES Defines
+ * @{ */
+
+/**@defgroup BLE_ERRORS_GAP SVC return values specific to GAP
+ * @{ */
+#define BLE_ERROR_GAP_UUID_LIST_MISMATCH            (NRF_GAP_ERR_BASE + 0x000)  /**< UUID list does not contain an integral number of UUIDs. */
+#define BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST   (NRF_GAP_ERR_BASE + 0x001)  /**< Use of Whitelist not permitted with discoverable advertising. */
+#define BLE_ERROR_GAP_INVALID_BLE_ADDR              (NRF_GAP_ERR_BASE + 0x002)  /**< The upper two bits of the address do not correspond to the specified address type. */
+#define BLE_ERROR_GAP_WHITELIST_IN_USE              (NRF_GAP_ERR_BASE + 0x003)  /**< Attempt to modify the whitelist while already in use by another operation. */
+#define BLE_ERROR_GAP_DEVICE_IDENTITIES_IN_USE      (NRF_GAP_ERR_BASE + 0x004)  /**< Attempt to modify the device identity list while already in use by another operation. */
+#define BLE_ERROR_GAP_DEVICE_IDENTITIES_DUPLICATE   (NRF_GAP_ERR_BASE + 0x005)  /**< The device identity list contains entries with duplicate identity addresses. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_ROLES GAP Roles
+ * @note Not explicitly used in peripheral API, but will be relevant for central API.
+ * @{ */
+#define BLE_GAP_ROLE_INVALID     0x0            /**< Invalid Role. */
+#define BLE_GAP_ROLE_PERIPH      0x1            /**< Peripheral Role. */
+#define BLE_GAP_ROLE_CENTRAL     0x2            /**< Central Role. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_TIMEOUT_SOURCES GAP Timeout sources
+ * @{ */
+#define BLE_GAP_TIMEOUT_SRC_ADVERTISING                0x00 /**< Advertising timeout. */
+#define BLE_GAP_TIMEOUT_SRC_SECURITY_REQUEST           0x01 /**< Security request timeout. */
+#define BLE_GAP_TIMEOUT_SRC_SCAN                       0x02 /**< Scanning timeout. */
+#define BLE_GAP_TIMEOUT_SRC_CONN                       0x03 /**< Connection timeout. */
+#define BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD               0x04 /**< Authenticated payload timeout. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_ADDR_TYPES GAP Address types
+ * @{ */
+#define BLE_GAP_ADDR_TYPE_PUBLIC                        0x00 /**< Public address. */
+#define BLE_GAP_ADDR_TYPE_RANDOM_STATIC                 0x01 /**< Random static address. */
+#define BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE     0x02 /**< Random private resolvable address. */
+#define BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE 0x03 /**< Random private non-resolvable address. */
+/**@} */
+
+
+/**@brief The default interval in seconds at which a private address is refreshed.  */
+#define BLE_GAP_DEFAULT_PRIVATE_ADDR_CYCLE_INTERVAL_S (900) /* 15 minutes. */
+/**@brief The maximum interval in seconds at which a private address can be refreshed.  */
+#define BLE_GAP_MAX_PRIVATE_ADDR_CYCLE_INTERVAL_S     (41400) /* 11 hours 30 minutes. */
+
+
+/** @brief BLE address length. */
+#define BLE_GAP_ADDR_LEN (6)
+
+
+/**@defgroup BLE_GAP_PRIVACY_MODES Privacy modes
+ * @{ */
+#define BLE_GAP_PRIVACY_MODE_OFF                       0x00 /**< Device will send and accept its identity address for its own address. */
+#define BLE_GAP_PRIVACY_MODE_DEVICE_PRIVACY            0x01 /**< Device will send and accept only private addresses for its own address. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_AD_TYPE_DEFINITIONS GAP Advertising and Scan Response Data format
+ * @note Found at https://www.bluetooth.org/Technical/AssignedNumbers/generic_access_profile.htm
+ * @{ */
+#define BLE_GAP_AD_TYPE_FLAGS                               0x01 /**< Flags for discoverability. */
+#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE   0x02 /**< Partial list of 16 bit service UUIDs. */
+#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE         0x03 /**< Complete list of 16 bit service UUIDs. */
+#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_MORE_AVAILABLE   0x04 /**< Partial list of 32 bit service UUIDs. */
+#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_COMPLETE         0x05 /**< Complete list of 32 bit service UUIDs. */
+#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE  0x06 /**< Partial list of 128 bit service UUIDs. */
+#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE        0x07 /**< Complete list of 128 bit service UUIDs. */
+#define BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME                    0x08 /**< Short local device name. */
+#define BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME                 0x09 /**< Complete local device name. */
+#define BLE_GAP_AD_TYPE_TX_POWER_LEVEL                      0x0A /**< Transmit power level. */
+#define BLE_GAP_AD_TYPE_CLASS_OF_DEVICE                     0x0D /**< Class of device. */
+#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C               0x0E /**< Simple Pairing Hash C. */
+#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R         0x0F /**< Simple Pairing Randomizer R. */
+#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_TK_VALUE           0x10 /**< Security Manager TK Value. */
+#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_OOB_FLAGS          0x11 /**< Security Manager Out Of Band Flags. */
+#define BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE     0x12 /**< Slave Connection Interval Range. */
+#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT       0x14 /**< List of 16-bit Service Solicitation UUIDs. */
+#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT      0x15 /**< List of 128-bit Service Solicitation UUIDs. */
+#define BLE_GAP_AD_TYPE_SERVICE_DATA                        0x16 /**< Service Data - 16-bit UUID. */
+#define BLE_GAP_AD_TYPE_PUBLIC_TARGET_ADDRESS               0x17 /**< Public Target Address. */
+#define BLE_GAP_AD_TYPE_RANDOM_TARGET_ADDRESS               0x18 /**< Random Target Address. */
+#define BLE_GAP_AD_TYPE_APPEARANCE                          0x19 /**< Appearance. */
+#define BLE_GAP_AD_TYPE_ADVERTISING_INTERVAL                0x1A /**< Advertising Interval. */
+#define BLE_GAP_AD_TYPE_LE_BLUETOOTH_DEVICE_ADDRESS         0x1B /**< LE Bluetooth Device Address. */
+#define BLE_GAP_AD_TYPE_LE_ROLE                             0x1C /**< LE Role. */
+#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C256            0x1D /**< Simple Pairing Hash C-256. */
+#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R256      0x1E /**< Simple Pairing Randomizer R-256. */
+#define BLE_GAP_AD_TYPE_SERVICE_DATA_32BIT_UUID             0x20 /**< Service Data - 32-bit UUID. */
+#define BLE_GAP_AD_TYPE_SERVICE_DATA_128BIT_UUID            0x21 /**< Service Data - 128-bit UUID. */
+#define BLE_GAP_AD_TYPE_URI                                 0x24 /**< URI */
+#define BLE_GAP_AD_TYPE_3D_INFORMATION_DATA                 0x3D /**< 3D Information Data. */
+#define BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA          0xFF /**< Manufacturer Specific Data. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_ADV_FLAGS GAP Advertisement Flags
+ * @{ */
+#define BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE         (0x01)   /**< LE Limited Discoverable Mode. */
+#define BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE         (0x02)   /**< LE General Discoverable Mode. */
+#define BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED         (0x04)   /**< BR/EDR not supported. */
+#define BLE_GAP_ADV_FLAG_LE_BR_EDR_CONTROLLER         (0x08)   /**< Simultaneous LE and BR/EDR, Controller. */
+#define BLE_GAP_ADV_FLAG_LE_BR_EDR_HOST               (0x10)   /**< Simultaneous LE and BR/EDR, Host. */
+#define BLE_GAP_ADV_FLAGS_LE_ONLY_LIMITED_DISC_MODE   (BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)   /**< LE Limited Discoverable Mode, BR/EDR not supported. */
+#define BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE   (BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)   /**< LE General Discoverable Mode, BR/EDR not supported. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_ADV_INTERVALS GAP Advertising interval max and min
+ * @{ */
+#define BLE_GAP_ADV_INTERVAL_MIN        0x0020 /**< Minimum Advertising interval in 625 us units, i.e. 20 ms. */
+#define BLE_GAP_ADV_NONCON_INTERVAL_MIN 0x00A0 /**< Minimum Advertising interval in 625 us units for non connectable mode, i.e. 100 ms. */
+#define BLE_GAP_ADV_INTERVAL_MAX        0x4000 /**< Maximum Advertising interval in 625 us units, i.e. 10.24 s. */
+ /**@}  */
+
+
+/**@defgroup BLE_GAP_SCAN_INTERVALS GAP Scan interval max and min
+ * @{ */
+#define BLE_GAP_SCAN_INTERVAL_MIN       0x0004 /**< Minimum Scan interval in 625 us units, i.e. 2.5 ms. */
+#define BLE_GAP_SCAN_INTERVAL_MAX       0x4000 /**< Maximum Scan interval in 625 us units, i.e. 10.24 s. */
+ /** @}  */
+
+
+/**@defgroup BLE_GAP_SCAN_WINDOW GAP Scan window max and min
+ * @{ */
+#define BLE_GAP_SCAN_WINDOW_MIN         0x0004 /**< Minimum Scan window in 625 us units, i.e. 2.5 ms. */
+#define BLE_GAP_SCAN_WINDOW_MAX         0x4000 /**< Maximum Scan window in 625 us units, i.e. 10.24 s. */
+ /** @}  */
+
+
+/**@defgroup BLE_GAP_SCAN_TIMEOUT GAP Scan timeout max and min
+ * @{ */
+#define BLE_GAP_SCAN_TIMEOUT_MIN        0x0001 /**< Minimum Scan timeout in seconds. */
+#define BLE_GAP_SCAN_TIMEOUT_MAX        0xFFFF /**< Maximum Scan timeout in seconds. */
+ /** @}  */
+
+
+/**@brief Maximum size of advertising data in octets. */
+#define BLE_GAP_ADV_MAX_SIZE            (31)
+
+
+/**@defgroup BLE_GAP_ADV_TYPES GAP Advertising types
+ * @{ */
+#define BLE_GAP_ADV_TYPE_ADV_IND          0x00   /**< Connectable undirected. */
+#define BLE_GAP_ADV_TYPE_ADV_DIRECT_IND   0x01   /**< Connectable directed. */
+#define BLE_GAP_ADV_TYPE_ADV_SCAN_IND     0x02   /**< Scannable undirected. */
+#define BLE_GAP_ADV_TYPE_ADV_NONCONN_IND  0x03   /**< Non connectable undirected. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_ADV_FILTER_POLICIES GAP Advertising filter policies
+ * @{ */
+#define BLE_GAP_ADV_FP_ANY                0x00   /**< Allow scan requests and connect requests from any device. */
+#define BLE_GAP_ADV_FP_FILTER_SCANREQ     0x01   /**< Filter scan requests with whitelist. */
+#define BLE_GAP_ADV_FP_FILTER_CONNREQ     0x02   /**< Filter connect requests with whitelist. */
+#define BLE_GAP_ADV_FP_FILTER_BOTH        0x03   /**< Filter both scan and connect requests with whitelist. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_ADV_TIMEOUT_VALUES GAP Advertising timeout values
+ * @{ */
+#define BLE_GAP_ADV_TIMEOUT_LIMITED_MAX       (180) /**< Maximum advertising time in limited discoverable mode (TGAP(lim_adv_timeout) = 180s). */
+#define BLE_GAP_ADV_TIMEOUT_GENERAL_UNLIMITED (0)   /**< Unlimited advertising in general discoverable mode. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_DISC_MODES GAP Discovery modes
+ * @{ */
+#define BLE_GAP_DISC_MODE_NOT_DISCOVERABLE  0x00   /**< Not discoverable discovery Mode. */
+#define BLE_GAP_DISC_MODE_LIMITED           0x01   /**< Limited Discovery Mode. */
+#define BLE_GAP_DISC_MODE_GENERAL           0x02   /**< General Discovery Mode. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_IO_CAPS GAP IO Capabilities
+ * @{ */
+#define BLE_GAP_IO_CAPS_DISPLAY_ONLY      0x00   /**< Display Only. */
+#define BLE_GAP_IO_CAPS_DISPLAY_YESNO     0x01   /**< Display and Yes/No entry. */
+#define BLE_GAP_IO_CAPS_KEYBOARD_ONLY     0x02   /**< Keyboard Only. */
+#define BLE_GAP_IO_CAPS_NONE              0x03   /**< No I/O capabilities. */
+#define BLE_GAP_IO_CAPS_KEYBOARD_DISPLAY  0x04   /**< Keyboard and Display. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_AUTH_KEY_TYPES GAP Authentication Key Types
+ * @{ */
+#define BLE_GAP_AUTH_KEY_TYPE_NONE        0x00   /**< No key (may be used to reject). */
+#define BLE_GAP_AUTH_KEY_TYPE_PASSKEY     0x01   /**< 6-digit Passkey. */
+#define BLE_GAP_AUTH_KEY_TYPE_OOB         0x02   /**< Out Of Band data. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_KP_NOT_TYPES GAP Keypress Notification Types
+ * @{ */
+#define BLE_GAP_KP_NOT_TYPE_PASSKEY_START       0x00   /**< Passkey entry started. */
+#define BLE_GAP_KP_NOT_TYPE_PASSKEY_DIGIT_IN    0x01   /**< Passkey digit entered. */
+#define BLE_GAP_KP_NOT_TYPE_PASSKEY_DIGIT_OUT   0x02   /**< Passkey digit erased. */
+#define BLE_GAP_KP_NOT_TYPE_PASSKEY_CLEAR       0x03   /**< Passkey cleared. */
+#define BLE_GAP_KP_NOT_TYPE_PASSKEY_END         0x04   /**< Passkey entry completed. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_SEC_STATUS GAP Security status
+ * @{ */
+#define BLE_GAP_SEC_STATUS_SUCCESS                0x00  /**< Procedure completed with success. */
+#define BLE_GAP_SEC_STATUS_TIMEOUT                0x01  /**< Procedure timed out. */
+#define BLE_GAP_SEC_STATUS_PDU_INVALID            0x02  /**< Invalid PDU received. */
+#define BLE_GAP_SEC_STATUS_RFU_RANGE1_BEGIN       0x03  /**< Reserved for Future Use range #1 begin. */
+#define BLE_GAP_SEC_STATUS_RFU_RANGE1_END         0x80  /**< Reserved for Future Use range #1 end. */
+#define BLE_GAP_SEC_STATUS_PASSKEY_ENTRY_FAILED   0x81  /**< Passkey entry failed (user cancelled or other). */
+#define BLE_GAP_SEC_STATUS_OOB_NOT_AVAILABLE      0x82  /**< Out of Band Key not available. */
+#define BLE_GAP_SEC_STATUS_AUTH_REQ               0x83  /**< Authentication requirements not met. */
+#define BLE_GAP_SEC_STATUS_CONFIRM_VALUE          0x84  /**< Confirm value failed. */
+#define BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP       0x85  /**< Pairing not supported.  */
+#define BLE_GAP_SEC_STATUS_ENC_KEY_SIZE           0x86  /**< Encryption key size. */
+#define BLE_GAP_SEC_STATUS_SMP_CMD_UNSUPPORTED    0x87  /**< Unsupported SMP command. */
+#define BLE_GAP_SEC_STATUS_UNSPECIFIED            0x88  /**< Unspecified reason. */
+#define BLE_GAP_SEC_STATUS_REPEATED_ATTEMPTS      0x89  /**< Too little time elapsed since last attempt. */
+#define BLE_GAP_SEC_STATUS_INVALID_PARAMS         0x8A  /**< Invalid parameters. */
+#define BLE_GAP_SEC_STATUS_DHKEY_FAILURE          0x8B  /**< DHKey check failure. */
+#define BLE_GAP_SEC_STATUS_NUM_COMP_FAILURE       0x8C  /**< Numeric Comparison failure. */
+#define BLE_GAP_SEC_STATUS_BR_EDR_IN_PROG         0x8D  /**< BR/EDR pairing in progress. */
+#define BLE_GAP_SEC_STATUS_X_TRANS_KEY_DISALLOWED 0x8E  /**< BR/EDR Link Key cannot be used for LE keys. */
+#define BLE_GAP_SEC_STATUS_RFU_RANGE2_BEGIN       0x8F  /**< Reserved for Future Use range #2 begin. */
+#define BLE_GAP_SEC_STATUS_RFU_RANGE2_END         0xFF  /**< Reserved for Future Use range #2 end. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_SEC_STATUS_SOURCES GAP Security status sources
+ * @{ */
+#define BLE_GAP_SEC_STATUS_SOURCE_LOCAL           0x00  /**< Local failure. */
+#define BLE_GAP_SEC_STATUS_SOURCE_REMOTE          0x01  /**< Remote failure. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_CP_LIMITS GAP Connection Parameters Limits
+ * @{ */
+#define BLE_GAP_CP_MIN_CONN_INTVL_NONE           0xFFFF  /**< No new minimum connection interval specified in connect parameters. */
+#define BLE_GAP_CP_MIN_CONN_INTVL_MIN            0x0006  /**< Lowest minimum connection interval permitted, in units of 1.25 ms, i.e. 7.5 ms. */
+#define BLE_GAP_CP_MIN_CONN_INTVL_MAX            0x0C80  /**< Highest minimum connection interval permitted, in units of 1.25 ms, i.e. 4 s. */
+#define BLE_GAP_CP_MAX_CONN_INTVL_NONE           0xFFFF  /**< No new maximum connection interval specified in connect parameters. */
+#define BLE_GAP_CP_MAX_CONN_INTVL_MIN            0x0006  /**< Lowest maximum connection interval permitted, in units of 1.25 ms, i.e. 7.5 ms. */
+#define BLE_GAP_CP_MAX_CONN_INTVL_MAX            0x0C80  /**< Highest maximum connection interval permitted, in units of 1.25 ms, i.e. 4 s. */
+#define BLE_GAP_CP_SLAVE_LATENCY_MAX             0x01F3  /**< Highest slave latency permitted, in connection events. */
+#define BLE_GAP_CP_CONN_SUP_TIMEOUT_NONE         0xFFFF  /**< No new supervision timeout specified in connect parameters. */
+#define BLE_GAP_CP_CONN_SUP_TIMEOUT_MIN          0x000A  /**< Lowest supervision timeout permitted, in units of 10 ms, i.e. 100 ms. */
+#define BLE_GAP_CP_CONN_SUP_TIMEOUT_MAX          0x0C80  /**< Highest supervision timeout permitted, in units of 10 ms, i.e. 32 s. */
+/**@} */
+
+
+/**@brief GAP device name defines. */
+#define BLE_GAP_DEVNAME_DEFAULT                  "nRF5x" /**< Default device name value. */
+#define BLE_GAP_DEVNAME_DEFAULT_LEN              31      /**< Default number of octets in device name. */
+#define BLE_GAP_DEVNAME_MAX_LEN                  248     /**< Maximum number of octets in device name. */
+
+
+/**@brief Disable RSSI events for connections */
+#define BLE_GAP_RSSI_THRESHOLD_INVALID 0xFF
+
+
+/**@defgroup BLE_GAP_CONN_SEC_MODE_SET_MACROS GAP attribute security requirement setters
+ *
+ * See @ref ble_gap_conn_sec_mode_t.
+ * @{ */
+/**@brief Set sec_mode pointed to by ptr to have no access rights.*/
+#define BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(ptr)          do {(ptr)->sm = 0; (ptr)->lv = 0;} while (0)
+/**@brief Set sec_mode pointed to by ptr to require no protection, open link.*/
+#define BLE_GAP_CONN_SEC_MODE_SET_OPEN(ptr)               do {(ptr)->sm = 1; (ptr)->lv = 1;} while (0)
+/**@brief Set sec_mode pointed to by ptr to require encryption, but no MITM protection.*/
+#define BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(ptr)        do {(ptr)->sm = 1; (ptr)->lv = 2;} while (0)
+/**@brief Set sec_mode pointed to by ptr to require encryption and MITM protection.*/
+#define BLE_GAP_CONN_SEC_MODE_SET_ENC_WITH_MITM(ptr)      do {(ptr)->sm = 1; (ptr)->lv = 3;} while (0)
+/**@brief Set sec_mode pointed to by ptr to require LESC encryption and MITM protection.*/
+#define BLE_GAP_CONN_SEC_MODE_SET_LESC_ENC_WITH_MITM(ptr) do {(ptr)->sm = 1; (ptr)->lv = 4;} while (0)
+/**@brief Set sec_mode pointed to by ptr to require signing or encryption, no MITM protection needed.*/
+#define BLE_GAP_CONN_SEC_MODE_SET_SIGNED_NO_MITM(ptr)     do {(ptr)->sm = 2; (ptr)->lv = 1;} while (0)
+/**@brief Set sec_mode pointed to by ptr to require signing or encryption with MITM protection.*/
+#define BLE_GAP_CONN_SEC_MODE_SET_SIGNED_WITH_MITM(ptr)   do {(ptr)->sm = 2; (ptr)->lv = 2;} while (0)
+/**@} */
+
+
+/**@brief GAP Security Random Number Length. */
+#define BLE_GAP_SEC_RAND_LEN 8
+
+
+/**@brief GAP Security Key Length. */
+#define BLE_GAP_SEC_KEY_LEN 16
+
+
+/**@brief GAP LE Secure Connections Elliptic Curve Diffie-Hellman P-256 Public Key Length. */
+#define BLE_GAP_LESC_P256_PK_LEN 64
+
+
+/**@brief GAP LE Secure Connections Elliptic Curve Diffie-Hellman DHKey Length. */
+#define BLE_GAP_LESC_DHKEY_LEN   32
+
+
+/**@brief GAP Passkey Length. */
+#define BLE_GAP_PASSKEY_LEN 6
+
+
+/**@brief Maximum amount of addresses in the whitelist. */
+#define BLE_GAP_WHITELIST_ADDR_MAX_COUNT (8)
+
+
+/**@brief Maximum amount of identities in the device identities list. */
+#define BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT (8)
+
+
+/**@defgroup GAP_SEC_MODES GAP Security Modes
+ * @{ */
+#define BLE_GAP_SEC_MODE 0x00 /**< No key (may be used to reject). */
+/**@} */
+/** @} */
+
+
+/**@addtogroup BLE_GAP_STRUCTURES Structures
+ * @{ */
+
+/**@brief Bluetooth Low Energy address. */
+typedef struct
+{
+  uint8_t addr_id_peer : 1;       /**< Only valid for peer addresses.
+                                       Reference to peer in device identities list (as set with @ref sd_ble_gap_device_identities_set) when peer is using privacy. */
+  uint8_t addr_type    : 7;       /**< See @ref BLE_GAP_ADDR_TYPES. */
+  uint8_t addr[BLE_GAP_ADDR_LEN]; /**< 48-bit address, LSB format. */
+} ble_gap_addr_t;
+
+
+/**@brief GAP connection parameters.
+ *
+ * @note  When ble_conn_params_t is received in an event, both min_conn_interval and
+ *        max_conn_interval will be equal to the connection interval set by the central.
+ *
+ * @note If both conn_sup_timeout and max_conn_interval are specified, then the following constraint applies:
+ *       conn_sup_timeout * 4 > (1 + slave_latency) * max_conn_interval
+ *       that corresponds to the following Bluetooth Spec requirement:
+ *       The Supervision_Timeout in milliseconds shall be larger than
+ *       (1 + Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is given in milliseconds.
+ */
+typedef struct
+{
+  uint16_t min_conn_interval;         /**< Minimum Connection Interval in 1.25 ms units, see @ref BLE_GAP_CP_LIMITS.*/
+  uint16_t max_conn_interval;         /**< Maximum Connection Interval in 1.25 ms units, see @ref BLE_GAP_CP_LIMITS.*/
+  uint16_t slave_latency;             /**< Slave Latency in number of connection events, see @ref BLE_GAP_CP_LIMITS.*/
+  uint16_t conn_sup_timeout;          /**< Connection Supervision Timeout in 10 ms units, see @ref BLE_GAP_CP_LIMITS.*/
+} ble_gap_conn_params_t;
+
+
+/**@brief GAP connection security modes.
+ *
+ * Security Mode 0 Level 0: No access permissions at all (this level is not defined by the Bluetooth Core specification).\n
+ * Security Mode 1 Level 1: No security is needed (aka open link).\n
+ * Security Mode 1 Level 2: Encrypted link required, MITM protection not necessary.\n
+ * Security Mode 1 Level 3: MITM protected encrypted link required.\n
+ * Security Mode 1 Level 4: LESC MITM protected encrypted link required.\n
+ * Security Mode 2 Level 1: Signing or encryption required, MITM protection not necessary.\n
+ * Security Mode 2 Level 2: MITM protected signing required, unless link is MITM protected encrypted.\n
+ */
+typedef struct
+{
+  uint8_t sm : 4;                     /**< Security Mode (1 or 2), 0 for no permissions at all. */
+  uint8_t lv : 4;                     /**< Level (1, 2, 3 or 4), 0 for no permissions at all. */
+
+} ble_gap_conn_sec_mode_t;
+
+
+/**@brief GAP connection security status.*/
+typedef struct
+{
+  ble_gap_conn_sec_mode_t sec_mode;           /**< Currently active security mode for this connection.*/
+  uint8_t                 encr_key_size;      /**< Length of currently active encryption key, 7 to 16 octets (only applicable for bonding procedures). */
+} ble_gap_conn_sec_t;
+
+
+/**
+ * @brief Device name and its properties
+ * @note If @ref max_len is more than @ref BLE_GAP_DEVNAME_DEFAULT_LEN and vloc is set to @ref BLE_GATTS_VLOC_STACK, the attribute table size must be increased to have room for the longer device name (see @ref ble_gatts_enable_params_t).
+ */
+typedef struct
+{
+  ble_gap_conn_sec_mode_t  write_perm;   /**< Write permissions. */
+  uint8_t                  vloc:2;       /**< Value location, see @ref BLE_GATTS_VLOCS.*/
+  uint8_t                 *p_value;      /**< Pointer to where the value (device name) is stored or will be stored.*/
+  uint16_t                 current_len;  /**< Current length in bytes of the memory pointed to by p_value.*/
+  uint16_t                 max_len;      /**< Maximum length in bytes of the memory pointed to by p_value.*/
+} ble_gap_device_name_t;
+
+
+/**
+ * @brief BLE GAP initialization parameters.
+ */
+typedef struct
+{
+  uint8_t                      periph_conn_count;  /**< Number of connections acting as a peripheral  */
+  uint8_t                      central_conn_count; /**< Number of connections acting as a central */
+  uint8_t                      central_sec_count;  /**< Number of SMP instances for all connections acting as a central. */
+  ble_gap_device_name_t const *p_device_name;      /**< Pointer to device name instance. If NULL, @ref sd_ble_enable() will set the device name to @ref BLE_GAP_DEVNAME_DEFAULT. */
+} ble_gap_enable_params_t;
+
+
+/**@brief Identity Resolving Key. */
+typedef struct
+{
+  uint8_t irk[BLE_GAP_SEC_KEY_LEN];   /**< Array containing IRK. */
+} ble_gap_irk_t;
+
+
+/**@brief Channel mask for RF channels used in advertising. */
+typedef struct
+{
+  uint8_t ch_37_off : 1;  /**< Setting this bit to 1 will turn off advertising on channel 37 */
+  uint8_t ch_38_off : 1;  /**< Setting this bit to 1 will turn off advertising on channel 38 */
+  uint8_t ch_39_off : 1;  /**< Setting this bit to 1 will turn off advertising on channel 39 */
+} ble_gap_adv_ch_mask_t;
+
+
+/**@brief GAP advertising parameters. */
+typedef struct
+{
+  uint8_t               type;                 /**< See @ref BLE_GAP_ADV_TYPES. */
+  ble_gap_addr_t const *p_peer_addr;          /**< Address of a known peer.
+                                                   - When privacy is enabled and the local device use @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE addresses, the device identity list is searched for a matching
+                                                     entry. If the local IRK for that device identity is set, the local IRK for that device will be used to generate the advertiser address field in the advertise packet.
+                                                   - If type is @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND, this must be set to the targeted initiator. If the initiator is in the device identity list,
+                                                     the peer IRK for that device will be used to generate the initiator address field in the ADV_DIRECT_IND packet. */
+  uint8_t               fp;                   /**< Filter Policy, see @ref BLE_GAP_ADV_FILTER_POLICIES. */
+  uint16_t              interval;             /**< Advertising interval between 0x0020 and 0x4000 in 0.625 ms units (20ms to 10.24s), see @ref BLE_GAP_ADV_INTERVALS.
+                                                   - If type equals @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND, this parameter must be set to 0 for high duty cycle directed advertising.
+                                                   - If type equals @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND, set @ref BLE_GAP_ADV_INTERVAL_MIN <= interval <= @ref BLE_GAP_ADV_INTERVAL_MAX for low duty cycle advertising.*/
+  uint16_t              timeout;              /**< Advertising timeout between 0x0001 and 0x3FFF in seconds, 0x0000 disables timeout. See also @ref BLE_GAP_ADV_TIMEOUT_VALUES. If type equals @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND, this parameter must be set to 0 for High duty cycle directed advertising. */
+  ble_gap_adv_ch_mask_t channel_mask;         /**< Advertising channel mask. See @ref ble_gap_adv_ch_mask_t. */
+} ble_gap_adv_params_t;
+
+
+/**@brief GAP scanning parameters. */
+typedef struct
+{
+  uint8_t  active         : 1;  /**< If 1, perform active scanning (scan requests). */
+  uint8_t  use_whitelist  : 1;  /**< If 1, filter advertisers using current active whitelist. */
+  uint8_t  adv_dir_report : 1;  /**< If 1, also report directed advertisements where the initiator field is set to a private resolvable address,
+                                     even if the address did not resolve to an entry in the device identity list. A report will be generated
+                                     even if the peer is not in the whitelist. */
+  uint16_t interval;            /**< Scan interval between 0x0004 and 0x4000 in 0.625ms units (2.5ms to 10.24s). */
+  uint16_t window;              /**< Scan window between 0x0004 and 0x4000 in 0.625ms units (2.5ms to 10.24s). */
+  uint16_t timeout;             /**< Scan timeout between 0x0001 and 0xFFFF in seconds, 0x0000 disables timeout. */
+} ble_gap_scan_params_t;
+
+
+/**@brief Device Privacy.
+ *
+ *        The privacy feature provides a way for the device to avoid being tracked over a period of time.
+ *        The privacy feature, when enabled, hides the local device identity and replaces it with a private address
+ *        that is automatically refreshed at a specified interval.
+ *
+ *        If a device still wants to be recognized by other peers, it needs to share it's Identity Resolving Key (IRK).
+ *        With this key, a device can generate a random private address that can only be recognized by peers in possession of that key,
+ *        and devices can establish connections without revealing their real identities.
+ *
+ * @note  If the device IRK is updated, the new IRK becomes the one to be distributed in all
+ *        bonding procedures performed after @ref sd_ble_gap_privacy_set returns.
+ *        The IRK distributed during bonding procedure is the device IRK that is active when @ref sd_ble_gap_sec_params_reply is called.
+ */
+typedef struct
+{
+  uint8_t        privacy_mode;         /**< Privacy mode, see @ref BLE_GAP_PRIVACY_MODES. Default is @ref BLE_GAP_PRIVACY_MODE_OFF. */
+  uint8_t        private_addr_type;    /**< The private address type must be either @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE or @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE. */
+  uint16_t       private_addr_cycle_s; /**< Private address cycle interval in seconds. Providing an address cycle value of 0 will use the default value defined by @ref BLE_GAP_DEFAULT_PRIVATE_ADDR_CYCLE_INTERVAL_S. */
+  ble_gap_irk_t *p_device_irk;         /**< When used as input, pointer to IRK structure that will be used as the default IRK. If NULL, the device default IRK will be used.
+                                            When used as output, pointer to IRK structure where the current default IRK will be written to. If NULL, this argument is ignored.
+                                            By default, the default IRK is used to generate random private resolvable addresses for the local device unless instructed otherwise. */
+} ble_gap_privacy_params_t;
+
+
+/** @brief Keys that can be exchanged during a bonding procedure. */
+typedef struct
+{
+  uint8_t enc     : 1;                        /**< Long Term Key and Master Identification. */
+  uint8_t id      : 1;                        /**< Identity Resolving Key and Identity Address Information. */
+  uint8_t sign    : 1;                        /**< Connection Signature Resolving Key. */
+  uint8_t link    : 1;                        /**< Derive the Link Key from the LTK. */
+} ble_gap_sec_kdist_t;
+
+
+/**@brief GAP security parameters. */
+typedef struct
+{
+  uint8_t               bond      : 1;             /**< Perform bonding. */
+  uint8_t               mitm      : 1;             /**< Enable Man In The Middle protection. */
+  uint8_t               lesc      : 1;             /**< Enable LE Secure Connection pairing. */
+  uint8_t               keypress  : 1;             /**< Enable generation of keypress notifications. */
+  uint8_t               io_caps   : 3;             /**< IO capabilities, see @ref BLE_GAP_IO_CAPS. */
+  uint8_t               oob       : 1;             /**< Out Of Band data available. */
+  uint8_t               min_key_size;              /**< Minimum encryption key size in octets between 7 and 16. If 0 then not applicable in this instance. */
+  uint8_t               max_key_size;              /**< Maximum encryption key size in octets between min_key_size and 16. */
+  ble_gap_sec_kdist_t   kdist_own;                 /**< Key distribution bitmap: keys that the local device will distribute. */
+  ble_gap_sec_kdist_t   kdist_peer;                /**< Key distribution bitmap: keys that the remote device will distribute. */
+} ble_gap_sec_params_t;
+
+
+/**@brief GAP Encryption Information. */
+typedef struct
+{
+  uint8_t   ltk[BLE_GAP_SEC_KEY_LEN];   /**< Long Term Key. */
+  uint8_t   lesc : 1;                   /**< Key generated using LE Secure Connections. */
+  uint8_t   auth : 1;                   /**< Authenticated Key. */
+  uint8_t   ltk_len : 6;                /**< LTK length in octets. */
+} ble_gap_enc_info_t;
+
+
+/**@brief GAP Master Identification. */
+typedef struct
+{
+  uint16_t  ediv;                       /**< Encrypted Diversifier. */
+  uint8_t   rand[BLE_GAP_SEC_RAND_LEN]; /**< Random Number. */
+} ble_gap_master_id_t;
+
+
+/**@brief GAP Signing Information. */
+typedef struct
+{
+  uint8_t   csrk[BLE_GAP_SEC_KEY_LEN];        /**< Connection Signature Resolving Key. */
+} ble_gap_sign_info_t;
+
+
+/**@brief GAP LE Secure Connections P-256 Public Key. */
+typedef struct
+{
+  uint8_t   pk[BLE_GAP_LESC_P256_PK_LEN];        /**< LE Secure Connections Elliptic Curve Diffie-Hellman P-256 Public Key. Stored in the standard SMP protocol format: {X,Y} both in little-endian. */
+} ble_gap_lesc_p256_pk_t;
+
+
+/**@brief GAP LE Secure Connections DHKey. */
+typedef struct
+{
+  uint8_t   key[BLE_GAP_LESC_DHKEY_LEN];        /**< LE Secure Connections Elliptic Curve Diffie-Hellman Key. Stored in little-endian. */
+} ble_gap_lesc_dhkey_t;
+
+
+/**@brief GAP LE Secure Connections OOB data. */
+typedef struct
+{
+  ble_gap_addr_t  addr;                          /**< Bluetooth address of the device. */
+  uint8_t         r[BLE_GAP_SEC_KEY_LEN];        /**< Random Number. */
+  uint8_t         c[BLE_GAP_SEC_KEY_LEN];        /**< Confirm Value. */
+} ble_gap_lesc_oob_data_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_CONNECTED. */
+typedef struct
+{
+  ble_gap_addr_t        peer_addr;              /**< Bluetooth address of the peer device. If the peer_addr resolved: @ref ble_gap_addr_t::addr_id_peer is set to 1
+                                                     and the address is the device's identity address. */
+  uint8_t               role;                   /**< BLE role for this connection, see @ref BLE_GAP_ROLES */
+  ble_gap_conn_params_t conn_params;            /**< GAP Connection Parameters. */
+} ble_gap_evt_connected_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_DISCONNECTED. */
+typedef struct
+{
+  uint8_t reason;                               /**< HCI error code, see @ref BLE_HCI_STATUS_CODES. */
+} ble_gap_evt_disconnected_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_CONN_PARAM_UPDATE. */
+typedef struct
+{
+  ble_gap_conn_params_t conn_params;            /**<  GAP Connection Parameters. */
+} ble_gap_evt_conn_param_update_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_SEC_PARAMS_REQUEST. */
+typedef struct
+{
+  ble_gap_sec_params_t peer_params;             /**< Initiator Security Parameters. */
+} ble_gap_evt_sec_params_request_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_SEC_INFO_REQUEST. */
+typedef struct
+{
+  ble_gap_addr_t      peer_addr;                     /**< Bluetooth address of the peer device. */
+  ble_gap_master_id_t master_id;                     /**< Master Identification for LTK lookup. */
+  uint8_t             enc_info  : 1;                 /**< If 1, Encryption Information required. */
+  uint8_t             id_info   : 1;                 /**< If 1, Identity Information required. */
+  uint8_t             sign_info : 1;                 /**< If 1, Signing Information required. */
+} ble_gap_evt_sec_info_request_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_PASSKEY_DISPLAY. */
+typedef struct
+{
+  uint8_t passkey[BLE_GAP_PASSKEY_LEN];         /**< 6-digit passkey in ASCII ('0'-'9' digits only). */
+  uint8_t match_request : 1;                    /**< If 1 requires the application to report the match using @ref sd_ble_gap_auth_key_reply
+                                                     with either @ref BLE_GAP_AUTH_KEY_TYPE_NONE if there is no match or
+                                                     @ref BLE_GAP_AUTH_KEY_TYPE_PASSKEY if there is a match. */
+} ble_gap_evt_passkey_display_t;
+
+/**@brief Event structure for @ref BLE_GAP_EVT_KEY_PRESSED. */
+typedef struct
+{
+  uint8_t kp_not;         /**< Keypress notification type, see @ref BLE_GAP_KP_NOT_TYPES. */
+} ble_gap_evt_key_pressed_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_AUTH_KEY_REQUEST. */
+typedef struct
+{
+  uint8_t key_type;                             /**< See @ref BLE_GAP_AUTH_KEY_TYPES. */
+} ble_gap_evt_auth_key_request_t;
+
+/**@brief Event structure for @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST. */
+typedef struct
+{
+  ble_gap_lesc_p256_pk_t *p_pk_peer;  /**< LE Secure Connections remote P-256 Public Key. This will point to the application-supplied memory
+                                           inside the keyset during the call to @ref sd_ble_gap_sec_params_reply. */
+  uint8_t oobd_req       :1;          /**< LESC OOB data required. A call to @ref sd_ble_gap_lesc_oob_data_set is required to complete the procedure. */
+} ble_gap_evt_lesc_dhkey_request_t;
+
+
+/**@brief Security levels supported.
+ * @note See Bluetooth Specification Version 4.2 Volume 3, Part C, Chapter 10, Section 10.2.1.
+*/
+typedef struct
+{
+  uint8_t lv1 : 1;                              /**< If 1: Level 1 is supported. */
+  uint8_t lv2 : 1;                              /**< If 1: Level 2 is supported. */
+  uint8_t lv3 : 1;                              /**< If 1: Level 3 is supported. */
+  uint8_t lv4 : 1;                              /**< If 1: Level 4 is supported. */
+} ble_gap_sec_levels_t;
+
+
+/**@brief Encryption Key. */
+typedef struct
+{
+  ble_gap_enc_info_t    enc_info;             /**< Encryption Information. */
+  ble_gap_master_id_t   master_id;            /**< Master Identification. */
+} ble_gap_enc_key_t;
+
+
+/**@brief Identity Key. */
+typedef struct
+{
+  ble_gap_irk_t         id_info;              /**< Identity Resolving Key. */
+  ble_gap_addr_t        id_addr_info;         /**< Identity Address. */
+} ble_gap_id_key_t;
+
+
+/**@brief Security Keys. */
+typedef struct
+{
+  ble_gap_enc_key_t      *p_enc_key;           /**< Encryption Key, or NULL. */
+  ble_gap_id_key_t       *p_id_key;            /**< Identity Key, or NULL. */
+  ble_gap_sign_info_t    *p_sign_key;          /**< Signing Key, or NULL. */
+  ble_gap_lesc_p256_pk_t *p_pk;                /**< LE Secure Connections P-256 Public Key. When in debug mode the application must use the value defined
+                                                    in the Core Bluetooth Specification v4.2 Vol.3, Part H, Section 2.3.5.6.1 */
+} ble_gap_sec_keys_t;
+
+
+/**@brief Security key set for both local and peer keys. */
+typedef struct
+{
+  ble_gap_sec_keys_t            keys_own;     /**< Keys distributed by the local device. For LE Secure Connections the encryption key will be generated locally and will always be stored if bonding. */
+  ble_gap_sec_keys_t            keys_peer;    /**< Keys distributed by the remote device. For LE Secure Connections, p_enc_key must always be NULL. */
+} ble_gap_sec_keyset_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_AUTH_STATUS. */
+typedef struct
+{
+  uint8_t               auth_status;            /**< Authentication status, see @ref BLE_GAP_SEC_STATUS. */
+  uint8_t               error_src : 2;          /**< On error, source that caused the failure, see @ref BLE_GAP_SEC_STATUS_SOURCES. */
+  uint8_t               bonded : 1;             /**< Procedure resulted in a bond. */
+  ble_gap_sec_levels_t  sm1_levels;             /**< Levels supported in Security Mode 1. */
+  ble_gap_sec_levels_t  sm2_levels;             /**< Levels supported in Security Mode 2. */
+  ble_gap_sec_kdist_t   kdist_own;              /**< Bitmap stating which keys were exchanged (distributed) by the local device. If bonding with LE Secure Connections, the enc bit will be always set. */
+  ble_gap_sec_kdist_t   kdist_peer;             /**< Bitmap stating which keys were exchanged (distributed) by the remote device. If bonding with LE Secure Connections, the enc bit will never be set. */
+} ble_gap_evt_auth_status_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_CONN_SEC_UPDATE. */
+typedef struct
+{
+  ble_gap_conn_sec_t conn_sec;                  /**< Connection security level. */
+} ble_gap_evt_conn_sec_update_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_TIMEOUT. */
+typedef struct
+{
+  uint8_t src;                                  /**< Source of timeout event, see @ref BLE_GAP_TIMEOUT_SOURCES. */
+} ble_gap_evt_timeout_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_RSSI_CHANGED. */
+typedef struct
+{
+  int8_t  rssi;                               /**< Received Signal Strength Indication in dBm. */
+} ble_gap_evt_rssi_changed_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_ADV_REPORT. */
+typedef struct
+{
+  ble_gap_addr_t peer_addr;                     /**< Bluetooth address of the peer device. If the peer_addr resolved: @ref ble_gap_addr_t::addr_id_peer is set to 1
+                                                     and the address is the device's identity address. */
+  ble_gap_addr_t direct_addr;                   /**< Set when the scanner is unable to resolve the private resolvable address of the initiator
+                                                     field of a directed advertisement packet and the scanner has been enabled to report this in @ref ble_gap_scan_params_t::adv_dir_report. */
+  int8_t         rssi;                          /**< Received Signal Strength Indication in dBm. */
+  uint8_t        scan_rsp : 1;                  /**< If 1, the report corresponds to a scan response and the type field may be ignored. */
+  uint8_t        type     : 2;                  /**< See @ref BLE_GAP_ADV_TYPES. Only valid if the scan_rsp field is 0. */
+  uint8_t        dlen     : 5;                  /**< Advertising or scan response data length. */
+  uint8_t        data[BLE_GAP_ADV_MAX_SIZE];    /**< Advertising or scan response data. */
+} ble_gap_evt_adv_report_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_SEC_REQUEST. */
+typedef struct
+{
+  uint8_t    bond       : 1;                       /**< Perform bonding. */
+  uint8_t    mitm       : 1;                       /**< Man In The Middle protection requested. */
+  uint8_t    lesc       : 1;                       /**< LE Secure Connections requested. */
+  uint8_t    keypress   : 1;                       /**< Generation of keypress notifications requested. */
+} ble_gap_evt_sec_request_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST. */
+typedef struct
+{
+  ble_gap_conn_params_t conn_params;            /**<  GAP Connection Parameters. */
+} ble_gap_evt_conn_param_update_request_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_SCAN_REQ_REPORT. */
+typedef struct
+{
+  int8_t                  rssi;              /**< Received Signal Strength Indication in dBm. */
+  ble_gap_addr_t          peer_addr;         /**< Bluetooth address of the peer device. If the peer_addr resolved: @ref ble_gap_addr_t::addr_id_peer is set to 1
+                                                  and the address is the device's identity address. */
+} ble_gap_evt_scan_req_report_t;
+
+
+/**@brief GAP event structure. */
+typedef struct
+{
+  uint16_t conn_handle;                                     /**< Connection Handle on which event occurred. */
+  union                                                     /**< union alternative identified by evt_id in enclosing struct. */
+  {
+    ble_gap_evt_connected_t                   connected;                    /**< Connected Event Parameters. */
+    ble_gap_evt_disconnected_t                disconnected;                 /**< Disconnected Event Parameters. */
+    ble_gap_evt_conn_param_update_t           conn_param_update;            /**< Connection Parameter Update Parameters. */
+    ble_gap_evt_sec_params_request_t          sec_params_request;           /**< Security Parameters Request Event Parameters. */
+    ble_gap_evt_sec_info_request_t            sec_info_request;             /**< Security Information Request Event Parameters. */
+    ble_gap_evt_passkey_display_t             passkey_display;              /**< Passkey Display Event Parameters. */
+    ble_gap_evt_key_pressed_t                 key_pressed;                  /**< Key Pressed Event Parameters. */
+    ble_gap_evt_auth_key_request_t            auth_key_request;             /**< Authentication Key Request Event Parameters. */
+    ble_gap_evt_lesc_dhkey_request_t          lesc_dhkey_request;           /**< LE Secure Connections DHKey calculation request. */
+    ble_gap_evt_auth_status_t                 auth_status;                  /**< Authentication Status Event Parameters. */
+    ble_gap_evt_conn_sec_update_t             conn_sec_update;              /**< Connection Security Update Event Parameters. */
+    ble_gap_evt_timeout_t                     timeout;                      /**< Timeout Event Parameters. */
+    ble_gap_evt_rssi_changed_t                rssi_changed;                 /**< RSSI Event parameters. */
+    ble_gap_evt_adv_report_t                  adv_report;                   /**< Advertising Report Event Parameters. */
+    ble_gap_evt_sec_request_t                 sec_request;                  /**< Security Request Event Parameters. */
+    ble_gap_evt_conn_param_update_request_t   conn_param_update_request;    /**< Connection Parameter Update Parameters. */
+    ble_gap_evt_scan_req_report_t             scan_req_report;              /**< Scan Request Report parameters. */
+  } params;                                                                 /**< Event Parameters. */
+} ble_gap_evt_t;
+
+
+/**@brief Channel Map option.
+ *        Used with @ref sd_ble_opt_get to get the current channel map
+ *        or @ref sd_ble_opt_set to set a new channel map. When setting the
+ *        channel map, it applies to all current and future connections. When getting the
+ *        current channel map, it applies to a single connection and the connection handle
+ *        must be supplied.
+ *
+ * @note  Setting the channel map may take some time, depending on connection parameters.
+ *        The time taken may be different for each connection and the get operation will
+ *        return the previous channel map until the new one has taken effect.
+ *
+ * @note  After setting the channel map, by spec it can not be set again until at least 1 s has passed.
+ *        See Bluetooth Specification Version 4.1 Volume 2, Part E, Section 7.3.46.
+ *
+ * @retval ::NRF_SUCCESS Get or set successful.
+ * @retval ::NRF_ERROR_BUSY Channel map was set again before enough time had passed.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied for get.
+ * @retval ::NRF_ERROR_NOT_SUPPORTED Returned by sd_ble_opt_set in peripheral-only SoftDevices.
+ *
+ */
+typedef struct
+{
+  uint16_t conn_handle;                   /**< Connection Handle (only applicable for get) */
+  uint8_t ch_map[5];                      /**< Channel Map (37-bit). */
+} ble_gap_opt_ch_map_t;
+
+
+/**@brief Local connection latency option.
+ *
+ *        Local connection latency is a feature which enables the slave to improve
+ *        current consumption by ignoring the slave latency set by the peer. The
+ *        local connection latency can only be set to a multiple of the slave latency,
+ *        and cannot be longer than half of the supervision timeout.
+ *
+ *        Used with @ref sd_ble_opt_set to set the local connection latency. The
+ *        @ref sd_ble_opt_get is not supported for this option, but the actual
+ *        local connection latency (unless set to NULL) is set as a return parameter
+ *        when setting the option.
+ *
+ * @note  The latency set will be truncated down to the closest slave latency event
+ *        multiple, or the nearest multiple before half of the supervision timeout.
+ *
+ * @note  The local connection latency is disabled by default, and needs to be enabled for new
+ *        connections and whenever the connection is updated.
+ *
+ * @retval ::NRF_SUCCESS Set successfully.
+ * @retval ::NRF_ERROR_NOT_SUPPORTED Get is not supported.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.
+ */
+typedef struct
+{
+  uint16_t   conn_handle;                       /**< Connection Handle */
+  uint16_t   requested_latency;                 /**< Requested local connection latency. */
+  uint16_t * p_actual_latency;                  /**< Pointer to storage for the actual local connection latency (can be set to NULL to skip return value). */
+} ble_gap_opt_local_conn_latency_t;
+
+
+/**@brief Passkey Option.
+ *
+ *        Structure containing the passkey to be used during pairing. This can be used with @ref
+ *        sd_ble_opt_set to make the SoftDevice use a pre-programmed passkey for authentication
+ *        instead of generating a random one.
+ *
+ * @note  Repeated pairing attempts using the same pre-programmed passkey makes pairing vulnerable to MITM attacks.
+ *
+ * @note  @ref sd_ble_opt_get is not supported for this option.
+ *
+ */
+typedef struct
+{
+  uint8_t * p_passkey;                          /**< Pointer to 6-digit ASCII string (digit 0..9 only, no NULL termination) passkey to be used during pairing. If this is NULL, the SoftDevice will generate a random passkey if required.*/
+} ble_gap_opt_passkey_t;
+
+
+/**@brief Scan request report option.
+ *
+ *        This can be used with @ref sd_ble_opt_set to make the SoftDevice send
+ *        @ref BLE_GAP_EVT_SCAN_REQ_REPORT events.
+ *
+ *  @note   Due to the limited space reserved for scan request report events,
+ *          not all received scan requests will be reported.
+ *
+ *  @note   If whitelisting is used, only whitelisted requests are reported.
+ *
+ *  @retval ::NRF_SUCCESS Set successfully.
+ *  @retval ::NRF_ERROR_INVALID_STATE When advertising is ongoing while the option is set.
+ */
+typedef struct
+{
+   uint8_t enable : 1;                           /**< Enable scan request reports. */
+} ble_gap_opt_scan_req_report_t;
+
+
+/**@brief Compatibility mode option.
+ *
+ *        This can be used with @ref sd_ble_opt_set to enable and disable
+ *        compatibility modes. Compatibility modes are disabled by default.
+ *
+ *  @note  Compatibility mode 1 enables interoperability with devices that do not support
+ *         a value of 0 for the WinOffset parameter in the Link Layer CONNECT_REQ packet.
+ *
+ *  @retval ::NRF_SUCCESS Set successfully.
+ *  @retval ::NRF_ERROR_INVALID_STATE When connection creation is ongoing while mode 1 is set.
+ */
+typedef struct
+{
+   uint8_t mode_1_enable : 1;                           /**< Enable compatibility mode 1.*/
+} ble_gap_opt_compat_mode_t;
+
+/**@brief Data length extension option.
+ *
+ *        This can be used with @ref sd_ble_opt_set to enable longer data packets.
+ *
+ * @note  An rxtx_max_pdu_payload_size of 0 will result in the default minimum payload size of 27.
+ * @note  Not supported by SoftDevices for nRF51 Series devices.
+ * @note  The parameters for a connection are applied when a connection complete
+ *        event is generated for the host.
+ *
+ *
+ *  @retval ::NRF_SUCCESS Set successfully.
+ *  @retval ::NRF_ERROR_INVALID_PARAM If the payload size is not 0 or a valid link layer PDU payload size.
+ *  @retval ::NRF_ERROR_NOT_SUPPORTED If called on a SoftDevice designed for nRF51 (e.g. s130).
+ */
+typedef struct
+{
+  uint8_t  rxtx_max_pdu_payload_size;      /**< Max PDU payload size (in octets). */
+} ble_gap_opt_ext_len_t;
+
+
+
+/**@brief Authenticated payload timeout option.
+ *
+ * This can be used with @ref sd_ble_opt_set to change the Authenticated payload timeout to a value other than the default of 8 minutes.
+ *
+ * @note The authenticated payload timeout event ::BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD will be generated
+ * if auth_payload_timeout time has elapsed without receiving a packet with a valid MIC on an encrypted
+ * link.
+ *
+ * @note  The LE ping procedure will be initiated before the timer expires to give the peer a chance
+ * to reset the timer. In addition the stack will try to prioritize running of LE ping over other
+ * activities to increase chances of finishing LE ping before timer expires. To avoid side-effects
+ * on other activities, it is recommended to use high timeout values.
+ * Recommended timeout > 2*(connInterval * (6 + connSlaveLatency)).
+ *
+ * @retval ::NRF_SUCCESS Set successfully.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied. auth_payload_timeout was outside of allowed range.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.
+ */
+typedef struct
+{
+  uint16_t   conn_handle;                       /**< Connection Handle */
+  uint16_t   auth_payload_timeout;              /**< Requested timeout in 10 ms unit. Maximum is 48 000 (=480 000 ms =8 min). Minimum is 1 (=10ms). */
+} ble_gap_opt_auth_payload_timeout_t;
+
+
+/**@brief Option structure for GAP options. */
+typedef union
+{
+  ble_gap_opt_ch_map_t                  ch_map;                    /**< Parameters for the Channel Map option. */
+  ble_gap_opt_local_conn_latency_t      local_conn_latency;        /**< Parameters for the Local connection latency option */
+  ble_gap_opt_passkey_t                 passkey;                   /**< Parameters for the Passkey option.*/
+  ble_gap_opt_scan_req_report_t         scan_req_report;           /**< Parameters for the scan request report option.*/
+  ble_gap_opt_compat_mode_t             compat_mode;               /**< Parameters for the compatibility mode option.*/
+  ble_gap_opt_ext_len_t                 ext_len;                   /**< Parameters for the extended length option. */
+  ble_gap_opt_auth_payload_timeout_t    auth_payload_timeout;      /**< Parameters for the authenticated payload timeout option.*/
+} ble_gap_opt_t;
+/**@} */
+
+
+/**@addtogroup BLE_GAP_FUNCTIONS Functions
+ * @{ */
+
+/**@brief Set the local Bluetooth identity address.
+ *
+ * The local Bluetooth identity address is the address that identifies this device to other peers.
+ * The address type must be either @ref BLE_GAP_ADDR_TYPE_PUBLIC or @ref BLE_GAP_ADDR_TYPE_RANDOM_STATIC.
+ * The identity address cannot be changed while roles are running.
+ *
+ * @note This address will be distributed to the peer during bonding.
+ * If the address changes, the address stored in the peer device will not be valid and the ability to
+ * reconnect using the old address will be lost.
+ *
+ * @note By default the SoftDevice will set an address of type @ref BLE_GAP_ADDR_TYPE_RANDOM_STATIC upon being
+ * enabled. The address is a random number populated during the IC manufacturing process and remains unchanged
+ * for the lifetime of each IC.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_ADV_MSC}
+ * @endmscs
+ *
+ * @param[in] p_addr Pointer to address structure.
+ *
+ * @retval ::NRF_SUCCESS Address successfully set.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address.
+ * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
+ * @retval ::NRF_ERROR_INVALID_STATE The identity address cannot be changed while the roles are running.
+ */
+SVCALL(SD_BLE_GAP_ADDR_SET, uint32_t, sd_ble_gap_addr_set(ble_gap_addr_t const *p_addr));
+
+
+/**@brief Get local Bluetooth identity address.
+ *
+ * @note This will always return the identity address irrespective of the privacy settings,
+ * i.e. the address type will always be either @ref BLE_GAP_ADDR_TYPE_PUBLIC or @ref BLE_GAP_ADDR_TYPE_RANDOM_STATIC.
+ *
+ * @param[out] p_addr Pointer to address structure to be filled in.
+ *
+ * @retval ::NRF_SUCCESS Address successfully retrieved.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid or NULL pointer supplied.
+ */
+SVCALL(SD_BLE_GAP_ADDR_GET, uint32_t, sd_ble_gap_addr_get(ble_gap_addr_t *p_addr));
+
+
+/**@brief Set the active whitelist in the SoftDevice.
+ *
+ * @note Only one whitelist can be used at a time and the whitelist is shared between the BLE roles.
+ *       The whitelist cannot be set if a BLE role is using the whitelist.
+ *
+ * @note If an address is resolved using the information in the device identity list, then the whitelist
+ *       filter policy applies to the peer identity address and not the resolvable address sent on air.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
+ * @mmsc{@ref BLE_GAP_PRIVACY_SCAN_PRIVATE_SCAN_MSC}
+ * @endmscs
+ *
+ * @param[in] pp_wl_addrs Pointer to a whitelist of peer addresses, if NULL the whitelist will be cleared.
+ * @param[in] len         Length of the whitelist, maximum @ref BLE_GAP_WHITELIST_ADDR_MAX_COUNT.
+ *
+ * @retval ::NRF_SUCCESS The whitelist is successfully set/cleared.
+ * @retval ::NRF_ERROR_INVALID_ADDR The whitelist (or one of its entries) provided is invalid.
+ * @retval ::BLE_ERROR_GAP_WHITELIST_IN_USE The whitelist is in use by a BLE role and cannot be set or cleared.
+ * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address type is supplied.
+ * @retval ::NRF_ERROR_DATA_SIZE The given whitelist size is invalid (zero or too large); this can only return when
+ *                               pp_wl_addrs is not NULL.
+ */
+SVCALL(SD_BLE_GAP_WHITELIST_SET, uint32_t, sd_ble_gap_whitelist_set(ble_gap_addr_t const * const * pp_wl_addrs, uint8_t len));
+
+
+/**@brief Set device identity list.
+ *
+ * @note Only one device identity list can be used at a time and the list is shared between the BLE roles.
+ *       The device identity list cannot be set if a BLE role is using the list.
+ *
+ * @param[in] pp_id_keys     Pointer to an array of peer identity addresses and peer IRKs, if NULL the device identity list will be cleared.
+ * @param[in] pp_local_irks  Pointer to an array of local IRKs. Each entry in the array maps to the entry in pp_id_keys at the same index.
+ *                           To fill in the list with the currently set device IRK for all peers, set to NULL.
+ * @param[in] len            Length of the device identity list, maximum @ref BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PRIVACY_ADV_MSC}
+ * @mmsc{@ref BLE_GAP_PRIVACY_SCAN_MSC}
+ * @mmsc{@ref BLE_GAP_PRIVACY_SCAN_PRIVATE_SCAN_MSC}
+ * @mmsc{@ref BLE_GAP_PRIVACY_ADV_DIR_PRIV_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_CONN_PRIV_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_CONN_PRIV_MSC}
+ * @endmscs
+ *
+ * @retval ::NRF_SUCCESS The device identity list successfully set/cleared.
+ * @retval ::NRF_ERROR_INVALID_ADDR The device identity list (or one of its entries) provided is invalid.
+                                    This code may be returned if the local IRK list also has an invalid entry.
+ * @retval ::BLE_ERROR_GAP_DEVICE_IDENTITIES_IN_USE The device identity list is in use and cannot be set or cleared.
+ * @retval ::BLE_ERROR_GAP_DEVICE_IDENTITIES_DUPLICATE The device identity list contains multiple entries with the same identity address.
+ * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address type is supplied.
+ * @retval ::NRF_ERROR_DATA_SIZE The given device identity list size invalid (zero or too large); this can
+ *                               only return when pp_id_keys is not NULL.
+ */
+SVCALL(SD_BLE_GAP_DEVICE_IDENTITIES_SET, uint32_t, sd_ble_gap_device_identities_set(ble_gap_id_key_t const * const * pp_id_keys, ble_gap_irk_t const * const * pp_local_irks, uint8_t len));
+
+
+/**@brief Set privacy settings.
+ *
+ * @note Privacy settings cannot be set while BLE roles are running.
+ *
+ * @param[in] p_privacy_params Privacy settings.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PRIVACY_ADV_MSC}
+ * @mmsc{@ref BLE_GAP_PRIVACY_SCAN_MSC}
+ * @mmsc{@ref BLE_GAP_PRIVACY_ADV_DIR_PRIV_MSC}
+ * @endmscs
+ *
+ * @retval ::NRF_SUCCESS Set successfully.
+ * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
+ * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address type is supplied.
+ * @retval ::NRF_ERROR_INVALID_ADDR The pointer to privacy settings is NULL or invalid.
+                                    Otherwise, the p_device_irk pointer in privacy parameter is an invalid pointer.
+ * @retval ::NRF_ERROR_INVALID_PARAM Out of range parameters are provided.
+ * @retval ::NRF_ERROR_INVALID_STATE Privacy settings cannot be changed while BLE roles using privacy are enabled.
+  */
+SVCALL(SD_BLE_GAP_PRIVACY_SET, uint32_t, sd_ble_gap_privacy_set(ble_gap_privacy_params_t const *p_privacy_params));
+
+
+/**@brief Get privacy settings.
+ *
+ * @note The privacy settings returned include the current device irk as well.
+ *
+ * @param[in] p_privacy_params Privacy settings.
+ *
+ * @retval ::NRF_SUCCESS            Privacy settings read.
+ * @retval ::NRF_ERROR_INVALID_ADDR The pointer given for returning the privacy settings may be NULL or invalid.
+                                    Otherwise, the p_device_irk pointer in privacy parameter is an invalid pointer.
+ */
+SVCALL(SD_BLE_GAP_PRIVACY_GET, uint32_t, sd_ble_gap_privacy_get(ble_gap_privacy_params_t *p_privacy_params));
+
+
+/**@brief Set, clear or update advertising and scan response data.
+ *
+ * @note The format of the advertising data will be checked by this call to ensure interoperability.
+ *       Limitations imposed by this API call to the data provided include having a flags data type in the scan response data and
+ *       duplicating the local name in the advertising data and scan response data.
+ *
+ * @note To clear the advertising data and set it to a 0-length packet, simply provide a valid pointer (p_data/p_sr_data) with its corresponding
+ *        length (dlen/srdlen) set to 0.
+ *
+ * @note The call will fail if p_data and p_sr_data are both NULL since this would have no effect.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_ADV_MSC}
+ * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
+ * @endmscs
+ *
+ * @param[in] p_data    Raw data to be placed in advertising packet. If NULL, no changes are made to the current advertising packet data.
+ * @param[in] dlen      Data length for p_data. Max size: @ref BLE_GAP_ADV_MAX_SIZE octets. Should be 0 if p_data is NULL, can be 0 if p_data is not NULL.
+ * @param[in] p_sr_data Raw data to be placed in scan response packet. If NULL, no changes are made to the current scan response packet data.
+ * @param[in] srdlen    Data length for p_sr_data. Max size: @ref BLE_GAP_ADV_MAX_SIZE octets. Should be 0 if p_sr_data is NULL, can be 0 if p_data is not NULL.
+ *
+ * @retval ::NRF_SUCCESS Advertising data successfully updated or cleared.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, both p_data and p_sr_data cannot be NULL.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_FLAGS Invalid combination of advertising flags supplied.
+ * @retval ::NRF_ERROR_INVALID_DATA Invalid data type(s) supplied, check the advertising data format specification.
+ * @retval ::NRF_ERROR_INVALID_LENGTH Invalid data length(s) supplied.
+ * @retval ::NRF_ERROR_NOT_SUPPORTED Unsupported data type.
+ * @retval ::BLE_ERROR_GAP_UUID_LIST_MISMATCH Invalid UUID list supplied.
+ */
+SVCALL(SD_BLE_GAP_ADV_DATA_SET, uint32_t, sd_ble_gap_adv_data_set(uint8_t const *p_data, uint8_t dlen, uint8_t const *p_sr_data, uint8_t srdlen));
+
+
+/**@brief Start advertising (GAP Discoverable, Connectable modes, Broadcast Procedure).
+ *
+ * @note An application can start an advertising procedure for broadcasting purposes while a connection
+ *       is active. After a @ref BLE_GAP_EVT_CONNECTED event is received, this function may therefore
+ *       be called to start a broadcast advertising procedure. The advertising procedure
+ *       cannot however be connectable (it must be of type @ref BLE_GAP_ADV_TYPE_ADV_SCAN_IND or
+ *       @ref BLE_GAP_ADV_TYPE_ADV_NONCONN_IND). @note Only one advertiser may be active at any time.
+ *
+ * @events
+ * @event{@ref BLE_GAP_EVT_CONNECTED, Generated after connection has been established through connectable advertising.}
+ * @event{@ref BLE_GAP_EVT_TIMEOUT, Advertisement has timed out.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_ADV_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_CONN_PRIV_MSC}
+ * @mmsc{@ref BLE_GAP_PRIVACY_ADV_DIR_PRIV_MSC}
+ * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
+ * @endmscs
+ *
+ * @param[in] p_adv_params Pointer to advertising parameters structure.
+ *
+ * @retval ::NRF_SUCCESS The BLE stack has started advertising.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::NRF_ERROR_CONN_COUNT The limit of available connections has been reached; connectable advertiser cannot be started.
+ * @retval ::NRF_ERROR_NO_MEM The configured memory pools (see @ref ble_conn_bw_counts_t) are not large enough for the
+ *                            bandwidth selected for this connection.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check the accepted ranges and limits.
+ * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid Bluetooth address supplied.
+ * @retval ::BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST Discoverable mode and whitelist incompatible.
+ * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
+ * @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available.
+ *                               Stop one or more currently active roles (Central, Peripheral or Observer) and try again
+ */
+SVCALL(SD_BLE_GAP_ADV_START, uint32_t, sd_ble_gap_adv_start(ble_gap_adv_params_t const *p_adv_params));
+
+
+/**@brief Stop advertising (GAP Discoverable, Connectable modes, Broadcast Procedure).
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_ADV_MSC}
+ * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
+ * @endmscs
+ *
+ * @retval ::NRF_SUCCESS The BLE stack has stopped advertising.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation (most probably not in advertising state).
+ */
+SVCALL(SD_BLE_GAP_ADV_STOP, uint32_t, sd_ble_gap_adv_stop(void));
+
+
+/**@brief Update connection parameters.
+ *
+ * @details In the central role this will initiate a Link Layer connection parameter update procedure,
+ *          otherwise in the peripheral role, this will send the corresponding L2CAP request and wait for
+ *          the central to perform the procedure. In both cases, and regardless of success or failure, the application
+ *          will be informed of the result with a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE event.
+ *
+ * @details This function can be used as a central both to reply to a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST or to start the procedure unrequested.
+ *
+ * @events
+ * @event{@ref BLE_GAP_EVT_CONN_PARAM_UPDATE, Result of the connection parameter update procedure.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_CPU_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_ENC_AUTH_MUTEX_MSC}
+ * @mmsc{@ref BLE_GAP_MULTILINK_CPU_MSC}
+ * @mmsc{@ref BLE_GAP_MULTILINK_CTRL_PROC_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_CPU_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] p_conn_params  Pointer to desired connection parameters. If NULL is provided on a peripheral role,
+ *                           the parameters in the PPCP characteristic of the GAP service will be used instead.
+ *                           If NULL is provided on a central role and in response to a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST, the peripheral request will be rejected
+ *
+ * @retval ::NRF_SUCCESS The Connection Update procedure has been started successfully.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check parameter limits and constraints.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::NRF_ERROR_BUSY Procedure already in progress or not allowed at this time, process pending events and wait for pending procedures to complete and retry.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
+ */
+SVCALL(SD_BLE_GAP_CONN_PARAM_UPDATE, uint32_t, sd_ble_gap_conn_param_update(uint16_t conn_handle, ble_gap_conn_params_t const *p_conn_params));
+
+
+/**@brief Disconnect (GAP Link Termination).
+ *
+ * @details This call initiates the disconnection procedure, and its completion will be communicated to the application
+ *          with a @ref BLE_GAP_EVT_DISCONNECTED event.
+ *
+ * @events
+ * @event{@ref BLE_GAP_EVT_DISCONNECTED, Generated when disconnection procedure is complete.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_CONN_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] hci_status_code HCI status code, see @ref BLE_HCI_STATUS_CODES (accepted values are @ref BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION and @ref BLE_HCI_CONN_INTERVAL_UNACCEPTABLE).
+ *
+ * @retval ::NRF_SUCCESS The disconnection procedure has been started successfully.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation (disconnection is already in progress).
+ */
+SVCALL(SD_BLE_GAP_DISCONNECT, uint32_t, sd_ble_gap_disconnect(uint16_t conn_handle, uint8_t hci_status_code));
+
+
+/**@brief Set the radio's transmit power.
+ *
+ * @param[in] tx_power Radio transmit power in dBm (accepted values are -40, -30, -20, -16, -12, -8, -4, 0, 3, and 4 dBm).
+ *
+ * @note The +3dBm setting is only available on nRF52 series ICs.
+ * @note The -30dBm setting is only available on nRF51 series ICs.
+ * @note The -40dBm setting is only available on nRF52 series ICs.
+ *
+ * @retval ::NRF_SUCCESS Successfully changed the transmit power.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ */
+SVCALL(SD_BLE_GAP_TX_POWER_SET, uint32_t, sd_ble_gap_tx_power_set(int8_t tx_power));
+
+
+/**@brief Set GAP Appearance value.
+ *
+ * @param[in] appearance Appearance (16-bit), see @ref BLE_APPEARANCES.
+ *
+ * @retval ::NRF_SUCCESS  Appearance value set successfully.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ */
+SVCALL(SD_BLE_GAP_APPEARANCE_SET, uint32_t, sd_ble_gap_appearance_set(uint16_t appearance));
+
+
+/**@brief Get GAP Appearance value.
+ *
+ * @param[out] p_appearance Pointer to appearance (16-bit) to be filled in, see @ref BLE_APPEARANCES.
+ *
+ * @retval ::NRF_SUCCESS Appearance value retrieved successfully.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ */
+SVCALL(SD_BLE_GAP_APPEARANCE_GET, uint32_t, sd_ble_gap_appearance_get(uint16_t *p_appearance));
+
+
+/**@brief Set GAP Peripheral Preferred Connection Parameters.
+ *
+ * @param[in] p_conn_params Pointer to a @ref ble_gap_conn_params_t structure with the desired parameters.
+ *
+ * @retval ::NRF_SUCCESS Peripheral Preferred Connection Parameters set successfully.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ */
+SVCALL(SD_BLE_GAP_PPCP_SET, uint32_t, sd_ble_gap_ppcp_set(ble_gap_conn_params_t const *p_conn_params));
+
+
+/**@brief Get GAP Peripheral Preferred Connection Parameters.
+ *
+ * @param[out] p_conn_params Pointer to a @ref ble_gap_conn_params_t structure where the parameters will be stored.
+ *
+ * @retval ::NRF_SUCCESS Peripheral Preferred Connection Parameters retrieved successfully.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ */
+SVCALL(SD_BLE_GAP_PPCP_GET, uint32_t, sd_ble_gap_ppcp_get(ble_gap_conn_params_t *p_conn_params));
+
+
+/**@brief Set GAP device name.
+ *
+ * @param[in] p_write_perm Write permissions for the Device Name characteristic, see @ref ble_gap_conn_sec_mode_t.
+ * @param[in] p_dev_name Pointer to a UTF-8 encoded, <b>non NULL-terminated</b> string.
+ * @param[in] len Length of the UTF-8, <b>non NULL-terminated</b> string pointed to by p_dev_name in octets (must be smaller or equal than @ref BLE_GAP_DEVNAME_MAX_LEN).
+ *
+ * @note If the device name is located in application flash memory (see @ref ble_gap_device_name_t), it cannot be changed. Then @ref NRF_ERROR_FORBIDDEN will be returned.
+ *
+ * @retval ::NRF_SUCCESS GAP device name and permissions set successfully.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
+ * @retval ::NRF_ERROR_FORBIDDEN Device name is not writable.
+ */
+SVCALL(SD_BLE_GAP_DEVICE_NAME_SET, uint32_t, sd_ble_gap_device_name_set(ble_gap_conn_sec_mode_t const *p_write_perm, uint8_t const *p_dev_name, uint16_t len));
+
+
+/**@brief Get GAP device name.
+ *
+ * @note          If the device name is longer than the size of the supplied buffer,
+ *                p_len will return the complete device name length,
+ *                and not the number of bytes actually returned in p_dev_name.
+ *                The application may use this information to allocate a suitable buffer size.
+ *
+ * @param[out]    p_dev_name Pointer to an empty buffer where the UTF-8 <b>non NULL-terminated</b> string will be placed. Set to NULL to obtain the complete device name length.
+ * @param[in,out] p_len      Length of the buffer pointed by p_dev_name, complete device name length on output.
+ *
+ * @retval ::NRF_SUCCESS GAP device name retrieved successfully.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
+ */
+SVCALL(SD_BLE_GAP_DEVICE_NAME_GET, uint32_t, sd_ble_gap_device_name_get(uint8_t *p_dev_name, uint16_t *p_len));
+
+
+/**@brief Initiate the GAP Authentication procedure.
+ *
+ * @details In the central role, this function will send an SMP Pairing Request (or an SMP Pairing Failed if rejected),
+ *          otherwise in the peripheral role, an SMP Security Request will be sent.
+ *
+ * @events
+ * @event{Depending on the security parameters set and the packet exchanges with the peer\, the following events may be generated:}
+ * @event{@ref BLE_GAP_EVT_SEC_PARAMS_REQUEST}
+ * @event{@ref BLE_GAP_EVT_SEC_INFO_REQUEST}
+ * @event{@ref BLE_GAP_EVT_PASSKEY_DISPLAY}
+ * @event{@ref BLE_GAP_EVT_KEY_PRESSED}
+ * @event{@ref BLE_GAP_EVT_AUTH_KEY_REQUEST}
+ * @event{@ref BLE_GAP_EVT_LESC_DHKEY_REQUEST}
+ * @event{@ref BLE_GAP_EVT_CONN_SEC_UPDATE}
+ * @event{@ref BLE_GAP_EVT_AUTH_STATUS}
+ * @event{@ref BLE_GAP_EVT_TIMEOUT}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_SEC_REQ_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_SEC_REQ_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_ENC_AUTH_MUTEX_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_PAIRING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_PAIRING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_PD_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] p_sec_params Pointer to the @ref ble_gap_sec_params_t structure with the security parameters to be used during the pairing or bonding procedure.
+ *                         In the peripheral role, only the bond, mitm, lesc and keypress fields of this structure are used.
+ *                         In the central role, this pointer may be NULL to reject a Security Request.
+ *
+ * @retval ::NRF_SUCCESS Successfully initiated authentication procedure.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
+ * @retval ::NRF_ERROR_NO_MEM The maximum number of authentication procedures that can run in parallel for the given role is reached.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ * @retval ::NRF_ERROR_NOT_SUPPORTED Setting of sign or link fields in @ref ble_gap_sec_kdist_t not supported.
+ * @retval ::NRF_ERROR_TIMEOUT A SMP timeout has occurred, and further SMP operations on this link is prohibited.
+ */
+SVCALL(SD_BLE_GAP_AUTHENTICATE, uint32_t, sd_ble_gap_authenticate(uint16_t conn_handle, ble_gap_sec_params_t const *p_sec_params));
+
+
+/**@brief Reply with GAP security parameters.
+ *
+ * @details This function is only used to reply to a @ref BLE_GAP_EVT_SEC_PARAMS_REQUEST, calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE.
+ * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
+ *
+ * @events
+ * @event{This function is used during authentication procedures\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_BONDING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_BONDING_PK_PERIPH_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_BONDING_PK_CENTRAL_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_BONDING_STATIC_PK_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_CONFIRM_FAIL_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_PAIRING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_NC_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_PD_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_KS_TOO_SMALL_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_APP_ERROR_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_REMOTE_PAIRING_FAIL_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_TIMEOUT_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_PAIRING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_PAIRING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_PD_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] sec_status Security status, see @ref BLE_GAP_SEC_STATUS.
+ * @param[in] p_sec_params Pointer to a @ref ble_gap_sec_params_t security parameters structure. In the central role this must be set to NULL, as the parameters have
+ *                         already been provided during a previous call to @ref sd_ble_gap_authenticate.
+ * @param[in,out] p_sec_keyset Pointer to a @ref ble_gap_sec_keyset_t security keyset structure. Any keys generated and/or distributed as a result of the ongoing security procedure
+ *                         will be stored into the memory referenced by the pointers inside this structure. The keys will be stored and available to the application
+ *                         upon reception of a @ref BLE_GAP_EVT_AUTH_STATUS event.
+ *                         Note that the SoftDevice expects the application to provide memory for storing the
+ *                         peer's keys. So it must be ensured that the relevant pointers inside this structure are not NULL. The pointers to the local key
+ *                         can, however, be NULL, in which case, the local key data will not be available to the application upon reception of the
+ *                         @ref BLE_GAP_EVT_AUTH_STATUS event.
+ *
+ * @retval ::NRF_SUCCESS Successfully accepted security parameter from the application.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ * @retval ::NRF_ERROR_NOT_SUPPORTED Setting of sign or link fields in @ref ble_gap_sec_kdist_t not supported.
+ */
+SVCALL(SD_BLE_GAP_SEC_PARAMS_REPLY, uint32_t, sd_ble_gap_sec_params_reply(uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const *p_sec_params, ble_gap_sec_keyset_t const *p_sec_keyset));
+
+
+/**@brief Reply with an authentication key.
+ *
+ * @details This function is only used to reply to a @ref BLE_GAP_EVT_AUTH_KEY_REQUEST or a @ref BLE_GAP_EVT_PASSKEY_DISPLAY, calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE.
+ * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
+ *
+ * @events
+ * @event{This function is used during authentication procedures\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_BONDING_PK_CENTRAL_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_NC_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] key_type See @ref BLE_GAP_AUTH_KEY_TYPES.
+ * @param[in] p_key If key type is @ref BLE_GAP_AUTH_KEY_TYPE_NONE, then NULL.
+ *                  If key type is @ref BLE_GAP_AUTH_KEY_TYPE_PASSKEY, then a 6-byte ASCII string (digit 0..9 only, no NULL termination)
+ *                     or NULL when confirming LE Secure Connections Numeric Comparison.
+ *                  If key type is @ref BLE_GAP_AUTH_KEY_TYPE_OOB, then a 16-byte OOB key value in Little Endian format.
+ *
+ * @retval ::NRF_SUCCESS Authentication key successfully set.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ */
+SVCALL(SD_BLE_GAP_AUTH_KEY_REPLY, uint32_t, sd_ble_gap_auth_key_reply(uint16_t conn_handle, uint8_t key_type, uint8_t const *p_key));
+
+/**@brief Reply with an LE Secure connections DHKey.
+ *
+ * @details This function is only used to reply to a @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST, calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE.
+ * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
+ *
+ * @events
+ * @event{This function is used during authentication procedures\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_PAIRING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_NC_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_PD_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_PAIRING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_PD_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] p_dhkey LE Secure Connections DHKey.
+ *
+ * @retval ::NRF_SUCCESS DHKey successfully set.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ */
+SVCALL(SD_BLE_GAP_LESC_DHKEY_REPLY, uint32_t, sd_ble_gap_lesc_dhkey_reply(uint16_t conn_handle, ble_gap_lesc_dhkey_t const *p_dhkey));
+
+/**@brief Notify the peer of a local keypress.
+ *
+ * @details This function can only be used when an authentication procedure using LE Secure Connection is in progress. Calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] kp_not See @ref BLE_GAP_KP_NOT_TYPES.
+ *
+ * @retval ::NRF_SUCCESS Keypress notification successfully queued for transmission.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation. Either not entering a passkey or keypresses have not been enabled by both peers.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ * @retval ::NRF_ERROR_BUSY The BLE stack is busy. Retry at later time.
+ */
+SVCALL(SD_BLE_GAP_KEYPRESS_NOTIFY, uint32_t, sd_ble_gap_keypress_notify(uint16_t conn_handle, uint8_t kp_not));
+
+/**@brief Generate a set of OOB data to send to a peer out of band.
+ *
+ * @note The @ref ble_gap_addr_t included in the OOB data returned will be the currently active one (or, if a connection has already been established,
+ *       the one used during connection setup). The application may manually overwrite it with an updated value.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle. Can be BLE_CONN_HANDLE_INVALID if a BLE connection has not been established yet.
+ * @param[in] p_pk_own LE Secure Connections local P-256 Public Key.
+ * @param[out] p_oobd_own The OOB data to be sent out of band to a peer.
+ *
+ * @retval ::NRF_SUCCESS OOB data successfully generated.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ */
+SVCALL(SD_BLE_GAP_LESC_OOB_DATA_GET, uint32_t, sd_ble_gap_lesc_oob_data_get(uint16_t conn_handle, ble_gap_lesc_p256_pk_t const *p_pk_own, ble_gap_lesc_oob_data_t *p_oobd_own));
+
+/**@brief Provide the OOB data sent/received out of band.
+ *
+ * @note At least one of the 2 pointers provided must be different from NULL.
+ * @note An authentication procedure with OOB selected as an algorithm must be in progress when calling this function.
+ * @note A @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST event with the oobd_req set to 1 must have been received prior to calling this function.
+ *
+ * @events
+ * @event{This function is used during authentication procedures\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] p_oobd_own The OOB data sent out of band to a peer or NULL if none sent.
+ * @param[in] p_oobd_peer The OOB data received out of band from a peer or NULL if none received.
+ *
+ * @retval ::NRF_SUCCESS OOB data accepted.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ */
+SVCALL(SD_BLE_GAP_LESC_OOB_DATA_SET, uint32_t, sd_ble_gap_lesc_oob_data_set(uint16_t conn_handle, ble_gap_lesc_oob_data_t const *p_oobd_own, ble_gap_lesc_oob_data_t const *p_oobd_peer));
+
+/**@brief Initiate GAP Encryption procedure.
+ *
+ * @details In the central role, this function will initiate the encryption procedure using the encryption information provided.
+ *
+ * @events
+ * @event{@ref BLE_GAP_EVT_CONN_SEC_UPDATE, The connection security has been updated.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_CENTRAL_ENC_AUTH_MUTEX_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_ENC_MSC}
+ * @mmsc{@ref BLE_GAP_MULTILINK_CTRL_PROC_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_SEC_REQ_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] p_master_id Pointer to a @ref ble_gap_master_id_t master identification structure.
+ * @param[in] p_enc_info  Pointer to a @ref ble_gap_enc_info_t encryption information structure.
+ *
+ * @retval ::NRF_SUCCESS Successfully initiated authentication procedure.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ * @retval ::BLE_ERROR_INVALID_ROLE Operation is not supported in the Peripheral role.
+ * @retval ::NRF_ERROR_BUSY Procedure already in progress or not allowed at this time, wait for pending procedures to complete and retry.
+ */
+SVCALL(SD_BLE_GAP_ENCRYPT, uint32_t, sd_ble_gap_encrypt(uint16_t conn_handle, ble_gap_master_id_t const *p_master_id, ble_gap_enc_info_t const *p_enc_info));
+
+
+/**@brief Reply with GAP security information.
+ *
+ * @details This function is only used to reply to a @ref BLE_GAP_EVT_SEC_INFO_REQUEST, calling it at other times will result in @ref NRF_ERROR_INVALID_STATE.
+ * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
+ * @note    Data signing is not yet supported, and p_sign_info must therefore be NULL.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_ENC_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] p_enc_info Pointer to a @ref ble_gap_enc_info_t encryption information structure. May be NULL to signal none is available.
+ * @param[in] p_id_info Pointer to a @ref ble_gap_irk_t identity information structure. May be NULL to signal none is available.
+ * @param[in] p_sign_info Pointer to a @ref ble_gap_sign_info_t signing information structure. May be NULL to signal none is available.
+ *
+ * @retval ::NRF_SUCCESS Successfully accepted security information.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ */
+SVCALL(SD_BLE_GAP_SEC_INFO_REPLY, uint32_t, sd_ble_gap_sec_info_reply(uint16_t conn_handle, ble_gap_enc_info_t const *p_enc_info, ble_gap_irk_t const *p_id_info, ble_gap_sign_info_t const *p_sign_info));
+
+
+/**@brief Get the current connection security.
+ *
+ * @param[in]  conn_handle Connection handle.
+ * @param[out] p_conn_sec  Pointer to a @ref ble_gap_conn_sec_t structure to be filled in.
+ *
+ * @retval ::NRF_SUCCESS Current connection security successfully retrieved.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ */
+SVCALL(SD_BLE_GAP_CONN_SEC_GET, uint32_t, sd_ble_gap_conn_sec_get(uint16_t conn_handle, ble_gap_conn_sec_t *p_conn_sec));
+
+
+/**@brief Start reporting the received signal strength to the application.
+ *
+ * A new event is reported whenever the RSSI value changes, until @ref sd_ble_gap_rssi_stop is called.
+ *
+ * @events
+ * @event{@ref BLE_GAP_EVT_RSSI_CHANGED, New RSSI data available. How often the event is generated is
+                                         dependent on the settings of the <code>threshold_dbm</code>
+                                         and <code>skip_count</code> input parameters.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_CENTRAL_RSSI_READ_MSC}
+ * @mmsc{@ref BLE_GAP_RSSI_FILT_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle        Connection handle.
+ * @param[in] threshold_dbm      Minimum change in dBm before triggering the @ref BLE_GAP_EVT_RSSI_CHANGED event. Events are disabled if threshold_dbm equals @ref BLE_GAP_RSSI_THRESHOLD_INVALID.
+ * @param[in] skip_count         Number of RSSI samples with a change of threshold_dbm or more before sending a new @ref BLE_GAP_EVT_RSSI_CHANGED event.
+ *
+ * @retval ::NRF_SUCCESS                   Successfully activated RSSI reporting.
+ * @retval ::NRF_ERROR_INVALID_STATE       Disconnection in progress. Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ */
+SVCALL(SD_BLE_GAP_RSSI_START, uint32_t, sd_ble_gap_rssi_start(uint16_t conn_handle, uint8_t threshold_dbm, uint8_t skip_count));
+
+
+/**@brief Stop reporting the received signal strength.
+ *
+ * @note An RSSI change detected before the call but not yet received by the application
+ * may be reported after @ref sd_ble_gap_rssi_stop has been called.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_CENTRAL_RSSI_READ_MSC}
+ * @mmsc{@ref BLE_GAP_RSSI_FILT_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ *
+ * @retval ::NRF_SUCCESS                   Successfully deactivated RSSI reporting.
+ * @retval ::NRF_ERROR_INVALID_STATE       Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ */
+SVCALL(SD_BLE_GAP_RSSI_STOP, uint32_t, sd_ble_gap_rssi_stop(uint16_t conn_handle));
+
+
+/**@brief Get the received signal strength for the last connection event.
+ *
+ * @ref sd_ble_gap_rssi_start must be called to start reporting RSSI before using this function. @ref NRF_ERROR_NOT_FOUND
+ * will be returned until RSSI was sampled for the first time after calling @ref sd_ble_gap_rssi_start.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_CENTRAL_RSSI_READ_MSC}
+ * @endmscs
+ *
+ * @param[in]  conn_handle Connection handle.
+ * @param[out] p_rssi      Pointer to the location where the RSSI measurement shall be stored.
+ *
+ * @retval ::NRF_SUCCESS                   Successfully read the RSSI.
+ * @retval ::NRF_ERROR_NOT_FOUND           No sample is available.
+ * @retval ::NRF_ERROR_INVALID_ADDR        Invalid pointer supplied.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE       RSSI reporting is not ongoing, or disconnection in progress.
+ */
+SVCALL(SD_BLE_GAP_RSSI_GET, uint32_t, sd_ble_gap_rssi_get(uint16_t conn_handle, int8_t *p_rssi));
+
+
+/**@brief Start scanning (GAP Discovery procedure, Observer Procedure).
+ *
+ *
+ * @events
+ * @event{@ref BLE_GAP_EVT_ADV_REPORT, An advertising or scan response packet has been received.}
+ * @event{@ref BLE_GAP_EVT_TIMEOUT, Scanner has timed out.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_SCAN_MSC}
+ * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
+ * @endmscs
+ *
+ * @param[in] p_scan_params Pointer to scan parameters structure.
+ *
+ * @retval ::NRF_SUCCESS Successfully initiated scanning procedure.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
+ * @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available.
+ *                               Stop one or more currently active roles (Central, Peripheral or Broadcaster) and try again
+ */
+SVCALL(SD_BLE_GAP_SCAN_START, uint32_t, sd_ble_gap_scan_start(ble_gap_scan_params_t const *p_scan_params));
+
+
+/**@brief Stop scanning (GAP Discovery procedure, Observer Procedure).
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_SCAN_MSC}
+ * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
+ * @endmscs
+ *
+ * @retval ::NRF_SUCCESS Successfully stopped scanning procedure.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation (most probably not in scanning state).
+ */
+SVCALL(SD_BLE_GAP_SCAN_STOP, uint32_t, sd_ble_gap_scan_stop(void));
+
+
+/**@brief Create a connection (GAP Link Establishment).
+ *
+ * @note If a scanning procedure is currently in progress it will be automatically stopped when calling this function.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_CONN_PRIV_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_CONN_MSC}
+ * @endmscs
+ *
+ * @param[in] p_peer_addr   Pointer to peer address. If the use_whitelist bit is set in @ref ble_gap_scan_params_t, then this is ignored.
+ *                          If @ref ble_gap_addr_t::addr_id_peer is set then p_peer_addr must be present in the device identity list
+ *                          see @ref sd_ble_gap_device_identities_set.
+ * @param[in] p_scan_params Pointer to scan parameters structure.
+ * @param[in] p_conn_params Pointer to desired connection parameters.
+ *
+ * @retval ::NRF_SUCCESS Successfully initiated connection procedure.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid parameter(s) pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+                                     - Invalid parameter(s) in p_scan_params or p_conn_params.
+                                     - Use of whitelist requested but whitelist has not been set, see @ref sd_ble_gap_whitelist_set.
+                                     - Peer address was not present in the device identity list, see @ref sd_ble_gap_device_identities_set.
+ * @retval ::NRF_ERROR_INVALID_STATE The SoftDevice is in an invalid state to perform this operation. This may be due to an
+ *                                   existing locally initiated connect procedure, which must complete before initiating again.
+ * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid Peer address.
+ * @retval ::NRF_ERROR_CONN_COUNT The limit of available connections has been reached.
+ * @retval ::NRF_ERROR_NO_MEM The configured memory pool (see @ref ble_conn_bw_counts_t) is not large enough for the
+ *                            bandwidth selected for this connection.
+ * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry. If another connection is being established
+ *                          wait for the corresponding @ref BLE_GAP_EVT_CONNECTED event before calling again.
+ * @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available.
+ *                               Stop one or more currently active roles (Central, Peripheral or Broadcaster) and try again
+ */
+SVCALL(SD_BLE_GAP_CONNECT, uint32_t, sd_ble_gap_connect(ble_gap_addr_t const *p_peer_addr, ble_gap_scan_params_t const *p_scan_params, ble_gap_conn_params_t const *p_conn_params));
+
+
+/**@brief Cancel a connection establishment.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_CENTRAL_CONN_MSC}
+ * @endmscs
+ *
+ * @retval ::NRF_SUCCESS Successfully cancelled an ongoing connection procedure.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ */
+SVCALL(SD_BLE_GAP_CONNECT_CANCEL, uint32_t, sd_ble_gap_connect_cancel(void));
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+#endif // BLE_GAP_H__
+
+/**
+  @}
+*/
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_gatt.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_gatt.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_gatt.h   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_gatt.h    2018-04-24 08:48:28.978154500 +0200
@@ -0,0 +1,220 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @addtogroup BLE_GATT Generic Attribute Profile (GATT) Common
+  @{
+  @brief  Common definitions and prototypes for the GATT interfaces.
+ */
+
+#ifndef BLE_GATT_H__
+#define BLE_GATT_H__
+
+#include "ble_types.h"
+#include "ble_ranges.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup BLE_GATT_DEFINES Defines
+ * @{ */
+
+/** @brief Default MTU size, in bytes. */
+#define GATT_MTU_SIZE_DEFAULT 23
+
+/**@brief Invalid Attribute Handle. */
+#define BLE_GATT_HANDLE_INVALID            0x0000
+
+/**@brief First Attribute Handle. */
+#define BLE_GATT_HANDLE_START              0x0001
+
+/**@brief Last Attribute Handle. */
+#define BLE_GATT_HANDLE_END                0xFFFF
+
+/** @defgroup BLE_GATT_TIMEOUT_SOURCES GATT Timeout sources
+ * @{ */
+#define BLE_GATT_TIMEOUT_SRC_PROTOCOL      0x00  /**< ATT Protocol timeout. */
+/** @} */
+
+/** @defgroup BLE_GATT_WRITE_OPS GATT Write operations
+ * @{ */
+#define BLE_GATT_OP_INVALID                0x00  /**< Invalid Operation. */
+#define BLE_GATT_OP_WRITE_REQ              0x01  /**< Write Request. */
+#define BLE_GATT_OP_WRITE_CMD              0x02  /**< Write Command. */
+#define BLE_GATT_OP_SIGN_WRITE_CMD         0x03  /**< Signed Write Command. */
+#define BLE_GATT_OP_PREP_WRITE_REQ         0x04  /**< Prepare Write Request. */
+#define BLE_GATT_OP_EXEC_WRITE_REQ         0x05  /**< Execute Write Request. */
+/** @} */
+
+/** @defgroup BLE_GATT_EXEC_WRITE_FLAGS GATT Execute Write flags
+ * @{ */
+#define BLE_GATT_EXEC_WRITE_FLAG_PREPARED_CANCEL 0x00   /**< Cancel prepared write. */
+#define BLE_GATT_EXEC_WRITE_FLAG_PREPARED_WRITE  0x01   /**< Execute prepared write. */
+/** @} */
+
+/** @defgroup BLE_GATT_HVX_TYPES GATT Handle Value operations
+ * @{ */
+#define BLE_GATT_HVX_INVALID               0x00  /**< Invalid Operation. */
+#define BLE_GATT_HVX_NOTIFICATION          0x01  /**< Handle Value Notification. */
+#define BLE_GATT_HVX_INDICATION            0x02  /**< Handle Value Indication. */
+/** @} */
+
+/** @defgroup BLE_GATT_STATUS_CODES GATT Status Codes
+ * @{ */
+#define BLE_GATT_STATUS_SUCCESS                           0x0000  /**< Success. */
+#define BLE_GATT_STATUS_UNKNOWN                           0x0001  /**< Unknown or not applicable status. */
+#define BLE_GATT_STATUS_ATTERR_INVALID                    0x0100  /**< ATT Error: Invalid Error Code. */
+#define BLE_GATT_STATUS_ATTERR_INVALID_HANDLE             0x0101  /**< ATT Error: Invalid Attribute Handle. */
+#define BLE_GATT_STATUS_ATTERR_READ_NOT_PERMITTED         0x0102  /**< ATT Error: Read not permitted. */
+#define BLE_GATT_STATUS_ATTERR_WRITE_NOT_PERMITTED        0x0103  /**< ATT Error: Write not permitted. */
+#define BLE_GATT_STATUS_ATTERR_INVALID_PDU                0x0104  /**< ATT Error: Used in ATT as Invalid PDU. */
+#define BLE_GATT_STATUS_ATTERR_INSUF_AUTHENTICATION       0x0105  /**< ATT Error: Authenticated link required. */
+#define BLE_GATT_STATUS_ATTERR_REQUEST_NOT_SUPPORTED      0x0106  /**< ATT Error: Used in ATT as Request Not Supported. */
+#define BLE_GATT_STATUS_ATTERR_INVALID_OFFSET             0x0107  /**< ATT Error: Offset specified was past the end of the attribute. */
+#define BLE_GATT_STATUS_ATTERR_INSUF_AUTHORIZATION        0x0108  /**< ATT Error: Used in ATT as Insufficient Authorisation. */
+#define BLE_GATT_STATUS_ATTERR_PREPARE_QUEUE_FULL         0x0109  /**< ATT Error: Used in ATT as Prepare Queue Full. */
+#define BLE_GATT_STATUS_ATTERR_ATTRIBUTE_NOT_FOUND        0x010A  /**< ATT Error: Used in ATT as Attribute not found. */
+#define BLE_GATT_STATUS_ATTERR_ATTRIBUTE_NOT_LONG         0x010B  /**< ATT Error: Attribute cannot be read or written using read/write blob requests. */
+#define BLE_GATT_STATUS_ATTERR_INSUF_ENC_KEY_SIZE         0x010C  /**< ATT Error: Encryption key size used is insufficient. */
+#define BLE_GATT_STATUS_ATTERR_INVALID_ATT_VAL_LENGTH     0x010D  /**< ATT Error: Invalid value size. */
+#define BLE_GATT_STATUS_ATTERR_UNLIKELY_ERROR             0x010E  /**< ATT Error: Very unlikely error. */
+#define BLE_GATT_STATUS_ATTERR_INSUF_ENCRYPTION           0x010F  /**< ATT Error: Encrypted link required. */
+#define BLE_GATT_STATUS_ATTERR_UNSUPPORTED_GROUP_TYPE     0x0110  /**< ATT Error: Attribute type is not a supported grouping attribute. */
+#define BLE_GATT_STATUS_ATTERR_INSUF_RESOURCES            0x0111  /**< ATT Error: Encrypted link required. */
+#define BLE_GATT_STATUS_ATTERR_RFU_RANGE1_BEGIN           0x0112  /**< ATT Error: Reserved for Future Use range #1 begin. */
+#define BLE_GATT_STATUS_ATTERR_RFU_RANGE1_END             0x017F  /**< ATT Error: Reserved for Future Use range #1 end. */
+#define BLE_GATT_STATUS_ATTERR_APP_BEGIN                  0x0180  /**< ATT Error: Application range begin. */
+#define BLE_GATT_STATUS_ATTERR_APP_END                    0x019F  /**< ATT Error: Application range end. */
+#define BLE_GATT_STATUS_ATTERR_RFU_RANGE2_BEGIN           0x01A0  /**< ATT Error: Reserved for Future Use range #2 begin. */
+#define BLE_GATT_STATUS_ATTERR_RFU_RANGE2_END             0x01DF  /**< ATT Error: Reserved for Future Use range #2 end. */
+#define BLE_GATT_STATUS_ATTERR_RFU_RANGE3_BEGIN           0x01E0  /**< ATT Error: Reserved for Future Use range #3 begin. */
+#define BLE_GATT_STATUS_ATTERR_RFU_RANGE3_END             0x01FC  /**< ATT Error: Reserved for Future Use range #3 end. */
+#define BLE_GATT_STATUS_ATTERR_CPS_CCCD_CONFIG_ERROR      0x01FD  /**< ATT Common Profile and Service Error: Client Characteristic Configuration Descriptor improperly configured. */
+#define BLE_GATT_STATUS_ATTERR_CPS_PROC_ALR_IN_PROG       0x01FE  /**< ATT Common Profile and Service Error: Procedure Already in Progress. */
+#define BLE_GATT_STATUS_ATTERR_CPS_OUT_OF_RANGE           0x01FF  /**< ATT Common Profile and Service Error: Out Of Range. */
+/** @} */
+
+
+/** @defgroup BLE_GATT_CPF_FORMATS Characteristic Presentation Formats
+ *  @note Found at http://developer.bluetooth.org/gatt/descriptors/Pages/DescriptorViewer.aspx?u=org.bluetooth.descriptor.gatt.characteristic_presentation_format.xml
+ * @{ */
+#define BLE_GATT_CPF_FORMAT_RFU                 0x00 /**< Reserved For Future Use. */
+#define BLE_GATT_CPF_FORMAT_BOOLEAN             0x01 /**< Boolean. */
+#define BLE_GATT_CPF_FORMAT_2BIT                0x02 /**< Unsigned 2-bit integer. */
+#define BLE_GATT_CPF_FORMAT_NIBBLE              0x03 /**< Unsigned 4-bit integer. */
+#define BLE_GATT_CPF_FORMAT_UINT8               0x04 /**< Unsigned 8-bit integer. */
+#define BLE_GATT_CPF_FORMAT_UINT12              0x05 /**< Unsigned 12-bit integer. */
+#define BLE_GATT_CPF_FORMAT_UINT16              0x06 /**< Unsigned 16-bit integer. */
+#define BLE_GATT_CPF_FORMAT_UINT24              0x07 /**< Unsigned 24-bit integer. */
+#define BLE_GATT_CPF_FORMAT_UINT32              0x08 /**< Unsigned 32-bit integer. */
+#define BLE_GATT_CPF_FORMAT_UINT48              0x09 /**< Unsigned 48-bit integer. */
+#define BLE_GATT_CPF_FORMAT_UINT64              0x0A /**< Unsigned 64-bit integer. */
+#define BLE_GATT_CPF_FORMAT_UINT128             0x0B /**< Unsigned 128-bit integer. */
+#define BLE_GATT_CPF_FORMAT_SINT8               0x0C /**< Signed 2-bit integer. */
+#define BLE_GATT_CPF_FORMAT_SINT12              0x0D /**< Signed 12-bit integer. */
+#define BLE_GATT_CPF_FORMAT_SINT16              0x0E /**< Signed 16-bit integer. */
+#define BLE_GATT_CPF_FORMAT_SINT24              0x0F /**< Signed 24-bit integer. */
+#define BLE_GATT_CPF_FORMAT_SINT32              0x10 /**< Signed 32-bit integer. */
+#define BLE_GATT_CPF_FORMAT_SINT48              0x11 /**< Signed 48-bit integer. */
+#define BLE_GATT_CPF_FORMAT_SINT64              0x12 /**< Signed 64-bit integer. */
+#define BLE_GATT_CPF_FORMAT_SINT128             0x13 /**< Signed 128-bit integer. */
+#define BLE_GATT_CPF_FORMAT_FLOAT32             0x14 /**< IEEE-754 32-bit floating point. */
+#define BLE_GATT_CPF_FORMAT_FLOAT64             0x15 /**< IEEE-754 64-bit floating point. */
+#define BLE_GATT_CPF_FORMAT_SFLOAT              0x16 /**< IEEE-11073 16-bit SFLOAT. */
+#define BLE_GATT_CPF_FORMAT_FLOAT               0x17 /**< IEEE-11073 32-bit FLOAT. */
+#define BLE_GATT_CPF_FORMAT_DUINT16             0x18 /**< IEEE-20601 format. */
+#define BLE_GATT_CPF_FORMAT_UTF8S               0x19 /**< UTF-8 string. */
+#define BLE_GATT_CPF_FORMAT_UTF16S              0x1A /**< UTF-16 string. */
+#define BLE_GATT_CPF_FORMAT_STRUCT              0x1B /**< Opaque Structure. */
+/** @} */
+
+/** @defgroup BLE_GATT_CPF_NAMESPACES GATT Bluetooth Namespaces
+ * @{
+ */
+#define BLE_GATT_CPF_NAMESPACE_BTSIG            0x01 /**< Bluetooth SIG defined Namespace. */
+#define BLE_GATT_CPF_NAMESPACE_DESCRIPTION_UNKNOWN 0x0000 /**< Namespace Description Unknown. */
+/** @} */
+
+/** @} */
+
+/** @addtogroup BLE_GATT_STRUCTURES Structures
+ * @{ */
+
+/**
+ * @brief BLE GATT initialization parameters.
+ */
+typedef struct
+{
+  uint16_t  att_mtu;          /**< Maximum size of ATT packet the SoftDevice can send or receive.
+                                   If it is 0 then @ref GATT_MTU_SIZE_DEFAULT will be used.
+                                   Otherwise @ref GATT_MTU_SIZE_DEFAULT is the minimum value.
+                                   @mscs
+                                   @mmsc{@ref BLE_GATTC_MTU_EXCHANGE}
+                                   @mmsc{@ref BLE_GATTS_MTU_EXCHANGE}
+                                   @endmscs
+                              */
+} ble_gatt_enable_params_t;
+
+/**@brief GATT Characteristic Properties. */
+typedef struct
+{
+  /* Standard properties */
+  uint8_t broadcast       :1; /**< Broadcasting of the value permitted. */
+  uint8_t read            :1; /**< Reading the value permitted. */
+  uint8_t write_wo_resp   :1; /**< Writing the value with Write Command permitted. */
+  uint8_t write           :1; /**< Writing the value with Write Request permitted. */
+  uint8_t notify          :1; /**< Notications of the value permitted. */
+  uint8_t indicate        :1; /**< Indications of the value permitted. */
+  uint8_t auth_signed_wr  :1; /**< Writing the value with Signed Write Command permitted. */
+} ble_gatt_char_props_t;
+
+/**@brief GATT Characteristic Extended Properties. */
+typedef struct
+{
+  /* Extended properties */
+  uint8_t reliable_wr     :1; /**< Writing the value with Queued Write operations permitted. */
+  uint8_t wr_aux          :1; /**< Writing the Characteristic User Description descriptor permitted. */
+} ble_gatt_char_ext_props_t;
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+#endif // BLE_GATT_H__
+
+/** @} */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_gattc.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_gattc.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_gattc.h  1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_gattc.h   2018-04-24 08:48:28.988154700 +0200
@@ -0,0 +1,660 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @addtogroup BLE_GATTC Generic Attribute Profile (GATT) Client
+  @{
+  @brief  Definitions and prototypes for the GATT Client interface.
+ */
+
+#ifndef BLE_GATTC_H__
+#define BLE_GATTC_H__
+
+#include "ble_gatt.h"
+#include "ble_types.h"
+#include "ble_ranges.h"
+#include "nrf_svc.h"
+#include "nrf_error.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup BLE_GATTC_ENUMERATIONS Enumerations
+ * @{ */
+
+/**@brief GATTC API SVC numbers. */
+enum BLE_GATTC_SVCS
+{
+  SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER = BLE_GATTC_SVC_BASE, /**< Primary Service Discovery. */
+  SD_BLE_GATTC_RELATIONSHIPS_DISCOVER,                         /**< Relationship Discovery. */
+  SD_BLE_GATTC_CHARACTERISTICS_DISCOVER,                       /**< Characteristic Discovery. */
+  SD_BLE_GATTC_DESCRIPTORS_DISCOVER,                           /**< Characteristic Descriptor Discovery. */
+  SD_BLE_GATTC_ATTR_INFO_DISCOVER,                             /**< Attribute Information Discovery. */
+  SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ,                        /**< Read Characteristic Value by UUID. */
+  SD_BLE_GATTC_READ,                                           /**< Generic read. */
+  SD_BLE_GATTC_CHAR_VALUES_READ,                               /**< Read multiple Characteristic Values. */
+  SD_BLE_GATTC_WRITE,                                          /**< Generic write. */
+  SD_BLE_GATTC_HV_CONFIRM,                                     /**< Handle Value Confirmation. */
+  SD_BLE_GATTC_EXCHANGE_MTU_REQUEST,                           /**< Exchange MTU Request. */
+};
+
+/**
+ * @brief GATT Client Event IDs.
+ */
+enum BLE_GATTC_EVTS
+{
+  BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP = BLE_GATTC_EVT_BASE,  /**< Primary Service Discovery Response event.      \n See @ref ble_gattc_evt_prim_srvc_disc_rsp_t.          */
+  BLE_GATTC_EVT_REL_DISC_RSP,                             /**< Relationship Discovery Response event.         \n See @ref ble_gattc_evt_rel_disc_rsp_t.                */
+  BLE_GATTC_EVT_CHAR_DISC_RSP,                            /**< Characteristic Discovery Response event.       \n See @ref ble_gattc_evt_char_disc_rsp_t.               */
+  BLE_GATTC_EVT_DESC_DISC_RSP,                            /**< Descriptor Discovery Response event.           \n See @ref ble_gattc_evt_desc_disc_rsp_t.               */
+  BLE_GATTC_EVT_ATTR_INFO_DISC_RSP,                       /**< Attribute Information Response event.          \n See @ref ble_gattc_evt_attr_info_disc_rsp_t. */
+  BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP,                /**< Read By UUID Response event.                   \n See @ref ble_gattc_evt_char_val_by_uuid_read_rsp_t.   */
+  BLE_GATTC_EVT_READ_RSP,                                 /**< Read Response event.                           \n See @ref ble_gattc_evt_read_rsp_t.                    */
+  BLE_GATTC_EVT_CHAR_VALS_READ_RSP,                       /**< Read multiple Response event.                  \n See @ref ble_gattc_evt_char_vals_read_rsp_t.          */
+  BLE_GATTC_EVT_WRITE_RSP,                                /**< Write Response event.                          \n See @ref ble_gattc_evt_write_rsp_t.                   */
+  BLE_GATTC_EVT_HVX,                                      /**< Handle Value Notification or Indication event. \n Confirm indication with @ref sd_ble_gattc_hv_confirm.  \n See @ref ble_gattc_evt_hvx_t. */
+  BLE_GATTC_EVT_EXCHANGE_MTU_RSP,                         /**< Exchange MTU Response event.                   \n See @ref ble_gattc_evt_exchange_mtu_rsp_t.            */
+  BLE_GATTC_EVT_TIMEOUT                                   /**< Timeout event.                                 \n See @ref ble_gattc_evt_timeout_t.                     */
+};
+
+/** @} */
+
+/** @addtogroup BLE_GATTC_DEFINES Defines
+ * @{ */
+
+/** @defgroup BLE_ERRORS_GATTC SVC return values specific to GATTC
+ * @{ */
+#define BLE_ERROR_GATTC_PROC_NOT_PERMITTED    (NRF_GATTC_ERR_BASE + 0x000) /**< Procedure not Permitted. */
+/** @} */
+
+/** @defgroup BLE_GATTC_ATTR_INFO_FORMAT Attribute Information Formats
+ * @{ */
+#define BLE_GATTC_ATTR_INFO_FORMAT_16BIT    1 /**< 16-bit Attribute Information Format. */
+#define BLE_GATTC_ATTR_INFO_FORMAT_128BIT   2 /**< 128-bit Attribute Information Format. */
+/** @} */
+
+/** @} */
+
+/** @addtogroup BLE_GATTC_STRUCTURES Structures
+ * @{ */
+
+/**@brief Operation Handle Range. */
+typedef struct
+{
+  uint16_t          start_handle; /**< Start Handle. */
+  uint16_t          end_handle;   /**< End Handle. */
+} ble_gattc_handle_range_t;
+
+
+/**@brief GATT service. */
+typedef struct
+{
+  ble_uuid_t               uuid;          /**< Service UUID. */
+  ble_gattc_handle_range_t handle_range;  /**< Service Handle Range. */
+} ble_gattc_service_t;
+
+
+/**@brief  GATT include. */
+typedef struct
+{
+  uint16_t            handle;           /**< Include Handle. */
+  ble_gattc_service_t included_srvc;    /**< Handle of the included service. */
+} ble_gattc_include_t;
+
+
+/**@brief GATT characteristic. */
+typedef struct
+{
+  ble_uuid_t              uuid;                 /**< Characteristic UUID. */
+  ble_gatt_char_props_t   char_props;           /**< Characteristic Properties. */
+  uint8_t                 char_ext_props : 1;   /**< Extended properties present. */
+  uint16_t                handle_decl;          /**< Handle of the Characteristic Declaration. */
+  uint16_t                handle_value;         /**< Handle of the Characteristic Value. */
+} ble_gattc_char_t;
+
+
+/**@brief GATT descriptor. */
+typedef struct
+{
+  uint16_t          handle;         /**< Descriptor Handle. */
+  ble_uuid_t        uuid;           /**< Descriptor UUID. */
+} ble_gattc_desc_t;
+
+
+/**@brief Write Parameters. */
+typedef struct
+{
+  uint8_t        write_op;             /**< Write Operation to be performed, see @ref BLE_GATT_WRITE_OPS. */
+  uint8_t        flags;                /**< Flags, see @ref BLE_GATT_EXEC_WRITE_FLAGS. */
+  uint16_t       handle;               /**< Handle to the attribute to be written. */
+  uint16_t       offset;               /**< Offset in bytes. @note For WRITE_CMD and WRITE_REQ, offset must be 0. */
+  uint16_t       len;                  /**< Length of data in bytes. */
+  uint8_t const *p_value;              /**< Pointer to the value data. */
+} ble_gattc_write_params_t;
+
+/**@brief Attribute Information for 16-bit Attribute UUID. */
+typedef struct
+{
+  uint16_t       handle;               /**< Attribute handle. */
+  ble_uuid_t     uuid;                 /**< 16-bit Attribute UUID. */
+} ble_gattc_attr_info16_t;
+
+/**@brief Attribute Information for 128-bit Attribute UUID. */
+typedef struct
+{
+  uint16_t       handle;               /**< Attribute handle. */
+  ble_uuid128_t  uuid;                 /**< 128-bit Attribute UUID. */
+} ble_gattc_attr_info128_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP. */
+typedef struct
+{
+  uint16_t             count;           /**< Service count. */
+  ble_gattc_service_t services[1];      /**< Service data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                             See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_prim_srvc_disc_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_REL_DISC_RSP. */
+typedef struct
+{
+  uint16_t             count;           /**< Include count. */
+  ble_gattc_include_t includes[1];      /**< Include data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                             See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_rel_disc_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_CHAR_DISC_RSP. */
+typedef struct
+{
+  uint16_t            count;          /**< Characteristic count. */
+  ble_gattc_char_t    chars[1];       /**< Characteristic data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                           See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_char_disc_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_DESC_DISC_RSP. */
+typedef struct
+{
+  uint16_t            count;          /**< Descriptor count. */
+  ble_gattc_desc_t    descs[1];       /**< Descriptor data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                           See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_desc_disc_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_ATTR_INFO_DISC_RSP. */
+typedef struct
+{
+  uint16_t                     count;            /**< Attribute count. */
+  uint8_t                      format;           /**< Attribute information format, see @ref BLE_GATTC_ATTR_INFO_FORMAT. */
+  union {
+    ble_gattc_attr_info16_t  attr_info16[1];     /**< Attribute information for 16-bit Attribute UUID.
+                                                      @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                                      See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+    ble_gattc_attr_info128_t attr_info128[1];    /**< Attribute information for 128-bit Attribute UUID.
+                                                      @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                                      See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+  } info;                                        /**< Attribute information union. */
+} ble_gattc_evt_attr_info_disc_rsp_t;
+
+/**@brief GATT read by UUID handle value pair. */
+typedef struct
+{
+  uint16_t            handle;          /**< Attribute Handle. */
+  uint8_t            *p_value;         /**< Pointer to the Attribute Value, length is available in @ref ble_gattc_evt_char_val_by_uuid_read_rsp_t::value_len. */
+} ble_gattc_handle_value_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP. */
+typedef struct
+{
+  uint16_t                  count;            /**< Handle-Value Pair Count. */
+  uint16_t                  value_len;        /**< Length of the value in Handle-Value(s) list. */
+  uint8_t                   handle_value[1];  /**< Handle-Value(s) list. To iterate through the list use @ref sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter.
+                                                   @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                                   See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_char_val_by_uuid_read_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_READ_RSP. */
+typedef struct
+{
+  uint16_t            handle;         /**< Attribute Handle. */
+  uint16_t            offset;         /**< Offset of the attribute data. */
+  uint16_t            len;            /**< Attribute data length. */
+  uint8_t             data[1];        /**< Attribute data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                           See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_read_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_CHAR_VALS_READ_RSP. */
+typedef struct
+{
+  uint16_t            len;            /**< Concatenated Attribute values length. */
+  uint8_t             values[1];      /**< Attribute values. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                           See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_char_vals_read_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_WRITE_RSP. */
+typedef struct
+{
+  uint16_t            handle;           /**< Attribute Handle. */
+  uint8_t             write_op;         /**< Type of write operation, see @ref BLE_GATT_WRITE_OPS. */
+  uint16_t            offset;           /**< Data offset. */
+  uint16_t            len;              /**< Data length. */
+  uint8_t             data[1];          /**< Data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                             See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_write_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_HVX. */
+typedef struct
+{
+  uint16_t            handle;         /**< Handle to which the HVx operation applies. */
+  uint8_t             type;           /**< Indication or Notification, see @ref BLE_GATT_HVX_TYPES. */
+  uint16_t            len;            /**< Attribute data length. */
+  uint8_t             data[1];        /**< Attribute data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                           See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_hvx_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_EXCHANGE_MTU_RSP. */
+typedef struct
+{
+  uint16_t          server_rx_mtu;            /**< Server RX MTU size. */
+} ble_gattc_evt_exchange_mtu_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_TIMEOUT. */
+typedef struct
+{
+  uint8_t          src;                       /**< Timeout source, see @ref BLE_GATT_TIMEOUT_SOURCES. */
+} ble_gattc_evt_timeout_t;
+
+/**@brief GATTC event structure. */
+typedef struct
+{
+  uint16_t            conn_handle;                /**< Connection Handle on which event occured. */
+  uint16_t            gatt_status;                /**< GATT status code for the operation, see @ref BLE_GATT_STATUS_CODES. */
+  uint16_t            error_handle;               /**< In case of error: The handle causing the error. In all other cases @ref BLE_GATT_HANDLE_INVALID. */
+  union
+  {
+    ble_gattc_evt_prim_srvc_disc_rsp_t          prim_srvc_disc_rsp;         /**< Primary Service Discovery Response Event Parameters. */
+    ble_gattc_evt_rel_disc_rsp_t                rel_disc_rsp;               /**< Relationship Discovery Response Event Parameters. */
+    ble_gattc_evt_char_disc_rsp_t               char_disc_rsp;              /**< Characteristic Discovery Response Event Parameters. */
+    ble_gattc_evt_desc_disc_rsp_t               desc_disc_rsp;              /**< Descriptor Discovery Response Event Parameters. */
+    ble_gattc_evt_char_val_by_uuid_read_rsp_t   char_val_by_uuid_read_rsp;  /**< Characteristic Value Read by UUID Response Event Parameters. */
+    ble_gattc_evt_read_rsp_t                    read_rsp;                   /**< Read Response Event Parameters. */
+    ble_gattc_evt_char_vals_read_rsp_t          char_vals_read_rsp;         /**< Characteristic Values Read Response Event Parameters. */
+    ble_gattc_evt_write_rsp_t                   write_rsp;                  /**< Write Response Event Parameters. */
+    ble_gattc_evt_hvx_t                         hvx;                        /**< Handle Value Notification/Indication Event Parameters. */
+    ble_gattc_evt_exchange_mtu_rsp_t            exchange_mtu_rsp;           /**< Exchange MTU Response Event Parameters. */
+    ble_gattc_evt_timeout_t                     timeout;                    /**< Timeout Event Parameters. */
+    ble_gattc_evt_attr_info_disc_rsp_t          attr_info_disc_rsp;         /**< Attribute Information Discovery Event Parameters. */
+  } params;                                                                 /**< Event Parameters. @note Only valid if @ref gatt_status == @ref BLE_GATT_STATUS_SUCCESS. */
+} ble_gattc_evt_t;
+/** @} */
+
+/** @addtogroup BLE_GATTC_FUNCTIONS Functions
+ * @{ */
+
+/**@brief Initiate or continue a GATT Primary Service Discovery procedure.
+ *
+ * @details This function initiates or resumes a Primary Service discovery procedure, starting from the supplied handle.
+ *          If the last service has not been reached, this function must be called again with an updated start handle value to continue the search.
+ *
+ * @note If any of the discovered services have 128-bit UUIDs which are not present in the table provided to ble_vs_uuids_assign, a UUID structure with
+ *       type @ref BLE_UUID_TYPE_UNKNOWN will be received in the corresponding event.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_PRIM_SRVC_DISC_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] start_handle Handle to start searching from.
+ * @param[in] p_srvc_uuid Pointer to the service UUID to be found. If it is NULL, all primary services will be returned.
+ *
+ * @retval ::NRF_SUCCESS Successfully started or resumed the Primary Service Discovery procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER, uint32_t, sd_ble_gattc_primary_services_discover(uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const *p_srvc_uuid));
+
+
+/**@brief Initiate or continue a GATT Relationship Discovery procedure.
+ *
+ * @details This function initiates or resumes the Find Included Services sub-procedure. If the last included service has not been reached,
+ *          this must be called again with an updated handle range to continue the search.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_REL_DISC_RSP}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_REL_DISC_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] p_handle_range A pointer to the range of handles of the Service to perform this procedure on.
+ *
+ * @retval ::NRF_SUCCESS Successfully started or resumed the Relationship Discovery procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_RELATIONSHIPS_DISCOVER, uint32_t, sd_ble_gattc_relationships_discover(uint16_t conn_handle, ble_gattc_handle_range_t const *p_handle_range));
+
+
+/**@brief Initiate or continue a GATT Characteristic Discovery procedure.
+ *
+ * @details This function initiates or resumes a Characteristic discovery procedure. If the last Characteristic has not been reached,
+ *          this must be called again with an updated handle range to continue the discovery.
+ *
+ * @note If any of the discovered characteristics have 128-bit UUIDs which are not present in the table provided to ble_vs_uuids_assign, a UUID structure with
+ *       type @ref BLE_UUID_TYPE_UNKNOWN will be received in the corresponding event.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_CHAR_DISC_RSP}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_CHAR_DISC_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] p_handle_range A pointer to the range of handles of the Service to perform this procedure on.
+ *
+ * @retval ::NRF_SUCCESS Successfully started or resumed the Characteristic Discovery procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_CHARACTERISTICS_DISCOVER, uint32_t, sd_ble_gattc_characteristics_discover(uint16_t conn_handle, ble_gattc_handle_range_t const *p_handle_range));
+
+
+/**@brief Initiate or continue a GATT Characteristic Descriptor Discovery procedure.
+ *
+ * @details This function initiates or resumes a Characteristic Descriptor discovery procedure. If the last Descriptor has not been reached,
+ *          this must be called again with an updated handle range to continue the discovery.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_DESC_DISC_RSP}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_DESC_DISC_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] p_handle_range A pointer to the range of handles of the Characteristic to perform this procedure on.
+ *
+ * @retval ::NRF_SUCCESS Successfully started or resumed the Descriptor Discovery procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_DESCRIPTORS_DISCOVER, uint32_t, sd_ble_gattc_descriptors_discover(uint16_t conn_handle, ble_gattc_handle_range_t const *p_handle_range));
+
+
+/**@brief Initiate or continue a GATT Read using Characteristic UUID procedure.
+ *
+ * @details This function initiates or resumes a Read using Characteristic UUID procedure. If the last Characteristic has not been reached,
+ *          this must be called again with an updated handle range to continue the discovery.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_READ_UUID_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] p_uuid Pointer to a Characteristic value UUID to read.
+ * @param[in] p_handle_range A pointer to the range of handles to perform this procedure on.
+ *
+ * @retval ::NRF_SUCCESS Successfully started or resumed the Read using Characteristic UUID procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ, uint32_t, sd_ble_gattc_char_value_by_uuid_read(uint16_t conn_handle, ble_uuid_t const *p_uuid, ble_gattc_handle_range_t const *p_handle_range));
+
+
+/**@brief Initiate or continue a GATT Read (Long) Characteristic or Descriptor procedure.
+ *
+ * @details This function initiates or resumes a GATT Read (Long) Characteristic or Descriptor procedure. If the Characteristic or Descriptor
+ *          to be read is longer than ATT_MTU - 1, this function must be called multiple times with appropriate offset to read the
+ *          complete value.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_READ_RSP}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_VALUE_READ_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] handle The handle of the attribute to be read.
+ * @param[in] offset Offset into the attribute value to be read.
+ *
+ * @retval ::NRF_SUCCESS Successfully started or resumed the Read (Long) procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_READ, uint32_t, sd_ble_gattc_read(uint16_t conn_handle, uint16_t handle, uint16_t offset));
+
+
+/**@brief Initiate a GATT Read Multiple Characteristic Values procedure.
+ *
+ * @details This function initiates a GATT Read Multiple Characteristic Values procedure.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_CHAR_VALS_READ_RSP}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_READ_MULT_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] p_handles A pointer to the handle(s) of the attribute(s) to be read.
+ * @param[in] handle_count The number of handles in p_handles.
+ *
+ * @retval ::NRF_SUCCESS Successfully started the Read Multiple Characteristic Values procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_CHAR_VALUES_READ, uint32_t, sd_ble_gattc_char_values_read(uint16_t conn_handle, uint16_t const *p_handles, uint16_t handle_count));
+
+
+/**@brief Perform a Write (Characteristic Value or Descriptor, with or without response, signed or not, long or reliable) procedure.
+ *
+ * @details This function can perform all write procedures described in GATT.
+ *
+ * @note    It is important to note that a write without response will <b>consume an application buffer</b>, and will therefore
+ *          generate a @ref BLE_EVT_TX_COMPLETE event when the packet has been transmitted. A write (with response) on the other hand will use the
+ *          standard client internal buffer and thus will only generate a @ref BLE_GATTC_EVT_WRITE_RSP event as soon as the write response
+ *          has been received from the peer. Please see the documentation of @ref sd_ble_tx_packet_count_get for more details.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_WRITE_RSP, Generated when using write request or queued writes.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_VALUE_WRITE_MSC}
+ * @mmsc{@ref BLE_GATTC_VALUE_LONG_WRITE_MSC}
+ * @mmsc{@ref BLE_GATTC_VALUE_RELIABLE_WRITE_MSC}
+ * @mmsc{@ref BLE_COMMON_APP_BUFF_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] p_write_params A pointer to a write parameters structure.
+ *
+ * @retval ::NRF_SUCCESS Successfully started the Write procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
+ * @retval ::NRF_ERROR_BUSY Procedure already in progress.
+ * @retval ::BLE_ERROR_NO_TX_PACKETS No available application packets for this connection.
+ */
+SVCALL(SD_BLE_GATTC_WRITE, uint32_t, sd_ble_gattc_write(uint16_t conn_handle, ble_gattc_write_params_t const *p_write_params));
+
+
+/**@brief Send a Handle Value Confirmation to the GATT Server.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_HVI_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] handle The handle of the attribute in the indication.
+ *
+ * @retval ::NRF_SUCCESS Successfully queued the Handle Value Confirmation for transmission.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State or no Indication pending to be confirmed.
+ * @retval ::BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle.
+ */
+SVCALL(SD_BLE_GATTC_HV_CONFIRM, uint32_t, sd_ble_gattc_hv_confirm(uint16_t conn_handle, uint16_t handle));
+
+/**@brief Discovers information about a range of attributes on a GATT server.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_ATTR_INFO_DISC_RSP, Generated when information about a range of attributes has been received.}
+ * @endevents
+ *
+ * @param[in] conn_handle    The connection handle identifying the connection to perform this procedure on.
+ * @param[in] p_handle_range The range of handles to request information about.
+ *
+ * @retval ::NRF_SUCCESS Successfully started an attribute information discovery procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid connection state
+ * @retval ::NRF_ERROR_INVALID_ADDR  Invalid pointer supplied.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_ATTR_INFO_DISCOVER, uint32_t, sd_ble_gattc_attr_info_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * p_handle_range));
+
+/**@brief Start an ATT_MTU exchange by sending an Exchange MTU Request to the server.
+ *
+ * @details The SoftDevice sets ATT_MTU to the minimum of:
+ *          - The Client RX MTU value, and
+ *          - The Server RX MTU value from @ref BLE_GATTC_EVT_EXCHANGE_MTU_RSP.
+ *
+ *          However, the SoftDevice never sets ATT_MTU lower than @ref GATT_MTU_SIZE_DEFAULT.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_EXCHANGE_MTU_RSP}
+ * @event{@ref BLE_EVT_DATA_LENGTH_CHANGED, Generated if a data length update procedure is performed after the ATT_MTU exchange.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_MTU_EXCHANGE}
+ * @endmscs
+ *
+ * @param[in] conn_handle    The connection handle identifying the connection to perform this procedure on.
+ * @param[in] client_rx_mtu  Client RX MTU size.
+ *                           - The minimum value is @ref GATT_MTU_SIZE_DEFAULT.
+ *                           - The maximum value is @ref ble_gatt_enable_params_t::att_mtu.
+ *                           - The value must be equal to Server RX MTU size given in @ref sd_ble_gatts_exchange_mtu_reply
+ *                             if an ATT_MTU exchange has already been performed in the other direction.
+ *
+ * @retval ::NRF_SUCCESS Successfully sent request to the server.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid connection state or an ATT_MTU exchange was already requested once.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid Client RX MTU size supplied.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_EXCHANGE_MTU_REQUEST, uint32_t, sd_ble_gattc_exchange_mtu_request(uint16_t conn_handle, uint16_t client_rx_mtu));
+
+/**@brief Iterate through Handle-Value(s) list in @ref BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP event.
+ *
+ * @param[in] p_gattc_evt  Pointer to event buffer containing @ref BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP event.
+ *                         @note If the buffer contains different event, behavior is undefined.
+ * @param[in,out] p_iter   Iterator, points to @ref ble_gattc_handle_value_t structure that will be filled in with
+ *                         the next Handle-Value pair in each iteration. If the function returns other than
+ *                         @ref NRF_SUCCESS, it will not be changed.
+ *                         - To start iteration, initialize the structure to zero.
+ *                         - To continue, pass the value from previous iteration.
+ *
+ * \code
+ * ble_gattc_handle_value_t iter;
+ * memset(&iter, 0, sizeof(ble_gattc_handle_value_t));
+ * while (sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter(&ble_evt.evt.gattc_evt, &iter) == NRF_SUCCESS)
+ * {
+ *   app_handle = iter.handle;
+ *   memcpy(app_value, iter.p_value, ble_evt.evt.gattc_evt.params.char_val_by_uuid_read_rsp.value_len);
+ * }
+ * \endcode
+ *
+ * @retval ::NRF_SUCCESS Successfully retrieved the next Handle-Value pair.
+ * @retval ::NRF_ERROR_NOT_FOUND No more Handle-Value pairs available in the list.
+ */
+static inline uint32_t sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter(ble_gattc_evt_t *p_gattc_evt, ble_gattc_handle_value_t *p_iter)
+{
+  uint32_t value_len = p_gattc_evt->params.char_val_by_uuid_read_rsp.value_len;
+  uint8_t *p_first = p_gattc_evt->params.char_val_by_uuid_read_rsp.handle_value;
+  uint8_t *p_next = p_iter->p_value ? p_iter->p_value + value_len : p_first;
+
+  if ((p_next - p_first) / (sizeof(uint16_t) + value_len) < p_gattc_evt->params.char_val_by_uuid_read_rsp.count)
+  {
+    p_iter->handle = (uint16_t)p_next[1] << 8 | p_next[0];
+    p_iter->p_value = p_next + sizeof(uint16_t);
+    return NRF_SUCCESS;
+  }
+  else
+  {
+    return NRF_ERROR_NOT_FOUND;
+  }
+}
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* BLE_GATTC_H__ */
+
+/**
+  @}
+*/
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_gatts.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_gatts.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_gatts.h  1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_gatts.h   2018-04-24 08:48:28.988154700 +0200
@@ -0,0 +1,778 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @addtogroup BLE_GATTS Generic Attribute Profile (GATT) Server
+  @{
+  @brief  Definitions and prototypes for the GATTS interface.
+ */
+
+#ifndef BLE_GATTS_H__
+#define BLE_GATTS_H__
+
+#include "ble_types.h"
+#include "ble_ranges.h"
+#include "ble_l2cap.h"
+#include "ble_gap.h"
+#include "ble_gatt.h"
+#include "nrf_svc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup BLE_GATTS_ENUMERATIONS Enumerations
+ * @{ */
+
+/**
+ * @brief GATTS API SVC numbers.
+ */
+enum BLE_GATTS_SVCS
+{
+  SD_BLE_GATTS_SERVICE_ADD = BLE_GATTS_SVC_BASE, /**< Add a service. */
+  SD_BLE_GATTS_INCLUDE_ADD,                      /**< Add an included service. */
+  SD_BLE_GATTS_CHARACTERISTIC_ADD,               /**< Add a characteristic. */
+  SD_BLE_GATTS_DESCRIPTOR_ADD,                   /**< Add a generic attribute. */
+  SD_BLE_GATTS_VALUE_SET,                        /**< Set an attribute value. */
+  SD_BLE_GATTS_VALUE_GET,                        /**< Get an attribute value. */
+  SD_BLE_GATTS_HVX,                              /**< Handle Value Notification or Indication. */
+  SD_BLE_GATTS_SERVICE_CHANGED,                  /**< Perform a Service Changed Indication to one or more peers. */
+  SD_BLE_GATTS_RW_AUTHORIZE_REPLY,               /**< Reply to an authorization request for a read or write operation on one or more attributes. */
+  SD_BLE_GATTS_SYS_ATTR_SET,                     /**< Set the persistent system attributes for a connection. */
+  SD_BLE_GATTS_SYS_ATTR_GET,                     /**< Retrieve the persistent system attributes. */
+  SD_BLE_GATTS_INITIAL_USER_HANDLE_GET,          /**< Retrieve the first valid user handle. */
+  SD_BLE_GATTS_ATTR_GET,                         /**< Retrieve the UUID and/or metadata of an attribute. */
+  SD_BLE_GATTS_EXCHANGE_MTU_REPLY                /**< Reply to Exchange MTU Request. */
+};
+
+/**
+ * @brief GATT Server Event IDs.
+ */
+enum BLE_GATTS_EVTS
+{
+  BLE_GATTS_EVT_WRITE = BLE_GATTS_EVT_BASE,       /**< Write operation performed.                                           \n See @ref ble_gatts_evt_write_t.                 */
+  BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST,             /**< Read/Write Authorization request.                                    \n Reply with @ref sd_ble_gatts_rw_authorize_reply. \n See @ref ble_gatts_evt_rw_authorize_request_t. */
+  BLE_GATTS_EVT_SYS_ATTR_MISSING,                 /**< A persistent system attribute access is pending.                     \n Respond with @ref sd_ble_gatts_sys_attr_set.     \n See @ref ble_gatts_evt_sys_attr_missing_t.     */
+  BLE_GATTS_EVT_HVC,                              /**< Handle Value Confirmation.                                           \n See @ref ble_gatts_evt_hvc_t.                   */
+  BLE_GATTS_EVT_SC_CONFIRM,                       /**< Service Changed Confirmation. No additional event structure applies.                                                    */
+  BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST,             /**< Exchange MTU Request.                                                \n Reply with @ref sd_ble_gatts_exchange_mtu_reply. \n See @ref ble_gatts_evt_exchange_mtu_request_t. */
+  BLE_GATTS_EVT_TIMEOUT                           /**< Peer failed to resonpond to an ATT request in time.                  \n See @ref ble_gatts_evt_timeout_t.               */
+};
+/** @} */
+
+/** @addtogroup BLE_GATTS_DEFINES Defines
+ * @{ */
+
+/** @defgroup BLE_ERRORS_GATTS SVC return values specific to GATTS
+ * @{ */
+#define BLE_ERROR_GATTS_INVALID_ATTR_TYPE   (NRF_GATTS_ERR_BASE + 0x000) /**< Invalid attribute type. */
+#define BLE_ERROR_GATTS_SYS_ATTR_MISSING    (NRF_GATTS_ERR_BASE + 0x001) /**< System Attributes missing. */
+/** @} */
+
+/** @defgroup BLE_GATTS_ATTR_LENS_MAX Maximum attribute lengths
+ * @{ */
+#define BLE_GATTS_FIX_ATTR_LEN_MAX (510)  /**< Maximum length for fixed length Attribute Values. */
+#define BLE_GATTS_VAR_ATTR_LEN_MAX (512)  /**< Maximum length for variable length Attribute Values. */
+/** @} */
+
+/** @defgroup BLE_GATTS_SRVC_TYPES GATT Server Service Types
+ * @{ */
+#define BLE_GATTS_SRVC_TYPE_INVALID          0x00  /**< Invalid Service Type. */
+#define BLE_GATTS_SRVC_TYPE_PRIMARY          0x01  /**< Primary Service. */
+#define BLE_GATTS_SRVC_TYPE_SECONDARY        0x02  /**< Secondary Type. */
+/** @} */
+
+
+/** @defgroup BLE_GATTS_ATTR_TYPES GATT Server Attribute Types
+ * @{ */
+#define BLE_GATTS_ATTR_TYPE_INVALID         0x00  /**< Invalid Attribute Type. */
+#define BLE_GATTS_ATTR_TYPE_PRIM_SRVC_DECL  0x01  /**< Primary Service Declaration. */
+#define BLE_GATTS_ATTR_TYPE_SEC_SRVC_DECL   0x02  /**< Secondary Service Declaration. */
+#define BLE_GATTS_ATTR_TYPE_INC_DECL        0x03  /**< Include Declaration. */
+#define BLE_GATTS_ATTR_TYPE_CHAR_DECL       0x04  /**< Characteristic Declaration. */
+#define BLE_GATTS_ATTR_TYPE_CHAR_VAL        0x05  /**< Characteristic Value. */
+#define BLE_GATTS_ATTR_TYPE_DESC            0x06  /**< Descriptor. */
+#define BLE_GATTS_ATTR_TYPE_OTHER           0x07  /**< Other, non-GATT specific type. */
+/** @} */
+
+
+/** @defgroup BLE_GATTS_OPS GATT Server Operations
+ * @{ */
+#define BLE_GATTS_OP_INVALID                0x00  /**< Invalid Operation. */
+#define BLE_GATTS_OP_WRITE_REQ              0x01  /**< Write Request. */
+#define BLE_GATTS_OP_WRITE_CMD              0x02  /**< Write Command. */
+#define BLE_GATTS_OP_SIGN_WRITE_CMD         0x03  /**< Signed Write Command. */
+#define BLE_GATTS_OP_PREP_WRITE_REQ         0x04  /**< Prepare Write Request. */
+#define BLE_GATTS_OP_EXEC_WRITE_REQ_CANCEL  0x05  /**< Execute Write Request: Cancel all prepared writes. */
+#define BLE_GATTS_OP_EXEC_WRITE_REQ_NOW     0x06  /**< Execute Write Request: Immediately execute all prepared writes. */
+/** @} */
+
+/** @defgroup BLE_GATTS_VLOCS GATT Value Locations
+ * @{ */
+#define BLE_GATTS_VLOC_INVALID       0x00  /**< Invalid Location. */
+#define BLE_GATTS_VLOC_STACK         0x01  /**< Attribute Value is located in stack memory, no user memory is required. */
+#define BLE_GATTS_VLOC_USER          0x02  /**< Attribute Value is located in user memory. This requires the user to maintain a valid buffer through the lifetime of the attribute, since the stack
+                                                will read and write directly to the memory using the pointer provided in the APIs. There are no alignment requirements for the buffer. */
+/** @} */
+
+/** @defgroup BLE_GATTS_AUTHORIZE_TYPES GATT Server Authorization Types
+ * @{ */
+#define BLE_GATTS_AUTHORIZE_TYPE_INVALID    0x00  /**< Invalid Type. */
+#define BLE_GATTS_AUTHORIZE_TYPE_READ       0x01  /**< Authorize a Read Operation. */
+#define BLE_GATTS_AUTHORIZE_TYPE_WRITE      0x02  /**< Authorize a Write Request Operation. */
+/** @} */
+
+/** @defgroup BLE_GATTS_SYS_ATTR_FLAGS System Attribute Flags
+ * @{ */
+#define BLE_GATTS_SYS_ATTR_FLAG_SYS_SRVCS (1 << 0)  /**< Restrict system attributes to system services only. */
+#define BLE_GATTS_SYS_ATTR_FLAG_USR_SRVCS (1 << 1)  /**< Restrict system attributes to user services only. */
+/** @} */
+
+/** @defgroup BLE_GATTS_ATTR_TAB_SIZE Attribute Table size
+ * @{
+ */
+#define BLE_GATTS_ATTR_TAB_SIZE_MIN         248    /**< Minimum Attribute Table size */
+#define BLE_GATTS_ATTR_TAB_SIZE_DEFAULT     0x0000 /**< Default Attribute Table size (0x580 bytes for this version of the SoftDevice). */
+/** @} */
+
+/** @} */
+
+/** @addtogroup BLE_GATTS_STRUCTURES Structures
+ * @{ */
+
+/**
+ * @brief BLE GATTS initialization parameters.
+ */
+typedef struct
+{
+  uint8_t                  service_changed:1; /**< Include the Service Changed characteristic in the Attribute Table. */
+  uint32_t                 attr_tab_size;     /**< Attribute Table size in bytes. The size must be a multiple of 4. @ref BLE_GATTS_ATTR_TAB_SIZE_DEFAULT is used to set the default size. */
+} ble_gatts_enable_params_t;
+
+/**@brief Attribute metadata. */
+typedef struct
+{
+  ble_gap_conn_sec_mode_t read_perm;       /**< Read permissions. */
+  ble_gap_conn_sec_mode_t write_perm;      /**< Write permissions. */
+  uint8_t                 vlen       :1;   /**< Variable length attribute. */
+  uint8_t                 vloc       :2;   /**< Value location, see @ref BLE_GATTS_VLOCS.*/
+  uint8_t                 rd_auth    :1;   /**< Read authorization and value will be requested from the application on every read operation. */
+  uint8_t                 wr_auth    :1;   /**< Write authorization will be requested from the application on every Write Request operation (but not Write Command). */
+} ble_gatts_attr_md_t;
+
+
+/**@brief GATT Attribute. */
+typedef struct
+{
+  ble_uuid_t          *p_uuid;          /**< Pointer to the attribute UUID. */
+  ble_gatts_attr_md_t *p_attr_md;       /**< Pointer to the attribute metadata structure. */
+  uint16_t             init_len;        /**< Initial attribute value length in bytes. */
+  uint16_t             init_offs;       /**< Initial attribute value offset in bytes. If different from zero, the first init_offs bytes of the attribute value will be left uninitialized. */
+  uint16_t             max_len;         /**< Maximum attribute value length in bytes, see @ref BLE_GATTS_ATTR_LENS_MAX for maximum values. */
+  uint8_t*             p_value;         /**< Pointer to the attribute data. Please note that if the @ref BLE_GATTS_VLOC_USER value location is selected in the attribute metadata, this will have to point to a buffer
+                                             that remains valid through the lifetime of the attribute. This excludes usage of automatic variables that may go out of scope or any other temporary location.
+                                             The stack may access that memory directly without the application's knowledge. For writable characteristics, this value must not be a location in flash memory.*/
+} ble_gatts_attr_t;
+
+/**@brief GATT Attribute Value. */
+typedef struct
+{
+  uint16_t  len;        /**< Length in bytes to be written or read. Length in bytes written or read after successful return.*/
+  uint16_t  offset;     /**< Attribute value offset. */
+  uint8_t   *p_value;   /**< Pointer to where value is stored or will be stored.
+                             If value is stored in user memory, only the attribute length is updated when p_value == NULL.
+                             Set to NULL when reading to obtain the complete length of the attribute value */
+} ble_gatts_value_t;
+
+
+/**@brief GATT Characteristic Presentation Format. */
+typedef struct
+{
+  uint8_t          format;      /**< Format of the value, see @ref BLE_GATT_CPF_FORMATS. */
+  int8_t           exponent;    /**< Exponent for integer data types. */
+  uint16_t         unit;        /**< Unit from Bluetooth Assigned Numbers. */
+  uint8_t          name_space;  /**< Namespace from Bluetooth Assigned Numbers, see @ref BLE_GATT_CPF_NAMESPACES. */
+  uint16_t         desc;        /**< Namespace description from Bluetooth Assigned Numbers, see @ref BLE_GATT_CPF_NAMESPACES. */
+} ble_gatts_char_pf_t;
+
+
+/**@brief GATT Characteristic metadata. */
+typedef struct
+{
+  ble_gatt_char_props_t       char_props;               /**< Characteristic Properties. */
+  ble_gatt_char_ext_props_t   char_ext_props;           /**< Characteristic Extended Properties. */
+  uint8_t                    *p_char_user_desc;         /**< Pointer to a UTF-8 encoded string (non-NULL terminated), NULL if the descriptor is not required. */
+  uint16_t                    char_user_desc_max_size;  /**< The maximum size in bytes of the user description descriptor. */
+  uint16_t                    char_user_desc_size;      /**< The size of the user description, must be smaller or equal to char_user_desc_max_size. */
+  ble_gatts_char_pf_t*        p_char_pf;                /**< Pointer to a presentation format structure or NULL if the CPF descriptor is not required. */
+  ble_gatts_attr_md_t*        p_user_desc_md;           /**< Attribute metadata for the User Description descriptor, or NULL for default values. */
+  ble_gatts_attr_md_t*        p_cccd_md;                /**< Attribute metadata for the Client Characteristic Configuration Descriptor, or NULL for default values. */
+  ble_gatts_attr_md_t*        p_sccd_md;                /**< Attribute metadata for the Server Characteristic Configuration Descriptor, or NULL for default values. */
+} ble_gatts_char_md_t;
+
+
+/**@brief GATT Characteristic Definition Handles. */
+typedef struct
+{
+  uint16_t          value_handle;       /**< Handle to the characteristic value. */
+  uint16_t          user_desc_handle;   /**< Handle to the User Description descriptor, or @ref BLE_GATT_HANDLE_INVALID if not present. */
+  uint16_t          cccd_handle;        /**< Handle to the Client Characteristic Configuration Descriptor, or @ref BLE_GATT_HANDLE_INVALID if not present. */
+  uint16_t          sccd_handle;        /**< Handle to the Server Characteristic Configuration Descriptor, or @ref BLE_GATT_HANDLE_INVALID if not present. */
+} ble_gatts_char_handles_t;
+
+
+/**@brief GATT HVx parameters. */
+typedef struct
+{
+  uint16_t          handle;             /**< Characteristic Value Handle. */
+  uint8_t           type;               /**< Indication or Notification, see @ref BLE_GATT_HVX_TYPES. */
+  uint16_t          offset;             /**< Offset within the attribute value. */
+  uint16_t         *p_len;              /**< Length in bytes to be written, length in bytes written after successful return. */
+  uint8_t          *p_data;             /**< Actual data content, use NULL to use the current attribute value. */
+} ble_gatts_hvx_params_t;
+
+/**@brief GATT Authorization parameters. */
+typedef struct
+{
+  uint16_t          gatt_status;        /**< GATT status code for the operation, see @ref BLE_GATT_STATUS_CODES. */
+  uint8_t           update : 1;         /**< If set, data supplied in p_data will be used to update the attribute value.
+                                             Please note that for @ref BLE_GATTS_AUTHORIZE_TYPE_WRITE operations this bit must always be set,
+                                             as the data to be written needs to be stored and later provided by the application. */
+  uint16_t          offset;             /**< Offset of the attribute value being updated. */
+  uint16_t          len;                /**< Length in bytes of the value in p_data pointer, see @ref BLE_GATTS_ATTR_LENS_MAX. */
+  const uint8_t    *p_data;             /**< Pointer to new value used to update the attribute value. */
+} ble_gatts_authorize_params_t;
+
+/**@brief GATT Read or Write Authorize Reply parameters. */
+typedef struct
+{
+  uint8_t                               type;   /**< Type of authorize operation, see @ref BLE_GATTS_AUTHORIZE_TYPES. */
+  union {
+    ble_gatts_authorize_params_t        read;   /**< Read authorization parameters. */
+    ble_gatts_authorize_params_t        write;  /**< Write authorization parameters. */
+  } params;                                     /**< Reply Parameters. */
+} ble_gatts_rw_authorize_reply_params_t;
+
+
+
+/**@brief Event structure for @ref BLE_GATTS_EVT_WRITE. */
+typedef struct
+{
+  uint16_t                    handle;             /**< Attribute Handle. */
+  ble_uuid_t                  uuid;               /**< Attribute UUID. */
+  uint8_t                     op;                 /**< Type of write operation, see @ref BLE_GATTS_OPS. */
+  uint8_t                     auth_required;      /**< Writing operation deferred due to authorization requirement. Application may use @ref sd_ble_gatts_value_set to finalise the writing operation. */
+  uint16_t                    offset;             /**< Offset for the write operation. */
+  uint16_t                    len;                /**< Length of the received data. */
+  uint8_t                     data[1];            /**< Received data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                                       See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gatts_evt_write_t;
+
+/**@brief Event substructure for authorized read requests, see @ref ble_gatts_evt_rw_authorize_request_t. */
+typedef struct
+{
+  uint16_t                    handle;             /**< Attribute Handle. */
+  ble_uuid_t                  uuid;               /**< Attribute UUID. */
+  uint16_t                    offset;             /**< Offset for the read operation. */
+} ble_gatts_evt_read_t;
+
+/**@brief Event structure for @ref BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST. */
+typedef struct
+{
+  uint8_t                     type;             /**< Type of authorize operation, see @ref BLE_GATTS_AUTHORIZE_TYPES. */
+  union {
+    ble_gatts_evt_read_t      read;             /**< Attribute Read Parameters. */
+    ble_gatts_evt_write_t     write;            /**< Attribute Write Parameters. */
+  } request;                                    /**< Request Parameters. */
+} ble_gatts_evt_rw_authorize_request_t;
+
+/**@brief Event structure for @ref BLE_GATTS_EVT_SYS_ATTR_MISSING. */
+typedef struct
+{
+  uint8_t hint;                                 /**< Hint (currently unused). */
+} ble_gatts_evt_sys_attr_missing_t;
+
+
+/**@brief Event structure for @ref BLE_GATTS_EVT_HVC. */
+typedef struct
+{
+  uint16_t          handle;                       /**< Attribute Handle. */
+} ble_gatts_evt_hvc_t;
+
+/**@brief Event structure for @ref BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST. */
+typedef struct
+{
+  uint16_t          client_rx_mtu;              /**< Client RX MTU size. */
+} ble_gatts_evt_exchange_mtu_request_t;
+
+/**@brief Event structure for @ref BLE_GATTS_EVT_TIMEOUT. */
+typedef struct
+{
+  uint8_t          src;                       /**< Timeout source, see @ref BLE_GATT_TIMEOUT_SOURCES. */
+} ble_gatts_evt_timeout_t;
+
+
+/**@brief GATTS event structure. */
+typedef struct
+{
+  uint16_t conn_handle;                                       /**< Connection Handle on which the event occurred. */
+  union
+  {
+    ble_gatts_evt_write_t                 write;                 /**< Write Event Parameters. */
+    ble_gatts_evt_rw_authorize_request_t  authorize_request;     /**< Read or Write Authorize Request Parameters. */
+    ble_gatts_evt_sys_attr_missing_t      sys_attr_missing;      /**< System attributes missing. */
+    ble_gatts_evt_hvc_t                   hvc;                   /**< Handle Value Confirmation Event Parameters. */
+    ble_gatts_evt_exchange_mtu_request_t  exchange_mtu_request;  /**< Exchange MTU Request Event Parameters. */
+    ble_gatts_evt_timeout_t               timeout;               /**< Timeout Event. */
+  } params;                                                      /**< Event Parameters. */
+} ble_gatts_evt_t;
+
+/** @} */
+
+/** @addtogroup BLE_GATTS_FUNCTIONS Functions
+ * @{ */
+
+/**@brief Add a service declaration to the Attribute Table.
+ *
+ * @note Secondary Services are only relevant in the context of the entity that references them, it is therefore forbidden to
+ *       add a secondary service declaration that is not referenced by another service later in the Attribute Table.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTS_ATT_TABLE_POP_MSC}
+ * @endmscs
+ *
+ * @param[in] type      Toggles between primary and secondary services, see @ref BLE_GATTS_SRVC_TYPES.
+ * @param[in] p_uuid    Pointer to service UUID.
+ * @param[out] p_handle Pointer to a 16-bit word where the assigned handle will be stored.
+ *
+ * @retval ::NRF_SUCCESS Successfully added a service declaration.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, Vendor Specific UUIDs need to be present in the table.
+ * @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
+ * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
+ */
+SVCALL(SD_BLE_GATTS_SERVICE_ADD, uint32_t, sd_ble_gatts_service_add(uint8_t type, ble_uuid_t const *p_uuid, uint16_t *p_handle));
+
+
+/**@brief Add an include declaration to the Attribute Table.
+ *
+ * @note It is currently only possible to add an include declaration to the last added service (i.e. only sequential population is supported at this time).
+ *
+ * @note The included service must already be present in the Attribute Table prior to this call.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTS_ATT_TABLE_POP_MSC}
+ * @endmscs
+ *
+ * @param[in] service_handle    Handle of the service where the included service is to be placed, if @ref BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially.
+ * @param[in] inc_srvc_handle   Handle of the included service.
+ * @param[out] p_include_handle Pointer to a 16-bit word where the assigned handle will be stored.
+ *
+ * @retval ::NRF_SUCCESS Successfully added an include declaration.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, handle values need to match previously added services.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::NRF_ERROR_NOT_SUPPORTED Feature is not supported, service_handle must be that of the last added service.
+ * @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, self inclusions are not allowed.
+ * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
+ * @retval ::NRF_ERROR_NOT_FOUND Attribute not found.
+ */
+SVCALL(SD_BLE_GATTS_INCLUDE_ADD, uint32_t, sd_ble_gatts_include_add(uint16_t service_handle, uint16_t inc_srvc_handle, uint16_t *p_include_handle));
+
+
+/**@brief Add a characteristic declaration, a characteristic value declaration and optional characteristic descriptor declarations to the Attribute Table.
+ *
+ * @note It is currently only possible to add a characteristic to the last added service (i.e. only sequential population is supported at this time).
+ *
+ * @note Several restrictions apply to the parameters, such as matching permissions between the user description descriptor and the writeable auxiliaries bits,
+ *       readable (no security) and writeable (selectable) CCCDs and SCCDs and valid presentation format values.
+ *
+ * @note If no metadata is provided for the optional descriptors, their permissions will be derived from the characteristic permissions.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTS_ATT_TABLE_POP_MSC}
+ * @endmscs
+ *
+ * @param[in] service_handle    Handle of the service where the characteristic is to be placed, if @ref BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially.
+ * @param[in] p_char_md         Characteristic metadata.
+ * @param[in] p_attr_char_value Pointer to the attribute structure corresponding to the characteristic value.
+ * @param[out] p_handles        Pointer to the structure where the assigned handles will be stored.
+ *
+ * @retval ::NRF_SUCCESS Successfully added a characteristic.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, service handle, Vendor Specific UUIDs, lengths, and permissions need to adhere to the constraints.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation, a service context is required.
+ * @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
+ * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
+ * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX.
+ */
+SVCALL(SD_BLE_GATTS_CHARACTERISTIC_ADD, uint32_t, sd_ble_gatts_characteristic_add(uint16_t service_handle, ble_gatts_char_md_t const *p_char_md, ble_gatts_attr_t const *p_attr_char_value, ble_gatts_char_handles_t *p_handles));
+
+
+/**@brief Add a descriptor to the Attribute Table.
+ *
+ * @note It is currently only possible to add a descriptor to the last added characteristic (i.e. only sequential population is supported at this time).
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTS_ATT_TABLE_POP_MSC}
+ * @endmscs
+ *
+ * @param[in] char_handle   Handle of the characteristic where the descriptor is to be placed, if @ref BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially.
+ * @param[in] p_attr        Pointer to the attribute structure.
+ * @param[out] p_handle     Pointer to a 16-bit word where the assigned handle will be stored.
+ *
+ * @retval ::NRF_SUCCESS Successfully added a descriptor.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, characteristic handle, Vendor Specific UUIDs, lengths, and permissions need to adhere to the constraints.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation, a characteristic context is required.
+ * @retval ::NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
+ * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
+ * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX.
+ */
+SVCALL(SD_BLE_GATTS_DESCRIPTOR_ADD, uint32_t, sd_ble_gatts_descriptor_add(uint16_t char_handle, ble_gatts_attr_t const *p_attr, uint16_t *p_handle));
+
+/**@brief Set the value of a given attribute.
+ *
+ * @note Values other than system attributes can be set at any time, regardless of wheter any active connections exist.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_QUEUE_FULL_MSC}
+ * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_NOAUTH_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle  Connection handle. If the value does not belong to a system attribute then @ref BLE_CONN_HANDLE_INVALID can be used.
+ * @param[in] handle       Attribute handle.
+ * @param[in,out] p_value  Attribute value information.
+ *
+ * @retval ::NRF_SUCCESS Successfully set the value of the attribute.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_NOT_FOUND Attribute not found.
+ * @retval ::NRF_ERROR_FORBIDDEN Forbidden handle supplied, certain attributes are not modifiable by the application.
+ * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ * @retval ::BLE_ERROR_GATTS_INVALID_ATTR_TYPE @ref BLE_CONN_HANDLE_INVALID supplied on a system attribute.
+ */
+SVCALL(SD_BLE_GATTS_VALUE_SET, uint32_t, sd_ble_gatts_value_set(uint16_t conn_handle, uint16_t handle, ble_gatts_value_t *p_value));
+
+/**@brief Get the value of a given attribute.
+ *
+ * @note                 If the attribute value is longer than the size of the supplied buffer,
+ *                       p_len will return the total attribute value length (excluding offset),
+ *                       and not the number of bytes actually returned in p_data.
+ *                       The application may use this information to allocate a suitable buffer size.
+ *
+ * @note                 When retrieving system attribute values with this function, the connection handle
+ *                       may refer to an already disconnected connection. Refer to the documentation of
+ *                       @ref sd_ble_gatts_sys_attr_get for further information.
+ *
+ * @param[in] conn_handle  Connection handle. If the value does not belong to a system attribute then @ref BLE_CONN_HANDLE_INVALID can be used.
+ * @param[in] handle       Attribute handle.
+ * @param[in,out] p_value  Attribute value information.
+ *
+ * @retval ::NRF_SUCCESS Successfully retrieved the value of the attribute.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_NOT_FOUND Attribute not found.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid attribute offset supplied.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ * @retval ::BLE_ERROR_GATTS_INVALID_ATTR_TYPE @ref BLE_CONN_HANDLE_INVALID supplied on a system attribute.
+ * @retval ::BLE_ERROR_GATTS_SYS_ATTR_MISSING System attributes missing, use @ref sd_ble_gatts_sys_attr_set to set them to a known value.
+ */
+SVCALL(SD_BLE_GATTS_VALUE_GET, uint32_t, sd_ble_gatts_value_get(uint16_t conn_handle, uint16_t handle, ble_gatts_value_t *p_value));
+
+/**@brief Notify or Indicate an attribute value.
+ *
+ * @details This function checks for the relevant Client Characteristic Configuration descriptor value to verify that the relevant operation
+ *          (notification or indication) has been enabled by the client. It is also able to update the attribute value before issuing the PDU, so that
+ *          the application can atomically perform a value update and a server initiated transaction with a single API call.
+ *          If the application chooses to indicate an attribute value, a @ref BLE_GATTS_EVT_HVC event will be issued as soon as the confirmation arrives from
+ *          the peer.
+ *
+ * @note    The local attribute value may be updated even if an outgoing packet is not sent to the peer due to an error during execution.
+ *          The Attribute Table has been updated if one of the following error codes is returned: @ref NRF_ERROR_INVALID_STATE, @ref NRF_ERROR_BUSY,
+ *          @ref NRF_ERROR_FORBIDDEN, @ref BLE_ERROR_GATTS_SYS_ATTR_MISSING and @ref BLE_ERROR_NO_TX_PACKETS.
+ *          The caller can check whether the value has been updated by looking at the contents of *(p_hvx_params->p_len).
+ *
+ * @note    It is important to note that a notification will <b>consume an application buffer</b>, and will therefore
+ *          generate a @ref BLE_EVT_TX_COMPLETE event when the packet has been transmitted. An indication on the other hand will use the
+ *          standard server internal buffer and thus will only generate a @ref BLE_GATTS_EVT_HVC event as soon as the confirmation
+ *          has been received from the peer. Please see the documentation of @ref sd_ble_tx_packet_count_get for more details.
+ *
+ * @events
+ * @event{@ref BLE_EVT_TX_COMPLETE, Transmission complete.}
+ * @event{@ref BLE_GATTS_EVT_HVC, Confirmation received from peer.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTS_HVX_SYS_ATTRS_MISSING_MSC}
+ * @mmsc{@ref BLE_GATTS_HVN_MSC}
+ * @mmsc{@ref BLE_GATTS_HVI_MSC}
+ * @mmsc{@ref BLE_GATTS_HVX_DISABLED_MSC}
+ * @mmsc{@ref BLE_COMMON_APP_BUFF_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle  Connection handle.
+ * @param[in] p_hvx_params Pointer to an HVx parameters structure. If the p_data member contains a non-NULL pointer the attribute value will be updated with
+ *                         the contents pointed by it before sending the notification or indication.
+ *
+ * @retval ::NRF_SUCCESS Successfully queued a notification or indication for transmission, and optionally updated the attribute value.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE One or more of the following is true:
+ *                                   - Invalid Connection State
+ *                                   - Notifications and/or indications not enabled in the CCCD
+ *                                   - An ATT_MTU exchange is ongoing
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle(s) supplied. Only attributes added directly by the application are available to notify and indicate.
+ * @retval ::BLE_ERROR_GATTS_INVALID_ATTR_TYPE Invalid attribute type(s) supplied, only characteristic values may be notified and indicated.
+ * @retval ::NRF_ERROR_NOT_FOUND Attribute not found.
+ * @retval ::NRF_ERROR_FORBIDDEN The connection's current security level is lower than the one required by the write permissions of the CCCD associated with this characteristic.
+ * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
+ * @retval ::NRF_ERROR_BUSY Procedure already in progress.
+ * @retval ::BLE_ERROR_GATTS_SYS_ATTR_MISSING System attributes missing, use @ref sd_ble_gatts_sys_attr_set to set them to a known value.
+ * @retval ::BLE_ERROR_NO_TX_PACKETS  No available application packets for this connection, applies only to notifications.
+ */
+SVCALL(SD_BLE_GATTS_HVX, uint32_t, sd_ble_gatts_hvx(uint16_t conn_handle, ble_gatts_hvx_params_t const *p_hvx_params));
+
+/**@brief Indicate the Service Changed attribute value.
+ *
+ * @details This call will send a Handle Value Indication to one or more peers connected to inform them that the Attribute
+ *          Table layout has changed. As soon as the peer has confirmed the indication, a @ref BLE_GATTS_EVT_SC_CONFIRM event will
+ *          be issued.
+ *
+ * @note    Some of the restrictions and limitations that apply to @ref sd_ble_gatts_hvx also apply here.
+ *
+ * @events
+ * @event{@ref BLE_GATTS_EVT_SC_CONFIRM, Confirmation of attribute table change received from peer.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTS_SC_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle  Connection handle.
+ * @param[in] start_handle Start of affected attribute handle range.
+ * @param[in] end_handle   End of affected attribute handle range.
+ *
+ * @retval ::NRF_SUCCESS Successfully queued the Service Changed indication for transmission.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_NOT_SUPPORTED Service Changed not enabled at initialization. See @ref sd_ble_enable and @ref ble_gatts_enable_params_t.
+ * @retval ::NRF_ERROR_INVALID_STATE One or more of the following is true:
+ *                                   - Invalid Connection State
+ *                                   - Notifications and/or indications not enabled in the CCCD
+ *                                   - An ATT_MTU exchange is ongoing
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle(s) supplied, handles must be in the range populated by the application.
+ * @retval ::NRF_ERROR_BUSY Procedure already in progress.
+ * @retval ::BLE_ERROR_GATTS_SYS_ATTR_MISSING System attributes missing, use @ref sd_ble_gatts_sys_attr_set to set them to a known value.
+ */
+SVCALL(SD_BLE_GATTS_SERVICE_CHANGED, uint32_t, sd_ble_gatts_service_changed(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle));
+
+/**@brief Respond to a Read/Write authorization request.
+ *
+ * @note This call should only be used as a response to a @ref BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST event issued to the application.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_AUTH_MSC}
+ * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_BUF_AUTH_MSC}
+ * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_NOAUTH_MSC}
+ * @mmsc{@ref BLE_GATTS_READ_REQ_AUTH_MSC}
+ * @mmsc{@ref BLE_GATTS_WRITE_REQ_AUTH_MSC}
+ * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_QUEUE_FULL_MSC}
+ * @mmsc{@ref BLE_GATTS_QUEUED_WRITE_NOBUF_PEER_CANCEL_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle                 Connection handle.
+ * @param[in] p_rw_authorize_reply_params Pointer to a structure with the attribute provided by the application.
+ *
+ * @note @ref ble_gatts_authorize_params_t::p_data is ignored when this function is used to respond
+ *       to a @ref BLE_GATTS_AUTHORIZE_TYPE_READ event if @ref ble_gatts_authorize_params_t::update
+ *       is set to 0.
+ *
+ * @retval ::NRF_SUCCESS               Successfully queued a response to the peer, and in the case of a write operation, Attribute Table updated.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_ADDR    Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE   Invalid Connection State or no authorization request pending.
+ * @retval ::NRF_ERROR_INVALID_PARAM   Authorization op invalid,
+ *                                         handle supplied does not match requested handle,
+ *                                         or invalid data to be written provided by the application.
+ * @retval ::NRF_ERROR_BUSY The stack is busy. Retry at later time.
+ */
+SVCALL(SD_BLE_GATTS_RW_AUTHORIZE_REPLY, uint32_t, sd_ble_gatts_rw_authorize_reply(uint16_t conn_handle, ble_gatts_rw_authorize_reply_params_t const *p_rw_authorize_reply_params));
+
+
+/**@brief Update persistent system attribute information.
+ *
+ * @details Supply information about persistent system attributes to the stack,
+ *          previously obtained using @ref sd_ble_gatts_sys_attr_get.
+ *          This call is only allowed for active connections, and is usually
+ *          made immediately after a connection is established with an known bonded device,
+ *          often as a response to a @ref BLE_GATTS_EVT_SYS_ATTR_MISSING.
+ *
+ *          p_sysattrs may point directly to the application's stored copy of the system attributes
+ *          obtained using @ref sd_ble_gatts_sys_attr_get.
+ *          If the pointer is NULL, the system attribute info is initialized, assuming that
+ *          the application does not have any previously saved system attribute data for this device.
+ *
+ * @note The state of persistent system attributes is reset upon connection establishment and then remembered for its duration.
+ *
+ * @note If this call returns with an error code different from @ref NRF_SUCCESS, the storage of persistent system attributes may have been completed only partially.
+ *       This means that the state of the attribute table is undefined, and the application should either provide a new set of attributes using this same call or
+ *       reset the SoftDevice to return to a known state.
+ *
+ * @note When the @ref BLE_GATTS_SYS_ATTR_FLAG_SYS_SRVCS is used with this function, only the system attributes included in system services will be modified.
+ * @note When the @ref BLE_GATTS_SYS_ATTR_FLAG_USR_SRVCS is used with this function, only the system attributes included in user services will be modified.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTS_HVX_SYS_ATTRS_MISSING_MSC}
+ * @mmsc{@ref BLE_GATTS_SYS_ATTRS_UNK_PEER_MSC}
+ * @mmsc{@ref BLE_GATTS_SYS_ATTRS_BONDED_PEER_MSC}
+ * @endmscs
+ *
+ * @param[in]  conn_handle        Connection handle.
+ * @param[in]  p_sys_attr_data    Pointer to a saved copy of system attributes supplied to the stack, or NULL.
+ * @param[in]  len                Size of data pointed by p_sys_attr_data, in octets.
+ * @param[in]  flags              Optional additional flags, see @ref BLE_GATTS_SYS_ATTR_FLAGS
+ *
+ * @retval ::NRF_SUCCESS Successfully set the system attribute information.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid flags supplied.
+ * @retval ::NRF_ERROR_INVALID_DATA Invalid data supplied, the data should be exactly the same as retrieved with @ref sd_ble_gatts_sys_attr_get.
+ * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
+ * @retval ::NRF_ERROR_BUSY The stack is busy. Retry at later time.
+ */
+SVCALL(SD_BLE_GATTS_SYS_ATTR_SET, uint32_t, sd_ble_gatts_sys_attr_set(uint16_t conn_handle, uint8_t const *p_sys_attr_data, uint16_t len, uint32_t flags));
+
+
+/**@brief Retrieve persistent system attribute information from the stack.
+ *
+ * @details This call is used to retrieve information about values to be stored perisistently by the application
+ *          during the lifetime of a connection or after it has been terminated. When a new connection is established with the same bonded device,
+ *          the system attribute information retrieved with this function should be restored using using @ref sd_ble_gatts_sys_attr_set.
+ *          If retrieved after disconnection, the data should be read before a new connection established. The connection handle for
+ *          the previous, now disconnected, connection will remain valid until a new one is created to allow this API call to refer to it.
+ *          Connection handles belonging to active connections can be used as well, but care should be taken since the system attributes
+ *          may be written to at any time by the peer during a connection's lifetime.
+ *
+ * @note When the @ref BLE_GATTS_SYS_ATTR_FLAG_SYS_SRVCS is used with this function, only the system attributes included in system services will be returned.
+ * @note When the @ref BLE_GATTS_SYS_ATTR_FLAG_USR_SRVCS is used with this function, only the system attributes included in user services will be returned.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTS_SYS_ATTRS_BONDED_PEER_MSC}
+ * @endmscs
+ *
+ * @param[in]     conn_handle       Connection handle of the recently terminated connection.
+ * @param[out]    p_sys_attr_data   Pointer to a buffer where updated information about system attributes will be filled in. The format of the data is described
+ *                                  in @ref BLE_GATTS_SYS_ATTRS_FORMAT. NULL can be provided to obtain the length of the data.
+ * @param[in,out] p_len             Size of application buffer if p_sys_attr_data is not NULL. Unconditially updated to actual length of system attribute data.
+ * @param[in]     flags             Optional additional flags, see @ref BLE_GATTS_SYS_ATTR_FLAGS
+ *
+ * @retval ::NRF_SUCCESS Successfully retrieved the system attribute information.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid flags supplied.
+ * @retval ::NRF_ERROR_DATA_SIZE The system attribute information did not fit into the provided buffer.
+ * @retval ::NRF_ERROR_NOT_FOUND No system attributes found.
+ */
+SVCALL(SD_BLE_GATTS_SYS_ATTR_GET, uint32_t, sd_ble_gatts_sys_attr_get(uint16_t conn_handle, uint8_t *p_sys_attr_data, uint16_t *p_len, uint32_t flags));
+
+
+/**@brief Retrieve the first valid user attribute handle.
+ *
+ * @param[out] p_handle   Pointer to an integer where the handle will be stored.
+ *
+ * @retval ::NRF_SUCCESS Successfully retrieved the handle.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ */
+SVCALL(SD_BLE_GATTS_INITIAL_USER_HANDLE_GET, uint32_t, sd_ble_gatts_initial_user_handle_get(uint16_t *p_handle));
+
+/**@brief Retrieve the attribute UUID and/or metadata.
+ *
+ * @param[in]  handle Attribute handle
+ * @param[out] p_uuid UUID of the attribute. Use NULL to omit this field.
+ * @param[out] p_md Metadata of the attribute. Use NULL to omit this field.
+ *
+ * @retval ::NRF_SUCCESS Successfully retrieved the attribute metadata,
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameters supplied. Returned when both @c p_uuid and @c p_md are NULL.
+ * @retval ::NRF_ERROR_NOT_FOUND Attribute was not found.
+ */
+SVCALL(SD_BLE_GATTS_ATTR_GET, uint32_t, sd_ble_gatts_attr_get(uint16_t handle, ble_uuid_t * p_uuid, ble_gatts_attr_md_t * p_md));
+
+/**@brief Reply to an ATT_MTU exchange request by sending an Exchange MTU Response to the client.
+ *
+ * @details This function is only used to reply to a @ref BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST event.
+ *
+ * @details The SoftDevice sets ATT_MTU to the minimum of:
+ *          - The Client RX MTU value from @ref BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST, and
+ *          - The Server RX MTU value.
+ *
+ *          However, the SoftDevice never sets ATT_MTU lower than @ref GATT_MTU_SIZE_DEFAULT.
+ *
+ * @events
+ * @event{@ref BLE_EVT_DATA_LENGTH_CHANGED, Generated if a data length update procedure is performed after the ATT_MTU exchange.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTS_MTU_EXCHANGE}
+ * @endmscs
+ *
+ * @param[in] conn_handle    The connection handle identifying the connection to perform this procedure on.
+ * @param[in] server_rx_mtu  Server RX MTU size.
+ *                           - The minimum value is @ref GATT_MTU_SIZE_DEFAULT.
+ *                           - The maximum value is @ref ble_gatt_enable_params_t::att_mtu.
+ *                           - The value must be equal to Client RX MTU size given in @ref sd_ble_gattc_exchange_mtu_request
+ *                             if an ATT_MTU exchange has already been performed in the other direction.
+ *
+ * @retval ::NRF_SUCCESS Successfully sent response to the client.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State or no ATT_MTU exchange request pending.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid Server RX MTU size supplied.
+ * @retval ::NRF_ERROR_BUSY The stack is busy. Retry at later time.
+ */
+SVCALL(SD_BLE_GATTS_EXCHANGE_MTU_REPLY, uint32_t, sd_ble_gatts_exchange_mtu_reply(uint16_t conn_handle, uint16_t server_rx_mtu));
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+#endif // BLE_GATTS_H__
+
+/**
+  @}
+*/
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_hci.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_hci.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_hci.h    1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_hci.h 2018-04-24 08:48:28.998154900 +0200
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @addtogroup BLE_COMMON
+  @{
+*/
+
+
+#ifndef BLE_HCI_H__
+#define BLE_HCI_H__
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup BLE_HCI_STATUS_CODES Bluetooth status codes
+ * @{ */
+
+#define BLE_HCI_STATUS_CODE_SUCCESS                        0x00   /**< Success. */
+#define BLE_HCI_STATUS_CODE_UNKNOWN_BTLE_COMMAND           0x01   /**< Unknown BLE Command. */
+#define BLE_HCI_STATUS_CODE_UNKNOWN_CONNECTION_IDENTIFIER  0x02   /**< Unknown Connection Identifier. */
+/*0x03 Hardware Failure
+0x04 Page Timeout
+*/
+#define BLE_HCI_AUTHENTICATION_FAILURE                     0x05   /**< Authentication Failure. */
+#define BLE_HCI_STATUS_CODE_PIN_OR_KEY_MISSING             0x06   /**< Pin or Key missing. */
+#define BLE_HCI_MEMORY_CAPACITY_EXCEEDED                   0x07   /**< Memory Capacity Exceeded. */
+#define BLE_HCI_CONNECTION_TIMEOUT                         0x08   /**< Connection Timeout. */
+/*0x09 Connection Limit Exceeded
+0x0A Synchronous Connection Limit To A Device Exceeded
+0x0B ACL Connection Already Exists*/
+#define BLE_HCI_STATUS_CODE_COMMAND_DISALLOWED             0x0C   /**< Command Disallowed. */
+/*0x0D Connection Rejected due to Limited Resources
+0x0E Connection Rejected Due To Security Reasons
+0x0F Connection Rejected due to Unacceptable BD_ADDR
+0x10 Connection Accept Timeout Exceeded
+0x11 Unsupported Feature or Parameter Value*/
+#define BLE_HCI_STATUS_CODE_INVALID_BTLE_COMMAND_PARAMETERS 0x12  /**< Invalid BLE Command Parameters. */
+#define BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION           0x13  /**< Remote User Terminated Connection. */
+#define BLE_HCI_REMOTE_DEV_TERMINATION_DUE_TO_LOW_RESOURCES 0x14  /**< Remote Device Terminated Connection due to low resources.*/
+#define BLE_HCI_REMOTE_DEV_TERMINATION_DUE_TO_POWER_OFF     0x15  /**< Remote Device Terminated Connection due to power off. */
+#define BLE_HCI_LOCAL_HOST_TERMINATED_CONNECTION            0x16  /**< Local Host Terminated Connection. */
+/*
+0x17 Repeated Attempts
+0x18 Pairing Not Allowed
+0x19 Unknown LMP PDU
+*/
+#define BLE_HCI_UNSUPPORTED_REMOTE_FEATURE 0x1A                   /**< Unsupported Remote Feature. */
+/*
+0x1B SCO Offset Rejected
+0x1C SCO Interval Rejected
+0x1D SCO Air Mode Rejected*/
+#define BLE_HCI_STATUS_CODE_INVALID_LMP_PARAMETERS     0x1E       /**< Invalid LMP Parameters. */
+#define BLE_HCI_STATUS_CODE_UNSPECIFIED_ERROR          0x1F       /**< Unspecified Error. */
+/*0x20 Unsupported LMP Parameter Value
+0x21 Role Change Not Allowed
+*/
+#define BLE_HCI_STATUS_CODE_LMP_RESPONSE_TIMEOUT       0x22       /**< LMP Response Timeout. */
+/*0x23 LMP Error Transaction Collision*/
+#define BLE_HCI_STATUS_CODE_LMP_PDU_NOT_ALLOWED        0x24       /**< LMP PDU Not Allowed. */
+/*0x25 Encryption Mode Not Acceptable
+0x26 Link Key Can Not be Changed
+0x27 Requested QoS Not Supported
+*/
+#define BLE_HCI_INSTANT_PASSED                         0x28       /**< Instant Passed. */
+#define BLE_HCI_PAIRING_WITH_UNIT_KEY_UNSUPPORTED      0x29       /**< Pairing with Unit Key Unsupported. */
+#define BLE_HCI_DIFFERENT_TRANSACTION_COLLISION        0x2A       /**< Different Transaction Collision. */
+/*
+0x2B Reserved
+0x2C QoS Unacceptable Parameter
+0x2D QoS Rejected
+0x2E Channel Classification Not Supported
+0x2F Insufficient Security
+0x30 Parameter Out Of Mandatory Range
+0x31 Reserved
+0x32 Role Switch Pending
+0x33 Reserved
+0x34 Reserved Slot Violation
+0x35 Role Switch Failed
+0x36 Extended Inquiry Response Too Large
+0x37 Secure Simple Pairing Not Supported By Host.
+0x38 Host Busy - Pairing
+0x39 Connection Rejected due to No Suitable Channel Found*/
+#define BLE_HCI_CONTROLLER_BUSY                        0x3A       /**< Controller Busy. */
+#define BLE_HCI_CONN_INTERVAL_UNACCEPTABLE             0x3B       /**< Connection Interval Unacceptable. */
+#define BLE_HCI_DIRECTED_ADVERTISER_TIMEOUT            0x3C       /**< Directed Adverisement Timeout. */
+#define BLE_HCI_CONN_TERMINATED_DUE_TO_MIC_FAILURE     0x3D       /**< Connection Terminated due to MIC Failure. */
+#define BLE_HCI_CONN_FAILED_TO_BE_ESTABLISHED          0x3E       /**< Connection Failed to be Established. */
+
+/** @} */
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif // BLE_HCI_H__
+
+/** @} */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_l2cap.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_l2cap.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_l2cap.h  1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_l2cap.h   2018-04-24 08:48:28.998154900 +0200
@@ -0,0 +1,202 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @addtogroup BLE_L2CAP Logical Link Control and Adaptation Protocol (L2CAP)
+  @{
+  @brief Definitions and prototypes for the L2CAP interface.
+ */
+
+#ifndef BLE_L2CAP_H__
+#define BLE_L2CAP_H__
+
+#include "ble_types.h"
+#include "ble_ranges.h"
+#include "ble_err.h"
+#include "nrf_svc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**@addtogroup BLE_L2CAP_ENUMERATIONS Enumerations
+ * @{ */
+
+/**@brief L2CAP API SVC numbers. */
+enum BLE_L2CAP_SVCS
+{
+  SD_BLE_L2CAP_CID_REGISTER = BLE_L2CAP_SVC_BASE,  /**< Register a CID. */
+  SD_BLE_L2CAP_CID_UNREGISTER,                     /**< Unregister a CID. */
+  SD_BLE_L2CAP_TX                                  /**< Transmit a packet. */
+};
+
+/**@brief L2CAP Event IDs. */
+enum BLE_L2CAP_EVTS
+{
+  BLE_L2CAP_EVT_RX  = BLE_L2CAP_EVT_BASE          /**< L2CAP packet received. */
+};
+
+/** @} */
+
+/**@addtogroup BLE_L2CAP_DEFINES Defines
+ * @{ */
+
+/**@defgroup BLE_ERRORS_L2CAP SVC return values specific to L2CAP
+ * @{ */
+#define BLE_ERROR_L2CAP_CID_IN_USE            (NRF_L2CAP_ERR_BASE + 0x000)  /**< CID already in use. */
+/** @} */
+
+/**@brief Default L2CAP MTU. */
+#define BLE_L2CAP_MTU_DEF           (23)
+
+/**@brief Invalid Channel Identifier. */
+#define BLE_L2CAP_CID_INVALID       (0x0000)
+
+/**@brief Dynamic Channel Identifier base. */
+#define BLE_L2CAP_CID_DYN_BASE      (0x0040)
+
+/**@brief Maximum amount of dynamic CIDs. */
+#define BLE_L2CAP_CID_DYN_MAX       (8)
+
+/** @} */
+
+/**@addtogroup BLE_L2CAP_STRUCTURES Structures
+ * @{ */
+
+/**@brief Packet header format for L2CAP transmission. */
+typedef struct
+{
+  uint16_t   len;                                 /**< Length of valid info in data member. */
+  uint16_t   cid;                                 /**< Channel ID on which packet is transmitted. */
+} ble_l2cap_header_t;
+
+
+/**@brief L2CAP Received packet event report. */
+typedef struct
+{
+  ble_l2cap_header_t header;                      /**< L2CAP packet header. */
+  uint8_t    data[1];                             /**< Packet data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                                       See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_l2cap_evt_rx_t;
+
+
+/**@brief L2CAP event callback event structure. */
+typedef struct
+{
+  uint16_t conn_handle;                           /**< Connection Handle on which event occured. */
+  union
+  {
+    ble_l2cap_evt_rx_t rx;                        /**< RX Event parameters. */
+  } params;                                       /**< Event Parameters. */
+} ble_l2cap_evt_t;
+
+/** @} */
+
+/**@addtogroup BLE_L2CAP_FUNCTIONS Functions
+ * @{ */
+
+/**@brief Register a CID with L2CAP.
+ *
+ * @details This registers a higher protocol layer with the L2CAP multiplexer, and is requried prior to all operations on the CID.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_L2CAP_API_MSC}
+ * @endmscs
+ *
+ * @param[in] cid L2CAP CID.
+ *
+ * @retval ::NRF_SUCCESS Successfully registered a CID with the L2CAP layer.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, CID must be above @ref BLE_L2CAP_CID_DYN_BASE.
+ * @retval ::BLE_ERROR_L2CAP_CID_IN_USE L2CAP CID already in use.
+ * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
+ */
+SVCALL(SD_BLE_L2CAP_CID_REGISTER, uint32_t, sd_ble_l2cap_cid_register(uint16_t cid));
+
+/**@brief Unregister a CID with L2CAP.
+ *
+ * @details This unregisters a previously registerd higher protocol layer with the L2CAP multiplexer.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_L2CAP_API_MSC}
+ * @endmscs
+ *
+ * @param[in] cid L2CAP CID.
+ *
+ * @retval ::NRF_SUCCESS Successfully unregistered the CID.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_NOT_FOUND CID not previously registered.
+ */
+SVCALL(SD_BLE_L2CAP_CID_UNREGISTER, uint32_t, sd_ble_l2cap_cid_unregister(uint16_t cid));
+
+/**@brief Transmit an L2CAP packet.
+ *
+ * @note    It is important to note that a call to this function will <b>consume an application packet</b>, and will therefore
+ *          generate a @ref BLE_EVT_TX_COMPLETE event when the packet has been transmitted.
+ *          Please see the documentation of @ref sd_ble_tx_packet_count_get for more details.
+ *
+ * @events
+ * @event{@ref BLE_EVT_TX_COMPLETE}
+ * @event{@ref BLE_L2CAP_EVT_RX}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_L2CAP_API_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection Handle.
+ * @param[in] p_header    Pointer to a packet header containing length and CID.
+ * @param[in] p_data      Pointer to the data to be transmitted.
+ *
+ * @retval ::NRF_SUCCESS Successfully queued an L2CAP packet for transmission.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, CIDs must be registered beforehand with @ref sd_ble_l2cap_cid_register.
+ * @retval ::NRF_ERROR_NOT_FOUND CID not found.
+ * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
+ * @retval ::BLE_ERROR_NO_TX_PACKETS Not enough application packets available.
+ * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, see @ref BLE_L2CAP_MTU_DEF.
+ */
+SVCALL(SD_BLE_L2CAP_TX, uint32_t, sd_ble_l2cap_tx(uint16_t conn_handle, ble_l2cap_header_t const *p_header, uint8_t const *p_data));
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+#endif // BLE_L2CAP_H__
+
+/**
+  @}
+*/
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_ranges.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_ranges.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_ranges.h 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_ranges.h  2018-04-24 08:48:28.998154900 +0200
@@ -0,0 +1,138 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @addtogroup BLE_COMMON
+  @{
+  @defgroup ble_ranges Module specific SVC, event and option number subranges
+  @{
+
+  @brief Definition of SVC, event and option number subranges for each API module.
+
+  @note
+  SVCs, event and option numbers are split into subranges for each API module.
+  Each module receives its entire allocated range of SVC calls, whether implemented or not,
+  but return BLE_ERROR_NOT_SUPPORTED for unimplemented or undefined calls in its range.
+
+  Note that the symbols BLE_<module>_SVC_LAST is the end of the allocated SVC range,
+  rather than the last SVC function call actually defined and implemented.
+
+  Specific SVC, event and option values are defined in each module's ble_<module>.h file,
+  which defines names of each individual SVC code based on the range start value.
+*/
+
+#ifndef BLE_RANGES_H__
+#define BLE_RANGES_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define BLE_SVC_BASE           0x60       /**< Common BLE SVC base. */
+#define BLE_SVC_LAST           0x6B       /**< Common BLE SVC last. */
+
+
+#define BLE_GAP_SVC_BASE       0x6C       /**< GAP BLE SVC base. */
+#define BLE_GAP_SVC_LAST       0x93       /**< GAP BLE SVC last. */
+
+
+#define BLE_GATTC_SVC_BASE     0x94       /**< GATTC BLE SVC base. */
+#define BLE_GATTC_SVC_LAST     0x9F       /**< GATTC BLE SVC last. */
+
+
+#define BLE_GATTS_SVC_BASE     0xA0       /**< GATTS BLE SVC base. */
+#define BLE_GATTS_SVC_LAST     0xAF       /**< GATTS BLE SVC last. */
+
+
+#define BLE_L2CAP_SVC_BASE     0xB0       /**< L2CAP BLE SVC base. */
+#define BLE_L2CAP_SVC_LAST     0xBF       /**< L2CAP BLE SVC last. */
+
+
+#define BLE_EVT_INVALID        0x00       /**< Invalid BLE Event. */
+
+
+#define BLE_EVT_BASE           0x01       /**< Common BLE Event base. */
+#define BLE_EVT_LAST           0x0F       /**< Common BLE Event last. */
+
+
+#define BLE_GAP_EVT_BASE       0x10       /**< GAP BLE Event base. */
+#define BLE_GAP_EVT_LAST       0x2F       /**< GAP BLE Event last. */
+
+
+#define BLE_GATTC_EVT_BASE     0x30       /**< GATTC BLE Event base. */
+#define BLE_GATTC_EVT_LAST     0x4F       /**< GATTC BLE Event last. */
+
+
+#define BLE_GATTS_EVT_BASE     0x50       /**< GATTS BLE Event base. */
+#define BLE_GATTS_EVT_LAST     0x6F       /**< GATTS BLE Event last. */
+
+
+#define BLE_L2CAP_EVT_BASE     0x70       /**< L2CAP BLE Event base. */
+#define BLE_L2CAP_EVT_LAST     0x8F       /**< L2CAP BLE Event last. */
+
+
+#define BLE_OPT_INVALID        0x00       /**< Invalid BLE Option. */
+
+
+#define BLE_OPT_BASE           0x01       /**< Common BLE Option base. */
+#define BLE_OPT_LAST           0x1F       /**< Common BLE Option last. */
+
+
+#define BLE_GAP_OPT_BASE       0x20       /**< GAP BLE Option base. */
+#define BLE_GAP_OPT_LAST       0x3F       /**< GAP BLE Option last. */
+
+
+#define BLE_GATTC_OPT_BASE     0x40       /**< GATTC BLE Option base. */
+#define BLE_GATTC_OPT_LAST     0x5F       /**< GATTC BLE Option last. */
+
+
+#define BLE_GATTS_OPT_BASE     0x60       /**< GATTS BLE Option base. */
+#define BLE_GATTS_OPT_LAST     0x7F       /**< GATTS BLE Option last. */
+
+
+#define BLE_L2CAP_OPT_BASE     0x80       /**< L2CAP BLE Option base. */
+#define BLE_L2CAP_OPT_LAST     0x9F       /**< L2CAP BLE Option last. */
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* BLE_RANGES_H__ */
+
+/**
+  @}
+  @}
+*/
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_types.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_types.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/ble_types.h  1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/ble_types.h   2018-04-24 08:48:29.008155100 +0200
@@ -0,0 +1,213 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @addtogroup BLE_COMMON
+  @{
+  @defgroup ble_types Common types and macro definitions
+  @{
+
+  @brief Common types and macro definitions for the BLE SoftDevice.
+ */
+
+#ifndef BLE_TYPES_H__
+#define BLE_TYPES_H__
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup BLE_TYPES_DEFINES Defines
+ * @{ */
+
+/** @defgroup BLE_CONN_HANDLES BLE Connection Handles
+ * @{ */
+#define BLE_CONN_HANDLE_INVALID 0xFFFF  /**< Invalid Connection Handle. */
+#define BLE_CONN_HANDLE_ALL     0xFFFE  /**< Applies to all Connection Handles. */
+/** @} */
+
+
+/** @defgroup BLE_UUID_VALUES Assigned Values for BLE UUIDs
+ * @{ */
+/* Generic UUIDs, applicable to all services */
+#define BLE_UUID_UNKNOWN                              0x0000 /**< Reserved UUID. */
+#define BLE_UUID_SERVICE_PRIMARY                      0x2800 /**< Primary Service. */
+#define BLE_UUID_SERVICE_SECONDARY                    0x2801 /**< Secondary Service. */
+#define BLE_UUID_SERVICE_INCLUDE                      0x2802 /**< Include. */
+#define BLE_UUID_CHARACTERISTIC                       0x2803 /**< Characteristic. */
+#define BLE_UUID_DESCRIPTOR_CHAR_EXT_PROP             0x2900 /**< Characteristic Extended Properties Descriptor. */
+#define BLE_UUID_DESCRIPTOR_CHAR_USER_DESC            0x2901 /**< Characteristic User Description Descriptor. */
+#define BLE_UUID_DESCRIPTOR_CLIENT_CHAR_CONFIG        0x2902 /**< Client Characteristic Configuration Descriptor. */
+#define BLE_UUID_DESCRIPTOR_SERVER_CHAR_CONFIG        0x2903 /**< Server Characteristic Configuration Descriptor. */
+#define BLE_UUID_DESCRIPTOR_CHAR_PRESENTATION_FORMAT  0x2904 /**< Characteristic Presentation Format Descriptor. */
+#define BLE_UUID_DESCRIPTOR_CHAR_AGGREGATE_FORMAT     0x2905 /**< Characteristic Aggregate Format Descriptor. */
+/* GATT specific UUIDs */
+#define BLE_UUID_GATT                                 0x1801 /**< Generic Attribute Profile. */
+#define BLE_UUID_GATT_CHARACTERISTIC_SERVICE_CHANGED  0x2A05 /**< Service Changed Characteristic. */
+/* GAP specific UUIDs */
+#define BLE_UUID_GAP                                  0x1800 /**< Generic Access Profile. */
+#define BLE_UUID_GAP_CHARACTERISTIC_DEVICE_NAME       0x2A00 /**< Device Name Characteristic. */
+#define BLE_UUID_GAP_CHARACTERISTIC_APPEARANCE        0x2A01 /**< Appearance Characteristic. */
+#define BLE_UUID_GAP_CHARACTERISTIC_RECONN_ADDR       0x2A03 /**< Reconnection Address Characteristic. */
+#define BLE_UUID_GAP_CHARACTERISTIC_PPCP              0x2A04 /**< Peripheral Preferred Connection Parameters Characteristic. */
+#define BLE_UUID_GAP_CHARACTERISTIC_CAR               0x2AA6 /**< Central Address Resolution Characteristic. */
+/** @} */
+
+
+/** @defgroup BLE_UUID_TYPES Types of UUID
+ * @{ */
+#define BLE_UUID_TYPE_UNKNOWN       0x00 /**< Invalid UUID type. */
+#define BLE_UUID_TYPE_BLE           0x01 /**< Bluetooth SIG UUID (16-bit). */
+#define BLE_UUID_TYPE_VENDOR_BEGIN  0x02 /**< Vendor UUID types start at this index (128-bit). */
+/** @} */
+
+
+/** @defgroup BLE_APPEARANCES Bluetooth Appearance values
+ *  @note Retrieved from http://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.gap.appearance.xml
+ * @{ */
+#define BLE_APPEARANCE_UNKNOWN                                0 /**< Unknown. */
+#define BLE_APPEARANCE_GENERIC_PHONE                         64 /**< Generic Phone. */
+#define BLE_APPEARANCE_GENERIC_COMPUTER                     128 /**< Generic Computer. */
+#define BLE_APPEARANCE_GENERIC_WATCH                        192 /**< Generic Watch. */
+#define BLE_APPEARANCE_WATCH_SPORTS_WATCH                   193 /**< Watch: Sports Watch. */
+#define BLE_APPEARANCE_GENERIC_CLOCK                        256 /**< Generic Clock. */
+#define BLE_APPEARANCE_GENERIC_DISPLAY                      320 /**< Generic Display. */
+#define BLE_APPEARANCE_GENERIC_REMOTE_CONTROL               384 /**< Generic Remote Control. */
+#define BLE_APPEARANCE_GENERIC_EYE_GLASSES                  448 /**< Generic Eye-glasses. */
+#define BLE_APPEARANCE_GENERIC_TAG                          512 /**< Generic Tag. */
+#define BLE_APPEARANCE_GENERIC_KEYRING                      576 /**< Generic Keyring. */
+#define BLE_APPEARANCE_GENERIC_MEDIA_PLAYER                 640 /**< Generic Media Player. */
+#define BLE_APPEARANCE_GENERIC_BARCODE_SCANNER              704 /**< Generic Barcode Scanner. */
+#define BLE_APPEARANCE_GENERIC_THERMOMETER                  768 /**< Generic Thermometer. */
+#define BLE_APPEARANCE_THERMOMETER_EAR                      769 /**< Thermometer: Ear. */
+#define BLE_APPEARANCE_GENERIC_HEART_RATE_SENSOR            832 /**< Generic Heart rate Sensor. */
+#define BLE_APPEARANCE_HEART_RATE_SENSOR_HEART_RATE_BELT    833 /**< Heart Rate Sensor: Heart Rate Belt. */
+#define BLE_APPEARANCE_GENERIC_BLOOD_PRESSURE               896 /**< Generic Blood Pressure. */
+#define BLE_APPEARANCE_BLOOD_PRESSURE_ARM                   897 /**< Blood Pressure: Arm. */
+#define BLE_APPEARANCE_BLOOD_PRESSURE_WRIST                 898 /**< Blood Pressure: Wrist. */
+#define BLE_APPEARANCE_GENERIC_HID                          960 /**< Human Interface Device (HID). */
+#define BLE_APPEARANCE_HID_KEYBOARD                         961 /**< Keyboard (HID Subtype). */
+#define BLE_APPEARANCE_HID_MOUSE                            962 /**< Mouse (HID Subtype). */
+#define BLE_APPEARANCE_HID_JOYSTICK                         963 /**< Joystiq (HID Subtype). */
+#define BLE_APPEARANCE_HID_GAMEPAD                          964 /**< Gamepad (HID Subtype). */
+#define BLE_APPEARANCE_HID_DIGITIZERSUBTYPE                 965 /**< Digitizer Tablet (HID Subtype). */
+#define BLE_APPEARANCE_HID_CARD_READER                      966 /**< Card Reader (HID Subtype). */
+#define BLE_APPEARANCE_HID_DIGITAL_PEN                      967 /**< Digital Pen (HID Subtype). */
+#define BLE_APPEARANCE_HID_BARCODE                          968 /**< Barcode Scanner (HID Subtype). */
+#define BLE_APPEARANCE_GENERIC_GLUCOSE_METER               1024 /**< Generic Glucose Meter. */
+#define BLE_APPEARANCE_GENERIC_RUNNING_WALKING_SENSOR      1088 /**< Generic Running Walking Sensor. */
+#define BLE_APPEARANCE_RUNNING_WALKING_SENSOR_IN_SHOE      1089 /**< Running Walking Sensor: In-Shoe. */
+#define BLE_APPEARANCE_RUNNING_WALKING_SENSOR_ON_SHOE      1090 /**< Running Walking Sensor: On-Shoe. */
+#define BLE_APPEARANCE_RUNNING_WALKING_SENSOR_ON_HIP       1091 /**< Running Walking Sensor: On-Hip. */
+#define BLE_APPEARANCE_GENERIC_CYCLING                     1152 /**< Generic Cycling. */
+#define BLE_APPEARANCE_CYCLING_CYCLING_COMPUTER            1153 /**< Cycling: Cycling Computer. */
+#define BLE_APPEARANCE_CYCLING_SPEED_SENSOR                1154 /**< Cycling: Speed Sensor. */
+#define BLE_APPEARANCE_CYCLING_CADENCE_SENSOR              1155 /**< Cycling: Cadence Sensor. */
+#define BLE_APPEARANCE_CYCLING_POWER_SENSOR                1156 /**< Cycling: Power Sensor. */
+#define BLE_APPEARANCE_CYCLING_SPEED_CADENCE_SENSOR        1157 /**< Cycling: Speed and Cadence Sensor. */
+#define BLE_APPEARANCE_GENERIC_PULSE_OXIMETER              3136 /**< Generic Pulse Oximeter. */
+#define BLE_APPEARANCE_PULSE_OXIMETER_FINGERTIP            3137 /**< Fingertip (Pulse Oximeter subtype). */
+#define BLE_APPEARANCE_PULSE_OXIMETER_WRIST_WORN           3138 /**< Wrist Worn(Pulse Oximeter subtype). */
+#define BLE_APPEARANCE_GENERIC_WEIGHT_SCALE                3200 /**< Generic Weight Scale. */
+#define BLE_APPEARANCE_GENERIC_OUTDOOR_SPORTS_ACT          5184 /**< Generic Outdoor Sports Activity. */
+#define BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_DISP         5185 /**< Location Display Device (Outdoor Sports Activity subtype). */
+#define BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_AND_NAV_DISP 5186 /**< Location and Navigation Display Device (Outdoor Sports Activity subtype). */
+#define BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_POD          5187 /**< Location Pod (Outdoor Sports Activity subtype). */
+#define BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_AND_NAV_POD  5188 /**< Location and Navigation Pod (Outdoor Sports Activity subtype). */
+/** @} */
+
+/** @brief Set .type and .uuid fields of ble_uuid_struct to specified uuid value. */
+#define BLE_UUID_BLE_ASSIGN(instance, value) do {\
+            instance.type = BLE_UUID_TYPE_BLE; \
+            instance.uuid = value;} while (0)
+
+/** @brief Copy type and uuid members from src to dst ble_uuid_t pointer. Both pointers must be valid/non-null. */
+#define BLE_UUID_COPY_PTR(dst, src) do {\
+            (dst)->type = (src)->type; \
+            (dst)->uuid = (src)->uuid;} while (0)
+
+/** @brief Copy type and uuid members from src to dst ble_uuid_t struct. */
+#define BLE_UUID_COPY_INST(dst, src) do {\
+            (dst).type = (src).type; \
+            (dst).uuid = (src).uuid;} while (0)
+
+/** @brief Compare for equality both type and uuid members of two (valid, non-null) ble_uuid_t pointers. */
+#define BLE_UUID_EQ(p_uuid1, p_uuid2) \
+            (((p_uuid1)->type == (p_uuid2)->type) && ((p_uuid1)->uuid == (p_uuid2)->uuid))
+
+/** @brief Compare for difference both type and uuid members of two (valid, non-null) ble_uuid_t pointers. */
+#define BLE_UUID_NEQ(p_uuid1, p_uuid2) \
+            (((p_uuid1)->type != (p_uuid2)->type) || ((p_uuid1)->uuid != (p_uuid2)->uuid))
+
+/** @} */
+
+/** @addtogroup BLE_TYPES_STRUCTURES Structures
+ * @{ */
+
+/** @brief 128 bit UUID values. */
+typedef struct
+{
+  uint8_t uuid128[16]; /**< Little-Endian UUID bytes. */
+} ble_uuid128_t;
+
+/** @brief  Bluetooth Low Energy UUID type, encapsulates both 16-bit and 128-bit UUIDs. */
+typedef struct
+{
+  uint16_t    uuid; /**< 16-bit UUID value or octets 12-13 of 128-bit UUID. */
+  uint8_t     type; /**< UUID type, see @ref BLE_UUID_TYPES. If type is @ref BLE_UUID_TYPE_UNKNOWN, the value of uuid is undefined. */
+} ble_uuid_t;
+
+/* note: added to make the unit test work*/
+/**@brief Data structure. */
+typedef struct
+{
+  uint8_t     *p_data;  /**< Pointer to the data buffer provided to/from the application. */
+  uint16_t     len;     /**< Length of the data buffer, in bytes. */
+} ble_data_t;
+
+/** @} */
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* BLE_TYPES_H__ */
+
+/**
+  @}
+  @}
+*/
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf52/nrf_mbr.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf52/nrf_mbr.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf52/nrf_mbr.h  1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf52/nrf_mbr.h   2018-04-24 08:48:29.008155100 +0200
@@ -0,0 +1,217 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/**
+  @defgroup nrf_mbr_api Master Boot Record API
+  @{
+
+  @brief APIs for updating SoftDevice and BootLoader
+
+*/
+
+/* Header guard */
+#ifndef NRF_MBR_H__
+#define NRF_MBR_H__
+
+#include "nrf_svc.h"
+#include <stdint.h>
+
+#if !(defined(NRF52) || defined(NRF52840_XXAA))
+#error "This header file shall only be included for nRF52 projects"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup NRF_MBR_DEFINES Defines
+ * @{ */
+
+/**@brief MBR SVC Base number. */
+#define MBR_SVC_BASE            (0x18)
+
+/**@brief Page size in words. */
+#define MBR_PAGE_SIZE_IN_WORDS  (1024)
+
+/** @brief The size that must be reserved for the MBR when a softdevice is written to flash.
+This is the offset where the first byte of the softdevice hex file is written.*/
+#define MBR_SIZE                (0x1000)
+
+/** @} */
+
+/** @addtogroup NRF_MBR_ENUMS Enumerations
+ * @{ */
+
+/**@brief nRF Master Boot Record API SVC numbers. */
+enum NRF_MBR_SVCS
+{
+  SD_MBR_COMMAND = MBR_SVC_BASE, /**< ::sd_mbr_command */
+};
+
+/**@brief Possible values for ::sd_mbr_command_t.command */
+enum NRF_MBR_COMMANDS
+{
+  SD_MBR_COMMAND_COPY_BL,               /**< Copy a new BootLoader. @see sd_mbr_command_copy_bl_t */
+  SD_MBR_COMMAND_COPY_SD,               /**< Copy a new SoftDevice. @see ::sd_mbr_command_copy_sd_t*/
+  SD_MBR_COMMAND_INIT_SD,               /**< Init forwarding interrupts to SD, and run reset function in SD*/
+  SD_MBR_COMMAND_COMPARE,               /**< This command works like memcmp. @see ::sd_mbr_command_compare_t*/
+  SD_MBR_COMMAND_VECTOR_TABLE_BASE_SET, /**< Start forwarding all exception to this address @see ::sd_mbr_command_vector_table_base_set_t*/
+};
+
+/** @} */
+
+/** @addtogroup NRF_MBR_TYPES Types
+ * @{ */
+
+/**@brief This command copies part of a new SoftDevice
+ * The destination area is erased before copying.
+ * If dst is in the middle of a flash page, that whole flash page will be erased.
+ * If (dst+len) is in the middle of a flash page, that whole flash page will be erased.
+ *
+ * The user of this function is responsible for setting the BPROT registers.
+ *
+ * @retval ::NRF_SUCCESS indicates that the contents of the memory blocks where copied correctly.
+ * @retval ::NRF_ERROR_INTERNAL indicates that the contents of the memory blocks where not verified correctly after copying.
+ */
+typedef struct
+{
+  uint32_t *src;  /**< Pointer to the source of data to be copied.*/
+  uint32_t *dst;  /**< Pointer to the destination where the content is to be copied.*/
+  uint32_t len;   /**< Number of 32 bit words to copy. Must be a multiple of @ref MBR_PAGE_SIZE_IN_WORDS words.*/
+} sd_mbr_command_copy_sd_t;
+
+
+/**@brief This command works like memcmp, but takes the length in words.
+ *
+ * @retval ::NRF_SUCCESS indicates that the contents of both memory blocks are equal.
+ * @retval ::NRF_ERROR_NULL indicates that the contents of the memory blocks are not equal.
+ */
+typedef struct
+{
+  uint32_t *ptr1; /**< Pointer to block of memory. */
+  uint32_t *ptr2; /**< Pointer to block of memory. */
+  uint32_t len;   /**< Number of 32 bit words to compare.*/
+} sd_mbr_command_compare_t;
+
+
+/**@brief This command copies a new BootLoader.
+ *  With this command, destination of BootLoader is always the address written in NRF_UICR->BOOTADDR.
+ *
+ *  Destination is erased by this function.
+ *  If (destination+bl_len) is in the middle of a flash page, that whole flash page will be erased.
+ *
+ *  This function will use PROTENSET to protect the flash that is not intended to be written.
+ *
+ *  On Success, this function will not return. It will start the new BootLoader from reset-vector as normal.
+ *
+ * @retval ::NRF_ERROR_INTERNAL indicates an internal error that should not happen.
+ * @retval ::NRF_ERROR_FORBIDDEN if NRF_UICR->BOOTADDR is not set.
+ * @retval ::NRF_ERROR_INVALID_LENGTH if parameters attempts to read or write outside flash area.
+ * @retval ::NRF_ERROR_NO_MEM if no parameter page is provided (see sds for more info)
+ */
+typedef struct
+{
+  uint32_t *bl_src;  /**< Pointer to the source of the Bootloader to be be copied.*/
+  uint32_t bl_len;   /**< Number of 32 bit words to copy for BootLoader. */
+} sd_mbr_command_copy_bl_t;
+
+/**@brief Sets the base address of the interrupt vector table for interrupts forwarded from the MBR
+ *
+ * Once this function has been called, this address is where the MBR will start to forward interrupts to after a reset.
+ *
+ * To restore default forwarding this function should be called with @param address set to 0.
+ * The MBR will then start forwarding to interrupts to the address in NFR_UICR->BOOTADDR or to the SoftDevice if the BOOTADDR is not set.
+ *
+ * On Success, this function will not return. It will reset the device.
+ *
+ * @retval ::NRF_ERROR_INTERNAL indicates an internal error that should not happen.
+ * @retval ::NRF_ERROR_INVALID_ADDR if parameter address is outside of the flash size.
+ * @retval ::NRF_ERROR_NO_MEM if no parameter page is provided (see sds for more info)
+ */
+typedef struct
+{
+  uint32_t address; /**< The base address of the interrupt vector table for forwarded interrupts.*/
+} sd_mbr_command_vector_table_base_set_t;
+
+
+typedef struct
+{
+  uint32_t command;  /**< type of command to be issued see @ref NRF_MBR_COMMANDS. */
+  union
+  {
+    sd_mbr_command_copy_sd_t copy_sd;  /**< Parameters for copy SoftDevice.*/
+    sd_mbr_command_compare_t compare;  /**< Parameters for verify.*/
+    sd_mbr_command_copy_bl_t copy_bl;  /**< Parameters for copy BootLoader. Requires parameter page. */
+    sd_mbr_command_vector_table_base_set_t base_set; /**< Parameters for vector table base set. Requires parameter page.*/
+  } params;
+} sd_mbr_command_t;
+
+/** @} */
+
+/** @addtogroup NRF_MBR_FUNCTIONS Functions
+ * @{ */
+
+/**@brief Issue Master Boot Record commands
+ *
+ * Commands used when updating a SoftDevice and bootloader.
+ *
+ * The SD_MBR_COMMAND_COPY_BL and SD_MBR_COMMAND_VECTOR_TABLE_BASE_SET requires parameters to be
+ * retained by the MBR when resetting the IC. This is done in a separate flash page
+ * provided by the application. The uicr register UICR.NRFFW[1] must be set
+ * to an address corresponding to a page in the application flash space. This page will be cleared
+ * by the MBR and used to store the command before reset. When the UICR.NRFFW[1] field is set
+ * the page it refers to must not be used by the application. If the UICR.NRFFW[1] is set to
+ * 0xFFFFFFFF (the default) MBR commands which use flash will be unavailable and return
+ * NRF_ERROR_NO_MEM.
+ *
+ * @param[in]  param Pointer to a struct describing the command.
+ *
+ * @note for retvals see ::sd_mbr_command_copy_sd_t ::sd_mbr_command_copy_bl_t ::sd_mbr_command_compare_t ::sd_mbr_command_vector_table_base_set_t
+ *
+ * @retval NRF_ERROR_NO_MEM if UICR.NRFFW[1] is not set (i.e. is 0xFFFFFFFF).
+ * @retval NRF_ERROR_INVALID_PARAM if an invalid command is given.
+*/
+SVCALL(SD_MBR_COMMAND, uint32_t, sd_mbr_command(sd_mbr_command_t* param));
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+#endif // NRF_MBR_H__
+
+/**
+  @}
+*/
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf_error.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf_error.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf_error.h  1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf_error.h   2018-04-24 08:48:29.018155300 +0200
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+ /**
+  @defgroup nrf_error SoftDevice Global Error Codes
+  @{
+
+  @brief Global Error definitions
+*/
+
+/* Header guard */
+#ifndef NRF_ERROR_H__
+#define NRF_ERROR_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup NRF_ERRORS_BASE Error Codes Base number definitions
+ * @{ */
+#define NRF_ERROR_BASE_NUM      (0x0)       ///< Global error base
+#define NRF_ERROR_SDM_BASE_NUM  (0x1000)    ///< SDM error base
+#define NRF_ERROR_SOC_BASE_NUM  (0x2000)    ///< SoC error base
+#define NRF_ERROR_STK_BASE_NUM  (0x3000)    ///< STK error base
+/** @} */
+
+#define NRF_SUCCESS                           (NRF_ERROR_BASE_NUM + 0)  ///< Successful command
+#define NRF_ERROR_SVC_HANDLER_MISSING         (NRF_ERROR_BASE_NUM + 1)  ///< SVC handler is missing
+#define NRF_ERROR_SOFTDEVICE_NOT_ENABLED      (NRF_ERROR_BASE_NUM + 2)  ///< SoftDevice has not been enabled
+#define NRF_ERROR_INTERNAL                    (NRF_ERROR_BASE_NUM + 3)  ///< Internal Error
+#define NRF_ERROR_NO_MEM                      (NRF_ERROR_BASE_NUM + 4)  ///< No Memory for operation
+#define NRF_ERROR_NOT_FOUND                   (NRF_ERROR_BASE_NUM + 5)  ///< Not found
+#define NRF_ERROR_NOT_SUPPORTED               (NRF_ERROR_BASE_NUM + 6)  ///< Not supported
+#define NRF_ERROR_INVALID_PARAM               (NRF_ERROR_BASE_NUM + 7)  ///< Invalid Parameter
+#define NRF_ERROR_INVALID_STATE               (NRF_ERROR_BASE_NUM + 8)  ///< Invalid state, operation disallowed in this state
+#define NRF_ERROR_INVALID_LENGTH              (NRF_ERROR_BASE_NUM + 9)  ///< Invalid Length
+#define NRF_ERROR_INVALID_FLAGS               (NRF_ERROR_BASE_NUM + 10) ///< Invalid Flags
+#define NRF_ERROR_INVALID_DATA                (NRF_ERROR_BASE_NUM + 11) ///< Invalid Data
+#define NRF_ERROR_DATA_SIZE                   (NRF_ERROR_BASE_NUM + 12) ///< Invalid Data size
+#define NRF_ERROR_TIMEOUT                     (NRF_ERROR_BASE_NUM + 13) ///< Operation timed out
+#define NRF_ERROR_NULL                        (NRF_ERROR_BASE_NUM + 14) ///< Null Pointer
+#define NRF_ERROR_FORBIDDEN                   (NRF_ERROR_BASE_NUM + 15) ///< Forbidden Operation
+#define NRF_ERROR_INVALID_ADDR                (NRF_ERROR_BASE_NUM + 16) ///< Bad Memory Address
+#define NRF_ERROR_BUSY                        (NRF_ERROR_BASE_NUM + 17) ///< Busy
+#define NRF_ERROR_CONN_COUNT                  (NRF_ERROR_BASE_NUM + 18) ///< Maximum connection count exceeded.
+#define NRF_ERROR_RESOURCES                   (NRF_ERROR_BASE_NUM + 19) ///< Not enough resources for operation
+
+#ifdef __cplusplus
+}
+#endif
+#endif // NRF_ERROR_H__
+
+/**
+  @}
+*/
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf_error_sdm.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf_error_sdm.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf_error_sdm.h  1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf_error_sdm.h   2018-04-24 08:48:29.018155300 +0200
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+ /**
+  @addtogroup nrf_sdm_api
+  @{
+  @defgroup nrf_sdm_error SoftDevice Manager Error Codes
+  @{
+
+  @brief Error definitions for the SDM API
+*/
+
+/* Header guard */
+#ifndef NRF_ERROR_SDM_H__
+#define NRF_ERROR_SDM_H__
+
+#include "nrf_error.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define NRF_ERROR_SDM_LFCLK_SOURCE_UNKNOWN              (NRF_ERROR_SDM_BASE_NUM + 0)  ///< Unknown lfclk source.
+#define NRF_ERROR_SDM_INCORRECT_INTERRUPT_CONFIGURATION (NRF_ERROR_SDM_BASE_NUM + 1)  ///< Incorrect interrupt configuration (can be caused by using illegal priority levels, or having enabled SoftDevice interrupts).
+#define NRF_ERROR_SDM_INCORRECT_CLENR0                  (NRF_ERROR_SDM_BASE_NUM + 2)  ///< Incorrect CLENR0 (can be caused by erronous SoftDevice flashing).
+
+#ifdef __cplusplus
+}
+#endif
+#endif // NRF_ERROR_SDM_H__
+
+/**
+  @}
+  @}
+*/
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf_error_soc.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf_error_soc.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf_error_soc.h  1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf_error_soc.h   2018-04-24 08:48:29.018155300 +0200
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/**
+  @addtogroup nrf_soc_api
+  @{
+  @defgroup nrf_soc_error SoC Library Error Codes
+  @{
+
+  @brief Error definitions for the SoC library
+
+*/
+
+/* Header guard */
+#ifndef NRF_ERROR_SOC_H__
+#define NRF_ERROR_SOC_H__
+
+#include "nrf_error.h"
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Mutex Errors */
+#define NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN                 (NRF_ERROR_SOC_BASE_NUM + 0)  ///< Mutex already taken
+
+/* NVIC errors */
+#define NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE        (NRF_ERROR_SOC_BASE_NUM + 1)  ///< NVIC interrupt not available
+#define NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED (NRF_ERROR_SOC_BASE_NUM + 2)  ///< NVIC interrupt priority not allowed
+#define NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN              (NRF_ERROR_SOC_BASE_NUM + 3)  ///< NVIC should not return
+
+/* Power errors */
+#define NRF_ERROR_SOC_POWER_MODE_UNKNOWN                  (NRF_ERROR_SOC_BASE_NUM + 4)  ///< Power mode unknown
+#define NRF_ERROR_SOC_POWER_POF_THRESHOLD_UNKNOWN         (NRF_ERROR_SOC_BASE_NUM + 5)  ///< Power POF threshold unknown
+#define NRF_ERROR_SOC_POWER_OFF_SHOULD_NOT_RETURN         (NRF_ERROR_SOC_BASE_NUM + 6)  ///< Power off should not return
+
+/* Rand errors */
+#define NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES              (NRF_ERROR_SOC_BASE_NUM + 7)  ///< RAND not enough values
+
+/* PPI errors */
+#define NRF_ERROR_SOC_PPI_INVALID_CHANNEL                 (NRF_ERROR_SOC_BASE_NUM + 8)  ///< Invalid PPI Channel
+#define NRF_ERROR_SOC_PPI_INVALID_GROUP                   (NRF_ERROR_SOC_BASE_NUM + 9)  ///< Invalid PPI Group
+
+#ifdef __cplusplus
+}
+#endif
+#endif // NRF_ERROR_SOC_H__
+/**
+  @}
+  @}
+*/
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf_nvic.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf_nvic.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf_nvic.h   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf_nvic.h    2018-04-24 08:48:29.028155500 +0200
@@ -0,0 +1,485 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/**
+ * @defgroup nrf_nvic_api SoftDevice NVIC API
+ * @{
+ *
+ * @note In order to use this module, the following code has to be added to a .c file:
+ *     \code
+ *     nrf_nvic_state_t nrf_nvic_state = {0};
+ *     \endcode
+ *
+ * @note Definitions and declarations starting with __ (double underscore) in this header file are
+ * not intended for direct use by the application.
+ *
+ * @brief APIs for the accessing NVIC when using a SoftDevice.
+ *
+ */
+
+#ifndef NRF_NVIC_H__
+#define NRF_NVIC_H__
+
+#include <stdint.h>
+#include "nrf.h"
+
+#include "nrf_error_soc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**@addtogroup NRF_NVIC_DEFINES Defines
+ * @{ */
+
+/**@defgroup NRF_NVIC_ISER_DEFINES SoftDevice NVIC internal definitions
+ * @{ */
+
+#define __NRF_NVIC_NVMC_IRQn (30) /**< The peripheral ID of the NVMC. IRQ numbers are used to identify peripherals, but the NVMC doesn't have an IRQ number in the MDK. */
+
+#ifdef NRF51
+  #define __NRF_NVIC_ISER_COUNT (1) /**< The number of ISER/ICER registers in the NVIC that are used. */
+
+  /**@brief Interrupts used by the SoftDevice. */
+  #define __NRF_NVIC_SD_IRQS_0 ((uint32_t)( \
+        (1U << POWER_CLOCK_IRQn) \
+      | (1U << RADIO_IRQn) \
+      | (1U << RTC0_IRQn) \
+      | (1U << TIMER0_IRQn) \
+      | (1U << RNG_IRQn) \
+      | (1U << ECB_IRQn) \
+      | (1U << CCM_AAR_IRQn) \
+      | (1U << TEMP_IRQn) \
+      | (1U << __NRF_NVIC_NVMC_IRQn) \
+      | (1U << (uint32_t)SWI4_IRQn) \
+      | (1U << (uint32_t)SWI5_IRQn) \
+    ))
+
+  /**@brief Interrupts available for to application. */
+  #define __NRF_NVIC_APP_IRQS_0 (~__NRF_NVIC_SD_IRQS_0)
+#endif
+
+#if (defined(NRF52) || defined(NRF52840_XXAA))
+  #define __NRF_NVIC_ISER_COUNT (2) /**< The number of ISER/ICER registers in the NVIC that are used. */
+
+  /**@brief Interrupts used by the SoftDevice. */
+  #define __NRF_NVIC_SD_IRQS_0 ((uint32_t)( \
+        (1U << POWER_CLOCK_IRQn) \
+      | (1U << RADIO_IRQn) \
+      | (1U << RTC0_IRQn) \
+      | (1U << TIMER0_IRQn) \
+      | (1U << RNG_IRQn) \
+      | (1U << ECB_IRQn) \
+      | (1U << CCM_AAR_IRQn) \
+      | (1U << TEMP_IRQn) \
+      | (1U << __NRF_NVIC_NVMC_IRQn) \
+      | (1U << (uint32_t)SWI4_EGU4_IRQn) \
+      | (1U << (uint32_t)SWI5_EGU5_IRQn) \
+    ))
+  #define __NRF_NVIC_SD_IRQS_1 ((uint32_t)0)
+
+  /**@brief Interrupts available for to application. */
+  #define __NRF_NVIC_APP_IRQS_0 (~__NRF_NVIC_SD_IRQS_0)
+  #define __NRF_NVIC_APP_IRQS_1 (~__NRF_NVIC_SD_IRQS_1)
+#endif
+/**@} */
+
+/**@} */
+
+/**@addtogroup NRF_NVIC_VARIABLES Variables
+ * @{ */
+
+/**@brief Type representing the state struct for the SoftDevice NVIC module. */
+typedef struct
+{
+  uint32_t volatile __irq_masks[__NRF_NVIC_ISER_COUNT]; /**< IRQs enabled by the application in the NVIC. */
+  uint32_t volatile __cr_flag;                          /**< Non-zero if already in a critical region */
+} nrf_nvic_state_t;
+
+/**@brief Variable keeping the state for the SoftDevice NVIC module. This must be declared in an
+ * application source file. */
+extern nrf_nvic_state_t nrf_nvic_state;
+
+/**@} */
+
+/**@addtogroup NRF_NVIC_INTERNAL_FUNCTIONS SoftDevice NVIC internal functions
+ * @{ */
+
+/**@brief Disables IRQ interrupts globally, including the SoftDevice's interrupts.
+ *
+ * @retval  The value of PRIMASK prior to disabling the interrupts.
+ */
+static inline int __sd_nvic_irq_disable(void)
+{
+  int pm = __get_PRIMASK();
+  __disable_irq();
+  return pm;
+}
+
+/**@brief Enables IRQ interrupts globally, including the SoftDevice's interrupts.
+ */
+static inline void __sd_nvic_irq_enable(void)
+{
+  __enable_irq();
+}
+
+/**@brief Checks if IRQn is available to application
+ * @param[in]  IRQn  irq to check
+ *
+ * @retval  1 (true) if the irq to check is available to the application
+ */
+static inline uint32_t __sd_nvic_app_accessible_irq(IRQn_Type IRQn)
+{
+  if (IRQn < 32)
+  {
+    return ((1UL<<IRQn) & __NRF_NVIC_APP_IRQS_0) != 0;
+  }
+#if (defined(NRF52) || defined(NRF52840_XXAA))
+  else if (IRQn < 64)
+  {
+    return ((1UL<<(IRQn-32)) & __NRF_NVIC_APP_IRQS_1) != 0;
+  }
+#endif
+  else
+  {
+    return 1;
+  }
+}
+
+/**@brief Checks if IRQn is available to application
+ * @param[in]  priority  priority to check
+ *
+ * @retval  1 (true) if the priority to check is available to the application
+ */
+static inline uint32_t __sd_nvic_is_app_accessible_priority(uint32_t priority)
+{
+  if (priority >= (1 << __NVIC_PRIO_BITS))
+  {
+    return 0;
+  }
+#ifdef NRF51
+  if (   priority == 0
+     || priority == 2
+     )
+  {
+    return 0;
+  }
+#endif
+#if (defined(NRF52) || defined(NRF52840_XXAA))
+  if (   priority == 0
+     || priority == 1
+     || priority == 4
+     || priority == 5
+     )
+  {
+    return 0;
+  }
+#endif
+  return 1;
+}
+
+/**@} */
+
+/**@addtogroup NRF_NVIC_FUNCTIONS SoftDevice NVIC public functions
+ * @{ */
+
+/**@brief Enable External Interrupt.
+ * @note Corresponds to NVIC_EnableIRQ in CMSIS.
+ *
+ * @pre IRQn is valid and not reserved by the stack.
+ *
+ * @param[in] IRQn See the NVIC_EnableIRQ documentation in CMSIS.
+ *
+ * @retval ::NRF_SUCCESS The interrupt was enabled.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE The interrupt is not available for the application.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED The interrupt has a priority not available for the application.
+ */
+static inline uint32_t sd_nvic_EnableIRQ(IRQn_Type IRQn)
+{
+  if (!__sd_nvic_app_accessible_irq(IRQn))
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
+  }
+  if (!__sd_nvic_is_app_accessible_priority(NVIC_GetPriority(IRQn)))
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
+  }
+
+  if (nrf_nvic_state.__cr_flag)
+  {
+    nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] |= (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));
+  }
+  else
+  {
+    NVIC_EnableIRQ(IRQn);
+  }
+  return NRF_SUCCESS;
+}
+
+/**@brief  Disable External Interrupt.
+ * @note Corresponds to NVIC_DisableIRQ in CMSIS.
+ *
+ * @pre IRQn is valid and not reserved by the stack.
+ *
+ * @param[in] IRQn See the NVIC_DisableIRQ documentation in CMSIS.
+ *
+ * @retval ::NRF_SUCCESS The interrupt was disabled.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE The interrupt is not available for the application.
+ */
+static inline uint32_t sd_nvic_DisableIRQ(IRQn_Type IRQn)
+{
+  if (!__sd_nvic_app_accessible_irq(IRQn))
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
+  }
+
+  if (nrf_nvic_state.__cr_flag)
+  {
+    nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] &= ~(1UL << ((uint32_t)(IRQn) & 0x1F));
+  }
+  else
+  {
+    NVIC_DisableIRQ(IRQn);
+  }
+
+  return NRF_SUCCESS;
+}
+
+/**@brief  Get Pending Interrupt.
+ * @note Corresponds to NVIC_GetPendingIRQ in CMSIS.
+ *
+ * @pre IRQn is valid and not reserved by the stack.
+ *
+ * @param[in]   IRQn          See the NVIC_GetPendingIRQ documentation in CMSIS.
+ * @param[out]  p_pending_irq Return value from NVIC_GetPendingIRQ.
+ *
+ * @retval ::NRF_SUCCESS The interrupt is available for the application.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE IRQn is not available for the application.
+ */
+static inline uint32_t sd_nvic_GetPendingIRQ(IRQn_Type IRQn, uint32_t * p_pending_irq)
+{
+  if (__sd_nvic_app_accessible_irq(IRQn))
+  {
+    *p_pending_irq = NVIC_GetPendingIRQ(IRQn);
+    return NRF_SUCCESS;
+  }
+  else
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
+  }
+}
+
+/**@brief  Set Pending Interrupt.
+ * @note Corresponds to NVIC_SetPendingIRQ in CMSIS.
+ *
+ * @pre IRQn is valid and not reserved by the stack.
+ *
+ * @param[in] IRQn See the NVIC_SetPendingIRQ documentation in CMSIS.
+ *
+ * @retval ::NRF_SUCCESS The interrupt is set pending.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE IRQn is not available for the application.
+ */
+static inline uint32_t sd_nvic_SetPendingIRQ(IRQn_Type IRQn)
+{
+  if (__sd_nvic_app_accessible_irq(IRQn))
+  {
+    NVIC_SetPendingIRQ(IRQn);
+    return NRF_SUCCESS;
+  }
+  else
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
+  }
+}
+
+/**@brief  Clear Pending Interrupt.
+ * @note Corresponds to NVIC_ClearPendingIRQ in CMSIS.
+ *
+ * @pre IRQn is valid and not reserved by the stack.
+ *
+ * @param[in] IRQn See the NVIC_ClearPendingIRQ documentation in CMSIS.
+ *
+ * @retval ::NRF_SUCCESS The interrupt pending flag is cleared.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE IRQn is not available for the application.
+ */
+static inline uint32_t sd_nvic_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  if (__sd_nvic_app_accessible_irq(IRQn))
+  {
+    NVIC_ClearPendingIRQ(IRQn);
+    return NRF_SUCCESS;
+  }
+  else
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
+  }
+}
+
+/**@brief Set Interrupt Priority.
+ * @note Corresponds to NVIC_SetPriority in CMSIS.
+ *
+ * @pre IRQn is valid and not reserved by the stack.
+ * @pre Priority is valid and not reserved by the stack.
+ *
+ * @param[in] IRQn      See the NVIC_SetPriority documentation in CMSIS.
+ * @param[in] priority  A valid IRQ priority for use by the application.
+ *
+ * @retval ::NRF_SUCCESS The interrupt and priority level is available for the application.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE IRQn is not available for the application.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED The interrupt priority is not available for the application.
+ */
+static inline uint32_t sd_nvic_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  if (!__sd_nvic_app_accessible_irq(IRQn))
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
+  }
+
+  if (!__sd_nvic_is_app_accessible_priority(priority))
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
+  }
+
+  NVIC_SetPriority(IRQn, (uint32_t)priority);
+  return NRF_SUCCESS;
+}
+
+/**@brief Get Interrupt Priority.
+ * @note Corresponds to NVIC_GetPriority in CMSIS.
+ *
+ * @pre IRQn is valid and not reserved by the stack.
+ *
+ * @param[in]  IRQn         See the NVIC_GetPriority documentation in CMSIS.
+ * @param[out] p_priority   Return value from NVIC_GetPriority.
+ *
+ * @retval ::NRF_SUCCESS The interrupt priority is returned in p_priority.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE - IRQn is not available for the application.
+ */
+static inline uint32_t sd_nvic_GetPriority(IRQn_Type IRQn, uint32_t * p_priority)
+{
+  if (__sd_nvic_app_accessible_irq(IRQn))
+  {
+    *p_priority = (NVIC_GetPriority(IRQn) & 0xFF);
+    return NRF_SUCCESS;
+  }
+  else
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
+  }
+}
+
+/**@brief System Reset.
+ * @note Corresponds to NVIC_SystemReset in CMSIS.
+ *
+ * @retval ::NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN
+ */
+static inline uint32_t sd_nvic_SystemReset(void)
+{
+  NVIC_SystemReset();
+  return NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN;
+}
+
+/**@brief Enters critical region.
+ *
+ * @post Application interrupts will be disabled.
+ * @note sd_nvic_critical_region_enter() and ::sd_nvic_critical_region_exit() must be called in matching pairs inside each
+ * execution context
+ * @sa sd_nvic_critical_region_exit
+ *
+ * @param[out] p_is_nested_critical_region If 1, the application is now in a nested critical region.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+static inline uint32_t sd_nvic_critical_region_enter(uint8_t * p_is_nested_critical_region)
+{
+  int was_masked = __sd_nvic_irq_disable();
+  if (!nrf_nvic_state.__cr_flag)
+  {
+    nrf_nvic_state.__cr_flag = 1;
+    nrf_nvic_state.__irq_masks[0] = ( NVIC->ICER[0] & __NRF_NVIC_APP_IRQS_0 );
+    NVIC->ICER[0] = __NRF_NVIC_APP_IRQS_0;
+    #if (defined(NRF52) || defined(NRF52840_XXAA))
+    nrf_nvic_state.__irq_masks[1] = ( NVIC->ICER[1] & __NRF_NVIC_APP_IRQS_1 );
+    NVIC->ICER[1] = __NRF_NVIC_APP_IRQS_1;
+    #endif
+    *p_is_nested_critical_region = 0;
+  }
+  else
+  {
+    *p_is_nested_critical_region = 1;
+  }
+  if (!was_masked)
+  {
+    __sd_nvic_irq_enable();
+  }
+  return NRF_SUCCESS;
+}
+
+/**@brief Exit critical region.
+ *
+ * @pre Application has entered a critical region using ::sd_nvic_critical_region_enter.
+ * @post If not in a nested critical region, the application interrupts will restored to the state before ::sd_nvic_critical_region_enter was called.
+ *
+ * @param[in] is_nested_critical_region If this is set to 1, the critical region won't be exited. @sa sd_nvic_critical_region_enter.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+static inline uint32_t sd_nvic_critical_region_exit(uint8_t is_nested_critical_region)
+{
+  if (nrf_nvic_state.__cr_flag && (is_nested_critical_region == 0))
+  {
+    int was_masked = __sd_nvic_irq_disable();
+    NVIC->ISER[0] = nrf_nvic_state.__irq_masks[0];
+    #if (defined(NRF52) || defined(NRF52840_XXAA))
+    NVIC->ISER[1] = nrf_nvic_state.__irq_masks[1];
+    #endif
+    nrf_nvic_state.__cr_flag = 0;
+    if (!was_masked)
+    {
+      __sd_nvic_irq_enable();
+    }
+  }
+
+  return NRF_SUCCESS;
+}
+/**@} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // NRF_NVIC_H__
+
+/**@} */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf_sd_def.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf_sd_def.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf_sd_def.h 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf_sd_def.h  2018-04-24 08:48:29.028155500 +0200
@@ -0,0 +1,28 @@
+/* Copyright (c) 2015 - 2018 Nordic Semiconductor ASA. All Rights Reserved.
+ *
+ * The information contained herein is confidential property of Nordic Semiconductor ASA.
+ * The use, copying, transfer or disclosure of such information is prohibited except by
+ * express written agreement with Nordic Semiconductor ASA.
+ *
+ */
+
+#ifndef NRF_SD_DEF_H__
+#define NRF_SD_DEF_H__
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define SD_PPI_CHANNELS_USED            0xFFF0C000uL /**< PPI channels utilized by SotfDevice (not available to the application). */
+#define SD_PPI_GROUPS_USED              0x0000000CuL /**< PPI groups utilized by SoftDevice (not available to the application). */
+#define SD_TIMERS_USED                  0x00000001uL /**< Timers used by SoftDevice. */
+#define SD_SWI_USED                     0x0000003CuL /**< Software interrupts used by SoftDevice */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NRF_SD_DEF_H__ */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf_sdm.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf_sdm.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf_sdm.h    1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf_sdm.h 2018-04-24 08:48:29.038155700 +0200
@@ -0,0 +1,331 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/**
+  @defgroup nrf_sdm_api SoftDevice Manager API
+  @{
+
+  @brief APIs for SoftDevice management.
+
+*/
+
+#ifndef NRF_SDM_H__
+#define NRF_SDM_H__
+
+#include "nrf_svc.h"
+#include "nrf.h"
+#include "nrf_soc.h"
+#include "nrf_error_sdm.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup NRF_SDM_DEFINES Defines
+ * @{ */
+#ifdef NRFSOC_DOXYGEN
+/// Declared in nrf_mbr.h
+#define MBR_SIZE 0
+#warning test
+#endif
+
+/** @brief The major version for the SoftDevice binary distributed with this header file. */
+#define SD_MAJOR_VERSION  (3)
+
+/** @brief The minor version for the SoftDevice binary distributed with this header file. */
+#define SD_MINOR_VERSION  (0)
+
+/** @brief The bugfix version for the SoftDevice binary distributed with this header file. */
+#define SD_BUGFIX_VERSION (0)
+
+/** @brief The full version number for the SoftDevice binary this header file was distributed
+ *         with, as a decimal number in the form Mmmmbbb, where:
+ *           - M is major version (one or more digits)
+ *           - mmm is minor version (three digits)
+ *           - bbb is bugfix version (three digits). */
+#define SD_VERSION (SD_MAJOR_VERSION * 1000000 + SD_MINOR_VERSION * 1000 + SD_BUGFIX_VERSION)
+
+/** @brief SoftDevice Manager SVC Base number. */
+#define SDM_SVC_BASE 0x10
+
+/** @brief Invalid info field. Returned when an info field does not exist. */
+#define SDM_INFO_FIELD_INVALID (0)
+
+/** @brief Defines the SoftDevice Information Structure location (address) as an offset from
+the start of the softdevice (without MBR)*/
+#define SOFTDEVICE_INFO_STRUCT_OFFSET (0x2000)
+
+/** @brief Defines the absolute SoftDevice Information Structure location (address) when the
+ *         SoftDevice is installed just above the MBR (the usual case). */
+#define SOFTDEVICE_INFO_STRUCT_ADDRESS (SOFTDEVICE_INFO_STRUCT_OFFSET + MBR_SIZE)
+
+/** @brief Defines the offset for the SoftDevice Information Structure size value relative to the
+ *         SoftDevice base address. The size value is of type uint8_t. */
+#define SD_INFO_STRUCT_SIZE_OFFSET (SOFTDEVICE_INFO_STRUCT_OFFSET)
+
+/** @brief Defines the offset for the SoftDevice size value relative to the SoftDevice base address.
+ *         The size value is of type uint32_t. */
+#define SD_SIZE_OFFSET (SOFTDEVICE_INFO_STRUCT_OFFSET + 0x08)
+
+/** @brief Defines the offset for FWID value relative to the SoftDevice base address. The FWID value
+ *         is of type uint16_t.  */
+#define SD_FWID_OFFSET (SOFTDEVICE_INFO_STRUCT_OFFSET + 0x0C)
+
+/** @brief Defines the offset for the SoftDevice ID relative to the SoftDevice base address. The ID
+ *         is of type uint32_t. */
+#define SD_ID_OFFSET (SOFTDEVICE_INFO_STRUCT_OFFSET + 0x10)
+
+/** @brief Defines the offset for the SoftDevice version relative to the SoftDevice base address in
+ *         the same format as @ref SD_VERSION, stored as an uint32_t. */
+#define SD_VERSION_OFFSET (SOFTDEVICE_INFO_STRUCT_OFFSET + 0x14)
+
+/** @brief Defines a macro for retreiving the actual SoftDevice Information Structure size value
+ *         from a given base address. Use @ref MBR_SIZE as the argument when the SoftDevice is
+ *         installed just above the MBR (the usual case). */
+#define SD_INFO_STRUCT_SIZE_GET(baseaddr) (*((uint8_t *) ((baseaddr) + SD_INFO_STRUCT_SIZE_OFFSET)))
+
+/** @brief Defines a macro for retreiving the actual SoftDevice size value from a given base
+ *         address. Use @ref MBR_SIZE as the argument when the SoftDevice is installed just above
+ *         the MBR (the usual case). */
+#define SD_SIZE_GET(baseaddr) (*((uint32_t *) ((baseaddr) + SD_SIZE_OFFSET)))
+
+/** @brief Defines a macro for retreiving the actual FWID value from a given base address. Use @ref
+ *         MBR_SIZE as the argument when the SoftDevice is installed just above the MBR (the usual
+ *         case). */
+#define SD_FWID_GET(baseaddr) (*((uint16_t *) ((baseaddr) + SD_FWID_OFFSET)))
+
+/** @brief Defines a macro for retreiving the actual SoftDevice ID from a given base address. Use
+ *         @ref MBR_SIZE as the argument when the SoftDevice is installed just above the MBR (the
+ *         usual case). */
+#define SD_ID_GET(baseaddr) ((SD_INFO_STRUCT_SIZE_GET(baseaddr) > (SD_ID_OFFSET - SOFTDEVICE_INFO_STRUCT_OFFSET)) \
+        ? (*((uint32_t *) ((baseaddr) + SD_ID_OFFSET))) : SDM_INFO_FIELD_INVALID)
+
+/** @brief Defines a macro for retreiving the actual FWID value from a given base address. Use @ref
+ *         MBR_SIZE as the argument when the SoftDevice is installed just above the MBR (the usual
+ *         case). */
+#define SD_VERSION_GET(baseaddr) ((SD_INFO_STRUCT_SIZE_GET(baseaddr) > (SD_VERSION_OFFSET - SOFTDEVICE_INFO_STRUCT_OFFSET)) \
+        ? (*((uint32_t *) ((baseaddr) + SD_VERSION_OFFSET))) : SDM_INFO_FIELD_INVALID)
+
+/**@defgroup NRF_FAULT_ID_RANGES Fault ID ranges
+ * @{ */
+#define NRF_FAULT_ID_SD_RANGE_START     0x00000000            /**< SoftDevice ID range start. */
+#define NRF_FAULT_ID_APP_RANGE_START    0x00001000            /**< Application ID range start. */
+/**@} */
+
+/**@defgroup NRF_FAULT_IDS Fault ID types
+ * @{ */
+#define NRF_FAULT_ID_SD_ASSERT    (NRF_FAULT_ID_SD_RANGE_START + 1)           /**< SoftDevice assertion. The info parameter will be set to 0x00000000. */
+#define NRF_FAULT_ID_APP_MEMACC   (NRF_FAULT_ID_APP_RANGE_START + 1)          /**< Application invalid memory access (nRF52 only). The info parameter will contain 0x00000000, in case of SoftDevice RAM
+                                                                              access violation. In case of SoftDevice peripheral register violation the info parameter will contain the sub-region number of PREGION[0], on whose address range the unallowed
+                                                                              write access caused the memory access fault. */
+/**@} */
+
+/** @} */
+
+/** @addtogroup NRF_SDM_ENUMS Enumerations
+ * @{ */
+
+/**@brief nRF SoftDevice Manager API SVC numbers. */
+enum NRF_SD_SVCS
+{
+  SD_SOFTDEVICE_ENABLE = SDM_SVC_BASE, /**< ::sd_softdevice_enable */
+  SD_SOFTDEVICE_DISABLE,               /**< ::sd_softdevice_disable */
+  SD_SOFTDEVICE_IS_ENABLED,            /**< ::sd_softdevice_is_enabled */
+  SD_SOFTDEVICE_VECTOR_TABLE_BASE_SET, /**< ::sd_softdevice_vector_table_base_set */
+  SVC_SDM_LAST                         /**< Placeholder for last SDM SVC */
+};
+
+/** @} */
+
+/** @addtogroup NRF_SDM_DEFINES Defines
+ * @{ */
+
+/**@defgroup NRF_CLOCK_LF_XTAL_ACCURACY Clock accuracy
+ * @{ */
+
+#define NRF_CLOCK_LF_XTAL_ACCURACY_250_PPM (0) /**< Default: 250 ppm */
+#define NRF_CLOCK_LF_XTAL_ACCURACY_500_PPM (1) /**< 500 ppm */
+#define NRF_CLOCK_LF_XTAL_ACCURACY_150_PPM (2) /**< 150 ppm */
+#define NRF_CLOCK_LF_XTAL_ACCURACY_100_PPM (3) /**< 100 ppm */
+#define NRF_CLOCK_LF_XTAL_ACCURACY_75_PPM  (4) /**< 75 ppm */
+#define NRF_CLOCK_LF_XTAL_ACCURACY_50_PPM  (5) /**< 50 ppm */
+#define NRF_CLOCK_LF_XTAL_ACCURACY_30_PPM  (6) /**< 30 ppm */
+#define NRF_CLOCK_LF_XTAL_ACCURACY_20_PPM  (7) /**< 20 ppm */
+
+/** @} */
+
+/**@defgroup NRF_CLOCK_LF_SRC Possible lfclk oscillator sources
+ * @{ */
+
+#define NRF_CLOCK_LF_SRC_RC      (0)                        /**< LFCLK RC oscillator. */
+#define NRF_CLOCK_LF_SRC_XTAL    (1)                        /**< LFCLK crystal oscillator. */
+#define NRF_CLOCK_LF_SRC_SYNTH   (2)                        /**< LFCLK Synthesized from HFCLK. */
+
+/** @} */
+
+/** @} */
+
+/** @addtogroup NRF_SDM_TYPES Types
+ * @{ */
+
+/**@brief Type representing lfclk oscillator source. */
+typedef struct
+{
+  uint8_t source;        /**< LF oscillator clock source, see @ref NRF_CLOCK_LF_SRC. */
+  uint8_t rc_ctiv;      /**< Only for NRF_CLOCK_LF_SRC_RC: Calibration timer interval in 1/4 second
+                              units (nRF51: 1-64, nRF52: 1-32).
+                              @note To avoid excessive clock drift, 0.5 degrees Celsius is the
+                                    maximum temperature change allowed in one calibration timer
+                                    interval. The interval should be selected to ensure this.
+
+                              @note Must be 0 if source is not NRF_CLOCK_LF_SRC_RC.  */
+  uint8_t rc_temp_ctiv; /**<  Only for NRF_CLOCK_LF_SRC_RC: How often (in number of calibration
+                              intervals) the RC oscillator shall be calibrated if the temperature
+                              hasn't changed.
+                                  0: Always calibrate even if the temperature hasn't changed.
+                                  1: Only calibrate if the temperature has changed (nRF51 only).
+                                  2-33: Check the temperature and only calibrate if it has changed,
+                                        however calibration will take place every rc_temp_ctiv
+                                        intervals in any case.
+
+                              @note Must be 0 if source is not NRF_CLOCK_LF_SRC_RC.
+
+                              @note For nRF52, the application must ensure calibration at least once
+                                    every 8 seconds to ensure +/-250ppm clock stability. The
+                                    recommended configuration for NRF_CLOCK_LF_SRC_RC on nRF52 is
+                                    rc_ctiv=16 and rc_temp_ctiv=2. This will ensure calibration at
+                                    least once every 8 seconds and for temperature changes of 0.5
+                                    degrees Celsius every 4 seconds. See the Product Specification
+                                    for the nRF52 device being used for more information.*/
+  uint8_t xtal_accuracy; /**< External crystal clock accuracy used in the LL to compute timing windows.
+
+                              @note For the NRF_CLOCK_LF_SRC_RC clock source this parameter is ignored. */
+} nrf_clock_lf_cfg_t;
+
+/**@brief Fault Handler type.
+ *
+ * When certain unrecoverable errors occur within the application or SoftDevice the fault handler will be called back.
+ * The protocol stack will be in an undefined state when this happens and the only way to recover will be to
+ * perform a reset, using e.g. CMSIS NVIC_SystemReset().
+ *
+ * @note This callback is executed in HardFault context, thus SVC functions cannot be called from the fault callback.
+ *
+ * @param[in] id Fault identifier. See @ref NRF_FAULT_IDS.
+ * @param[in] pc The program counter of the instruction that triggered the fault.
+ * @param[in] info Optional additional information regarding the fault. Refer to each Fault identifier for details.
+ *
+ * @note When id is set to NRF_FAULT_ID_APP_MEMACC, pc will contain the address of the instruction being executed at the time when
+ * the fault is detected by the CPU. The CPU program counter may have advanced up to 2 instructions (no branching) after the one that triggered the fault.
+ */
+typedef void (*nrf_fault_handler_t)(uint32_t id, uint32_t pc, uint32_t info);
+
+/** @} */
+
+/** @addtogroup NRF_SDM_FUNCTIONS Functions
+ * @{ */
+
+/**@brief Enables the SoftDevice and by extension the protocol stack.
+ *
+ * @note Some care must be taken if a low frequency clock source is already running when calling this function:
+ *       If the LF clock has a different source then the one currently running, it will be stopped. Then, the new
+ *       clock source will be started.
+ *
+ * @note This function has no effect when returning with an error.
+ *
+ * @post If return code is ::NRF_SUCCESS
+ *       - SoC library and protocol stack APIs are made available.
+ *       - A portion of RAM will be unavailable (see relevant SDS documentation).
+ *       - Some peripherals will be unavailable or available only through the SoC API (see relevant SDS documentation).
+ *       - Interrupts will not arrive from protected peripherals or interrupts.
+ *       - nrf_nvic_ functions must be used instead of CMSIS NVIC_ functions for reliable usage of the SoftDevice.
+ *       - Interrupt latency may be affected by the SoftDevice  (see relevant SDS documentation).
+ *       - Chosen low frequency clock source will be running.
+ *
+ * @param p_clock_lf_cfg Low frequency clock source and accuracy.
+                         If NULL the clock will be configured as an rc source with rc_ctiv = 16 and .rc_temp_ctiv = 2
+                         In the case of XTAL source, the PPM accuracy of the chosen clock source must be greater than or equal to the actual characteristics of your XTAL clock.
+ * @param fault_handler Callback to be invoked in case of fault.
+ *
+ * @retval ::NRF_SUCCESS
+ * @retval ::NRF_ERROR_INVALID_STATE SoftDevice is already enabled, and the clock source and fault handler cannot be updated.
+ * @retval ::NRF_ERROR_SDM_INCORRECT_INTERRUPT_CONFIGURATION SoftDevice interrupt is already enabled, or an enabled interrupt has an illegal priority level.
+ * @retval ::NRF_ERROR_SDM_LFCLK_SOURCE_UNKNOWN Unknown low frequency clock source selected.
+ */
+SVCALL(SD_SOFTDEVICE_ENABLE, uint32_t, sd_softdevice_enable(nrf_clock_lf_cfg_t const * p_clock_lf_cfg, nrf_fault_handler_t fault_handler));
+
+
+/**@brief Disables the SoftDevice and by extension the protocol stack.
+ *
+ * Idempotent function to disable the SoftDevice.
+ *
+ * @post SoC library and protocol stack APIs are made unavailable.
+ * @post All interrupts that was protected by the SoftDevice will be disabled and initialized to priority 0 (highest).
+ * @post All peripherals used by the SoftDevice will be reset to default values.
+ * @post All of RAM become available.
+ * @post All interrupts are forwarded to the application.
+ * @post LFCLK source chosen in ::sd_softdevice_enable will be left running.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_SOFTDEVICE_DISABLE, uint32_t, sd_softdevice_disable(void));
+
+/**@brief Check if the SoftDevice is enabled.
+ *
+ * @param[out]  p_softdevice_enabled If the SoftDevice is enabled: 1 else 0.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_SOFTDEVICE_IS_ENABLED, uint32_t, sd_softdevice_is_enabled(uint8_t * p_softdevice_enabled));
+
+/**@brief Sets the base address of the interrupt vector table for interrupts forwarded from the SoftDevice
+ *
+ * This function is only intended to be called when a bootloader is enabled.
+ *
+ * @param[in] address The base address of the interrupt vector table for forwarded interrupts.
+
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_SOFTDEVICE_VECTOR_TABLE_BASE_SET, uint32_t, sd_softdevice_vector_table_base_set(uint32_t address));
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+#endif // NRF_SDM_H__
+
+/**
+  @}
+*/
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf_soc.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf_soc.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf_soc.h    1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf_soc.h 2018-04-24 08:48:29.038155700 +0200
@@ -0,0 +1,906 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/**
+ * @defgroup nrf_soc_api SoC Library API
+ * @{
+ *
+ * @brief APIs for the SoC library.
+ *
+ */
+
+#ifndef NRF_SOC_H__
+#define NRF_SOC_H__
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "nrf_svc.h"
+#include "nrf.h"
+
+#include "nrf_error_soc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**@addtogroup NRF_SOC_DEFINES Defines
+ * @{ */
+
+/**@brief The number of the lowest SVC number reserved for the SoC library. */
+#define SOC_SVC_BASE               (0x20)                   /**< Base value for SVCs that are available when the SoftDevice is disabled. */
+#define SOC_SVC_BASE_NOT_AVAILABLE (0x2B)                   /**< Base value for SVCs that are not available when the SoftDevice is disabled. */
+
+/**@brief Guranteed time for application to process radio inactive notification. */
+#define NRF_RADIO_NOTIFICATION_INACTIVE_GUARANTEED_TIME_US  (62)
+
+/**@brief The minimum allowed timeslot extension time. */
+#define NRF_RADIO_MINIMUM_TIMESLOT_LENGTH_EXTENSION_TIME_US (200)
+
+#define SOC_ECB_KEY_LENGTH                (16)                       /**< ECB key length. */
+#define SOC_ECB_CLEARTEXT_LENGTH          (16)                       /**< ECB cleartext length. */
+#define SOC_ECB_CIPHERTEXT_LENGTH         (SOC_ECB_CLEARTEXT_LENGTH) /**< ECB ciphertext length. */
+
+#ifdef NRF51
+#define SD_EVT_IRQn                       (SWI2_IRQn)        /**< SoftDevice Event IRQ number. Used for both protocol events and SoC events. */
+#define SD_EVT_IRQHandler                 (SWI2_IRQHandler)  /**< SoftDevice Event IRQ handler. Used for both protocol events and SoC events. */
+#define RADIO_NOTIFICATION_IRQn           (SWI1_IRQn)        /**< The radio notification IRQ number. */
+#define RADIO_NOTIFICATION_IRQHandler     (SWI1_IRQHandler)  /**< The radio notification IRQ handler. */
+#endif
+#if (defined(NRF52) || defined(NRF52840_XXAA))
+#define SD_EVT_IRQn                       (SWI2_EGU2_IRQn)        /**< SoftDevice Event IRQ number. Used for both protocol events and SoC events. */
+#define SD_EVT_IRQHandler                 (SWI2_EGU2_IRQHandler)  /**< SoftDevice Event IRQ handler. Used for both protocol events and SoC events. */
+#define RADIO_NOTIFICATION_IRQn           (SWI1_EGU1_IRQn)        /**< The radio notification IRQ number. */
+#define RADIO_NOTIFICATION_IRQHandler     (SWI1_EGU1_IRQHandler)  /**< The radio notification IRQ handler. */
+#endif
+
+#define NRF_RADIO_LENGTH_MIN_US           (100)               /**< The shortest allowed radio timeslot, in microseconds. */
+#define NRF_RADIO_LENGTH_MAX_US           (100000)            /**< The longest allowed radio timeslot, in microseconds. */
+
+#define NRF_RADIO_DISTANCE_MAX_US         (128000000UL - 1UL) /**< The longest timeslot distance, in microseconds, allowed for the distance parameter (see @ref nrf_radio_request_normal_t) in the request. */
+
+#define NRF_RADIO_EARLIEST_TIMEOUT_MAX_US (128000000UL - 1UL) /**< The longest timeout, in microseconds, allowed when requesting the earliest possible timeslot. */
+
+#define NRF_RADIO_START_JITTER_US         (2)                 /**< The maximum jitter in @ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START relative to the requested start time. */
+
+/**@} */
+
+/**@addtogroup NRF_SOC_ENUMS Enumerations
+ * @{ */
+
+/**@brief The SVC numbers used by the SVC functions in the SoC library. */
+enum NRF_SOC_SVCS
+{
+  SD_PPI_CHANNEL_ENABLE_GET = SOC_SVC_BASE,
+  SD_PPI_CHANNEL_ENABLE_SET,
+  SD_PPI_CHANNEL_ENABLE_CLR,
+  SD_PPI_CHANNEL_ASSIGN,
+  SD_PPI_GROUP_TASK_ENABLE,
+  SD_PPI_GROUP_TASK_DISABLE,
+  SD_PPI_GROUP_ASSIGN,
+  SD_PPI_GROUP_GET,
+  SD_FLASH_PAGE_ERASE,
+  SD_FLASH_WRITE,
+  SD_FLASH_PROTECT,
+  SD_MUTEX_NEW = SOC_SVC_BASE_NOT_AVAILABLE,
+  SD_MUTEX_ACQUIRE,
+  SD_MUTEX_RELEASE,
+  SD_RAND_APPLICATION_POOL_CAPACITY_GET,
+  SD_RAND_APPLICATION_BYTES_AVAILABLE_GET,
+  SD_RAND_APPLICATION_VECTOR_GET,
+  SD_POWER_MODE_SET,
+  SD_POWER_SYSTEM_OFF,
+  SD_POWER_RESET_REASON_GET,
+  SD_POWER_RESET_REASON_CLR,
+  SD_POWER_POF_ENABLE,
+  SD_POWER_POF_THRESHOLD_SET,
+  SD_POWER_RAMON_SET,
+  SD_POWER_RAMON_CLR,
+  SD_POWER_RAMON_GET,
+  SD_POWER_GPREGRET_SET,
+  SD_POWER_GPREGRET_CLR,
+  SD_POWER_GPREGRET_GET,
+  SD_POWER_DCDC_MODE_SET,
+  SD_APP_EVT_WAIT,
+  SD_CLOCK_HFCLK_REQUEST,
+  SD_CLOCK_HFCLK_RELEASE,
+  SD_CLOCK_HFCLK_IS_RUNNING,
+  SD_RADIO_NOTIFICATION_CFG_SET,
+  SD_ECB_BLOCK_ENCRYPT,
+  SD_ECB_BLOCKS_ENCRYPT,
+  SD_RADIO_SESSION_OPEN,
+  SD_RADIO_SESSION_CLOSE,
+  SD_RADIO_REQUEST,
+  SD_EVT_GET,
+  SD_TEMP_GET,
+  SVC_SOC_LAST
+};
+
+/**@brief Possible values of a ::nrf_mutex_t. */
+enum NRF_MUTEX_VALUES
+{
+  NRF_MUTEX_FREE,
+  NRF_MUTEX_TAKEN
+};
+
+/**@brief Power modes. */
+enum NRF_POWER_MODES
+{
+  NRF_POWER_MODE_CONSTLAT,  /**< Constant latency mode. See power management in the reference manual. */
+  NRF_POWER_MODE_LOWPWR     /**< Low power mode. See power management in the reference manual. */
+};
+
+
+/**@brief Power failure thresholds */
+enum NRF_POWER_THRESHOLDS
+{
+  NRF_POWER_THRESHOLD_V21,  /**< 2.1 Volts power failure threshold. */
+  NRF_POWER_THRESHOLD_V23,  /**< 2.3 Volts power failure threshold. */
+  NRF_POWER_THRESHOLD_V25,  /**< 2.5 Volts power failure threshold. */
+  NRF_POWER_THRESHOLD_V27   /**< 2.7 Volts power failure threshold. */
+};
+
+
+/**@brief DC/DC converter modes. */
+enum NRF_POWER_DCDC_MODES
+{
+  NRF_POWER_DCDC_DISABLE,          /**< The DCDC is disabled. */
+  NRF_POWER_DCDC_ENABLE            /**< The DCDC is enabled.  */
+};
+
+/**@brief Radio notification distances. */
+enum NRF_RADIO_NOTIFICATION_DISTANCES
+{
+  NRF_RADIO_NOTIFICATION_DISTANCE_NONE = 0, /**< The event does not have a notification. */
+  NRF_RADIO_NOTIFICATION_DISTANCE_800US,    /**< The distance from the active notification to start of radio activity. */
+  NRF_RADIO_NOTIFICATION_DISTANCE_1740US,   /**< The distance from the active notification to start of radio activity. */
+  NRF_RADIO_NOTIFICATION_DISTANCE_2680US,   /**< The distance from the active notification to start of radio activity. */
+  NRF_RADIO_NOTIFICATION_DISTANCE_3620US,   /**< The distance from the active notification to start of radio activity. */
+  NRF_RADIO_NOTIFICATION_DISTANCE_4560US,   /**< The distance from the active notification to start of radio activity. */
+  NRF_RADIO_NOTIFICATION_DISTANCE_5500US    /**< The distance from the active notification to start of radio activity. */
+};
+
+
+/**@brief Radio notification types. */
+enum NRF_RADIO_NOTIFICATION_TYPES
+{
+  NRF_RADIO_NOTIFICATION_TYPE_NONE = 0,        /**< The event does not have a radio notification signal. */
+  NRF_RADIO_NOTIFICATION_TYPE_INT_ON_ACTIVE,   /**< Using interrupt for notification when the radio will be enabled. */
+  NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE, /**< Using interrupt for notification when the radio has been disabled. */
+  NRF_RADIO_NOTIFICATION_TYPE_INT_ON_BOTH,     /**< Using interrupt for notification both when the radio will be enabled and disabled. */
+};
+
+/**@brief The Radio signal callback types. */
+enum NRF_RADIO_CALLBACK_SIGNAL_TYPE
+{
+  NRF_RADIO_CALLBACK_SIGNAL_TYPE_START,             /**< This signal indicates the start of the radio timeslot. */
+  NRF_RADIO_CALLBACK_SIGNAL_TYPE_TIMER0,            /**< This signal indicates the NRF_TIMER0 interrupt. */
+  NRF_RADIO_CALLBACK_SIGNAL_TYPE_RADIO,             /**< This signal indicates the NRF_RADIO interrupt. */
+  NRF_RADIO_CALLBACK_SIGNAL_TYPE_EXTEND_FAILED,     /**< This signal indicates extend action failed. */
+  NRF_RADIO_CALLBACK_SIGNAL_TYPE_EXTEND_SUCCEEDED   /**< This signal indicates extend action succeeded. */
+};
+
+/**@brief The actions requested by the signal callback.
+ *
+ *  This code gives the SOC instructions about what action to take when the signal callback has
+ *  returned.
+ */
+enum NRF_RADIO_SIGNAL_CALLBACK_ACTION
+{
+  NRF_RADIO_SIGNAL_CALLBACK_ACTION_NONE,            /**< Return without action. */
+  NRF_RADIO_SIGNAL_CALLBACK_ACTION_EXTEND,          /**< Request an extension of the current timeslot (maximum execution time for this action is when the extension succeeded). */
+  NRF_RADIO_SIGNAL_CALLBACK_ACTION_END,             /**< End the current radio timeslot. */
+  NRF_RADIO_SIGNAL_CALLBACK_ACTION_REQUEST_AND_END  /**< Request a new radio timeslot and end the current timeslot. */
+};
+
+/**@brief Radio timeslot high frequency clock source configuration. */
+enum NRF_RADIO_HFCLK_CFG
+{
+  NRF_RADIO_HFCLK_CFG_XTAL_GUARANTEED, /**< The SoftDevice will guarantee that the high frequency clock source is the
+                                           external crystal for the whole duration of the timeslot. This should be the
+                                           preferred option for events that use the radio or require high timing accuracy. */
+  NRF_RADIO_HFCLK_CFG_NO_GUARANTEE    /**< This configuration allows for earlier and tighter scheduling of timeslots.
+                                           The RC oscillator may be the clock source in part or for the whole duration of the timeslot.
+                                           The RC oscillator's accuracy must therefore be taken into consideration.
+                                           @note If the application will use the radio peripheral in timeslots with this configuration,
+                                           it must make sure that the crystal is running and stable before starting the radio. */
+};
+
+/**@brief Radio timeslot priorities. */
+enum NRF_RADIO_PRIORITY
+{
+  NRF_RADIO_PRIORITY_HIGH,                          /**< High (equal priority as the normal connection priority of the SoftDevice stack(s)). */
+  NRF_RADIO_PRIORITY_NORMAL,                        /**< Normal (equal priority as the priority of secondary activites of the SoftDevice stack(s)). */
+};
+
+/**@brief Radio timeslot request type. */
+enum NRF_RADIO_REQUEST_TYPE
+{
+  NRF_RADIO_REQ_TYPE_EARLIEST,                      /**< Request radio timeslot as early as possible. This should always be used for the first request in a session. */
+  NRF_RADIO_REQ_TYPE_NORMAL                         /**< Normal radio timeslot request. */
+};
+
+/**@brief SoC Events. */
+enum NRF_SOC_EVTS
+{
+  NRF_EVT_HFCLKSTARTED,                         /**< Event indicating that the HFCLK has started. */
+  NRF_EVT_POWER_FAILURE_WARNING,                /**< Event indicating that a power failure warning has occurred. */
+  NRF_EVT_FLASH_OPERATION_SUCCESS,              /**< Event indicating that the ongoing flash operation has completed successfully. */
+  NRF_EVT_FLASH_OPERATION_ERROR,                /**< Event indicating that the ongoing flash operation has timed out with an error. */
+  NRF_EVT_RADIO_BLOCKED,                        /**< Event indicating that a radio timeslot was blocked. */
+  NRF_EVT_RADIO_CANCELED,                       /**< Event indicating that a radio timeslot was canceled by SoftDevice. */
+  NRF_EVT_RADIO_SIGNAL_CALLBACK_INVALID_RETURN, /**< Event indicating that a radio timeslot signal callback handler return was invalid. */
+  NRF_EVT_RADIO_SESSION_IDLE,                   /**< Event indicating that a radio timeslot session is idle. */
+  NRF_EVT_RADIO_SESSION_CLOSED,                 /**< Event indicating that a radio timeslot session is closed. */
+  NRF_EVT_NUMBER_OF_EVTS
+};
+
+/**@} */
+
+
+/**@addtogroup NRF_SOC_STRUCTURES Structures
+ * @{ */
+
+/**@brief Represents a mutex for use with the nrf_mutex functions.
+ * @note Accessing the value directly is not safe, use the mutex functions!
+ */
+typedef volatile uint8_t nrf_mutex_t;
+
+/**@brief Parameters for a request for a timeslot as early as possible. */
+typedef struct
+{
+  uint8_t       hfclk;                              /**< High frequency clock source, see @ref NRF_RADIO_HFCLK_CFG. */
+  uint8_t       priority;                           /**< The radio timeslot priority, see @ref NRF_RADIO_PRIORITY. */
+  uint32_t      length_us;                          /**< The radio timeslot length (in the range 100 to 100,000] microseconds). */
+  uint32_t      timeout_us;                         /**< Longest acceptable delay until the start of the requested timeslot (up to @ref NRF_RADIO_EARLIEST_TIMEOUT_MAX_US microseconds). */
+} nrf_radio_request_earliest_t;
+
+/**@brief Parameters for a normal radio timeslot request. */
+typedef struct
+{
+  uint8_t       hfclk;                              /**< High frequency clock source, see @ref NRF_RADIO_HFCLK_CFG. */
+  uint8_t       priority;                           /**< The radio timeslot priority, see @ref NRF_RADIO_PRIORITY. */
+  uint32_t      distance_us;                        /**< Distance from the start of the previous radio timeslot (up to @ref NRF_RADIO_DISTANCE_MAX_US microseconds). */
+  uint32_t      length_us;                          /**< The radio timeslot length (in the range [100..100,000] microseconds). */
+} nrf_radio_request_normal_t;
+
+/**@brief Radio timeslot request parameters. */
+typedef struct
+{
+  uint8_t                         request_type;     /**< Type of request, see @ref NRF_RADIO_REQUEST_TYPE. */
+  union
+  {
+    nrf_radio_request_earliest_t  earliest;         /**< Parameters for requesting a radio timeslot as early as possible. */
+    nrf_radio_request_normal_t    normal;           /**< Parameters for requesting a normal radio timeslot. */
+  } params;                                         /**< Parameter union. */
+} nrf_radio_request_t;
+
+/**@brief Return parameters of the radio timeslot signal callback. */
+typedef struct
+{
+  uint8_t               callback_action;            /**< The action requested by the application when returning from the signal callback, see @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION. */
+  union
+  {
+    struct
+    {
+      nrf_radio_request_t * p_next;                 /**< The request parameters for the next radio timeslot. */
+    } request;                                      /**< Additional parameters for return_code @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION_REQUEST_AND_END. */
+    struct
+    {
+      uint32_t              length_us;              /**< Requested extension of the radio timeslot duration (microseconds) (for minimum time see @ref NRF_RADIO_MINIMUM_TIMESLOT_LENGTH_EXTENSION_TIME_US). */
+    } extend;                                       /**< Additional parameters for return_code @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION_EXTEND. */
+  } params;                                         /**< Parameter union. */
+} nrf_radio_signal_callback_return_param_t;
+
+/**@brief The radio timeslot signal callback type.
+ *
+ * @note In case of invalid return parameters, the radio timeslot will automatically end
+ *       immediately after returning from the signal callback and the
+ *       @ref NRF_EVT_RADIO_SIGNAL_CALLBACK_INVALID_RETURN event will be sent.
+ * @note The returned struct pointer must remain valid after the signal callback
+ *       function returns. For instance, this means that it must not point to a stack variable.
+ *
+ * @param[in] signal_type Type of signal, see @ref NRF_RADIO_CALLBACK_SIGNAL_TYPE.
+ *
+ * @return Pointer to structure containing action requested by the application.
+ */
+typedef nrf_radio_signal_callback_return_param_t * (*nrf_radio_signal_callback_t) (uint8_t signal_type);
+
+/**@brief AES ECB parameter typedefs */
+typedef uint8_t soc_ecb_key_t[SOC_ECB_KEY_LENGTH];                /**< Encryption key type. */
+typedef uint8_t soc_ecb_cleartext_t[SOC_ECB_CLEARTEXT_LENGTH];    /**< Cleartext data type. */
+typedef uint8_t soc_ecb_ciphertext_t[SOC_ECB_CIPHERTEXT_LENGTH];  /**< Ciphertext data type. */
+
+/**@brief AES ECB data structure */
+typedef struct
+{
+  soc_ecb_key_t        key;            /**< Encryption key. */
+  soc_ecb_cleartext_t  cleartext;      /**< Cleartext data. */
+  soc_ecb_ciphertext_t ciphertext;     /**< Ciphertext data. */
+} nrf_ecb_hal_data_t;
+
+/**@brief AES ECB block. Used to provide multiple blocks in a single call
+          to @ref sd_ecb_blocks_encrypt.*/
+typedef struct
+{
+  soc_ecb_key_t*        p_key;           /**< Pointer to the Encryption key. */
+  soc_ecb_cleartext_t*  p_cleartext;     /**< Pointer to the Cleartext data. */
+  soc_ecb_ciphertext_t* p_ciphertext;    /**< Pointer to the Ciphertext data. */
+} nrf_ecb_hal_data_block_t;
+
+/**@} */
+
+/**@addtogroup NRF_SOC_FUNCTIONS Functions
+ * @{ */
+
+/**@brief Initialize a mutex.
+ *
+ * @param[in] p_mutex Pointer to the mutex to initialize.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_MUTEX_NEW, uint32_t, sd_mutex_new(nrf_mutex_t * p_mutex));
+
+/**@brief Attempt to acquire a mutex.
+ *
+ * @param[in] p_mutex Pointer to the mutex to acquire.
+ *
+ * @retval ::NRF_SUCCESS The mutex was successfully acquired.
+ * @retval ::NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN The mutex could not be acquired.
+ */
+SVCALL(SD_MUTEX_ACQUIRE, uint32_t, sd_mutex_acquire(nrf_mutex_t * p_mutex));
+
+/**@brief Release a mutex.
+ *
+ * @param[in] p_mutex Pointer to the mutex to release.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_MUTEX_RELEASE, uint32_t, sd_mutex_release(nrf_mutex_t * p_mutex));
+
+/**@brief Query the capacity of the application random pool.
+ *
+ * @param[out] p_pool_capacity The capacity of the pool.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_RAND_APPLICATION_POOL_CAPACITY_GET, uint32_t, sd_rand_application_pool_capacity_get(uint8_t * p_pool_capacity));
+
+/**@brief Get number of random bytes available to the application.
+ *
+ * @param[out] p_bytes_available The number of bytes currently available in the pool.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_RAND_APPLICATION_BYTES_AVAILABLE_GET, uint32_t, sd_rand_application_bytes_available_get(uint8_t * p_bytes_available));
+
+/**@brief Get random bytes from the application pool.
+ *
+ * @param[out]  p_buff  Pointer to unit8_t buffer for storing the bytes.
+ * @param[in]   length  Number of bytes to take from pool and place in p_buff.
+ *
+ * @retval ::NRF_SUCCESS The requested bytes were written to p_buff.
+ * @retval ::NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES No bytes were written to the buffer, because there were not enough bytes available.
+*/
+SVCALL(SD_RAND_APPLICATION_VECTOR_GET, uint32_t, sd_rand_application_vector_get(uint8_t * p_buff, uint8_t length));
+
+/**@brief Gets the reset reason register.
+ *
+ * @param[out]  p_reset_reason  Contents of the NRF_POWER->RESETREAS register.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_POWER_RESET_REASON_GET, uint32_t, sd_power_reset_reason_get(uint32_t * p_reset_reason));
+
+/**@brief Clears the bits of the reset reason register.
+ *
+ * @param[in] reset_reason_clr_msk Contains the bits to clear from the reset reason register.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_POWER_RESET_REASON_CLR, uint32_t, sd_power_reset_reason_clr(uint32_t reset_reason_clr_msk));
+
+/**@brief Sets the power mode when in CPU sleep.
+ *
+ * @param[in] power_mode The power mode to use when in CPU sleep, see @ref NRF_POWER_MODES. @sa sd_app_evt_wait
+ *
+ * @retval ::NRF_SUCCESS The power mode was set.
+ * @retval ::NRF_ERROR_SOC_POWER_MODE_UNKNOWN The power mode was unknown.
+ */
+SVCALL(SD_POWER_MODE_SET, uint32_t, sd_power_mode_set(uint8_t power_mode));
+
+/**@brief Puts the chip in System OFF mode.
+ *
+ * @retval ::NRF_ERROR_SOC_POWER_OFF_SHOULD_NOT_RETURN
+ */
+SVCALL(SD_POWER_SYSTEM_OFF, uint32_t, sd_power_system_off(void));
+
+/**@brief Enables or disables the power-fail comparator.
+ *
+ * Enabling this will give a softdevice event (NRF_EVT_POWER_FAILURE_WARNING) when the power failure warning occurs.
+ * The event can be retrieved with sd_evt_get();
+ *
+ * @param[in] pof_enable    True if the power-fail comparator should be enabled, false if it should be disabled.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_POWER_POF_ENABLE, uint32_t, sd_power_pof_enable(uint8_t pof_enable));
+
+/**@brief Sets the power-fail threshold value.
+ *
+ * @param[in] threshold The power-fail threshold value to use, see @ref NRF_POWER_THRESHOLDS.
+ *
+ * @retval ::NRF_SUCCESS The power failure threshold was set.
+ * @retval ::NRF_ERROR_SOC_POWER_POF_THRESHOLD_UNKNOWN The power failure threshold is unknown.
+ */
+SVCALL(SD_POWER_POF_THRESHOLD_SET, uint32_t, sd_power_pof_threshold_set(uint8_t threshold));
+
+/**@brief Sets bits in the NRF_POWER->RAMON register.
+ *
+ * @param[in] ramon Contains the bits needed to be set in the NRF_POWER->RAMON register.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_POWER_RAMON_SET, uint32_t, sd_power_ramon_set(uint32_t ramon));
+
+/**@brief Clears bits in the NRF_POWER->RAMON register.
+ *
+ * @param ramon Contains the bits needed to be cleared in the NRF_POWER->RAMON register.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_POWER_RAMON_CLR, uint32_t, sd_power_ramon_clr(uint32_t ramon));
+
+/**@brief Get contents of NRF_POWER->RAMON register, indicates power status of ram blocks.
+ *
+ * @param[out] p_ramon Content of NRF_POWER->RAMON register.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_POWER_RAMON_GET, uint32_t, sd_power_ramon_get(uint32_t * p_ramon));
+
+/**@brief Set bits in the general purpose retention registers (NRF_POWER->GPREGRET*).
+ *
+ * @param[in] gpregret_id 0 for GPREGRET, 1 for GPREGRET2.
+ * @param[in] gpregret_msk Bits to be set in the GPREGRET register.
+ *
+ * @note nRF51 does only have one general purpose retained register, so gpregret_id must be 0 on nRF51.
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_POWER_GPREGRET_SET, uint32_t, sd_power_gpregret_set(uint32_t gpregret_id, uint32_t gpregret_msk));
+
+/**@brief Clear bits in the general purpose retention registers (NRF_POWER->GPREGRET*).
+ *
+ * @param[in] gpregret_id 0 for GPREGRET, 1 for GPREGRET2.
+ * @param[in] gpregret_msk Bits to be clear in the GPREGRET register.
+ *
+ * @note nRF51 does only have one general purpose retained register, so gpregret_id must be 0 on nRF51.
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_POWER_GPREGRET_CLR, uint32_t, sd_power_gpregret_clr(uint32_t gpregret_id, uint32_t gpregret_msk));
+
+/**@brief Get contents of the general purpose retention registers (NRF_POWER->GPREGRET*).
+ *
+ * @param[in] gpregret_id 0 for GPREGRET, 1 for GPREGRET2.
+ * @param[out] p_gpregret Contents of the GPREGRET register.
+ *
+ * @note nRF51 does only have one general purpose retained register, so gpregret_id must be 0 on nRF51.
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_POWER_GPREGRET_GET, uint32_t, sd_power_gpregret_get(uint32_t gpregret_id, uint32_t *p_gpregret));
+
+/**@brief Sets the DCDC mode.
+ *
+ * Enable or disable the DCDC peripheral.
+ *
+ * @param[in] dcdc_mode The mode of the DCDC, see @ref NRF_POWER_DCDC_MODES.
+ *
+ * @retval ::NRF_SUCCESS
+ * @retval ::NRF_ERROR_INVALID_PARAM The DCDC mode is invalid.
+ */
+SVCALL(SD_POWER_DCDC_MODE_SET, uint32_t, sd_power_dcdc_mode_set(uint8_t dcdc_mode));
+
+/**@brief Request the high frequency crystal oscillator.
+ *
+ * Will start the high frequency crystal oscillator, the startup time of the crystal varies
+ * and the ::sd_clock_hfclk_is_running function can be polled to check if it has started.
+ *
+ * @see sd_clock_hfclk_is_running
+ * @see sd_clock_hfclk_release
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_CLOCK_HFCLK_REQUEST, uint32_t, sd_clock_hfclk_request(void));
+
+/**@brief Releases the high frequency crystal oscillator.
+ *
+ * Will stop the high frequency crystal oscillator, this happens immediately.
+ *
+ * @see sd_clock_hfclk_is_running
+ * @see sd_clock_hfclk_request
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_CLOCK_HFCLK_RELEASE, uint32_t, sd_clock_hfclk_release(void));
+
+/**@brief Checks if the high frequency crystal oscillator is running.
+ *
+ * @see sd_clock_hfclk_request
+ * @see sd_clock_hfclk_release
+ *
+ * @param[out] p_is_running 1 if the external crystal oscillator is running, 0 if not.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_CLOCK_HFCLK_IS_RUNNING, uint32_t, sd_clock_hfclk_is_running(uint32_t * p_is_running));
+
+/**@brief Waits for an application event.
+ *
+ * An application event is either an application interrupt or a pended interrupt when the
+ * interrupt is disabled. When the interrupt is enabled it will be taken immediately since
+ * this function will wait in thread mode, then the execution will return in the application's
+ * main thread. When an interrupt is disabled and gets pended it will return to the application's
+ * thread main. The application must ensure that the pended flag is cleared using
+ * ::sd_nvic_ClearPendingIRQ in order to sleep using this function. This is only necessary for
+ * disabled interrupts, as the interrupt handler will clear the pending flag automatically for
+ * enabled interrupts.
+ *
+ * In order to wake up from disabled interrupts, the SEVONPEND flag has to be set in the Cortex-M0
+ * System Control Register (SCR). @sa CMSIS_SCB
+ *
+ * @note If an application interrupt has happened since the last time sd_app_evt_wait was
+ *       called this function will return immediately and not go to sleep. This is to avoid race
+ *       conditions that can occur when a flag is updated in the interrupt handler and processed
+ *       in the main loop.
+ *
+ * @post An application interrupt has happened or a interrupt pending flag is set.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_APP_EVT_WAIT, uint32_t, sd_app_evt_wait(void));
+
+/**@brief Get PPI channel enable register contents.
+ *
+ * @param[out] p_channel_enable The contents of the PPI CHEN register.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_PPI_CHANNEL_ENABLE_GET, uint32_t, sd_ppi_channel_enable_get(uint32_t * p_channel_enable));
+
+/**@brief Set PPI channel enable register.
+ *
+ * @param[in] channel_enable_set_msk Mask containing the bits to set in the PPI CHEN register.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_PPI_CHANNEL_ENABLE_SET, uint32_t, sd_ppi_channel_enable_set(uint32_t channel_enable_set_msk));
+
+/**@brief Clear PPI channel enable register.
+ *
+ * @param[in] channel_enable_clr_msk Mask containing the bits to clear in the PPI CHEN register.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_PPI_CHANNEL_ENABLE_CLR, uint32_t, sd_ppi_channel_enable_clr(uint32_t channel_enable_clr_msk));
+
+/**@brief Assign endpoints to a PPI channel.
+ *
+ * @param[in] channel_num Number of the PPI channel to assign.
+ * @param[in] evt_endpoint Event endpoint of the PPI channel.
+ * @param[in] task_endpoint Task endpoint of the PPI channel.
+ *
+ * @retval ::NRF_ERROR_SOC_PPI_INVALID_CHANNEL The channel number is invalid.
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_PPI_CHANNEL_ASSIGN, uint32_t, sd_ppi_channel_assign(uint8_t channel_num, const volatile void * evt_endpoint, const volatile void * task_endpoint));
+
+/**@brief Task to enable a channel group.
+ *
+ * @param[in] group_num Number of the channel group.
+ *
+ * @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_PPI_GROUP_TASK_ENABLE, uint32_t, sd_ppi_group_task_enable(uint8_t group_num));
+
+/**@brief Task to disable a channel group.
+ *
+ * @param[in] group_num Number of the PPI group.
+ *
+ * @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid.
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_PPI_GROUP_TASK_DISABLE, uint32_t, sd_ppi_group_task_disable(uint8_t group_num));
+
+/**@brief Assign PPI channels to a channel group.
+ *
+ * @param[in] group_num Number of the channel group.
+ * @param[in] channel_msk Mask of the channels to assign to the group.
+ *
+ * @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid.
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_PPI_GROUP_ASSIGN, uint32_t, sd_ppi_group_assign(uint8_t group_num, uint32_t channel_msk));
+
+/**@brief Gets the PPI channels of a channel group.
+ *
+ * @param[in]   group_num Number of the channel group.
+ * @param[out]  p_channel_msk Mask of the channels assigned to the group.
+ *
+ * @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid.
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_PPI_GROUP_GET, uint32_t, sd_ppi_group_get(uint8_t group_num, uint32_t * p_channel_msk));
+
+/**@brief Configures the Radio Notification signal.
+ *
+ * @note
+ *      - The notification signal latency depends on the interrupt priority settings of SWI used
+ *        for notification signal.
+ *      - To ensure that the radio notification signal behaves in a consistent way, always
+ *        configure radio notifications when there is no protocol stack or other SoftDevice
+ *        activity in progress. It is recommended that the radio notification signal is
+ *        configured directly after the SoftDevice has been enabled.
+ *      - In the period between the ACTIVE signal and the start of the Radio Event, the SoftDevice
+ *        will interrupt the application to do Radio Event preparation.
+ *      - Using the Radio Notification feature may limit the bandwidth, as the SoftDevice may have
+ *        to shorten the connection events to have time for the Radio Notification signals.
+ *
+ * @param[in]  type      Type of notification signal, see @ref NRF_RADIO_NOTIFICATION_TYPES.
+ *                       @ref NRF_RADIO_NOTIFICATION_TYPE_NONE shall be used to turn off radio
+ *                       notification. Using @ref NRF_RADIO_NOTIFICATION_DISTANCE_NONE is
+ *                       recommended (but not required) to be used with
+ *                       @ref NRF_RADIO_NOTIFICATION_TYPE_NONE.
+ *
+ * @param[in]  distance  Distance between the notification signal and start of radio activity, see @ref NRF_RADIO_NOTIFICATION_DISTANCES.
+ *                       This parameter is ignored when @ref NRF_RADIO_NOTIFICATION_TYPE_NONE or
+ *                       @ref NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE is used.
+ *
+ * @retval ::NRF_ERROR_INVALID_PARAM The group number is invalid.
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_RADIO_NOTIFICATION_CFG_SET, uint32_t, sd_radio_notification_cfg_set(uint8_t type, uint8_t distance));
+
+/**@brief Encrypts a block according to the specified parameters.
+ *
+ * 128-bit AES encryption.
+ *
+ * @note:
+ *    - The application may set the SEVONPEND bit in the SCR to 1 to make the SoftDevice sleep while
+ *      the ECB is running. The SEVONPEND bit should only be cleared (set to 0) from application
+ *      main or low interrupt level.
+ *
+ * @param[in, out] p_ecb_data Pointer to the ECB parameters' struct (two input
+ *                            parameters and one output parameter).
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_ECB_BLOCK_ENCRYPT, uint32_t, sd_ecb_block_encrypt(nrf_ecb_hal_data_t * p_ecb_data));
+
+/**@brief Encrypts multiple data blocks provided as an array of data block structures.
+ *
+ * @details: Performs 128-bit AES encryption on multiple data blocks
+ *
+ * @note:
+ *    - The application may set the SEVONPEND bit in the SCR to 1 to make the SoftDevice sleep while
+ *      the ECB is running. The SEVONPEND bit should only be cleared (set to 0) from application
+ *      main or low interrupt level.
+ *
+ * @param[in]     block_count     Count of blocks in the p_data_blocks array.
+ * @param[in,out] p_data_blocks   Pointer to the first entry in a contiguous array of
+ *                                @ref nrf_ecb_hal_data_block_t structures.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+SVCALL(SD_ECB_BLOCKS_ENCRYPT, uint32_t, sd_ecb_blocks_encrypt(uint8_t block_count, nrf_ecb_hal_data_block_t * p_data_blocks));
+
+/**@brief Gets any pending events generated by the SoC API.
+ *
+ * The application should keep calling this function to get events, until ::NRF_ERROR_NOT_FOUND is returned.
+ *
+ * @param[out] p_evt_id Set to one of the values in @ref NRF_SOC_EVTS, if any events are pending.
+ *
+ * @retval ::NRF_SUCCESS An event was pending. The event id is written in the p_evt_id parameter.
+ * @retval ::NRF_ERROR_NOT_FOUND No pending events.
+ */
+SVCALL(SD_EVT_GET, uint32_t, sd_evt_get(uint32_t * p_evt_id));
+
+/**@brief Get the temperature measured on the chip
+ *
+ * This function will block until the temperature measurement is done.
+ * It takes around 50us from call to return.
+ *
+ * @param[out] p_temp Result of temperature measurement. Die temperature in 0.25 degrees celsius.
+ *
+ * @retval ::NRF_SUCCESS A temperature measurement was done, and the temperature was written to temp
+ */
+SVCALL(SD_TEMP_GET, uint32_t, sd_temp_get(int32_t * p_temp));
+
+/**@brief Flash Write
+*
+* Commands to write a buffer to flash
+*
+* If the SoftDevice is enabled:
+*  This call initiates the flash access command, and its completion will be communicated to the
+*  application with exactly one of the following events:
+*      - @ref NRF_EVT_FLASH_OPERATION_SUCCESS - The command was successfully completed.
+*      - @ref NRF_EVT_FLASH_OPERATION_ERROR   - The command could not be started.
+*
+* If the SoftDevice is not enabled no event will be generated, and this call will return @ref NRF_SUCCESS when the
+ * write has been completed
+*
+* @note
+*      - This call takes control over the radio and the CPU during flash erase and write to make sure that
+*        they will not interfere with the flash access. This means that all interrupts will be blocked
+*        for a predictable time (depending on the NVMC specification in nRF51 Series Reference Manual
+*        and the command parameters).
+*      - The data in the p_src buffer should not be modified before the @ref NRF_EVT_FLASH_OPERATION_SUCCESS
+*        or the @ref NRF_EVT_FLASH_OPERATION_ERROR have been received if the SoftDevice is enabled.
+*
+*
+* @param[in]  p_dst Pointer to start of flash location to be written.
+* @param[in]  p_src Pointer to buffer with data to be written.
+* @param[in]  size  Number of 32-bit words to write. Maximum size is 256 32-bit words for nRF51 and 1024 for nRF52.
+*
+* @retval ::NRF_ERROR_INVALID_ADDR   Tried to write to a non existing flash address, or p_dst or p_src was unaligned.
+* @retval ::NRF_ERROR_BUSY           The previous command has not yet completed.
+* @retval ::NRF_ERROR_INVALID_LENGTH Size was 0, or higher than the maximum allowed size.
+* @retval ::NRF_ERROR_FORBIDDEN      Tried to write to or read from protected location.
+* @retval ::NRF_SUCCESS              The command was accepted.
+*/
+SVCALL(SD_FLASH_WRITE, uint32_t, sd_flash_write(uint32_t * const p_dst, uint32_t const * const p_src, uint32_t size));
+
+
+/**@brief Flash Erase page
+*
+* Commands to erase a flash page
+* If the SoftDevice is enabled:
+*  This call initiates the flash access command, and its completion will be communicated to the
+*  application with exactly one of the following events:
+*      - @ref NRF_EVT_FLASH_OPERATION_SUCCESS - The command was successfully completed.
+*      - @ref NRF_EVT_FLASH_OPERATION_ERROR   - The command could not be started.
+*
+* If the SoftDevice is not enabled no event will be generated, and this call will return @ref NRF_SUCCESS when the
+* erase has been completed
+*
+* @note
+*      - This call takes control over the radio and the CPU during flash erase and write to make sure that
+*        they will not interfere with the flash access. This means that all interrupts will be blocked
+*        for a predictable time (depending on the NVMC specification in nRF51 Series Reference Manual
+*        and the command parameters).
+*
+*
+* @param[in]  page_number Pagenumber of the page to erase
+* @retval ::NRF_ERROR_INTERNAL      If a new session could not be opened due to an internal error.
+* @retval ::NRF_ERROR_INVALID_ADDR  Tried to erase to a non existing flash page.
+* @retval ::NRF_ERROR_BUSY          The previous command has not yet completed.
+* @retval ::NRF_ERROR_FORBIDDEN     Tried to erase a protected page.
+* @retval ::NRF_SUCCESS             The command was accepted.
+*/
+SVCALL(SD_FLASH_PAGE_ERASE, uint32_t, sd_flash_page_erase(uint32_t page_number));
+
+
+/**@brief Flash Protection set
+ *
+ * Commands to set the flash protection configuration registers.
+   On nRF51 this sets the PROTENSETx registers of the MPU peripheral.
+   On nRF52 this sets the CONFIGx registers of the BPROT peripheral.
+ *
+ * @note To read the values read them directly. They are only write-protected.
+ *
+ * @param[in]  block_cfg0 Value to be written to the configuration register.
+ * @param[in]  block_cfg1 Value to be written to the configuration register.
+ * @param[in]  block_cfg2 Value to be written to the configuration register (ignored on nRF51).
+ * @param[in]  block_cfg3 Value to be written to the configuration register (ignored on nRF51).
+ *
+ * @retval ::NRF_ERROR_FORBIDDEN Tried to protect the SoftDevice.
+ * @retval ::NRF_SUCCESS Values successfully written to configuration registers.
+ */
+SVCALL(SD_FLASH_PROTECT, uint32_t, sd_flash_protect(uint32_t block_cfg0, uint32_t block_cfg1, uint32_t block_cfg2, uint32_t block_cfg3));
+
+/**@brief Opens a session for radio timeslot requests.
+ *
+ * @note Only one session can be open at a time.
+ * @note p_radio_signal_callback(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START) will be called when the radio timeslot
+ *       starts. From this point the NRF_RADIO and NRF_TIMER0 peripherals can be freely accessed
+ *       by the application.
+ * @note p_radio_signal_callback(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_TIMER0) is called whenever the NRF_TIMER0
+ *       interrupt occurs.
+ * @note p_radio_signal_callback(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_RADIO) is called whenever the NRF_RADIO
+ *       interrupt occurs.
+ * @note p_radio_signal_callback() will be called at ARM interrupt priority level 0. This
+ *       implies that none of the sd_* API calls can be used from p_radio_signal_callback().
+ *
+ * @param[in] p_radio_signal_callback The signal callback.
+ *
+ * @retval ::NRF_ERROR_INVALID_ADDR p_radio_signal_callback is an invalid function pointer.
+ * @retval ::NRF_ERROR_BUSY If session cannot be opened.
+ * @retval ::NRF_ERROR_INTERNAL If a new session could not be opened due to an internal error.
+ * @retval ::NRF_SUCCESS Otherwise.
+ */
+ SVCALL(SD_RADIO_SESSION_OPEN, uint32_t, sd_radio_session_open(nrf_radio_signal_callback_t p_radio_signal_callback));
+
+/**@brief Closes a session for radio timeslot requests.
+ *
+ * @note Any current radio timeslot will be finished before the session is closed.
+ * @note If a radio timeslot is scheduled when the session is closed, it will be canceled.
+ * @note The application cannot consider the session closed until the @ref NRF_EVT_RADIO_SESSION_CLOSED
+ *       event is received.
+ *
+ * @retval ::NRF_ERROR_FORBIDDEN If session not opened.
+ * @retval ::NRF_ERROR_BUSY If session is currently being closed.
+ * @retval ::NRF_SUCCESS Otherwise.
+ */
+ SVCALL(SD_RADIO_SESSION_CLOSE, uint32_t, sd_radio_session_close(void));
+
+/**@brief Requests a radio timeslot.
+ *
+ * @note The request type is determined by p_request->request_type, and can be one of @ref NRF_RADIO_REQ_TYPE_EARLIEST
+ *       and @ref NRF_RADIO_REQ_TYPE_NORMAL. The first request in a session must always be of type @ref NRF_RADIO_REQ_TYPE_EARLIEST.
+ * @note For a normal request (@ref NRF_RADIO_REQ_TYPE_NORMAL), the start time of a radio timeslot is specified by
+ *       p_request->distance_us and is given relative to the start of the previous timeslot.
+ * @note A too small p_request->distance_us will lead to a @ref NRF_EVT_RADIO_BLOCKED event.
+ * @note Timeslots scheduled too close will lead to a @ref NRF_EVT_RADIO_BLOCKED event.
+ * @note See the SoftDevice Specification for more on radio timeslot scheduling, distances and lengths.
+ * @note If an opportunity for the first radio timeslot is not found before 100ms after the call to this
+ *       function, it is not scheduled, and instead a @ref NRF_EVT_RADIO_BLOCKED event is sent.
+ *       The application may then try to schedule the first radio timeslot again.
+ * @note Successful requests will result in nrf_radio_signal_callback_t(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START).
+ *       Unsuccessful requests will result in a @ref NRF_EVT_RADIO_BLOCKED event, see @ref NRF_SOC_EVTS.
+ * @note The jitter in the start time of the radio timeslots is +/- @ref NRF_RADIO_START_JITTER_US us.
+ * @note The nrf_radio_signal_callback_t(@ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START) call has a latency relative to the
+ *       specified radio timeslot start, but this does not affect the actual start time of the timeslot.
+ * @note NRF_TIMER0 is reset at the start of the radio timeslot, and is clocked at 1MHz from the high frequency
+ *       (16 MHz) clock source. If p_request->hfclk_force_xtal is true, the high frequency clock is
+ *       guaranteed to be clocked from the external crystal.
+ * @note The SoftDevice will neither access the NRF_RADIO peripheral nor the NRF_TIMER0 peripheral
+ *       during the radio timeslot.
+ *
+ * @param[in] p_request Pointer to the request parameters.
+ *
+ * @retval ::NRF_ERROR_FORBIDDEN If session not opened or the session is not IDLE.
+ * @retval ::NRF_ERROR_INVALID_ADDR If the p_request pointer is invalid.
+ * @retval ::NRF_ERROR_INVALID_PARAM If the parameters of p_request are not valid.
+ * @retval ::NRF_SUCCESS Otherwise.
+ */
+ SVCALL(SD_RADIO_REQUEST, uint32_t, sd_radio_request(nrf_radio_request_t * p_request ));
+
+/**@} */
+
+#ifdef __cplusplus
+}
+#endif
+#endif // NRF_SOC_H__
+
+/**@} */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf_svc.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf_svc.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers/nrf_svc.h    1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers/nrf_svc.h 2018-04-24 08:48:29.048155900 +0200
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef NRF_SVC__
+#define NRF_SVC__
+
+#include "stdint.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef SVCALL_AS_NORMAL_FUNCTION
+#define SVCALL(number, return_type, signature) return_type signature
+#else
+
+#ifndef SVCALL
+#if defined (__CC_ARM)
+#define SVCALL(number, return_type, signature) return_type __svc(number) signature
+#elif defined (__GNUC__)
+#ifdef __cplusplus
+#define GCC_CAST_CPP (uint8_t)
+#else
+#define GCC_CAST_CPP
+#endif
+#define SVCALL(number, return_type, signature)          \
+  _Pragma("GCC diagnostic push")                        \
+  _Pragma("GCC diagnostic ignored \"-Wreturn-type\"")   \
+  __attribute__((naked))                                \
+  __attribute__((unused))                               \
+  static return_type signature                          \
+  {                                                     \
+    __asm(                                              \
+        "svc %0\n"                                      \
+        "bx r14" : : "I" (GCC_CAST_CPP number) : "r0"   \
+    );                                                  \
+  }                                                     \
+  _Pragma("GCC diagnostic pop")
+
+#elif defined (__ICCARM__)
+#define PRAGMA(x) _Pragma(#x)
+#define SVCALL(number, return_type, signature)          \
+PRAGMA(swi_number = (number))                           \
+ __swi return_type signature;
+#else
+#define SVCALL(number, return_type, signature) return_type signature
+#endif
+#endif  // SVCALL
+
+#endif  // SVCALL_AS_NORMAL_FUNCTION
+
+#ifdef __cplusplus
+}
+#endif
+#endif  // NRF_SVC__
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers_replacement/ble_gap.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers_replacement/ble_gap.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers_replacement/ble_gap.h    1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers_replacement/ble_gap.h 2018-04-24 08:48:29.058156100 +0200
@@ -0,0 +1,1919 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @addtogroup BLE_GAP Generic Access Profile (GAP)
+  @{
+  @brief Definitions and prototypes for the GAP interface.
+ */
+
+#ifndef BLE_GAP_H__
+#define BLE_GAP_H__
+
+#include "ble_types.h"
+#include "ble_ranges.h"
+#include "nrf_svc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**@addtogroup BLE_GAP_ENUMERATIONS Enumerations
+ * @{ */
+
+/**@brief GAP API SVC numbers.
+ */
+enum BLE_GAP_SVCS
+{
+  SD_BLE_GAP_ADDR_SET = BLE_GAP_SVC_BASE,       /**< Set own Bluetooth Address. */
+  SD_BLE_GAP_ADDR_GET,                          /**< Get own Bluetooth Address. */
+  SD_BLE_GAP_WHITELIST_SET,                     /**< Set active whitelist. */
+  SD_BLE_GAP_DEVICE_IDENTITIES_SET,             /**< Set device identity list. */
+  SD_BLE_GAP_PRIVACY_SET,                       /**< Set Privacy settings*/
+  SD_BLE_GAP_PRIVACY_GET,                       /**< Get Privacy settings*/
+  SD_BLE_GAP_ADV_DATA_SET,                      /**< Set Advertising Data. */
+  SD_BLE_GAP_ADV_START,                         /**< Start Advertising. */
+  SD_BLE_GAP_ADV_STOP,                          /**< Stop Advertising. */
+  SD_BLE_GAP_CONN_PARAM_UPDATE,                 /**< Connection Parameter Update. */
+  SD_BLE_GAP_DISCONNECT,                        /**< Disconnect. */
+  SD_BLE_GAP_TX_POWER_SET,                      /**< Set TX Power. */
+  SD_BLE_GAP_APPEARANCE_SET,                    /**< Set Appearance. */
+  SD_BLE_GAP_APPEARANCE_GET,                    /**< Get Appearance. */
+  SD_BLE_GAP_PPCP_SET,                          /**< Set PPCP. */
+  SD_BLE_GAP_PPCP_GET,                          /**< Get PPCP. */
+  SD_BLE_GAP_DEVICE_NAME_SET,                   /**< Set Device Name. */
+  SD_BLE_GAP_DEVICE_NAME_GET,                   /**< Get Device Name. */
+  SD_BLE_GAP_AUTHENTICATE,                      /**< Initiate Pairing/Bonding. */
+  SD_BLE_GAP_SEC_PARAMS_REPLY,                  /**< Reply with Security Parameters. */
+  SD_BLE_GAP_AUTH_KEY_REPLY,                    /**< Reply with an authentication key. */
+  SD_BLE_GAP_LESC_DHKEY_REPLY,                  /**< Reply with an LE Secure Connections DHKey. */
+  SD_BLE_GAP_KEYPRESS_NOTIFY,                   /**< Notify of a keypress during an authentication procedure. */
+  SD_BLE_GAP_LESC_OOB_DATA_GET,                 /**< Get the local LE Secure Connections OOB data. */
+  SD_BLE_GAP_LESC_OOB_DATA_SET,                 /**< Set the remote LE Secure Connections OOB data. */
+  SD_BLE_GAP_ENCRYPT,                           /**< Initiate encryption procedure. */
+  SD_BLE_GAP_SEC_INFO_REPLY,                    /**< Reply with Security Information. */
+  SD_BLE_GAP_CONN_SEC_GET,                      /**< Obtain connection security level. */
+  SD_BLE_GAP_RSSI_START,                        /**< Start reporting of changes in RSSI. */
+  SD_BLE_GAP_RSSI_STOP,                         /**< Stop reporting of changes in RSSI. */
+  SD_BLE_GAP_SCAN_START,                        /**< Start Scanning. */
+  SD_BLE_GAP_SCAN_STOP,                         /**< Stop Scanning. */
+  SD_BLE_GAP_CONNECT,                           /**< Connect. */
+  SD_BLE_GAP_CONNECT_CANCEL,                    /**< Cancel ongoing connection procedure. */
+  SD_BLE_GAP_RSSI_GET,                          /**< Get the last RSSI sample. */
+};
+
+/**@brief GAP Event IDs.
+ * IDs that uniquely identify an event coming from the stack to the application.
+ */
+enum BLE_GAP_EVTS
+{
+  BLE_GAP_EVT_CONNECTED  = BLE_GAP_EVT_BASE,    /**< Connection established.                         \n See @ref ble_gap_evt_connected_t.            */
+  BLE_GAP_EVT_DISCONNECTED,                     /**< Disconnected from peer.                         \n See @ref ble_gap_evt_disconnected_t.         */
+  BLE_GAP_EVT_CONN_PARAM_UPDATE,                /**< Connection Parameters updated.                  \n See @ref ble_gap_evt_conn_param_update_t.    */
+  BLE_GAP_EVT_SEC_PARAMS_REQUEST,               /**< Request to provide security parameters.         \n Reply with @ref sd_ble_gap_sec_params_reply.  \n See @ref ble_gap_evt_sec_params_request_t. */
+  BLE_GAP_EVT_SEC_INFO_REQUEST,                 /**< Request to provide security information.        \n Reply with @ref sd_ble_gap_sec_info_reply.    \n See @ref ble_gap_evt_sec_info_request_t.   */
+  BLE_GAP_EVT_PASSKEY_DISPLAY,                  /**< Request to display a passkey to the user.       \n In LESC Numeric Comparison, reply with @ref sd_ble_gap_auth_key_reply. \n See @ref ble_gap_evt_passkey_display_t. */
+  BLE_GAP_EVT_KEY_PRESSED,                      /**< Notification of a keypress on the remote device.\n See @ref ble_gap_evt_key_pressed_t           */
+  BLE_GAP_EVT_AUTH_KEY_REQUEST,                 /**< Request to provide an authentication key.       \n Reply with @ref sd_ble_gap_auth_key_reply.    \n See @ref ble_gap_evt_auth_key_request_t.   */
+  BLE_GAP_EVT_LESC_DHKEY_REQUEST,               /**< Request to calculate an LE Secure Connections DHKey. \n Reply with @ref sd_ble_gap_lesc_dhkey_reply.  \n See @ref ble_gap_evt_lesc_dhkey_request_t */
+  BLE_GAP_EVT_AUTH_STATUS,                      /**< Authentication procedure completed with status. \n See @ref ble_gap_evt_auth_status_t.          */
+  BLE_GAP_EVT_CONN_SEC_UPDATE,                  /**< Connection security updated.                    \n See @ref ble_gap_evt_conn_sec_update_t.      */
+  BLE_GAP_EVT_TIMEOUT,                          /**< Timeout expired.                                \n See @ref ble_gap_evt_timeout_t.              */
+  BLE_GAP_EVT_RSSI_CHANGED,                     /**< RSSI report.                                    \n See @ref ble_gap_evt_rssi_changed_t.         */
+  BLE_GAP_EVT_ADV_REPORT,                       /**< Advertising report.                             \n See @ref ble_gap_evt_adv_report_t.           */
+  BLE_GAP_EVT_SEC_REQUEST,                      /**< Security Request.                               \n See @ref ble_gap_evt_sec_request_t.          */
+  BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST,        /**< Connection Parameter Update Request.            \n Reply with @ref sd_ble_gap_conn_param_update. \n See @ref ble_gap_evt_conn_param_update_request_t. */
+  BLE_GAP_EVT_SCAN_REQ_REPORT,                  /**< Scan request report.                            \n See @ref ble_gap_evt_scan_req_report_t.      */
+};
+
+/**@brief GAP Option IDs.
+ * IDs that uniquely identify a GAP option.
+ */
+enum BLE_GAP_OPTS
+{
+  BLE_GAP_OPT_CH_MAP  = BLE_GAP_OPT_BASE,       /**< Channel Map. @ref ble_gap_opt_ch_map_t  */
+  BLE_GAP_OPT_LOCAL_CONN_LATENCY,               /**< Local connection latency. @ref ble_gap_opt_local_conn_latency_t */
+  BLE_GAP_OPT_PASSKEY,                          /**< Set passkey. @ref ble_gap_opt_passkey_t */
+  BLE_GAP_OPT_SCAN_REQ_REPORT,                  /**< Scan request report. @ref ble_gap_opt_scan_req_report_t */
+  BLE_GAP_OPT_COMPAT_MODE,                      /**< Compatibility mode. @ref ble_gap_opt_compat_mode_t */
+  BLE_GAP_OPT_AUTH_PAYLOAD_TIMEOUT,             /**< Set Authenticated payload timeout. @ref ble_gap_opt_auth_payload_timeout_t */
+  BLE_GAP_OPT_EXT_LEN,                          /**< Extended length packets. @ref ble_gap_opt_ext_len_t */
+};
+
+/** @} */
+
+/**@addtogroup BLE_GAP_DEFINES Defines
+ * @{ */
+
+/**@defgroup BLE_ERRORS_GAP SVC return values specific to GAP
+ * @{ */
+#define BLE_ERROR_GAP_UUID_LIST_MISMATCH            (NRF_GAP_ERR_BASE + 0x000)  /**< UUID list does not contain an integral number of UUIDs. */
+#define BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST   (NRF_GAP_ERR_BASE + 0x001)  /**< Use of Whitelist not permitted with discoverable advertising. */
+#define BLE_ERROR_GAP_INVALID_BLE_ADDR              (NRF_GAP_ERR_BASE + 0x002)  /**< The upper two bits of the address do not correspond to the specified address type. */
+#define BLE_ERROR_GAP_WHITELIST_IN_USE              (NRF_GAP_ERR_BASE + 0x003)  /**< Attempt to modify the whitelist while already in use by another operation. */
+#define BLE_ERROR_GAP_DEVICE_IDENTITIES_IN_USE      (NRF_GAP_ERR_BASE + 0x004)  /**< Attempt to modify the device identity list while already in use by another operation. */
+#define BLE_ERROR_GAP_DEVICE_IDENTITIES_DUPLICATE   (NRF_GAP_ERR_BASE + 0x005)  /**< The device identity list contains entries with duplicate identity addresses. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_ROLES GAP Roles
+ * @note Not explicitly used in peripheral API, but will be relevant for central API.
+ * @{ */
+#define BLE_GAP_ROLE_INVALID     0x0            /**< Invalid Role. */
+#define BLE_GAP_ROLE_PERIPH      0x1            /**< Peripheral Role. */
+#define BLE_GAP_ROLE_CENTRAL     0x2            /**< Central Role. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_TIMEOUT_SOURCES GAP Timeout sources
+ * @{ */
+#define BLE_GAP_TIMEOUT_SRC_ADVERTISING                0x00 /**< Advertising timeout. */
+#define BLE_GAP_TIMEOUT_SRC_SECURITY_REQUEST           0x01 /**< Security request timeout. */
+#define BLE_GAP_TIMEOUT_SRC_SCAN                       0x02 /**< Scanning timeout. */
+#define BLE_GAP_TIMEOUT_SRC_CONN                       0x03 /**< Connection timeout. */
+#define BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD               0x04 /**< Authenticated payload timeout. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_ADDR_TYPES GAP Address types
+ * @{ */
+#define BLE_GAP_ADDR_TYPE_PUBLIC                        0x00 /**< Public address. */
+#define BLE_GAP_ADDR_TYPE_RANDOM_STATIC                 0x01 /**< Random static address. */
+#define BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE     0x02 /**< Random private resolvable address. */
+#define BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE 0x03 /**< Random private non-resolvable address. */
+/**@} */
+
+
+/**@brief The default interval in seconds at which a private address is refreshed.  */
+#define BLE_GAP_DEFAULT_PRIVATE_ADDR_CYCLE_INTERVAL_S (900) /* 15 minutes. */
+/**@brief The maximum interval in seconds at which a private address can be refreshed.  */
+#define BLE_GAP_MAX_PRIVATE_ADDR_CYCLE_INTERVAL_S     (41400) /* 11 hours 30 minutes. */
+
+
+/** @brief BLE address length. */
+#define BLE_GAP_ADDR_LEN (6)
+
+
+/**@defgroup BLE_GAP_PRIVACY_MODES Privacy modes
+ * @{ */
+#define BLE_GAP_PRIVACY_MODE_OFF                       0x00 /**< Device will send and accept its identity address for its own address. */
+#define BLE_GAP_PRIVACY_MODE_DEVICE_PRIVACY            0x01 /**< Device will send and accept only private addresses for its own address. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_AD_TYPE_DEFINITIONS GAP Advertising and Scan Response Data format
+ * @note Found at https://www.bluetooth.org/Technical/AssignedNumbers/generic_access_profile.htm
+ * @{ */
+#define BLE_GAP_AD_TYPE_FLAGS                               0x01 /**< Flags for discoverability. */
+#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE   0x02 /**< Partial list of 16 bit service UUIDs. */
+#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE         0x03 /**< Complete list of 16 bit service UUIDs. */
+#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_MORE_AVAILABLE   0x04 /**< Partial list of 32 bit service UUIDs. */
+#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_COMPLETE         0x05 /**< Complete list of 32 bit service UUIDs. */
+#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE  0x06 /**< Partial list of 128 bit service UUIDs. */
+#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE        0x07 /**< Complete list of 128 bit service UUIDs. */
+#define BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME                    0x08 /**< Short local device name. */
+#define BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME                 0x09 /**< Complete local device name. */
+#define BLE_GAP_AD_TYPE_TX_POWER_LEVEL                      0x0A /**< Transmit power level. */
+#define BLE_GAP_AD_TYPE_CLASS_OF_DEVICE                     0x0D /**< Class of device. */
+#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C               0x0E /**< Simple Pairing Hash C. */
+#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R         0x0F /**< Simple Pairing Randomizer R. */
+#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_TK_VALUE           0x10 /**< Security Manager TK Value. */
+#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_OOB_FLAGS          0x11 /**< Security Manager Out Of Band Flags. */
+#define BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE     0x12 /**< Slave Connection Interval Range. */
+#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT       0x14 /**< List of 16-bit Service Solicitation UUIDs. */
+#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT      0x15 /**< List of 128-bit Service Solicitation UUIDs. */
+#define BLE_GAP_AD_TYPE_SERVICE_DATA                        0x16 /**< Service Data - 16-bit UUID. */
+#define BLE_GAP_AD_TYPE_PUBLIC_TARGET_ADDRESS               0x17 /**< Public Target Address. */
+#define BLE_GAP_AD_TYPE_RANDOM_TARGET_ADDRESS               0x18 /**< Random Target Address. */
+#define BLE_GAP_AD_TYPE_APPEARANCE                          0x19 /**< Appearance. */
+#define BLE_GAP_AD_TYPE_ADVERTISING_INTERVAL                0x1A /**< Advertising Interval. */
+#define BLE_GAP_AD_TYPE_LE_BLUETOOTH_DEVICE_ADDRESS         0x1B /**< LE Bluetooth Device Address. */
+#define BLE_GAP_AD_TYPE_LE_ROLE                             0x1C /**< LE Role. */
+#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C256            0x1D /**< Simple Pairing Hash C-256. */
+#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R256      0x1E /**< Simple Pairing Randomizer R-256. */
+#define BLE_GAP_AD_TYPE_SERVICE_DATA_32BIT_UUID             0x20 /**< Service Data - 32-bit UUID. */
+#define BLE_GAP_AD_TYPE_SERVICE_DATA_128BIT_UUID            0x21 /**< Service Data - 128-bit UUID. */
+#define BLE_GAP_AD_TYPE_URI                                 0x24 /**< URI */
+#define BLE_GAP_AD_TYPE_3D_INFORMATION_DATA                 0x3D /**< 3D Information Data. */
+#define BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA          0xFF /**< Manufacturer Specific Data. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_ADV_FLAGS GAP Advertisement Flags
+ * @{ */
+#define BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE         (0x01)   /**< LE Limited Discoverable Mode. */
+#define BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE         (0x02)   /**< LE General Discoverable Mode. */
+#define BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED         (0x04)   /**< BR/EDR not supported. */
+#define BLE_GAP_ADV_FLAG_LE_BR_EDR_CONTROLLER         (0x08)   /**< Simultaneous LE and BR/EDR, Controller. */
+#define BLE_GAP_ADV_FLAG_LE_BR_EDR_HOST               (0x10)   /**< Simultaneous LE and BR/EDR, Host. */
+#define BLE_GAP_ADV_FLAGS_LE_ONLY_LIMITED_DISC_MODE   (BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)   /**< LE Limited Discoverable Mode, BR/EDR not supported. */
+#define BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE   (BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)   /**< LE General Discoverable Mode, BR/EDR not supported. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_ADV_INTERVALS GAP Advertising interval max and min
+ * @{ */
+#define BLE_GAP_ADV_INTERVAL_MIN        0x0020 /**< Minimum Advertising interval in 625 us units, i.e. 20 ms. */
+#define BLE_GAP_ADV_NONCON_INTERVAL_MIN 0x00A0 /**< Minimum Advertising interval in 625 us units for non connectable mode, i.e. 100 ms. */
+#define BLE_GAP_ADV_INTERVAL_MAX        0x4000 /**< Maximum Advertising interval in 625 us units, i.e. 10.24 s. */
+ /**@}  */
+
+
+/**@defgroup BLE_GAP_SCAN_INTERVALS GAP Scan interval max and min
+ * @{ */
+#define BLE_GAP_SCAN_INTERVAL_MIN       0x0004 /**< Minimum Scan interval in 625 us units, i.e. 2.5 ms. */
+#define BLE_GAP_SCAN_INTERVAL_MAX       0x4000 /**< Maximum Scan interval in 625 us units, i.e. 10.24 s. */
+ /** @}  */
+
+
+/**@defgroup BLE_GAP_SCAN_WINDOW GAP Scan window max and min
+ * @{ */
+#define BLE_GAP_SCAN_WINDOW_MIN         0x0004 /**< Minimum Scan window in 625 us units, i.e. 2.5 ms. */
+#define BLE_GAP_SCAN_WINDOW_MAX         0x4000 /**< Maximum Scan window in 625 us units, i.e. 10.24 s. */
+ /** @}  */
+
+
+/**@defgroup BLE_GAP_SCAN_TIMEOUT GAP Scan timeout max and min
+ * @{ */
+#define BLE_GAP_SCAN_TIMEOUT_MIN        0x0001 /**< Minimum Scan timeout in seconds. */
+#define BLE_GAP_SCAN_TIMEOUT_MAX        0xFFFF /**< Maximum Scan timeout in seconds. */
+ /** @}  */
+
+
+/**@brief Maximum size of advertising data in octets. */
+#define BLE_GAP_ADV_MAX_SIZE            (31)
+
+
+/**@defgroup BLE_GAP_ADV_TYPES GAP Advertising types
+ * @{ */
+#define BLE_GAP_ADV_TYPE_ADV_IND          0x00   /**< Connectable undirected. */
+#define BLE_GAP_ADV_TYPE_ADV_DIRECT_IND   0x01   /**< Connectable directed. */
+#define BLE_GAP_ADV_TYPE_ADV_SCAN_IND     0x02   /**< Scannable undirected. */
+#define BLE_GAP_ADV_TYPE_ADV_NONCONN_IND  0x03   /**< Non connectable undirected. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_ADV_FILTER_POLICIES GAP Advertising filter policies
+ * @{ */
+#define BLE_GAP_ADV_FP_ANY                0x00   /**< Allow scan requests and connect requests from any device. */
+#define BLE_GAP_ADV_FP_FILTER_SCANREQ     0x01   /**< Filter scan requests with whitelist. */
+#define BLE_GAP_ADV_FP_FILTER_CONNREQ     0x02   /**< Filter connect requests with whitelist. */
+#define BLE_GAP_ADV_FP_FILTER_BOTH        0x03   /**< Filter both scan and connect requests with whitelist. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_ADV_TIMEOUT_VALUES GAP Advertising timeout values
+ * @{ */
+#define BLE_GAP_ADV_TIMEOUT_LIMITED_MAX       (180) /**< Maximum advertising time in limited discoverable mode (TGAP(lim_adv_timeout) = 180s). */
+#define BLE_GAP_ADV_TIMEOUT_GENERAL_UNLIMITED (0)   /**< Unlimited advertising in general discoverable mode. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_DISC_MODES GAP Discovery modes
+ * @{ */
+#define BLE_GAP_DISC_MODE_NOT_DISCOVERABLE  0x00   /**< Not discoverable discovery Mode. */
+#define BLE_GAP_DISC_MODE_LIMITED           0x01   /**< Limited Discovery Mode. */
+#define BLE_GAP_DISC_MODE_GENERAL           0x02   /**< General Discovery Mode. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_IO_CAPS GAP IO Capabilities
+ * @{ */
+#define BLE_GAP_IO_CAPS_DISPLAY_ONLY      0x00   /**< Display Only. */
+#define BLE_GAP_IO_CAPS_DISPLAY_YESNO     0x01   /**< Display and Yes/No entry. */
+#define BLE_GAP_IO_CAPS_KEYBOARD_ONLY     0x02   /**< Keyboard Only. */
+#define BLE_GAP_IO_CAPS_NONE              0x03   /**< No I/O capabilities. */
+#define BLE_GAP_IO_CAPS_KEYBOARD_DISPLAY  0x04   /**< Keyboard and Display. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_AUTH_KEY_TYPES GAP Authentication Key Types
+ * @{ */
+#define BLE_GAP_AUTH_KEY_TYPE_NONE        0x00   /**< No key (may be used to reject). */
+#define BLE_GAP_AUTH_KEY_TYPE_PASSKEY     0x01   /**< 6-digit Passkey. */
+#define BLE_GAP_AUTH_KEY_TYPE_OOB         0x02   /**< Out Of Band data. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_KP_NOT_TYPES GAP Keypress Notification Types
+ * @{ */
+#define BLE_GAP_KP_NOT_TYPE_PASSKEY_START       0x00   /**< Passkey entry started. */
+#define BLE_GAP_KP_NOT_TYPE_PASSKEY_DIGIT_IN    0x01   /**< Passkey digit entered. */
+#define BLE_GAP_KP_NOT_TYPE_PASSKEY_DIGIT_OUT   0x02   /**< Passkey digit erased. */
+#define BLE_GAP_KP_NOT_TYPE_PASSKEY_CLEAR       0x03   /**< Passkey cleared. */
+#define BLE_GAP_KP_NOT_TYPE_PASSKEY_END         0x04   /**< Passkey entry completed. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_SEC_STATUS GAP Security status
+ * @{ */
+#define BLE_GAP_SEC_STATUS_SUCCESS                0x00  /**< Procedure completed with success. */
+#define BLE_GAP_SEC_STATUS_TIMEOUT                0x01  /**< Procedure timed out. */
+#define BLE_GAP_SEC_STATUS_PDU_INVALID            0x02  /**< Invalid PDU received. */
+#define BLE_GAP_SEC_STATUS_RFU_RANGE1_BEGIN       0x03  /**< Reserved for Future Use range #1 begin. */
+#define BLE_GAP_SEC_STATUS_RFU_RANGE1_END         0x80  /**< Reserved for Future Use range #1 end. */
+#define BLE_GAP_SEC_STATUS_PASSKEY_ENTRY_FAILED   0x81  /**< Passkey entry failed (user cancelled or other). */
+#define BLE_GAP_SEC_STATUS_OOB_NOT_AVAILABLE      0x82  /**< Out of Band Key not available. */
+#define BLE_GAP_SEC_STATUS_AUTH_REQ               0x83  /**< Authentication requirements not met. */
+#define BLE_GAP_SEC_STATUS_CONFIRM_VALUE          0x84  /**< Confirm value failed. */
+#define BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP       0x85  /**< Pairing not supported.  */
+#define BLE_GAP_SEC_STATUS_ENC_KEY_SIZE           0x86  /**< Encryption key size. */
+#define BLE_GAP_SEC_STATUS_SMP_CMD_UNSUPPORTED    0x87  /**< Unsupported SMP command. */
+#define BLE_GAP_SEC_STATUS_UNSPECIFIED            0x88  /**< Unspecified reason. */
+#define BLE_GAP_SEC_STATUS_REPEATED_ATTEMPTS      0x89  /**< Too little time elapsed since last attempt. */
+#define BLE_GAP_SEC_STATUS_INVALID_PARAMS         0x8A  /**< Invalid parameters. */
+#define BLE_GAP_SEC_STATUS_DHKEY_FAILURE          0x8B  /**< DHKey check failure. */
+#define BLE_GAP_SEC_STATUS_NUM_COMP_FAILURE       0x8C  /**< Numeric Comparison failure. */
+#define BLE_GAP_SEC_STATUS_BR_EDR_IN_PROG         0x8D  /**< BR/EDR pairing in progress. */
+#define BLE_GAP_SEC_STATUS_X_TRANS_KEY_DISALLOWED 0x8E  /**< BR/EDR Link Key cannot be used for LE keys. */
+#define BLE_GAP_SEC_STATUS_RFU_RANGE2_BEGIN       0x8F  /**< Reserved for Future Use range #2 begin. */
+#define BLE_GAP_SEC_STATUS_RFU_RANGE2_END         0xFF  /**< Reserved for Future Use range #2 end. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_SEC_STATUS_SOURCES GAP Security status sources
+ * @{ */
+#define BLE_GAP_SEC_STATUS_SOURCE_LOCAL           0x00  /**< Local failure. */
+#define BLE_GAP_SEC_STATUS_SOURCE_REMOTE          0x01  /**< Remote failure. */
+/**@} */
+
+
+/**@defgroup BLE_GAP_CP_LIMITS GAP Connection Parameters Limits
+ * @{ */
+#define BLE_GAP_CP_MIN_CONN_INTVL_NONE           0xFFFF  /**< No new minimum connection interval specified in connect parameters. */
+#define BLE_GAP_CP_MIN_CONN_INTVL_MIN            0x0006  /**< Lowest minimum connection interval permitted, in units of 1.25 ms, i.e. 7.5 ms. */
+#define BLE_GAP_CP_MIN_CONN_INTVL_MAX            0x0C80  /**< Highest minimum connection interval permitted, in units of 1.25 ms, i.e. 4 s. */
+#define BLE_GAP_CP_MAX_CONN_INTVL_NONE           0xFFFF  /**< No new maximum connection interval specified in connect parameters. */
+#define BLE_GAP_CP_MAX_CONN_INTVL_MIN            0x0006  /**< Lowest maximum connection interval permitted, in units of 1.25 ms, i.e. 7.5 ms. */
+#define BLE_GAP_CP_MAX_CONN_INTVL_MAX            0x0C80  /**< Highest maximum connection interval permitted, in units of 1.25 ms, i.e. 4 s. */
+#define BLE_GAP_CP_SLAVE_LATENCY_MAX             0x01F3  /**< Highest slave latency permitted, in connection events. */
+#define BLE_GAP_CP_CONN_SUP_TIMEOUT_NONE         0xFFFF  /**< No new supervision timeout specified in connect parameters. */
+#define BLE_GAP_CP_CONN_SUP_TIMEOUT_MIN          0x000A  /**< Lowest supervision timeout permitted, in units of 10 ms, i.e. 100 ms. */
+#define BLE_GAP_CP_CONN_SUP_TIMEOUT_MAX          0x0C80  /**< Highest supervision timeout permitted, in units of 10 ms, i.e. 32 s. */
+/**@} */
+
+
+/**@brief GAP device name defines. */
+#define BLE_GAP_DEVNAME_DEFAULT                  "nRF5x" /**< Default device name value. */
+#define BLE_GAP_DEVNAME_DEFAULT_LEN              31      /**< Default number of octets in device name. */
+#define BLE_GAP_DEVNAME_MAX_LEN                  248     /**< Maximum number of octets in device name. */
+
+
+/**@brief Disable RSSI events for connections */
+#define BLE_GAP_RSSI_THRESHOLD_INVALID 0xFF
+
+
+/**@defgroup BLE_GAP_CONN_SEC_MODE_SET_MACROS GAP attribute security requirement setters
+ *
+ * See @ref ble_gap_conn_sec_mode_t.
+ * @{ */
+/**@brief Set sec_mode pointed to by ptr to have no access rights.*/
+#define BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(ptr)          do {(ptr)->sm = 0; (ptr)->lv = 0;} while (0)
+/**@brief Set sec_mode pointed to by ptr to require no protection, open link.*/
+#define BLE_GAP_CONN_SEC_MODE_SET_OPEN(ptr)               do {(ptr)->sm = 1; (ptr)->lv = 1;} while (0)
+/**@brief Set sec_mode pointed to by ptr to require encryption, but no MITM protection.*/
+#define BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(ptr)        do {(ptr)->sm = 1; (ptr)->lv = 2;} while (0)
+/**@brief Set sec_mode pointed to by ptr to require encryption and MITM protection.*/
+#define BLE_GAP_CONN_SEC_MODE_SET_ENC_WITH_MITM(ptr)      do {(ptr)->sm = 1; (ptr)->lv = 3;} while (0)
+/**@brief Set sec_mode pointed to by ptr to require LESC encryption and MITM protection.*/
+#define BLE_GAP_CONN_SEC_MODE_SET_LESC_ENC_WITH_MITM(ptr) do {(ptr)->sm = 1; (ptr)->lv = 4;} while (0)
+/**@brief Set sec_mode pointed to by ptr to require signing or encryption, no MITM protection needed.*/
+#define BLE_GAP_CONN_SEC_MODE_SET_SIGNED_NO_MITM(ptr)     do {(ptr)->sm = 2; (ptr)->lv = 1;} while (0)
+/**@brief Set sec_mode pointed to by ptr to require signing or encryption with MITM protection.*/
+#define BLE_GAP_CONN_SEC_MODE_SET_SIGNED_WITH_MITM(ptr)   do {(ptr)->sm = 2; (ptr)->lv = 2;} while (0)
+/**@} */
+
+
+/**@brief GAP Security Random Number Length. */
+#define BLE_GAP_SEC_RAND_LEN 8
+
+
+/**@brief GAP Security Key Length. */
+#define BLE_GAP_SEC_KEY_LEN 16
+
+
+/**@brief GAP LE Secure Connections Elliptic Curve Diffie-Hellman P-256 Public Key Length. */
+#define BLE_GAP_LESC_P256_PK_LEN 64
+
+
+/**@brief GAP LE Secure Connections Elliptic Curve Diffie-Hellman DHKey Length. */
+#define BLE_GAP_LESC_DHKEY_LEN   32
+
+
+/**@brief GAP Passkey Length. */
+#define BLE_GAP_PASSKEY_LEN 6
+
+
+/**@brief Maximum amount of addresses in the whitelist. */
+#define BLE_GAP_WHITELIST_ADDR_MAX_COUNT (8)
+
+
+/**@brief Maximum amount of identities in the device identities list. */
+#define BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT (8)
+
+
+/**@defgroup GAP_SEC_MODES GAP Security Modes
+ * @{ */
+#define BLE_GAP_SEC_MODE 0x00 /**< No key (may be used to reject). */
+/**@} */
+/** @} */
+
+
+/**@addtogroup BLE_GAP_STRUCTURES Structures
+ * @{ */
+
+/**@brief Bluetooth Low Energy address. */
+typedef struct
+{
+  uint8_t addr_id_peer : 1;       /**< Only valid for peer addresses.
+                                       Reference to peer in device identities list (as set with @ref sd_ble_gap_device_identities_set) when peer is using privacy. */
+  uint8_t addr_type    : 7;       /**< See @ref BLE_GAP_ADDR_TYPES. */
+  uint8_t addr[BLE_GAP_ADDR_LEN]; /**< 48-bit address, LSB format. */
+} ble_gap_addr_t;
+
+
+/**@brief GAP connection parameters.
+ *
+ * @note  When ble_conn_params_t is received in an event, both min_conn_interval and
+ *        max_conn_interval will be equal to the connection interval set by the central.
+ *
+ * @note If both conn_sup_timeout and max_conn_interval are specified, then the following constraint applies:
+ *       conn_sup_timeout * 4 > (1 + slave_latency) * max_conn_interval
+ *       that corresponds to the following Bluetooth Spec requirement:
+ *       The Supervision_Timeout in milliseconds shall be larger than
+ *       (1 + Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is given in milliseconds.
+ */
+typedef struct
+{
+  uint16_t min_conn_interval;         /**< Minimum Connection Interval in 1.25 ms units, see @ref BLE_GAP_CP_LIMITS.*/
+  uint16_t max_conn_interval;         /**< Maximum Connection Interval in 1.25 ms units, see @ref BLE_GAP_CP_LIMITS.*/
+  uint16_t slave_latency;             /**< Slave Latency in number of connection events, see @ref BLE_GAP_CP_LIMITS.*/
+  uint16_t conn_sup_timeout;          /**< Connection Supervision Timeout in 10 ms units, see @ref BLE_GAP_CP_LIMITS.*/
+} ble_gap_conn_params_t;
+
+
+/**@brief GAP connection security modes.
+ *
+ * Security Mode 0 Level 0: No access permissions at all (this level is not defined by the Bluetooth Core specification).\n
+ * Security Mode 1 Level 1: No security is needed (aka open link).\n
+ * Security Mode 1 Level 2: Encrypted link required, MITM protection not necessary.\n
+ * Security Mode 1 Level 3: MITM protected encrypted link required.\n
+ * Security Mode 1 Level 4: LESC MITM protected encrypted link required.\n
+ * Security Mode 2 Level 1: Signing or encryption required, MITM protection not necessary.\n
+ * Security Mode 2 Level 2: MITM protected signing required, unless link is MITM protected encrypted.\n
+ */
+typedef struct
+{
+  uint8_t sm : 4;                     /**< Security Mode (1 or 2), 0 for no permissions at all. */
+  uint8_t lv : 4;                     /**< Level (1, 2, 3 or 4), 0 for no permissions at all. */
+
+} ble_gap_conn_sec_mode_t;
+
+
+/**@brief GAP connection security status.*/
+typedef struct
+{
+  ble_gap_conn_sec_mode_t sec_mode;           /**< Currently active security mode for this connection.*/
+  uint8_t                 encr_key_size;      /**< Length of currently active encryption key, 7 to 16 octets (only applicable for bonding procedures). */
+} ble_gap_conn_sec_t;
+
+
+/**
+ * @brief Device name and its properties
+ * @note If @ref max_len is more than @ref BLE_GAP_DEVNAME_DEFAULT_LEN and vloc is set to @ref BLE_GATTS_VLOC_STACK, the attribute table size must be increased to have room for the longer device name (see @ref ble_gatts_enable_params_t).
+ */
+typedef struct
+{
+  ble_gap_conn_sec_mode_t  write_perm;   /**< Write permissions. */
+  uint8_t                  vloc:2;       /**< Value location, see @ref BLE_GATTS_VLOCS.*/
+  uint8_t                 *p_value;      /**< Pointer to where the value (device name) is stored or will be stored.*/
+  uint16_t                 current_len;  /**< Current length in bytes of the memory pointed to by p_value.*/
+  uint16_t                 max_len;      /**< Maximum length in bytes of the memory pointed to by p_value.*/
+} ble_gap_device_name_t;
+
+
+/**
+ * @brief BLE GAP initialization parameters.
+ */
+typedef struct
+{
+  uint8_t                      periph_conn_count;  /**< Number of connections acting as a peripheral  */
+  uint8_t                      central_conn_count; /**< Number of connections acting as a central */
+  uint8_t                      central_sec_count;  /**< Number of SMP instances for all connections acting as a central. */
+  ble_gap_device_name_t const *p_device_name;      /**< Pointer to device name instance. If NULL, @ref sd_ble_enable() will set the device name to @ref BLE_GAP_DEVNAME_DEFAULT. */
+} ble_gap_enable_params_t;
+
+
+/**@brief Identity Resolving Key. */
+typedef struct
+{
+  uint8_t irk[BLE_GAP_SEC_KEY_LEN];   /**< Array containing IRK. */
+} ble_gap_irk_t;
+
+
+/**@brief Channel mask for RF channels used in advertising. */
+typedef struct
+{
+  uint8_t ch_37_off : 1;  /**< Setting this bit to 1 will turn off advertising on channel 37 */
+  uint8_t ch_38_off : 1;  /**< Setting this bit to 1 will turn off advertising on channel 38 */
+  uint8_t ch_39_off : 1;  /**< Setting this bit to 1 will turn off advertising on channel 39 */
+} ble_gap_adv_ch_mask_t;
+
+
+/**@brief GAP advertising parameters. */
+typedef struct
+{
+  uint8_t               type;                 /**< See @ref BLE_GAP_ADV_TYPES. */
+  ble_gap_addr_t const *p_peer_addr;          /**< Address of a known peer.
+                                                   - When privacy is enabled and the local device use @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE addresses, the device identity list is searched for a matching
+                                                     entry. If the local IRK for that device identity is set, the local IRK for that device will be used to generate the advertiser address field in the advertise packet.
+                                                   - If type is @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND, this must be set to the targeted initiator. If the initiator is in the device identity list,
+                                                     the peer IRK for that device will be used to generate the initiator address field in the ADV_DIRECT_IND packet. */
+  uint8_t               fp;                   /**< Filter Policy, see @ref BLE_GAP_ADV_FILTER_POLICIES. */
+  uint16_t              interval;             /**< Advertising interval between 0x0020 and 0x4000 in 0.625 ms units (20ms to 10.24s), see @ref BLE_GAP_ADV_INTERVALS.
+                                                   - If type equals @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND, this parameter must be set to 0 for high duty cycle directed advertising.
+                                                   - If type equals @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND, set @ref BLE_GAP_ADV_INTERVAL_MIN <= interval <= @ref BLE_GAP_ADV_INTERVAL_MAX for low duty cycle advertising.*/
+  uint16_t              timeout;              /**< Advertising timeout between 0x0001 and 0x3FFF in seconds, 0x0000 disables timeout. See also @ref BLE_GAP_ADV_TIMEOUT_VALUES. If type equals @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND, this parameter must be set to 0 for High duty cycle directed advertising. */
+  ble_gap_adv_ch_mask_t channel_mask;         /**< Advertising channel mask. See @ref ble_gap_adv_ch_mask_t. */
+} ble_gap_adv_params_t;
+
+
+/**@brief GAP scanning parameters. */
+typedef struct
+{
+  uint8_t  active         : 1;  /**< If 1, perform active scanning (scan requests). */
+  uint8_t  use_whitelist  : 1;  /**< If 1, filter advertisers using current active whitelist. */
+  uint8_t  adv_dir_report : 1;  /**< If 1, also report directed advertisements where the initiator field is set to a private resolvable address,
+                                     even if the address did not resolve to an entry in the device identity list. A report will be generated
+                                     even if the peer is not in the whitelist. */
+  uint16_t interval;            /**< Scan interval between 0x0004 and 0x4000 in 0.625ms units (2.5ms to 10.24s). */
+  uint16_t window;              /**< Scan window between 0x0004 and 0x4000 in 0.625ms units (2.5ms to 10.24s). */
+  uint16_t timeout;             /**< Scan timeout between 0x0001 and 0xFFFF in seconds, 0x0000 disables timeout. */
+} ble_gap_scan_params_t;
+
+
+/**@brief Device Privacy.
+ *
+ *        The privacy feature provides a way for the device to avoid being tracked over a period of time.
+ *        The privacy feature, when enabled, hides the local device identity and replaces it with a private address
+ *        that is automatically refreshed at a specified interval.
+ *
+ *        If a device still wants to be recognized by other peers, it needs to share it's Identity Resolving Key (IRK).
+ *        With this key, a device can generate a random private address that can only be recognized by peers in possession of that key,
+ *        and devices can establish connections without revealing their real identities.
+ *
+ * @note  If the device IRK is updated, the new IRK becomes the one to be distributed in all
+ *        bonding procedures performed after @ref sd_ble_gap_privacy_set returns.
+ *        The IRK distributed during bonding procedure is the device IRK that is active when @ref sd_ble_gap_sec_params_reply is called.
+ */
+typedef struct
+{
+  uint8_t        privacy_mode;         /**< Privacy mode, see @ref BLE_GAP_PRIVACY_MODES. Default is @ref BLE_GAP_PRIVACY_MODE_OFF. */
+  uint8_t        private_addr_type;    /**< The private address type must be either @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE or @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE. */
+  uint16_t       private_addr_cycle_s; /**< Private address cycle interval in seconds. Providing an address cycle value of 0 will use the default value defined by @ref BLE_GAP_DEFAULT_PRIVATE_ADDR_CYCLE_INTERVAL_S. */
+  ble_gap_irk_t *p_device_irk;         /**< When used as input, pointer to IRK structure that will be used as the default IRK. If NULL, the device default IRK will be used.
+                                            When used as output, pointer to IRK structure where the current default IRK will be written to. If NULL, this argument is ignored.
+                                            By default, the default IRK is used to generate random private resolvable addresses for the local device unless instructed otherwise. */
+} ble_gap_privacy_params_t;
+
+
+/** @brief Keys that can be exchanged during a bonding procedure. */
+typedef struct
+{
+  uint8_t enc     : 1;                        /**< Long Term Key and Master Identification. */
+  uint8_t id      : 1;                        /**< Identity Resolving Key and Identity Address Information. */
+  uint8_t sign    : 1;                        /**< Connection Signature Resolving Key. */
+  uint8_t link    : 1;                        /**< Derive the Link Key from the LTK. */
+} ble_gap_sec_kdist_t;
+
+
+/**@brief GAP security parameters. */
+typedef struct
+{
+  uint8_t               bond      : 1;             /**< Perform bonding. */
+  uint8_t               mitm      : 1;             /**< Enable Man In The Middle protection. */
+  uint8_t               lesc      : 1;             /**< Enable LE Secure Connection pairing. */
+  uint8_t               keypress  : 1;             /**< Enable generation of keypress notifications. */
+  uint8_t               io_caps   : 3;             /**< IO capabilities, see @ref BLE_GAP_IO_CAPS. */
+  uint8_t               oob       : 1;             /**< Out Of Band data available. */
+  uint8_t               min_key_size;              /**< Minimum encryption key size in octets between 7 and 16. If 0 then not applicable in this instance. */
+  uint8_t               max_key_size;              /**< Maximum encryption key size in octets between min_key_size and 16. */
+  ble_gap_sec_kdist_t   kdist_own;                 /**< Key distribution bitmap: keys that the local device will distribute. */
+  ble_gap_sec_kdist_t   kdist_peer;                /**< Key distribution bitmap: keys that the remote device will distribute. */
+} ble_gap_sec_params_t;
+
+
+/**@brief GAP Encryption Information. */
+typedef struct
+{
+  uint8_t   ltk[BLE_GAP_SEC_KEY_LEN];   /**< Long Term Key. */
+  uint8_t   lesc : 1;                   /**< Key generated using LE Secure Connections. */
+  uint8_t   auth : 1;                   /**< Authenticated Key. */
+  uint8_t   ltk_len : 6;                /**< LTK length in octets. */
+} ble_gap_enc_info_t;
+
+
+/**@brief GAP Master Identification. */
+typedef struct
+{
+  uint16_t  ediv;                       /**< Encrypted Diversifier. */
+  uint8_t   rand[BLE_GAP_SEC_RAND_LEN]; /**< Random Number. */
+} ble_gap_master_id_t;
+
+
+/**@brief GAP Signing Information. */
+typedef struct
+{
+  uint8_t   csrk[BLE_GAP_SEC_KEY_LEN];        /**< Connection Signature Resolving Key. */
+} ble_gap_sign_info_t;
+
+
+/**@brief GAP LE Secure Connections P-256 Public Key. */
+typedef struct
+{
+  uint8_t   pk[BLE_GAP_LESC_P256_PK_LEN];        /**< LE Secure Connections Elliptic Curve Diffie-Hellman P-256 Public Key. Stored in the standard SMP protocol format: {X,Y} both in little-endian. */
+} ble_gap_lesc_p256_pk_t;
+
+
+/**@brief GAP LE Secure Connections DHKey. */
+typedef struct
+{
+  uint8_t   key[BLE_GAP_LESC_DHKEY_LEN];        /**< LE Secure Connections Elliptic Curve Diffie-Hellman Key. Stored in little-endian. */
+} ble_gap_lesc_dhkey_t;
+
+
+/**@brief GAP LE Secure Connections OOB data. */
+typedef struct
+{
+  ble_gap_addr_t  addr;                          /**< Bluetooth address of the device. */
+  uint8_t         r[BLE_GAP_SEC_KEY_LEN];        /**< Random Number. */
+  uint8_t         c[BLE_GAP_SEC_KEY_LEN];        /**< Confirm Value. */
+} ble_gap_lesc_oob_data_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_CONNECTED. */
+typedef struct
+{
+  ble_gap_addr_t        peer_addr;              /**< Bluetooth address of the peer device. If the peer_addr resolved: @ref ble_gap_addr_t::addr_id_peer is set to 1
+                                                     and the address is the device's identity address. */
+  uint8_t               role;                   /**< BLE role for this connection, see @ref BLE_GAP_ROLES */
+  ble_gap_conn_params_t conn_params;            /**< GAP Connection Parameters. */
+} ble_gap_evt_connected_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_DISCONNECTED. */
+typedef struct
+{
+  uint8_t reason;                               /**< HCI error code, see @ref BLE_HCI_STATUS_CODES. */
+} ble_gap_evt_disconnected_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_CONN_PARAM_UPDATE. */
+typedef struct
+{
+  ble_gap_conn_params_t conn_params;            /**<  GAP Connection Parameters. */
+} ble_gap_evt_conn_param_update_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_SEC_PARAMS_REQUEST. */
+typedef struct
+{
+  ble_gap_sec_params_t peer_params;             /**< Initiator Security Parameters. */
+} ble_gap_evt_sec_params_request_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_SEC_INFO_REQUEST. */
+typedef struct
+{
+  ble_gap_addr_t      peer_addr;                     /**< Bluetooth address of the peer device. */
+  ble_gap_master_id_t master_id;                     /**< Master Identification for LTK lookup. */
+  uint8_t             enc_info  : 1;                 /**< If 1, Encryption Information required. */
+  uint8_t             id_info   : 1;                 /**< If 1, Identity Information required. */
+  uint8_t             sign_info : 1;                 /**< If 1, Signing Information required. */
+} ble_gap_evt_sec_info_request_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_PASSKEY_DISPLAY. */
+typedef struct
+{
+  uint8_t passkey[BLE_GAP_PASSKEY_LEN];         /**< 6-digit passkey in ASCII ('0'-'9' digits only). */
+  uint8_t match_request : 1;                    /**< If 1 requires the application to report the match using @ref sd_ble_gap_auth_key_reply
+                                                     with either @ref BLE_GAP_AUTH_KEY_TYPE_NONE if there is no match or
+                                                     @ref BLE_GAP_AUTH_KEY_TYPE_PASSKEY if there is a match. */
+} ble_gap_evt_passkey_display_t;
+
+/**@brief Event structure for @ref BLE_GAP_EVT_KEY_PRESSED. */
+typedef struct
+{
+  uint8_t kp_not;         /**< Keypress notification type, see @ref BLE_GAP_KP_NOT_TYPES. */
+} ble_gap_evt_key_pressed_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_AUTH_KEY_REQUEST. */
+typedef struct
+{
+  uint8_t key_type;                             /**< See @ref BLE_GAP_AUTH_KEY_TYPES. */
+} ble_gap_evt_auth_key_request_t;
+
+/**@brief Event structure for @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST. */
+typedef struct
+{
+  ble_gap_lesc_p256_pk_t *p_pk_peer;  /**< LE Secure Connections remote P-256 Public Key. This will point to the application-supplied memory
+                                           inside the keyset during the call to @ref sd_ble_gap_sec_params_reply. */
+  uint8_t oobd_req       :1;          /**< LESC OOB data required. A call to @ref sd_ble_gap_lesc_oob_data_set is required to complete the procedure. */
+} ble_gap_evt_lesc_dhkey_request_t;
+
+
+/**@brief Security levels supported.
+ * @note See Bluetooth Specification Version 4.2 Volume 3, Part C, Chapter 10, Section 10.2.1.
+*/
+typedef struct
+{
+  uint8_t lv1 : 1;                              /**< If 1: Level 1 is supported. */
+  uint8_t lv2 : 1;                              /**< If 1: Level 2 is supported. */
+  uint8_t lv3 : 1;                              /**< If 1: Level 3 is supported. */
+  uint8_t lv4 : 1;                              /**< If 1: Level 4 is supported. */
+} ble_gap_sec_levels_t;
+
+
+/**@brief Encryption Key. */
+typedef struct
+{
+  ble_gap_enc_info_t    enc_info;             /**< Encryption Information. */
+  ble_gap_master_id_t   master_id;            /**< Master Identification. */
+} ble_gap_enc_key_t;
+
+
+/**@brief Identity Key. */
+typedef struct
+{
+  ble_gap_irk_t         id_info;              /**< Identity Resolving Key. */
+  ble_gap_addr_t        id_addr_info;         /**< Identity Address. */
+} ble_gap_id_key_t;
+
+
+/**@brief Security Keys. */
+typedef struct
+{
+  ble_gap_enc_key_t      *p_enc_key;           /**< Encryption Key, or NULL. */
+  ble_gap_id_key_t       *p_id_key;            /**< Identity Key, or NULL. */
+  ble_gap_sign_info_t    *p_sign_key;          /**< Signing Key, or NULL. */
+  ble_gap_lesc_p256_pk_t *p_pk;                /**< LE Secure Connections P-256 Public Key. When in debug mode the application must use the value defined
+                                                    in the Core Bluetooth Specification v4.2 Vol.3, Part H, Section 2.3.5.6.1 */
+} ble_gap_sec_keys_t;
+
+
+/**@brief Security key set for both local and peer keys. */
+typedef struct
+{
+  ble_gap_sec_keys_t            keys_own;     /**< Keys distributed by the local device. For LE Secure Connections the encryption key will be generated locally and will always be stored if bonding. */
+  ble_gap_sec_keys_t            keys_peer;    /**< Keys distributed by the remote device. For LE Secure Connections, p_enc_key must always be NULL. */
+} ble_gap_sec_keyset_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_AUTH_STATUS. */
+typedef struct
+{
+  uint8_t               auth_status;            /**< Authentication status, see @ref BLE_GAP_SEC_STATUS. */
+  uint8_t               error_src : 2;          /**< On error, source that caused the failure, see @ref BLE_GAP_SEC_STATUS_SOURCES. */
+  uint8_t               bonded : 1;             /**< Procedure resulted in a bond. */
+  ble_gap_sec_levels_t  sm1_levels;             /**< Levels supported in Security Mode 1. */
+  ble_gap_sec_levels_t  sm2_levels;             /**< Levels supported in Security Mode 2. */
+  ble_gap_sec_kdist_t   kdist_own;              /**< Bitmap stating which keys were exchanged (distributed) by the local device. If bonding with LE Secure Connections, the enc bit will be always set. */
+  ble_gap_sec_kdist_t   kdist_peer;             /**< Bitmap stating which keys were exchanged (distributed) by the remote device. If bonding with LE Secure Connections, the enc bit will never be set. */
+} ble_gap_evt_auth_status_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_CONN_SEC_UPDATE. */
+typedef struct
+{
+  ble_gap_conn_sec_t conn_sec;                  /**< Connection security level. */
+} ble_gap_evt_conn_sec_update_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_TIMEOUT. */
+typedef struct
+{
+  uint8_t src;                                  /**< Source of timeout event, see @ref BLE_GAP_TIMEOUT_SOURCES. */
+} ble_gap_evt_timeout_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_RSSI_CHANGED. */
+typedef struct
+{
+  int8_t  rssi;                               /**< Received Signal Strength Indication in dBm. */
+} ble_gap_evt_rssi_changed_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_ADV_REPORT. */
+typedef struct
+{
+  ble_gap_addr_t peer_addr;                     /**< Bluetooth address of the peer device. If the peer_addr resolved: @ref ble_gap_addr_t::addr_id_peer is set to 1
+                                                     and the address is the device's identity address. */
+  ble_gap_addr_t direct_addr;                   /**< Set when the scanner is unable to resolve the private resolvable address of the initiator
+                                                     field of a directed advertisement packet and the scanner has been enabled to report this in @ref ble_gap_scan_params_t::adv_dir_report. */
+  int8_t         rssi;                          /**< Received Signal Strength Indication in dBm. */
+  uint8_t        scan_rsp : 1;                  /**< If 1, the report corresponds to a scan response and the type field may be ignored. */
+  uint8_t        type     : 2;                  /**< See @ref BLE_GAP_ADV_TYPES. Only valid if the scan_rsp field is 0. */
+  uint8_t        dlen     : 5;                  /**< Advertising or scan response data length. */
+  uint8_t        data[BLE_GAP_ADV_MAX_SIZE];    /**< Advertising or scan response data. */
+} ble_gap_evt_adv_report_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_SEC_REQUEST. */
+typedef struct
+{
+  uint8_t    bond       : 1;                       /**< Perform bonding. */
+  uint8_t    mitm       : 1;                       /**< Man In The Middle protection requested. */
+  uint8_t    lesc       : 1;                       /**< LE Secure Connections requested. */
+  uint8_t    keypress   : 1;                       /**< Generation of keypress notifications requested. */
+} ble_gap_evt_sec_request_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST. */
+typedef struct
+{
+  ble_gap_conn_params_t conn_params;            /**<  GAP Connection Parameters. */
+} ble_gap_evt_conn_param_update_request_t;
+
+
+/**@brief Event structure for @ref BLE_GAP_EVT_SCAN_REQ_REPORT. */
+typedef struct
+{
+  int8_t                  rssi;              /**< Received Signal Strength Indication in dBm. */
+  ble_gap_addr_t          peer_addr;         /**< Bluetooth address of the peer device. If the peer_addr resolved: @ref ble_gap_addr_t::addr_id_peer is set to 1
+                                                  and the address is the device's identity address. */
+} ble_gap_evt_scan_req_report_t;
+
+
+/**@brief GAP event structure. */
+typedef struct
+{
+  uint16_t conn_handle;                                     /**< Connection Handle on which event occurred. */
+  union                                                     /**< union alternative identified by evt_id in enclosing struct. */
+  {
+    ble_gap_evt_connected_t                   connected;                    /**< Connected Event Parameters. */
+    ble_gap_evt_disconnected_t                disconnected;                 /**< Disconnected Event Parameters. */
+    ble_gap_evt_conn_param_update_t           conn_param_update;            /**< Connection Parameter Update Parameters. */
+    ble_gap_evt_sec_params_request_t          sec_params_request;           /**< Security Parameters Request Event Parameters. */
+    ble_gap_evt_sec_info_request_t            sec_info_request;             /**< Security Information Request Event Parameters. */
+    ble_gap_evt_passkey_display_t             passkey_display;              /**< Passkey Display Event Parameters. */
+    ble_gap_evt_key_pressed_t                 key_pressed;                  /**< Key Pressed Event Parameters. */
+    ble_gap_evt_auth_key_request_t            auth_key_request;             /**< Authentication Key Request Event Parameters. */
+    ble_gap_evt_lesc_dhkey_request_t          lesc_dhkey_request;           /**< LE Secure Connections DHKey calculation request. */
+    ble_gap_evt_auth_status_t                 auth_status;                  /**< Authentication Status Event Parameters. */
+    ble_gap_evt_conn_sec_update_t             conn_sec_update;              /**< Connection Security Update Event Parameters. */
+    ble_gap_evt_timeout_t                     timeout;                      /**< Timeout Event Parameters. */
+    ble_gap_evt_rssi_changed_t                rssi_changed;                 /**< RSSI Event parameters. */
+    ble_gap_evt_adv_report_t                  adv_report;                   /**< Advertising Report Event Parameters. */
+    ble_gap_evt_sec_request_t                 sec_request;                  /**< Security Request Event Parameters. */
+    ble_gap_evt_conn_param_update_request_t   conn_param_update_request;    /**< Connection Parameter Update Parameters. */
+    ble_gap_evt_scan_req_report_t             scan_req_report;              /**< Scan Request Report parameters. */
+  } params;                                                                 /**< Event Parameters. */
+} ble_gap_evt_t;
+
+
+/**@brief Channel Map option.
+ *        Used with @ref sd_ble_opt_get to get the current channel map
+ *        or @ref sd_ble_opt_set to set a new channel map. When setting the
+ *        channel map, it applies to all current and future connections. When getting the
+ *        current channel map, it applies to a single connection and the connection handle
+ *        must be supplied.
+ *
+ * @note  Setting the channel map may take some time, depending on connection parameters.
+ *        The time taken may be different for each connection and the get operation will
+ *        return the previous channel map until the new one has taken effect.
+ *
+ * @note  After setting the channel map, by spec it can not be set again until at least 1 s has passed.
+ *        See Bluetooth Specification Version 4.1 Volume 2, Part E, Section 7.3.46.
+ *
+ * @retval ::NRF_SUCCESS Get or set successful.
+ * @retval ::NRF_ERROR_BUSY Channel map was set again before enough time had passed.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied for get.
+ * @retval ::NRF_ERROR_NOT_SUPPORTED Returned by sd_ble_opt_set in peripheral-only SoftDevices.
+ *
+ */
+typedef struct
+{
+  uint16_t conn_handle;                   /**< Connection Handle (only applicable for get) */
+  uint8_t ch_map[5];                      /**< Channel Map (37-bit). */
+} ble_gap_opt_ch_map_t;
+
+
+/**@brief Local connection latency option.
+ *
+ *        Local connection latency is a feature which enables the slave to improve
+ *        current consumption by ignoring the slave latency set by the peer. The
+ *        local connection latency can only be set to a multiple of the slave latency,
+ *        and cannot be longer than half of the supervision timeout.
+ *
+ *        Used with @ref sd_ble_opt_set to set the local connection latency. The
+ *        @ref sd_ble_opt_get is not supported for this option, but the actual
+ *        local connection latency (unless set to NULL) is set as a return parameter
+ *        when setting the option.
+ *
+ * @note  The latency set will be truncated down to the closest slave latency event
+ *        multiple, or the nearest multiple before half of the supervision timeout.
+ *
+ * @note  The local connection latency is disabled by default, and needs to be enabled for new
+ *        connections and whenever the connection is updated.
+ *
+ * @retval ::NRF_SUCCESS Set successfully.
+ * @retval ::NRF_ERROR_NOT_SUPPORTED Get is not supported.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.
+ */
+typedef struct
+{
+  uint16_t   conn_handle;                       /**< Connection Handle */
+  uint16_t   requested_latency;                 /**< Requested local connection latency. */
+  uint16_t * p_actual_latency;                  /**< Pointer to storage for the actual local connection latency (can be set to NULL to skip return value). */
+} ble_gap_opt_local_conn_latency_t;
+
+
+/**@brief Passkey Option.
+ *
+ *        Structure containing the passkey to be used during pairing. This can be used with @ref
+ *        sd_ble_opt_set to make the SoftDevice use a pre-programmed passkey for authentication
+ *        instead of generating a random one.
+ *
+ * @note  Repeated pairing attempts using the same pre-programmed passkey makes pairing vulnerable to MITM attacks.
+ *
+ * @note  @ref sd_ble_opt_get is not supported for this option.
+ *
+ */
+typedef struct
+{
+  uint8_t * p_passkey;                          /**< Pointer to 6-digit ASCII string (digit 0..9 only, no NULL termination) passkey to be used during pairing. If this is NULL, the SoftDevice will generate a random passkey if required.*/
+} ble_gap_opt_passkey_t;
+
+
+/**@brief Scan request report option.
+ *
+ *        This can be used with @ref sd_ble_opt_set to make the SoftDevice send
+ *        @ref BLE_GAP_EVT_SCAN_REQ_REPORT events.
+ *
+ *  @note   Due to the limited space reserved for scan request report events,
+ *          not all received scan requests will be reported.
+ *
+ *  @note   If whitelisting is used, only whitelisted requests are reported.
+ *
+ *  @retval ::NRF_SUCCESS Set successfully.
+ *  @retval ::NRF_ERROR_INVALID_STATE When advertising is ongoing while the option is set.
+ */
+typedef struct
+{
+   uint8_t enable : 1;                           /**< Enable scan request reports. */
+} ble_gap_opt_scan_req_report_t;
+
+
+/**@brief Compatibility mode option.
+ *
+ *        This can be used with @ref sd_ble_opt_set to enable and disable
+ *        compatibility modes. Compatibility modes are disabled by default.
+ *
+ *  @note  Compatibility mode 1 enables interoperability with devices that do not support
+ *         a value of 0 for the WinOffset parameter in the Link Layer CONNECT_REQ packet.
+ *
+ *  @retval ::NRF_SUCCESS Set successfully.
+ *  @retval ::NRF_ERROR_INVALID_STATE When connection creation is ongoing while mode 1 is set.
+ */
+typedef struct
+{
+   uint8_t mode_1_enable : 1;                           /**< Enable compatibility mode 1.*/
+} ble_gap_opt_compat_mode_t;
+
+/**@brief Data length extension option.
+ *
+ *        This can be used with @ref sd_ble_opt_set to enable longer data packets.
+ *
+ * @note  An rxtx_max_pdu_payload_size of 0 will result in the default minimum payload size of 27.
+ * @note  Not supported by SoftDevices for nRF51 Series devices.
+ * @note  The parameters for a connection are applied when a connection complete
+ *        event is generated for the host.
+ *
+ *
+ *  @retval ::NRF_SUCCESS Set successfully.
+ *  @retval ::NRF_ERROR_INVALID_PARAM If the payload size is not 0 or a valid link layer PDU payload size.
+ *  @retval ::NRF_ERROR_NOT_SUPPORTED If called on a SoftDevice designed for nRF51 (e.g. s130).
+ */
+typedef struct
+{
+  uint8_t  rxtx_max_pdu_payload_size;      /**< Max PDU payload size (in octets). */
+} ble_gap_opt_ext_len_t;
+
+
+
+/**@brief Authenticated payload timeout option.
+ *
+ * This can be used with @ref sd_ble_opt_set to change the Authenticated payload timeout to a value other than the default of 8 minutes.
+ *
+ * @note The authenticated payload timeout event ::BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD will be generated
+ * if auth_payload_timeout time has elapsed without receiving a packet with a valid MIC on an encrypted
+ * link.
+ *
+ * @note  The LE ping procedure will be initiated before the timer expires to give the peer a chance
+ * to reset the timer. In addition the stack will try to prioritize running of LE ping over other
+ * activities to increase chances of finishing LE ping before timer expires. To avoid side-effects
+ * on other activities, it is recommended to use high timeout values.
+ * Recommended timeout > 2*(connInterval * (6 + connSlaveLatency)).
+ *
+ * @retval ::NRF_SUCCESS Set successfully.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied. auth_payload_timeout was outside of allowed range.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.
+ */
+typedef struct
+{
+  uint16_t   conn_handle;                       /**< Connection Handle */
+  uint16_t   auth_payload_timeout;              /**< Requested timeout in 10 ms unit. Maximum is 48 000 (=480 000 ms =8 min). Minimum is 1 (=10ms). */
+} ble_gap_opt_auth_payload_timeout_t;
+
+
+/**@brief Option structure for GAP options. */
+typedef union
+{
+  ble_gap_opt_ch_map_t                  ch_map;                    /**< Parameters for the Channel Map option. */
+  ble_gap_opt_local_conn_latency_t      local_conn_latency;        /**< Parameters for the Local connection latency option */
+  ble_gap_opt_passkey_t                 passkey;                   /**< Parameters for the Passkey option.*/
+  ble_gap_opt_scan_req_report_t         scan_req_report;           /**< Parameters for the scan request report option.*/
+  ble_gap_opt_compat_mode_t             compat_mode;               /**< Parameters for the compatibility mode option.*/
+  ble_gap_opt_ext_len_t                 ext_len;                   /**< Parameters for the extended length option. */
+  ble_gap_opt_auth_payload_timeout_t    auth_payload_timeout;      /**< Parameters for the authenticated payload timeout option.*/
+} ble_gap_opt_t;
+/**@} */
+
+
+/**@addtogroup BLE_GAP_FUNCTIONS Functions
+ * @{ */
+
+/**@brief Set the local Bluetooth identity address.
+ *
+ * The local Bluetooth identity address is the address that identifies this device to other peers.
+ * The address type must be either @ref BLE_GAP_ADDR_TYPE_PUBLIC or @ref BLE_GAP_ADDR_TYPE_RANDOM_STATIC.
+ * The identity address cannot be changed while roles are running.
+ *
+ * @note This address will be distributed to the peer during bonding.
+ * If the address changes, the address stored in the peer device will not be valid and the ability to
+ * reconnect using the old address will be lost.
+ *
+ * @note By default the SoftDevice will set an address of type @ref BLE_GAP_ADDR_TYPE_RANDOM_STATIC upon being
+ * enabled. The address is a random number populated during the IC manufacturing process and remains unchanged
+ * for the lifetime of each IC.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_ADV_MSC}
+ * @endmscs
+ *
+ * @param[in] p_addr Pointer to address structure.
+ *
+ * @retval ::NRF_SUCCESS Address successfully set.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address.
+ * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
+ * @retval ::NRF_ERROR_INVALID_STATE The identity address cannot be changed while the roles are running.
+ */
+SVCALL(SD_BLE_GAP_ADDR_SET, uint32_t, sd_ble_gap_addr_set(ble_gap_addr_t const *p_addr));
+
+
+/**@brief Get local Bluetooth identity address.
+ *
+ * @note This will always return the identity address irrespective of the privacy settings,
+ * i.e. the address type will always be either @ref BLE_GAP_ADDR_TYPE_PUBLIC or @ref BLE_GAP_ADDR_TYPE_RANDOM_STATIC.
+ *
+ * @param[out] p_addr Pointer to address structure to be filled in.
+ *
+ * @retval ::NRF_SUCCESS Address successfully retrieved.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid or NULL pointer supplied.
+ */
+SVCALL(SD_BLE_GAP_ADDR_GET, uint32_t, sd_ble_gap_addr_get(ble_gap_addr_t *p_addr));
+
+
+/**@brief Set the active whitelist in the SoftDevice.
+ *
+ * @note Only one whitelist can be used at a time and the whitelist is shared between the BLE roles.
+ *       The whitelist cannot be set if a BLE role is using the whitelist.
+ *
+ * @note If an address is resolved using the information in the device identity list, then the whitelist
+ *       filter policy applies to the peer identity address and not the resolvable address sent on air.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
+ * @mmsc{@ref BLE_GAP_PRIVACY_SCAN_PRIVATE_SCAN_MSC}
+ * @endmscs
+ *
+ * @param[in] pp_wl_addrs Pointer to a whitelist of peer addresses, if NULL the whitelist will be cleared.
+ * @param[in] len         Length of the whitelist, maximum @ref BLE_GAP_WHITELIST_ADDR_MAX_COUNT.
+ *
+ * @retval ::NRF_SUCCESS The whitelist is successfully set/cleared.
+ * @retval ::NRF_ERROR_INVALID_ADDR The whitelist (or one of its entries) provided is invalid.
+ * @retval ::BLE_ERROR_GAP_WHITELIST_IN_USE The whitelist is in use by a BLE role and cannot be set or cleared.
+ * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address type is supplied.
+ * @retval ::NRF_ERROR_DATA_SIZE The given whitelist size is invalid (zero or too large); this can only return when
+ *                               pp_wl_addrs is not NULL.
+ */
+//lint -save -esym(18, sd_ble_gap_whitelist_set)
+SVCALL(SD_BLE_GAP_WHITELIST_SET, uint32_t, sd_ble_gap_whitelist_set(ble_gap_addr_t const * const * pp_wl_addrs, uint8_t len));
+//lint -restore
+
+/**@brief Set device identity list.
+ *
+ * @note Only one device identity list can be used at a time and the list is shared between the BLE roles.
+ *       The device identity list cannot be set if a BLE role is using the list.
+ *
+ * @param[in] pp_id_keys     Pointer to an array of peer identity addresses and peer IRKs, if NULL the device identity list will be cleared.
+ * @param[in] pp_local_irks  Pointer to an array of local IRKs. Each entry in the array maps to the entry in pp_id_keys at the same index.
+ *                           To fill in the list with the currently set device IRK for all peers, set to NULL.
+ * @param[in] len            Length of the device identity list, maximum @ref BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PRIVACY_ADV_MSC}
+ * @mmsc{@ref BLE_GAP_PRIVACY_SCAN_MSC}
+ * @mmsc{@ref BLE_GAP_PRIVACY_SCAN_PRIVATE_SCAN_MSC}
+ * @mmsc{@ref BLE_GAP_PRIVACY_ADV_DIR_PRIV_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_CONN_PRIV_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_CONN_PRIV_MSC}
+ * @endmscs
+ *
+ * @retval ::NRF_SUCCESS The device identity list successfully set/cleared.
+ * @retval ::NRF_ERROR_INVALID_ADDR The device identity list (or one of its entries) provided is invalid.
+                                    This code may be returned if the local IRK list also has an invalid entry.
+ * @retval ::BLE_ERROR_GAP_DEVICE_IDENTITIES_IN_USE The device identity list is in use and cannot be set or cleared.
+ * @retval ::BLE_ERROR_GAP_DEVICE_IDENTITIES_DUPLICATE The device identity list contains multiple entries with the same identity address.
+ * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address type is supplied.
+ * @retval ::NRF_ERROR_DATA_SIZE The given device identity list size invalid (zero or too large); this can
+ *                               only return when pp_id_keys is not NULL.
+ */
+//lint -save -esym(18, sd_ble_gap_device_identities_set)
+SVCALL(SD_BLE_GAP_DEVICE_IDENTITIES_SET, uint32_t, sd_ble_gap_device_identities_set(ble_gap_id_key_t const * const * pp_id_keys, ble_gap_irk_t const * const * pp_local_irks, uint8_t len));
+//lint -restore
+
+/**@brief Set privacy settings.
+ *
+ * @note Privacy settings cannot be set while BLE roles are running.
+ *
+ * @param[in] p_privacy_params Privacy settings.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PRIVACY_ADV_MSC}
+ * @mmsc{@ref BLE_GAP_PRIVACY_SCAN_MSC}
+ * @mmsc{@ref BLE_GAP_PRIVACY_ADV_DIR_PRIV_MSC}
+ * @endmscs
+ *
+ * @retval ::NRF_SUCCESS Set successfully.
+ * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
+ * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address type is supplied.
+ * @retval ::NRF_ERROR_INVALID_ADDR The pointer to privacy settings is NULL or invalid.
+                                    Otherwise, the p_device_irk pointer in privacy parameter is an invalid pointer.
+ * @retval ::NRF_ERROR_INVALID_PARAM Out of range parameters are provided.
+ * @retval ::NRF_ERROR_INVALID_STATE Privacy settings cannot be changed while BLE roles using privacy are enabled.
+  */
+SVCALL(SD_BLE_GAP_PRIVACY_SET, uint32_t, sd_ble_gap_privacy_set(ble_gap_privacy_params_t const *p_privacy_params));
+
+
+/**@brief Get privacy settings.
+ *
+ * @note The privacy settings returned include the current device irk as well.
+ *
+ * @param[in] p_privacy_params Privacy settings.
+ *
+ * @retval ::NRF_SUCCESS            Privacy settings read.
+ * @retval ::NRF_ERROR_INVALID_ADDR The pointer given for returning the privacy settings may be NULL or invalid.
+                                    Otherwise, the p_device_irk pointer in privacy parameter is an invalid pointer.
+ */
+SVCALL(SD_BLE_GAP_PRIVACY_GET, uint32_t, sd_ble_gap_privacy_get(ble_gap_privacy_params_t *p_privacy_params));
+
+
+/**@brief Set, clear or update advertising and scan response data.
+ *
+ * @note The format of the advertising data will be checked by this call to ensure interoperability.
+ *       Limitations imposed by this API call to the data provided include having a flags data type in the scan response data and
+ *       duplicating the local name in the advertising data and scan response data.
+ *
+ * @note To clear the advertising data and set it to a 0-length packet, simply provide a valid pointer (p_data/p_sr_data) with its corresponding
+ *        length (dlen/srdlen) set to 0.
+ *
+ * @note The call will fail if p_data and p_sr_data are both NULL since this would have no effect.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_ADV_MSC}
+ * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
+ * @endmscs
+ *
+ * @param[in] p_data    Raw data to be placed in advertising packet. If NULL, no changes are made to the current advertising packet data.
+ * @param[in] dlen      Data length for p_data. Max size: @ref BLE_GAP_ADV_MAX_SIZE octets. Should be 0 if p_data is NULL, can be 0 if p_data is not NULL.
+ * @param[in] p_sr_data Raw data to be placed in scan response packet. If NULL, no changes are made to the current scan response packet data.
+ * @param[in] srdlen    Data length for p_sr_data. Max size: @ref BLE_GAP_ADV_MAX_SIZE octets. Should be 0 if p_sr_data is NULL, can be 0 if p_data is not NULL.
+ *
+ * @retval ::NRF_SUCCESS Advertising data successfully updated or cleared.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, both p_data and p_sr_data cannot be NULL.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_FLAGS Invalid combination of advertising flags supplied.
+ * @retval ::NRF_ERROR_INVALID_DATA Invalid data type(s) supplied, check the advertising data format specification.
+ * @retval ::NRF_ERROR_INVALID_LENGTH Invalid data length(s) supplied.
+ * @retval ::NRF_ERROR_NOT_SUPPORTED Unsupported data type.
+ * @retval ::BLE_ERROR_GAP_UUID_LIST_MISMATCH Invalid UUID list supplied.
+ */
+SVCALL(SD_BLE_GAP_ADV_DATA_SET, uint32_t, sd_ble_gap_adv_data_set(uint8_t const *p_data, uint8_t dlen, uint8_t const *p_sr_data, uint8_t srdlen));
+
+
+/**@brief Start advertising (GAP Discoverable, Connectable modes, Broadcast Procedure).
+ *
+ * @note An application can start an advertising procedure for broadcasting purposes while a connection
+ *       is active. After a @ref BLE_GAP_EVT_CONNECTED event is received, this function may therefore
+ *       be called to start a broadcast advertising procedure. The advertising procedure
+ *       cannot however be connectable (it must be of type @ref BLE_GAP_ADV_TYPE_ADV_SCAN_IND or
+ *       @ref BLE_GAP_ADV_TYPE_ADV_NONCONN_IND). @note Only one advertiser may be active at any time.
+ *
+ * @events
+ * @event{@ref BLE_GAP_EVT_CONNECTED, Generated after connection has been established through connectable advertising.}
+ * @event{@ref BLE_GAP_EVT_TIMEOUT, Advertisement has timed out.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_ADV_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_CONN_PRIV_MSC}
+ * @mmsc{@ref BLE_GAP_PRIVACY_ADV_DIR_PRIV_MSC}
+ * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
+ * @endmscs
+ *
+ * @param[in] p_adv_params Pointer to advertising parameters structure.
+ *
+ * @retval ::NRF_SUCCESS The BLE stack has started advertising.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::NRF_ERROR_CONN_COUNT The limit of available connections has been reached; connectable advertiser cannot be started.
+ * @retval ::NRF_ERROR_NO_MEM The configured memory pools (see @ref ble_conn_bw_counts_t) are not large enough for the
+ *                            bandwidth selected for this connection.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check the accepted ranges and limits.
+ * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid Bluetooth address supplied.
+ * @retval ::BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST Discoverable mode and whitelist incompatible.
+ * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
+ * @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available.
+ *                               Stop one or more currently active roles (Central, Peripheral or Observer) and try again
+ */
+SVCALL(SD_BLE_GAP_ADV_START, uint32_t, sd_ble_gap_adv_start(ble_gap_adv_params_t const *p_adv_params));
+
+
+/**@brief Stop advertising (GAP Discoverable, Connectable modes, Broadcast Procedure).
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_ADV_MSC}
+ * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
+ * @endmscs
+ *
+ * @retval ::NRF_SUCCESS The BLE stack has stopped advertising.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation (most probably not in advertising state).
+ */
+SVCALL(SD_BLE_GAP_ADV_STOP, uint32_t, sd_ble_gap_adv_stop(void));
+
+
+/**@brief Update connection parameters.
+ *
+ * @details In the central role this will initiate a Link Layer connection parameter update procedure,
+ *          otherwise in the peripheral role, this will send the corresponding L2CAP request and wait for
+ *          the central to perform the procedure. In both cases, and regardless of success or failure, the application
+ *          will be informed of the result with a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE event.
+ *
+ * @details This function can be used as a central both to reply to a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST or to start the procedure unrequested.
+ *
+ * @events
+ * @event{@ref BLE_GAP_EVT_CONN_PARAM_UPDATE, Result of the connection parameter update procedure.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_CPU_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_ENC_AUTH_MUTEX_MSC}
+ * @mmsc{@ref BLE_GAP_MULTILINK_CPU_MSC}
+ * @mmsc{@ref BLE_GAP_MULTILINK_CTRL_PROC_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_CPU_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] p_conn_params  Pointer to desired connection parameters. If NULL is provided on a peripheral role,
+ *                           the parameters in the PPCP characteristic of the GAP service will be used instead.
+ *                           If NULL is provided on a central role and in response to a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST, the peripheral request will be rejected
+ *
+ * @retval ::NRF_SUCCESS The Connection Update procedure has been started successfully.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check parameter limits and constraints.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::NRF_ERROR_BUSY Procedure already in progress or not allowed at this time, process pending events and wait for pending procedures to complete and retry.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ * @retval ::NRF_ERROR_NO_MEM Not enough memory to complete operation.
+ */
+SVCALL(SD_BLE_GAP_CONN_PARAM_UPDATE, uint32_t, sd_ble_gap_conn_param_update(uint16_t conn_handle, ble_gap_conn_params_t const *p_conn_params));
+
+
+/**@brief Disconnect (GAP Link Termination).
+ *
+ * @details This call initiates the disconnection procedure, and its completion will be communicated to the application
+ *          with a @ref BLE_GAP_EVT_DISCONNECTED event.
+ *
+ * @events
+ * @event{@ref BLE_GAP_EVT_DISCONNECTED, Generated when disconnection procedure is complete.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_CONN_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] hci_status_code HCI status code, see @ref BLE_HCI_STATUS_CODES (accepted values are @ref BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION and @ref BLE_HCI_CONN_INTERVAL_UNACCEPTABLE).
+ *
+ * @retval ::NRF_SUCCESS The disconnection procedure has been started successfully.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation (disconnection is already in progress).
+ */
+SVCALL(SD_BLE_GAP_DISCONNECT, uint32_t, sd_ble_gap_disconnect(uint16_t conn_handle, uint8_t hci_status_code));
+
+
+/**@brief Set the radio's transmit power.
+ *
+ * @param[in] tx_power Radio transmit power in dBm (accepted values are -40, -30, -20, -16, -12, -8, -4, 0, 3, and 4 dBm).
+ *
+ * @note The +3dBm setting is only available on nRF52 series ICs.
+ * @note The -30dBm setting is only available on nRF51 series ICs.
+ * @note The -40dBm setting is only available on nRF52 series ICs.
+ *
+ * @retval ::NRF_SUCCESS Successfully changed the transmit power.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ */
+SVCALL(SD_BLE_GAP_TX_POWER_SET, uint32_t, sd_ble_gap_tx_power_set(int8_t tx_power));
+
+
+/**@brief Set GAP Appearance value.
+ *
+ * @param[in] appearance Appearance (16-bit), see @ref BLE_APPEARANCES.
+ *
+ * @retval ::NRF_SUCCESS  Appearance value set successfully.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ */
+SVCALL(SD_BLE_GAP_APPEARANCE_SET, uint32_t, sd_ble_gap_appearance_set(uint16_t appearance));
+
+
+/**@brief Get GAP Appearance value.
+ *
+ * @param[out] p_appearance Pointer to appearance (16-bit) to be filled in, see @ref BLE_APPEARANCES.
+ *
+ * @retval ::NRF_SUCCESS Appearance value retrieved successfully.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ */
+SVCALL(SD_BLE_GAP_APPEARANCE_GET, uint32_t, sd_ble_gap_appearance_get(uint16_t *p_appearance));
+
+
+/**@brief Set GAP Peripheral Preferred Connection Parameters.
+ *
+ * @param[in] p_conn_params Pointer to a @ref ble_gap_conn_params_t structure with the desired parameters.
+ *
+ * @retval ::NRF_SUCCESS Peripheral Preferred Connection Parameters set successfully.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ */
+SVCALL(SD_BLE_GAP_PPCP_SET, uint32_t, sd_ble_gap_ppcp_set(ble_gap_conn_params_t const *p_conn_params));
+
+
+/**@brief Get GAP Peripheral Preferred Connection Parameters.
+ *
+ * @param[out] p_conn_params Pointer to a @ref ble_gap_conn_params_t structure where the parameters will be stored.
+ *
+ * @retval ::NRF_SUCCESS Peripheral Preferred Connection Parameters retrieved successfully.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ */
+SVCALL(SD_BLE_GAP_PPCP_GET, uint32_t, sd_ble_gap_ppcp_get(ble_gap_conn_params_t *p_conn_params));
+
+
+/**@brief Set GAP device name.
+ *
+ * @param[in] p_write_perm Write permissions for the Device Name characteristic, see @ref ble_gap_conn_sec_mode_t.
+ * @param[in] p_dev_name Pointer to a UTF-8 encoded, <b>non NULL-terminated</b> string.
+ * @param[in] len Length of the UTF-8, <b>non NULL-terminated</b> string pointed to by p_dev_name in octets (must be smaller or equal than @ref BLE_GAP_DEVNAME_MAX_LEN).
+ *
+ * @note If the device name is located in application flash memory (see @ref ble_gap_device_name_t), it cannot be changed. Then @ref NRF_ERROR_FORBIDDEN will be returned.
+ *
+ * @retval ::NRF_SUCCESS GAP device name and permissions set successfully.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
+ * @retval ::NRF_ERROR_FORBIDDEN Device name is not writable.
+ */
+SVCALL(SD_BLE_GAP_DEVICE_NAME_SET, uint32_t, sd_ble_gap_device_name_set(ble_gap_conn_sec_mode_t const *p_write_perm, uint8_t const *p_dev_name, uint16_t len));
+
+
+/**@brief Get GAP device name.
+ *
+ * @note          If the device name is longer than the size of the supplied buffer,
+ *                p_len will return the complete device name length,
+ *                and not the number of bytes actually returned in p_dev_name.
+ *                The application may use this information to allocate a suitable buffer size.
+ *
+ * @param[out]    p_dev_name Pointer to an empty buffer where the UTF-8 <b>non NULL-terminated</b> string will be placed. Set to NULL to obtain the complete device name length.
+ * @param[in,out] p_len      Length of the buffer pointed by p_dev_name, complete device name length on output.
+ *
+ * @retval ::NRF_SUCCESS GAP device name retrieved successfully.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
+ */
+SVCALL(SD_BLE_GAP_DEVICE_NAME_GET, uint32_t, sd_ble_gap_device_name_get(uint8_t *p_dev_name, uint16_t *p_len));
+
+
+/**@brief Initiate the GAP Authentication procedure.
+ *
+ * @details In the central role, this function will send an SMP Pairing Request (or an SMP Pairing Failed if rejected),
+ *          otherwise in the peripheral role, an SMP Security Request will be sent.
+ *
+ * @events
+ * @event{Depending on the security parameters set and the packet exchanges with the peer\, the following events may be generated:}
+ * @event{@ref BLE_GAP_EVT_SEC_PARAMS_REQUEST}
+ * @event{@ref BLE_GAP_EVT_SEC_INFO_REQUEST}
+ * @event{@ref BLE_GAP_EVT_PASSKEY_DISPLAY}
+ * @event{@ref BLE_GAP_EVT_KEY_PRESSED}
+ * @event{@ref BLE_GAP_EVT_AUTH_KEY_REQUEST}
+ * @event{@ref BLE_GAP_EVT_LESC_DHKEY_REQUEST}
+ * @event{@ref BLE_GAP_EVT_CONN_SEC_UPDATE}
+ * @event{@ref BLE_GAP_EVT_AUTH_STATUS}
+ * @event{@ref BLE_GAP_EVT_TIMEOUT}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_SEC_REQ_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_SEC_REQ_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_ENC_AUTH_MUTEX_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_PAIRING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_PAIRING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_PD_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] p_sec_params Pointer to the @ref ble_gap_sec_params_t structure with the security parameters to be used during the pairing or bonding procedure.
+ *                         In the peripheral role, only the bond, mitm, lesc and keypress fields of this structure are used.
+ *                         In the central role, this pointer may be NULL to reject a Security Request.
+ *
+ * @retval ::NRF_SUCCESS Successfully initiated authentication procedure.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
+ * @retval ::NRF_ERROR_NO_MEM The maximum number of authentication procedures that can run in parallel for the given role is reached.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ * @retval ::NRF_ERROR_NOT_SUPPORTED Setting of sign or link fields in @ref ble_gap_sec_kdist_t not supported.
+ * @retval ::NRF_ERROR_TIMEOUT A SMP timeout has occurred, and further SMP operations on this link is prohibited.
+ */
+SVCALL(SD_BLE_GAP_AUTHENTICATE, uint32_t, sd_ble_gap_authenticate(uint16_t conn_handle, ble_gap_sec_params_t const *p_sec_params));
+
+
+/**@brief Reply with GAP security parameters.
+ *
+ * @details This function is only used to reply to a @ref BLE_GAP_EVT_SEC_PARAMS_REQUEST, calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE.
+ * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
+ *
+ * @events
+ * @event{This function is used during authentication procedures\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_BONDING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_BONDING_PK_PERIPH_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_BONDING_PK_CENTRAL_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_BONDING_STATIC_PK_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_CONFIRM_FAIL_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_PAIRING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_NC_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_PD_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_KS_TOO_SMALL_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_APP_ERROR_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_REMOTE_PAIRING_FAIL_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_PAIRING_TIMEOUT_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_PAIRING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_PAIRING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_PD_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] sec_status Security status, see @ref BLE_GAP_SEC_STATUS.
+ * @param[in] p_sec_params Pointer to a @ref ble_gap_sec_params_t security parameters structure. In the central role this must be set to NULL, as the parameters have
+ *                         already been provided during a previous call to @ref sd_ble_gap_authenticate.
+ * @param[in,out] p_sec_keyset Pointer to a @ref ble_gap_sec_keyset_t security keyset structure. Any keys generated and/or distributed as a result of the ongoing security procedure
+ *                         will be stored into the memory referenced by the pointers inside this structure. The keys will be stored and available to the application
+ *                         upon reception of a @ref BLE_GAP_EVT_AUTH_STATUS event.
+ *                         Note that the SoftDevice expects the application to provide memory for storing the
+ *                         peer's keys. So it must be ensured that the relevant pointers inside this structure are not NULL. The pointers to the local key
+ *                         can, however, be NULL, in which case, the local key data will not be available to the application upon reception of the
+ *                         @ref BLE_GAP_EVT_AUTH_STATUS event.
+ *
+ * @retval ::NRF_SUCCESS Successfully accepted security parameter from the application.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ * @retval ::NRF_ERROR_NOT_SUPPORTED Setting of sign or link fields in @ref ble_gap_sec_kdist_t not supported.
+ */
+SVCALL(SD_BLE_GAP_SEC_PARAMS_REPLY, uint32_t, sd_ble_gap_sec_params_reply(uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const *p_sec_params, ble_gap_sec_keyset_t const *p_sec_keyset));
+
+
+/**@brief Reply with an authentication key.
+ *
+ * @details This function is only used to reply to a @ref BLE_GAP_EVT_AUTH_KEY_REQUEST or a @ref BLE_GAP_EVT_PASSKEY_DISPLAY, calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE.
+ * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
+ *
+ * @events
+ * @event{This function is used during authentication procedures\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_BONDING_PK_CENTRAL_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_NC_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_BONDING_PK_PERIPH_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] key_type See @ref BLE_GAP_AUTH_KEY_TYPES.
+ * @param[in] p_key If key type is @ref BLE_GAP_AUTH_KEY_TYPE_NONE, then NULL.
+ *                  If key type is @ref BLE_GAP_AUTH_KEY_TYPE_PASSKEY, then a 6-byte ASCII string (digit 0..9 only, no NULL termination)
+ *                     or NULL when confirming LE Secure Connections Numeric Comparison.
+ *                  If key type is @ref BLE_GAP_AUTH_KEY_TYPE_OOB, then a 16-byte OOB key value in Little Endian format.
+ *
+ * @retval ::NRF_SUCCESS Authentication key successfully set.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ */
+SVCALL(SD_BLE_GAP_AUTH_KEY_REPLY, uint32_t, sd_ble_gap_auth_key_reply(uint16_t conn_handle, uint8_t key_type, uint8_t const *p_key));
+
+/**@brief Reply with an LE Secure connections DHKey.
+ *
+ * @details This function is only used to reply to a @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST, calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE.
+ * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
+ *
+ * @events
+ * @event{This function is used during authentication procedures\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_PAIRING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_NC_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_PD_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_PAIRING_JW_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_NC_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_PD_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] p_dhkey LE Secure Connections DHKey.
+ *
+ * @retval ::NRF_SUCCESS DHKey successfully set.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ */
+SVCALL(SD_BLE_GAP_LESC_DHKEY_REPLY, uint32_t, sd_ble_gap_lesc_dhkey_reply(uint16_t conn_handle, ble_gap_lesc_dhkey_t const *p_dhkey));
+
+/**@brief Notify the peer of a local keypress.
+ *
+ * @details This function can only be used when an authentication procedure using LE Secure Connection is in progress. Calling it at other times will result in an @ref NRF_ERROR_INVALID_STATE.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_PKE_CD_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_PKE_CD_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] kp_not See @ref BLE_GAP_KP_NOT_TYPES.
+ *
+ * @retval ::NRF_SUCCESS Keypress notification successfully queued for transmission.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation. Either not entering a passkey or keypresses have not been enabled by both peers.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ * @retval ::NRF_ERROR_BUSY The BLE stack is busy. Retry at later time.
+ */
+SVCALL(SD_BLE_GAP_KEYPRESS_NOTIFY, uint32_t, sd_ble_gap_keypress_notify(uint16_t conn_handle, uint8_t kp_not));
+
+/**@brief Generate a set of OOB data to send to a peer out of band.
+ *
+ * @note The @ref ble_gap_addr_t included in the OOB data returned will be the currently active one (or, if a connection has already been established,
+ *       the one used during connection setup). The application may manually overwrite it with an updated value.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle. Can be BLE_CONN_HANDLE_INVALID if a BLE connection has not been established yet.
+ * @param[in] p_pk_own LE Secure Connections local P-256 Public Key.
+ * @param[out] p_oobd_own The OOB data to be sent out of band to a peer.
+ *
+ * @retval ::NRF_SUCCESS OOB data successfully generated.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ */
+SVCALL(SD_BLE_GAP_LESC_OOB_DATA_GET, uint32_t, sd_ble_gap_lesc_oob_data_get(uint16_t conn_handle, ble_gap_lesc_p256_pk_t const *p_pk_own, ble_gap_lesc_oob_data_t *p_oobd_own));
+
+/**@brief Provide the OOB data sent/received out of band.
+ *
+ * @note At least one of the 2 pointers provided must be different from NULL.
+ * @note An authentication procedure with OOB selected as an algorithm must be in progress when calling this function.
+ * @note A @ref BLE_GAP_EVT_LESC_DHKEY_REQUEST event with the oobd_req set to 1 must have been received prior to calling this function.
+ *
+ * @events
+ * @event{This function is used during authentication procedures\, see the list of events in the documentation of @ref sd_ble_gap_authenticate.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_LESC_BONDING_OOB_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_LESC_BONDING_OOB_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] p_oobd_own The OOB data sent out of band to a peer or NULL if none sent.
+ * @param[in] p_oobd_peer The OOB data received out of band from a peer or NULL if none received.
+ *
+ * @retval ::NRF_SUCCESS OOB data accepted.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ */
+SVCALL(SD_BLE_GAP_LESC_OOB_DATA_SET, uint32_t, sd_ble_gap_lesc_oob_data_set(uint16_t conn_handle, ble_gap_lesc_oob_data_t const *p_oobd_own, ble_gap_lesc_oob_data_t const *p_oobd_peer));
+
+/**@brief Initiate GAP Encryption procedure.
+ *
+ * @details In the central role, this function will initiate the encryption procedure using the encryption information provided.
+ *
+ * @events
+ * @event{@ref BLE_GAP_EVT_CONN_SEC_UPDATE, The connection security has been updated.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_CENTRAL_ENC_AUTH_MUTEX_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_ENC_MSC}
+ * @mmsc{@ref BLE_GAP_MULTILINK_CTRL_PROC_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_SEC_REQ_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] p_master_id Pointer to a @ref ble_gap_master_id_t master identification structure.
+ * @param[in] p_enc_info  Pointer to a @ref ble_gap_enc_info_t encryption information structure.
+ *
+ * @retval ::NRF_SUCCESS Successfully initiated authentication procedure.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ * @retval ::BLE_ERROR_INVALID_ROLE Operation is not supported in the Peripheral role.
+ * @retval ::NRF_ERROR_BUSY Procedure already in progress or not allowed at this time, wait for pending procedures to complete and retry.
+ */
+SVCALL(SD_BLE_GAP_ENCRYPT, uint32_t, sd_ble_gap_encrypt(uint16_t conn_handle, ble_gap_master_id_t const *p_master_id, ble_gap_enc_info_t const *p_enc_info));
+
+
+/**@brief Reply with GAP security information.
+ *
+ * @details This function is only used to reply to a @ref BLE_GAP_EVT_SEC_INFO_REQUEST, calling it at other times will result in @ref NRF_ERROR_INVALID_STATE.
+ * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
+ * @note    Data signing is not yet supported, and p_sign_info must therefore be NULL.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_PERIPH_ENC_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ * @param[in] p_enc_info Pointer to a @ref ble_gap_enc_info_t encryption information structure. May be NULL to signal none is available.
+ * @param[in] p_id_info Pointer to a @ref ble_gap_irk_t identity information structure. May be NULL to signal none is available.
+ * @param[in] p_sign_info Pointer to a @ref ble_gap_sign_info_t signing information structure. May be NULL to signal none is available.
+ *
+ * @retval ::NRF_SUCCESS Successfully accepted security information.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ */
+SVCALL(SD_BLE_GAP_SEC_INFO_REPLY, uint32_t, sd_ble_gap_sec_info_reply(uint16_t conn_handle, ble_gap_enc_info_t const *p_enc_info, ble_gap_irk_t const *p_id_info, ble_gap_sign_info_t const *p_sign_info));
+
+
+/**@brief Get the current connection security.
+ *
+ * @param[in]  conn_handle Connection handle.
+ * @param[out] p_conn_sec  Pointer to a @ref ble_gap_conn_sec_t structure to be filled in.
+ *
+ * @retval ::NRF_SUCCESS Current connection security successfully retrieved.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ */
+SVCALL(SD_BLE_GAP_CONN_SEC_GET, uint32_t, sd_ble_gap_conn_sec_get(uint16_t conn_handle, ble_gap_conn_sec_t *p_conn_sec));
+
+
+/**@brief Start reporting the received signal strength to the application.
+ *
+ * A new event is reported whenever the RSSI value changes, until @ref sd_ble_gap_rssi_stop is called.
+ *
+ * @events
+ * @event{@ref BLE_GAP_EVT_RSSI_CHANGED, New RSSI data available. How often the event is generated is
+                                         dependent on the settings of the <code>threshold_dbm</code>
+                                         and <code>skip_count</code> input parameters.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_CENTRAL_RSSI_READ_MSC}
+ * @mmsc{@ref BLE_GAP_RSSI_FILT_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle        Connection handle.
+ * @param[in] threshold_dbm      Minimum change in dBm before triggering the @ref BLE_GAP_EVT_RSSI_CHANGED event. Events are disabled if threshold_dbm equals @ref BLE_GAP_RSSI_THRESHOLD_INVALID.
+ * @param[in] skip_count         Number of RSSI samples with a change of threshold_dbm or more before sending a new @ref BLE_GAP_EVT_RSSI_CHANGED event.
+ *
+ * @retval ::NRF_SUCCESS                   Successfully activated RSSI reporting.
+ * @retval ::NRF_ERROR_INVALID_STATE       Disconnection in progress. Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ */
+SVCALL(SD_BLE_GAP_RSSI_START, uint32_t, sd_ble_gap_rssi_start(uint16_t conn_handle, uint8_t threshold_dbm, uint8_t skip_count));
+
+
+/**@brief Stop reporting the received signal strength.
+ *
+ * @note An RSSI change detected before the call but not yet received by the application
+ * may be reported after @ref sd_ble_gap_rssi_stop has been called.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_CENTRAL_RSSI_READ_MSC}
+ * @mmsc{@ref BLE_GAP_RSSI_FILT_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection handle.
+ *
+ * @retval ::NRF_SUCCESS                   Successfully deactivated RSSI reporting.
+ * @retval ::NRF_ERROR_INVALID_STATE       Invalid state to perform operation.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ */
+SVCALL(SD_BLE_GAP_RSSI_STOP, uint32_t, sd_ble_gap_rssi_stop(uint16_t conn_handle));
+
+
+/**@brief Get the received signal strength for the last connection event.
+ *
+ * @ref sd_ble_gap_rssi_start must be called to start reporting RSSI before using this function. @ref NRF_ERROR_NOT_FOUND
+ * will be returned until RSSI was sampled for the first time after calling @ref sd_ble_gap_rssi_start.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_CENTRAL_RSSI_READ_MSC}
+ * @endmscs
+ *
+ * @param[in]  conn_handle Connection handle.
+ * @param[out] p_rssi      Pointer to the location where the RSSI measurement shall be stored.
+ *
+ * @retval ::NRF_SUCCESS                   Successfully read the RSSI.
+ * @retval ::NRF_ERROR_NOT_FOUND           No sample is available.
+ * @retval ::NRF_ERROR_INVALID_ADDR        Invalid pointer supplied.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE       RSSI reporting is not ongoing, or disconnection in progress.
+ */
+SVCALL(SD_BLE_GAP_RSSI_GET, uint32_t, sd_ble_gap_rssi_get(uint16_t conn_handle, int8_t *p_rssi));
+
+
+/**@brief Start scanning (GAP Discovery procedure, Observer Procedure).
+ *
+ *
+ * @events
+ * @event{@ref BLE_GAP_EVT_ADV_REPORT, An advertising or scan response packet has been received.}
+ * @event{@ref BLE_GAP_EVT_TIMEOUT, Scanner has timed out.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_SCAN_MSC}
+ * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
+ * @endmscs
+ *
+ * @param[in] p_scan_params Pointer to scan parameters structure.
+ *
+ * @retval ::NRF_SUCCESS Successfully initiated scanning procedure.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
+ * @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available.
+ *                               Stop one or more currently active roles (Central, Peripheral or Broadcaster) and try again
+ */
+SVCALL(SD_BLE_GAP_SCAN_START, uint32_t, sd_ble_gap_scan_start(ble_gap_scan_params_t const *p_scan_params));
+
+
+/**@brief Stop scanning (GAP Discovery procedure, Observer Procedure).
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_SCAN_MSC}
+ * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
+ * @endmscs
+ *
+ * @retval ::NRF_SUCCESS Successfully stopped scanning procedure.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation (most probably not in scanning state).
+ */
+SVCALL(SD_BLE_GAP_SCAN_STOP, uint32_t, sd_ble_gap_scan_stop(void));
+
+
+/**@brief Create a connection (GAP Link Establishment).
+ *
+ * @note If a scanning procedure is currently in progress it will be automatically stopped when calling this function.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_WL_SHARE_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_CONN_PRIV_MSC}
+ * @mmsc{@ref BLE_GAP_CENTRAL_CONN_MSC}
+ * @endmscs
+ *
+ * @param[in] p_peer_addr   Pointer to peer address. If the use_whitelist bit is set in @ref ble_gap_scan_params_t, then this is ignored.
+ *                          If @ref ble_gap_addr_t::addr_id_peer is set then p_peer_addr must be present in the device identity list
+ *                          see @ref sd_ble_gap_device_identities_set.
+ * @param[in] p_scan_params Pointer to scan parameters structure.
+ * @param[in] p_conn_params Pointer to desired connection parameters.
+ *
+ * @retval ::NRF_SUCCESS Successfully initiated connection procedure.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid parameter(s) pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+                                     - Invalid parameter(s) in p_scan_params or p_conn_params.
+                                     - Use of whitelist requested but whitelist has not been set, see @ref sd_ble_gap_whitelist_set.
+                                     - Peer address was not present in the device identity list, see @ref sd_ble_gap_device_identities_set.
+ * @retval ::NRF_ERROR_INVALID_STATE The SoftDevice is in an invalid state to perform this operation. This may be due to an
+ *                                   existing locally initiated connect procedure, which must complete before initiating again.
+ * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid Peer address.
+ * @retval ::NRF_ERROR_CONN_COUNT The limit of available connections has been reached.
+ * @retval ::NRF_ERROR_NO_MEM The configured memory pool (see @ref ble_conn_bw_counts_t) is not large enough for the
+ *                            bandwidth selected for this connection.
+ * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry. If another connection is being established
+ *                          wait for the corresponding @ref BLE_GAP_EVT_CONNECTED event before calling again.
+ * @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available.
+ *                               Stop one or more currently active roles (Central, Peripheral or Broadcaster) and try again
+ */
+SVCALL(SD_BLE_GAP_CONNECT, uint32_t, sd_ble_gap_connect(ble_gap_addr_t const *p_peer_addr, ble_gap_scan_params_t const *p_scan_params, ble_gap_conn_params_t const *p_conn_params));
+
+
+/**@brief Cancel a connection establishment.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GAP_CENTRAL_CONN_MSC}
+ * @endmscs
+ *
+ * @retval ::NRF_SUCCESS Successfully cancelled an ongoing connection procedure.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
+ */
+SVCALL(SD_BLE_GAP_CONNECT_CANCEL, uint32_t, sd_ble_gap_connect_cancel(void));
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+#endif // BLE_GAP_H__
+
+/**
+  @}
+*/
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers_replacement/ble_gattc.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers_replacement/ble_gattc.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers_replacement/ble_gattc.h  1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers_replacement/ble_gattc.h   2018-04-24 08:48:29.068156300 +0200
@@ -0,0 +1,674 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/**
+  @addtogroup BLE_GATTC Generic Attribute Profile (GATT) Client
+  @{
+  @brief  Definitions and prototypes for the GATT Client interface.
+ */
+
+#ifndef BLE_GATTC_H__
+#define BLE_GATTC_H__
+
+#include "ble_gatt.h"
+#include "ble_types.h"
+#include "ble_ranges.h"
+#include "nrf_svc.h"
+#include "nrf_error.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/** @addtogroup BLE_GATTC_ENUMERATIONS Enumerations
+ * @{ */
+
+/**@brief GATTC API SVC numbers. */
+enum BLE_GATTC_SVCS
+{
+  SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER = BLE_GATTC_SVC_BASE, /**< Primary Service Discovery. */
+  SD_BLE_GATTC_RELATIONSHIPS_DISCOVER,                         /**< Relationship Discovery. */
+  SD_BLE_GATTC_CHARACTERISTICS_DISCOVER,                       /**< Characteristic Discovery. */
+  SD_BLE_GATTC_DESCRIPTORS_DISCOVER,                           /**< Characteristic Descriptor Discovery. */
+  SD_BLE_GATTC_ATTR_INFO_DISCOVER,                             /**< Attribute Information Discovery. */
+  SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ,                        /**< Read Characteristic Value by UUID. */
+  SD_BLE_GATTC_READ,                                           /**< Generic read. */
+  SD_BLE_GATTC_CHAR_VALUES_READ,                               /**< Read multiple Characteristic Values. */
+  SD_BLE_GATTC_WRITE,                                          /**< Generic write. */
+  SD_BLE_GATTC_HV_CONFIRM,                                     /**< Handle Value Confirmation. */
+  SD_BLE_GATTC_EXCHANGE_MTU_REQUEST,                           /**< Exchange MTU Request. */
+};
+
+/**
+ * @brief GATT Client Event IDs.
+ */
+enum BLE_GATTC_EVTS
+{
+  BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP = BLE_GATTC_EVT_BASE,  /**< Primary Service Discovery Response event.      \n See @ref ble_gattc_evt_prim_srvc_disc_rsp_t.          */
+  BLE_GATTC_EVT_REL_DISC_RSP,                             /**< Relationship Discovery Response event.         \n See @ref ble_gattc_evt_rel_disc_rsp_t.                */
+  BLE_GATTC_EVT_CHAR_DISC_RSP,                            /**< Characteristic Discovery Response event.       \n See @ref ble_gattc_evt_char_disc_rsp_t.               */
+  BLE_GATTC_EVT_DESC_DISC_RSP,                            /**< Descriptor Discovery Response event.           \n See @ref ble_gattc_evt_desc_disc_rsp_t.               */
+  BLE_GATTC_EVT_ATTR_INFO_DISC_RSP,                       /**< Attribute Information Response event.          \n See @ref ble_gattc_evt_attr_info_disc_rsp_t. */
+  BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP,                /**< Read By UUID Response event.                   \n See @ref ble_gattc_evt_char_val_by_uuid_read_rsp_t.   */
+  BLE_GATTC_EVT_READ_RSP,                                 /**< Read Response event.                           \n See @ref ble_gattc_evt_read_rsp_t.                    */
+  BLE_GATTC_EVT_CHAR_VALS_READ_RSP,                       /**< Read multiple Response event.                  \n See @ref ble_gattc_evt_char_vals_read_rsp_t.          */
+  BLE_GATTC_EVT_WRITE_RSP,                                /**< Write Response event.                          \n See @ref ble_gattc_evt_write_rsp_t.                   */
+  BLE_GATTC_EVT_HVX,                                      /**< Handle Value Notification or Indication event. \n Confirm indication with @ref sd_ble_gattc_hv_confirm.  \n See @ref ble_gattc_evt_hvx_t. */
+  BLE_GATTC_EVT_EXCHANGE_MTU_RSP,                         /**< Exchange MTU Response event.                   \n See @ref ble_gattc_evt_exchange_mtu_rsp_t.            */
+  BLE_GATTC_EVT_TIMEOUT                                   /**< Timeout event.                                 \n See @ref ble_gattc_evt_timeout_t.                     */
+};
+
+/** @} */
+
+/** @addtogroup BLE_GATTC_DEFINES Defines
+ * @{ */
+
+/** @defgroup BLE_ERRORS_GATTC SVC return values specific to GATTC
+ * @{ */
+#define BLE_ERROR_GATTC_PROC_NOT_PERMITTED    (NRF_GATTC_ERR_BASE + 0x000) /**< Procedure not Permitted. */
+/** @} */
+
+/** @defgroup BLE_GATTC_ATTR_INFO_FORMAT Attribute Information Formats
+ * @{ */
+#define BLE_GATTC_ATTR_INFO_FORMAT_16BIT    1 /**< 16-bit Attribute Information Format. */
+#define BLE_GATTC_ATTR_INFO_FORMAT_128BIT   2 /**< 128-bit Attribute Information Format. */
+/** @} */
+
+/** @} */
+
+/** @addtogroup BLE_GATTC_STRUCTURES Structures
+ * @{ */
+
+/**@brief Operation Handle Range. */
+typedef struct
+{
+  uint16_t          start_handle; /**< Start Handle. */
+  uint16_t          end_handle;   /**< End Handle. */
+} ble_gattc_handle_range_t;
+
+
+/**@brief GATT service. */
+typedef struct
+{
+  ble_uuid_t               uuid;          /**< Service UUID. */
+  ble_gattc_handle_range_t handle_range;  /**< Service Handle Range. */
+} ble_gattc_service_t;
+
+
+/**@brief  GATT include. */
+typedef struct
+{
+  uint16_t            handle;           /**< Include Handle. */
+  ble_gattc_service_t included_srvc;    /**< Handle of the included service. */
+} ble_gattc_include_t;
+
+
+/**@brief GATT characteristic. */
+typedef struct
+{
+  ble_uuid_t              uuid;                 /**< Characteristic UUID. */
+  ble_gatt_char_props_t   char_props;           /**< Characteristic Properties. */
+  uint8_t                 char_ext_props : 1;   /**< Extended properties present. */
+  uint16_t                handle_decl;          /**< Handle of the Characteristic Declaration. */
+  uint16_t                handle_value;         /**< Handle of the Characteristic Value. */
+} ble_gattc_char_t;
+
+
+/**@brief GATT descriptor. */
+typedef struct
+{
+  uint16_t          handle;         /**< Descriptor Handle. */
+  ble_uuid_t        uuid;           /**< Descriptor UUID. */
+} ble_gattc_desc_t;
+
+
+/**@brief Write Parameters. */
+typedef struct
+{
+  uint8_t        write_op;             /**< Write Operation to be performed, see @ref BLE_GATT_WRITE_OPS. */
+  uint8_t        flags;                /**< Flags, see @ref BLE_GATT_EXEC_WRITE_FLAGS. */
+  uint16_t       handle;               /**< Handle to the attribute to be written. */
+  uint16_t       offset;               /**< Offset in bytes. @note For WRITE_CMD and WRITE_REQ, offset must be 0. */
+  uint16_t       len;                  /**< Length of data in bytes. */
+  uint8_t const *p_value;              /**< Pointer to the value data. */
+} ble_gattc_write_params_t;
+
+/**@brief Attribute Information for 16-bit Attribute UUID. */
+typedef struct
+{
+  uint16_t       handle;               /**< Attribute handle. */
+  ble_uuid_t     uuid;                 /**< 16-bit Attribute UUID. */
+} ble_gattc_attr_info16_t;
+
+/**@brief Attribute Information for 128-bit Attribute UUID. */
+typedef struct
+{
+  uint16_t       handle;               /**< Attribute handle. */
+  ble_uuid128_t  uuid;                 /**< 128-bit Attribute UUID. */
+} ble_gattc_attr_info128_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP. */
+typedef struct
+{
+  uint16_t             count;           /**< Service count. */
+  ble_gattc_service_t services[1];      /**< Service data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                             See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_prim_srvc_disc_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_REL_DISC_RSP. */
+typedef struct
+{
+  uint16_t             count;           /**< Include count. */
+  ble_gattc_include_t includes[1];      /**< Include data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                             See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_rel_disc_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_CHAR_DISC_RSP. */
+typedef struct
+{
+  uint16_t            count;          /**< Characteristic count. */
+  ble_gattc_char_t    chars[1];       /**< Characteristic data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                           See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_char_disc_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_DESC_DISC_RSP. */
+typedef struct
+{
+  uint16_t            count;          /**< Descriptor count. */
+  ble_gattc_desc_t    descs[1];       /**< Descriptor data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                           See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_desc_disc_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_ATTR_INFO_DISC_RSP. */
+typedef struct
+{
+  uint16_t                     count;            /**< Attribute count. */
+  uint8_t                      format;           /**< Attribute information format, see @ref BLE_GATTC_ATTR_INFO_FORMAT. */
+  union {
+    ble_gattc_attr_info16_t  attr_info16[1];     /**< Attribute information for 16-bit Attribute UUID.
+                                                      @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                                      See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+    ble_gattc_attr_info128_t attr_info128[1];    /**< Attribute information for 128-bit Attribute UUID.
+                                                      @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                                      See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+  } info;                                        /**< Attribute information union. */
+} ble_gattc_evt_attr_info_disc_rsp_t;
+
+/**@brief GATT read by UUID handle value pair. */
+typedef struct
+{
+  uint16_t            handle;          /**< Attribute Handle. */
+  uint8_t            *p_value;         /**< Pointer to the Attribute Value, length is available in @ref ble_gattc_evt_char_val_by_uuid_read_rsp_t::value_len. */
+} ble_gattc_handle_value_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP. */
+typedef struct
+{
+  uint16_t                  count;            /**< Handle-Value Pair Count. */
+  uint16_t                  value_len;        /**< Length of the value in Handle-Value(s) list. */
+  uint8_t                   handle_value[1];  /**< Handle-Value(s) list. To iterate through the list use @ref sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter.
+                                                   @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                                   See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_char_val_by_uuid_read_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_READ_RSP. */
+typedef struct
+{
+  uint16_t            handle;         /**< Attribute Handle. */
+  uint16_t            offset;         /**< Offset of the attribute data. */
+  uint16_t            len;            /**< Attribute data length. */
+  uint8_t             data[1];        /**< Attribute data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                           See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_read_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_CHAR_VALS_READ_RSP. */
+typedef struct
+{
+  uint16_t            len;            /**< Concatenated Attribute values length. */
+  uint8_t             values[1];      /**< Attribute values. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                           See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_char_vals_read_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_WRITE_RSP. */
+typedef struct
+{
+  uint16_t            handle;           /**< Attribute Handle. */
+  uint8_t             write_op;         /**< Type of write operation, see @ref BLE_GATT_WRITE_OPS. */
+  uint16_t            offset;           /**< Data offset. */
+  uint16_t            len;              /**< Data length. */
+  uint8_t             data[1];          /**< Data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                             See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_write_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_HVX. */
+typedef struct
+{
+  uint16_t            handle;         /**< Handle to which the HVx operation applies. */
+  uint8_t             type;           /**< Indication or Notification, see @ref BLE_GATT_HVX_TYPES. */
+  uint16_t            len;            /**< Attribute data length. */
+  uint8_t             data[1];        /**< Attribute data. @note This is a variable length array. The size of 1 indicated is only a placeholder for compilation.
+                                           See @ref sd_ble_evt_get for more information on how to use event structures with variable length array members. */
+} ble_gattc_evt_hvx_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_EXCHANGE_MTU_RSP. */
+typedef struct
+{
+  uint16_t          server_rx_mtu;            /**< Server RX MTU size. */
+} ble_gattc_evt_exchange_mtu_rsp_t;
+
+/**@brief Event structure for @ref BLE_GATTC_EVT_TIMEOUT. */
+typedef struct
+{
+  uint8_t          src;                       /**< Timeout source, see @ref BLE_GATT_TIMEOUT_SOURCES. */
+} ble_gattc_evt_timeout_t;
+
+/**@brief GATTC event structure. */
+typedef struct
+{
+  uint16_t            conn_handle;                /**< Connection Handle on which event occured. */
+  uint16_t            gatt_status;                /**< GATT status code for the operation, see @ref BLE_GATT_STATUS_CODES. */
+  uint16_t            error_handle;               /**< In case of error: The handle causing the error. In all other cases @ref BLE_GATT_HANDLE_INVALID. */
+  union
+  {
+    ble_gattc_evt_prim_srvc_disc_rsp_t          prim_srvc_disc_rsp;         /**< Primary Service Discovery Response Event Parameters. */
+    ble_gattc_evt_rel_disc_rsp_t                rel_disc_rsp;               /**< Relationship Discovery Response Event Parameters. */
+    ble_gattc_evt_char_disc_rsp_t               char_disc_rsp;              /**< Characteristic Discovery Response Event Parameters. */
+    ble_gattc_evt_desc_disc_rsp_t               desc_disc_rsp;              /**< Descriptor Discovery Response Event Parameters. */
+    ble_gattc_evt_char_val_by_uuid_read_rsp_t   char_val_by_uuid_read_rsp;  /**< Characteristic Value Read by UUID Response Event Parameters. */
+    ble_gattc_evt_read_rsp_t                    read_rsp;                   /**< Read Response Event Parameters. */
+    ble_gattc_evt_char_vals_read_rsp_t          char_vals_read_rsp;         /**< Characteristic Values Read Response Event Parameters. */
+    ble_gattc_evt_write_rsp_t                   write_rsp;                  /**< Write Response Event Parameters. */
+    ble_gattc_evt_hvx_t                         hvx;                        /**< Handle Value Notification/Indication Event Parameters. */
+    ble_gattc_evt_exchange_mtu_rsp_t            exchange_mtu_rsp;           /**< Exchange MTU Response Event Parameters. */
+    ble_gattc_evt_timeout_t                     timeout;                    /**< Timeout Event Parameters. */
+    ble_gattc_evt_attr_info_disc_rsp_t          attr_info_disc_rsp;         /**< Attribute Information Discovery Event Parameters. */
+  } params;                                                                 /**< Event Parameters. @note Only valid if @ref gatt_status == @ref BLE_GATT_STATUS_SUCCESS. */
+} ble_gattc_evt_t;
+/** @} */
+
+/** @addtogroup BLE_GATTC_FUNCTIONS Functions
+ * @{ */
+
+/**@brief Initiate or continue a GATT Primary Service Discovery procedure.
+ *
+ * @details This function initiates or resumes a Primary Service discovery procedure, starting from the supplied handle.
+ *          If the last service has not been reached, this function must be called again with an updated start handle value to continue the search.
+ *
+ * @note If any of the discovered services have 128-bit UUIDs which are not present in the table provided to ble_vs_uuids_assign, a UUID structure with
+ *       type @ref BLE_UUID_TYPE_UNKNOWN will be received in the corresponding event.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_PRIM_SRVC_DISC_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] start_handle Handle to start searching from.
+ * @param[in] p_srvc_uuid Pointer to the service UUID to be found. If it is NULL, all primary services will be returned.
+ *
+ * @retval ::NRF_SUCCESS Successfully started or resumed the Primary Service Discovery procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER, uint32_t, sd_ble_gattc_primary_services_discover(uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const *p_srvc_uuid));
+
+
+/**@brief Initiate or continue a GATT Relationship Discovery procedure.
+ *
+ * @details This function initiates or resumes the Find Included Services sub-procedure. If the last included service has not been reached,
+ *          this must be called again with an updated handle range to continue the search.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_REL_DISC_RSP}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_REL_DISC_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] p_handle_range A pointer to the range of handles of the Service to perform this procedure on.
+ *
+ * @retval ::NRF_SUCCESS Successfully started or resumed the Relationship Discovery procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_RELATIONSHIPS_DISCOVER, uint32_t, sd_ble_gattc_relationships_discover(uint16_t conn_handle, ble_gattc_handle_range_t const *p_handle_range));
+
+
+/**@brief Initiate or continue a GATT Characteristic Discovery procedure.
+ *
+ * @details This function initiates or resumes a Characteristic discovery procedure. If the last Characteristic has not been reached,
+ *          this must be called again with an updated handle range to continue the discovery.
+ *
+ * @note If any of the discovered characteristics have 128-bit UUIDs which are not present in the table provided to ble_vs_uuids_assign, a UUID structure with
+ *       type @ref BLE_UUID_TYPE_UNKNOWN will be received in the corresponding event.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_CHAR_DISC_RSP}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_CHAR_DISC_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] p_handle_range A pointer to the range of handles of the Service to perform this procedure on.
+ *
+ * @retval ::NRF_SUCCESS Successfully started or resumed the Characteristic Discovery procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_CHARACTERISTICS_DISCOVER, uint32_t, sd_ble_gattc_characteristics_discover(uint16_t conn_handle, ble_gattc_handle_range_t const *p_handle_range));
+
+
+/**@brief Initiate or continue a GATT Characteristic Descriptor Discovery procedure.
+ *
+ * @details This function initiates or resumes a Characteristic Descriptor discovery procedure. If the last Descriptor has not been reached,
+ *          this must be called again with an updated handle range to continue the discovery.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_DESC_DISC_RSP}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_DESC_DISC_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] p_handle_range A pointer to the range of handles of the Characteristic to perform this procedure on.
+ *
+ * @retval ::NRF_SUCCESS Successfully started or resumed the Descriptor Discovery procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_DESCRIPTORS_DISCOVER, uint32_t, sd_ble_gattc_descriptors_discover(uint16_t conn_handle, ble_gattc_handle_range_t const *p_handle_range));
+
+
+/**@brief Initiate or continue a GATT Read using Characteristic UUID procedure.
+ *
+ * @details This function initiates or resumes a Read using Characteristic UUID procedure. If the last Characteristic has not been reached,
+ *          this must be called again with an updated handle range to continue the discovery.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_READ_UUID_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] p_uuid Pointer to a Characteristic value UUID to read.
+ * @param[in] p_handle_range A pointer to the range of handles to perform this procedure on.
+ *
+ * @retval ::NRF_SUCCESS Successfully started or resumed the Read using Characteristic UUID procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ, uint32_t, sd_ble_gattc_char_value_by_uuid_read(uint16_t conn_handle, ble_uuid_t const *p_uuid, ble_gattc_handle_range_t const *p_handle_range));
+
+
+/**@brief Initiate or continue a GATT Read (Long) Characteristic or Descriptor procedure.
+ *
+ * @details This function initiates or resumes a GATT Read (Long) Characteristic or Descriptor procedure. If the Characteristic or Descriptor
+ *          to be read is longer than ATT_MTU - 1, this function must be called multiple times with appropriate offset to read the
+ *          complete value.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_READ_RSP}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_VALUE_READ_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] handle The handle of the attribute to be read.
+ * @param[in] offset Offset into the attribute value to be read.
+ *
+ * @retval ::NRF_SUCCESS Successfully started or resumed the Read (Long) procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_READ, uint32_t, sd_ble_gattc_read(uint16_t conn_handle, uint16_t handle, uint16_t offset));
+
+
+/**@brief Initiate a GATT Read Multiple Characteristic Values procedure.
+ *
+ * @details This function initiates a GATT Read Multiple Characteristic Values procedure.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_CHAR_VALS_READ_RSP}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_READ_MULT_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] p_handles A pointer to the handle(s) of the attribute(s) to be read.
+ * @param[in] handle_count The number of handles in p_handles.
+ *
+ * @retval ::NRF_SUCCESS Successfully started the Read Multiple Characteristic Values procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_CHAR_VALUES_READ, uint32_t, sd_ble_gattc_char_values_read(uint16_t conn_handle, uint16_t const *p_handles, uint16_t handle_count));
+
+
+/**@brief Perform a Write (Characteristic Value or Descriptor, with or without response, signed or not, long or reliable) procedure.
+ *
+ * @details This function can perform all write procedures described in GATT.
+ *
+ * @note    It is important to note that a write without response will <b>consume an application buffer</b>, and will therefore
+ *          generate a @ref BLE_EVT_TX_COMPLETE event when the packet has been transmitted. A write (with response) on the other hand will use the
+ *          standard client internal buffer and thus will only generate a @ref BLE_GATTC_EVT_WRITE_RSP event as soon as the write response
+ *          has been received from the peer. Please see the documentation of @ref sd_ble_tx_packet_count_get for more details.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_WRITE_RSP, Generated when using write request or queued writes.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_VALUE_WRITE_MSC}
+ * @mmsc{@ref BLE_GATTC_VALUE_LONG_WRITE_MSC}
+ * @mmsc{@ref BLE_GATTC_VALUE_RELIABLE_WRITE_MSC}
+ * @mmsc{@ref BLE_COMMON_APP_BUFF_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] p_write_params A pointer to a write parameters structure.
+ *
+ * @retval ::NRF_SUCCESS Successfully started the Write procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State.
+ * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
+ * @retval ::NRF_ERROR_BUSY Procedure already in progress.
+ * @retval ::BLE_ERROR_NO_TX_PACKETS No available application packets for this connection.
+ */
+SVCALL(SD_BLE_GATTC_WRITE, uint32_t, sd_ble_gattc_write(uint16_t conn_handle, ble_gattc_write_params_t const *p_write_params));
+
+
+/**@brief Send a Handle Value Confirmation to the GATT Server.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_HVI_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
+ * @param[in] handle The handle of the attribute in the indication.
+ *
+ * @retval ::NRF_SUCCESS Successfully queued the Handle Value Confirmation for transmission.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State or no Indication pending to be confirmed.
+ * @retval ::BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle.
+ */
+SVCALL(SD_BLE_GATTC_HV_CONFIRM, uint32_t, sd_ble_gattc_hv_confirm(uint16_t conn_handle, uint16_t handle));
+
+/**@brief Discovers information about a range of attributes on a GATT server.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_ATTR_INFO_DISC_RSP, Generated when information about a range of attributes has been received.}
+ * @endevents
+ *
+ * @param[in] conn_handle    The connection handle identifying the connection to perform this procedure on.
+ * @param[in] p_handle_range The range of handles to request information about.
+ *
+ * @retval ::NRF_SUCCESS Successfully started an attribute information discovery procedure.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid connection state
+ * @retval ::NRF_ERROR_INVALID_ADDR  Invalid pointer supplied.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_ATTR_INFO_DISCOVER, uint32_t, sd_ble_gattc_attr_info_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * p_handle_range));
+
+/**@brief Start an ATT_MTU exchange by sending an Exchange MTU Request to the server.
+ *
+ * @details The SoftDevice sets ATT_MTU to the minimum of:
+ *          - The Client RX MTU value, and
+ *          - The Server RX MTU value from @ref BLE_GATTC_EVT_EXCHANGE_MTU_RSP.
+ *
+ *          However, the SoftDevice never sets ATT_MTU lower than @ref GATT_MTU_SIZE_DEFAULT.
+ *
+ * @events
+ * @event{@ref BLE_GATTC_EVT_EXCHANGE_MTU_RSP}
+ * @event{@ref BLE_EVT_DATA_LENGTH_CHANGED, Generated if a data length update procedure is performed after the ATT_MTU exchange.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_GATTC_MTU_EXCHANGE}
+ * @endmscs
+ *
+ * @param[in] conn_handle    The connection handle identifying the connection to perform this procedure on.
+ * @param[in] client_rx_mtu  Client RX MTU size.
+ *                           - The minimum value is @ref GATT_MTU_SIZE_DEFAULT.
+ *                           - The maximum value is @ref ble_gatt_enable_params_t::att_mtu.
+ *                           - The value must be equal to Server RX MTU size given in @ref sd_ble_gatts_exchange_mtu_reply
+ *                             if an ATT_MTU exchange has already been performed in the other direction.
+ *
+ * @retval ::NRF_SUCCESS Successfully sent request to the server.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle.
+ * @retval ::NRF_ERROR_INVALID_STATE Invalid connection state or an ATT_MTU exchange was already requested once.
+ * @retval ::NRF_ERROR_INVALID_PARAM Invalid Client RX MTU size supplied.
+ * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
+ */
+SVCALL(SD_BLE_GATTC_EXCHANGE_MTU_REQUEST, uint32_t, sd_ble_gattc_exchange_mtu_request(uint16_t conn_handle, uint16_t client_rx_mtu));
+
+/**@brief Iterate through Handle-Value(s) list in @ref BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP event.
+ *
+ * @param[in] p_gattc_evt  Pointer to event buffer containing @ref BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP event.
+ *                         @note If the buffer contains different event, behavior is undefined.
+ * @param[in,out] p_iter   Iterator, points to @ref ble_gattc_handle_value_t structure that will be filled in with
+ *                         the next Handle-Value pair in each iteration. If the function returns other than
+ *                         @ref NRF_SUCCESS, it will not be changed.
+ *                         - To start iteration, initialize the structure to zero.
+ *                         - To continue, pass the value from previous iteration.
+ *
+ * \code
+ * ble_gattc_handle_value_t iter;
+ * memset(&iter, 0, sizeof(ble_gattc_handle_value_t));
+ * while (sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter(&ble_evt.evt.gattc_evt, &iter) == NRF_SUCCESS)
+ * {
+ *   app_handle = iter.handle;
+ *   memcpy(app_value, iter.p_value, ble_evt.evt.gattc_evt.params.char_val_by_uuid_read_rsp.value_len);
+ * }
+ * \endcode
+ *
+ * @retval ::NRF_SUCCESS Successfully retrieved the next Handle-Value pair.
+ * @retval ::NRF_ERROR_NOT_FOUND No more Handle-Value pairs available in the list.
+ */
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE static inline
+#endif
+#if (__LINT__ != 1)
+__STATIC_INLINE uint32_t sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter(ble_gattc_evt_t *p_gattc_evt, ble_gattc_handle_value_t *p_iter);
+#endif // #ifdef (__LINT__ != 1)
+
+
+#ifndef SUPPRESS_INLINE_IMPLEMENTATION
+
+__STATIC_INLINE uint32_t sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter(ble_gattc_evt_t *p_gattc_evt, ble_gattc_handle_value_t *p_iter)
+{
+  uint32_t value_len = p_gattc_evt->params.char_val_by_uuid_read_rsp.value_len;
+  uint8_t *p_first = p_gattc_evt->params.char_val_by_uuid_read_rsp.handle_value;
+  uint8_t *p_next = p_iter->p_value ? p_iter->p_value + value_len : p_first;
+
+  if ((p_next - p_first) / (sizeof(uint16_t) + value_len) < p_gattc_evt->params.char_val_by_uuid_read_rsp.count)
+  {
+    p_iter->handle = (uint16_t)p_next[1] << 8 | p_next[0];
+    p_iter->p_value = p_next + sizeof(uint16_t);
+    return NRF_SUCCESS;
+  }
+  else
+  {
+    return NRF_ERROR_NOT_FOUND;
+  }
+}
+
+#endif // #ifndef SUPPRESS_INLINE_IMPLEMENTATION
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* BLE_GATTC_H__ */
+
+/**
+  @}
+*/
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers_replacement/mocks/mock_ble_gap.c nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers_replacement/mocks/mock_ble_gap.c
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers_replacement/mocks/mock_ble_gap.c 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers_replacement/mocks/mock_ble_gap.c  2018-04-24 08:48:29.098156900 +0200
@@ -0,0 +1,4883 @@
+/*lint -e???? -save */
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#include <string.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include "unity.h"
+#include "cmock.h"
+#include "mock_ble_gap.h"
+
+typedef struct _CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_addr_t const* Expected_p_addr;
+  int Expected_p_addr_Depth;
+  int ReturnThruPtr_p_addr_Used;
+  ble_gap_addr_t const* ReturnThruPtr_p_addr_Val;
+  int ReturnThruPtr_p_addr_Size;
+  int IgnoreArg_p_addr;
+
+} CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_addr_t* Expected_p_addr;
+  int Expected_p_addr_Depth;
+  int ReturnThruPtr_p_addr_Used;
+  ble_gap_addr_t* ReturnThruPtr_p_addr_Val;
+  int ReturnThruPtr_p_addr_Size;
+  int IgnoreArg_p_addr;
+
+} CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_addr_t const* const* Expected_pp_wl_addrs;
+  uint8_t Expected_len;
+  int Expected_pp_wl_addrs_Depth;
+  int ReturnThruPtr_pp_wl_addrs_Used;
+  ble_gap_addr_t const* const* ReturnThruPtr_pp_wl_addrs_Val;
+  int ReturnThruPtr_pp_wl_addrs_Size;
+  int IgnoreArg_pp_wl_addrs;
+  int IgnoreArg_len;
+
+} CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_id_key_t const* const* Expected_pp_id_keys;
+  ble_gap_irk_t const* const* Expected_pp_local_irks;
+  uint8_t Expected_len;
+  int Expected_pp_id_keys_Depth;
+  int Expected_pp_local_irks_Depth;
+  int ReturnThruPtr_pp_id_keys_Used;
+  ble_gap_id_key_t const* const* ReturnThruPtr_pp_id_keys_Val;
+  int ReturnThruPtr_pp_id_keys_Size;
+  int ReturnThruPtr_pp_local_irks_Used;
+  ble_gap_irk_t const* const* ReturnThruPtr_pp_local_irks_Val;
+  int ReturnThruPtr_pp_local_irks_Size;
+  int IgnoreArg_pp_id_keys;
+  int IgnoreArg_pp_local_irks;
+  int IgnoreArg_len;
+
+} CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_privacy_params_t const* Expected_p_privacy_params;
+  int Expected_p_privacy_params_Depth;
+  int ReturnThruPtr_p_privacy_params_Used;
+  ble_gap_privacy_params_t const* ReturnThruPtr_p_privacy_params_Val;
+  int ReturnThruPtr_p_privacy_params_Size;
+  int IgnoreArg_p_privacy_params;
+
+} CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_privacy_params_t* Expected_p_privacy_params;
+  int Expected_p_privacy_params_Depth;
+  int ReturnThruPtr_p_privacy_params_Used;
+  ble_gap_privacy_params_t* ReturnThruPtr_p_privacy_params_Val;
+  int ReturnThruPtr_p_privacy_params_Size;
+  int IgnoreArg_p_privacy_params;
+
+} CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t const* Expected_p_data;
+  uint8_t Expected_dlen;
+  uint8_t const* Expected_p_sr_data;
+  uint8_t Expected_srdlen;
+  int Expected_p_data_Depth;
+  int Expected_p_sr_data_Depth;
+  int ReturnThruPtr_p_data_Used;
+  uint8_t const* ReturnThruPtr_p_data_Val;
+  int ReturnThruPtr_p_data_Size;
+  int ReturnThruPtr_p_sr_data_Used;
+  uint8_t const* ReturnThruPtr_p_sr_data_Val;
+  int ReturnThruPtr_p_sr_data_Size;
+  int IgnoreArg_p_data;
+  int IgnoreArg_dlen;
+  int IgnoreArg_p_sr_data;
+  int IgnoreArg_srdlen;
+
+} CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_adv_params_t const* Expected_p_adv_params;
+  int Expected_p_adv_params_Depth;
+  int ReturnThruPtr_p_adv_params_Used;
+  ble_gap_adv_params_t const* ReturnThruPtr_p_adv_params_Val;
+  int ReturnThruPtr_p_adv_params_Size;
+  int IgnoreArg_p_adv_params;
+
+} CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+
+} CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gap_conn_params_t const* Expected_p_conn_params;
+  int Expected_p_conn_params_Depth;
+  int ReturnThruPtr_p_conn_params_Used;
+  ble_gap_conn_params_t const* ReturnThruPtr_p_conn_params_Val;
+  int ReturnThruPtr_p_conn_params_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_conn_params;
+
+} CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint8_t Expected_hci_status_code;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_hci_status_code;
+
+} CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  int8_t Expected_tx_power;
+  int IgnoreArg_tx_power;
+
+} CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_appearance;
+  int IgnoreArg_appearance;
+
+} CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t* Expected_p_appearance;
+  int Expected_p_appearance_Depth;
+  int ReturnThruPtr_p_appearance_Used;
+  uint16_t* ReturnThruPtr_p_appearance_Val;
+  int ReturnThruPtr_p_appearance_Size;
+  int IgnoreArg_p_appearance;
+
+} CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_conn_params_t const* Expected_p_conn_params;
+  int Expected_p_conn_params_Depth;
+  int ReturnThruPtr_p_conn_params_Used;
+  ble_gap_conn_params_t const* ReturnThruPtr_p_conn_params_Val;
+  int ReturnThruPtr_p_conn_params_Size;
+  int IgnoreArg_p_conn_params;
+
+} CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_conn_params_t* Expected_p_conn_params;
+  int Expected_p_conn_params_Depth;
+  int ReturnThruPtr_p_conn_params_Used;
+  ble_gap_conn_params_t* ReturnThruPtr_p_conn_params_Val;
+  int ReturnThruPtr_p_conn_params_Size;
+  int IgnoreArg_p_conn_params;
+
+} CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_conn_sec_mode_t const* Expected_p_write_perm;
+  uint8_t const* Expected_p_dev_name;
+  uint16_t Expected_len;
+  int Expected_p_write_perm_Depth;
+  int Expected_p_dev_name_Depth;
+  int ReturnThruPtr_p_write_perm_Used;
+  ble_gap_conn_sec_mode_t const* ReturnThruPtr_p_write_perm_Val;
+  int ReturnThruPtr_p_write_perm_Size;
+  int ReturnThruPtr_p_dev_name_Used;
+  uint8_t const* ReturnThruPtr_p_dev_name_Val;
+  int ReturnThruPtr_p_dev_name_Size;
+  int IgnoreArg_p_write_perm;
+  int IgnoreArg_p_dev_name;
+  int IgnoreArg_len;
+
+} CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint8_t* Expected_p_dev_name;
+  uint16_t* Expected_p_len;
+  int Expected_p_dev_name_Depth;
+  int Expected_p_len_Depth;
+  int ReturnThruPtr_p_dev_name_Used;
+  uint8_t* ReturnThruPtr_p_dev_name_Val;
+  int ReturnThruPtr_p_dev_name_Size;
+  int ReturnThruPtr_p_len_Used;
+  uint16_t* ReturnThruPtr_p_len_Val;
+  int ReturnThruPtr_p_len_Size;
+  int IgnoreArg_p_dev_name;
+  int IgnoreArg_p_len;
+
+} CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gap_sec_params_t const* Expected_p_sec_params;
+  int Expected_p_sec_params_Depth;
+  int ReturnThruPtr_p_sec_params_Used;
+  ble_gap_sec_params_t const* ReturnThruPtr_p_sec_params_Val;
+  int ReturnThruPtr_p_sec_params_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_sec_params;
+
+} CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint8_t Expected_sec_status;
+  ble_gap_sec_params_t const* Expected_p_sec_params;
+  ble_gap_sec_keyset_t const* Expected_p_sec_keyset;
+  int Expected_p_sec_params_Depth;
+  int Expected_p_sec_keyset_Depth;
+  int ReturnThruPtr_p_sec_params_Used;
+  ble_gap_sec_params_t const* ReturnThruPtr_p_sec_params_Val;
+  int ReturnThruPtr_p_sec_params_Size;
+  int ReturnThruPtr_p_sec_keyset_Used;
+  ble_gap_sec_keyset_t const* ReturnThruPtr_p_sec_keyset_Val;
+  int ReturnThruPtr_p_sec_keyset_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_sec_status;
+  int IgnoreArg_p_sec_params;
+  int IgnoreArg_p_sec_keyset;
+
+} CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint8_t Expected_key_type;
+  uint8_t const* Expected_p_key;
+  int Expected_p_key_Depth;
+  int ReturnThruPtr_p_key_Used;
+  uint8_t const* ReturnThruPtr_p_key_Val;
+  int ReturnThruPtr_p_key_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_key_type;
+  int IgnoreArg_p_key;
+
+} CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gap_lesc_dhkey_t const* Expected_p_dhkey;
+  int Expected_p_dhkey_Depth;
+  int ReturnThruPtr_p_dhkey_Used;
+  ble_gap_lesc_dhkey_t const* ReturnThruPtr_p_dhkey_Val;
+  int ReturnThruPtr_p_dhkey_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_dhkey;
+
+} CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint8_t Expected_kp_not;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_kp_not;
+
+} CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gap_lesc_p256_pk_t const* Expected_p_pk_own;
+  ble_gap_lesc_oob_data_t* Expected_p_oobd_own;
+  int Expected_p_pk_own_Depth;
+  int Expected_p_oobd_own_Depth;
+  int ReturnThruPtr_p_pk_own_Used;
+  ble_gap_lesc_p256_pk_t const* ReturnThruPtr_p_pk_own_Val;
+  int ReturnThruPtr_p_pk_own_Size;
+  int ReturnThruPtr_p_oobd_own_Used;
+  ble_gap_lesc_oob_data_t* ReturnThruPtr_p_oobd_own_Val;
+  int ReturnThruPtr_p_oobd_own_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_pk_own;
+  int IgnoreArg_p_oobd_own;
+
+} CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gap_lesc_oob_data_t const* Expected_p_oobd_own;
+  ble_gap_lesc_oob_data_t const* Expected_p_oobd_peer;
+  int Expected_p_oobd_own_Depth;
+  int Expected_p_oobd_peer_Depth;
+  int ReturnThruPtr_p_oobd_own_Used;
+  ble_gap_lesc_oob_data_t const* ReturnThruPtr_p_oobd_own_Val;
+  int ReturnThruPtr_p_oobd_own_Size;
+  int ReturnThruPtr_p_oobd_peer_Used;
+  ble_gap_lesc_oob_data_t const* ReturnThruPtr_p_oobd_peer_Val;
+  int ReturnThruPtr_p_oobd_peer_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_oobd_own;
+  int IgnoreArg_p_oobd_peer;
+
+} CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gap_master_id_t const* Expected_p_master_id;
+  ble_gap_enc_info_t const* Expected_p_enc_info;
+  int Expected_p_master_id_Depth;
+  int Expected_p_enc_info_Depth;
+  int ReturnThruPtr_p_master_id_Used;
+  ble_gap_master_id_t const* ReturnThruPtr_p_master_id_Val;
+  int ReturnThruPtr_p_master_id_Size;
+  int ReturnThruPtr_p_enc_info_Used;
+  ble_gap_enc_info_t const* ReturnThruPtr_p_enc_info_Val;
+  int ReturnThruPtr_p_enc_info_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_master_id;
+  int IgnoreArg_p_enc_info;
+
+} CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gap_enc_info_t const* Expected_p_enc_info;
+  ble_gap_irk_t const* Expected_p_id_info;
+  ble_gap_sign_info_t const* Expected_p_sign_info;
+  int Expected_p_enc_info_Depth;
+  int Expected_p_id_info_Depth;
+  int Expected_p_sign_info_Depth;
+  int ReturnThruPtr_p_enc_info_Used;
+  ble_gap_enc_info_t const* ReturnThruPtr_p_enc_info_Val;
+  int ReturnThruPtr_p_enc_info_Size;
+  int ReturnThruPtr_p_id_info_Used;
+  ble_gap_irk_t const* ReturnThruPtr_p_id_info_Val;
+  int ReturnThruPtr_p_id_info_Size;
+  int ReturnThruPtr_p_sign_info_Used;
+  ble_gap_sign_info_t const* ReturnThruPtr_p_sign_info_Val;
+  int ReturnThruPtr_p_sign_info_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_enc_info;
+  int IgnoreArg_p_id_info;
+  int IgnoreArg_p_sign_info;
+
+} CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  ble_gap_conn_sec_t* Expected_p_conn_sec;
+  int Expected_p_conn_sec_Depth;
+  int ReturnThruPtr_p_conn_sec_Used;
+  ble_gap_conn_sec_t* ReturnThruPtr_p_conn_sec_Val;
+  int ReturnThruPtr_p_conn_sec_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_conn_sec;
+
+} CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  uint8_t Expected_threshold_dbm;
+  uint8_t Expected_skip_count;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_threshold_dbm;
+  int IgnoreArg_skip_count;
+
+} CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  int IgnoreArg_conn_handle;
+
+} CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  uint16_t Expected_conn_handle;
+  int8_t* Expected_p_rssi;
+  int Expected_p_rssi_Depth;
+  int ReturnThruPtr_p_rssi_Used;
+  int8_t* ReturnThruPtr_p_rssi_Val;
+  int ReturnThruPtr_p_rssi_Size;
+  int IgnoreArg_conn_handle;
+  int IgnoreArg_p_rssi;
+
+} CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_scan_params_t const* Expected_p_scan_params;
+  int Expected_p_scan_params_Depth;
+  int ReturnThruPtr_p_scan_params_Used;
+  ble_gap_scan_params_t const* ReturnThruPtr_p_scan_params_Val;
+  int ReturnThruPtr_p_scan_params_Size;
+  int IgnoreArg_p_scan_params;
+
+} CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+
+} CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_connect_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+  ble_gap_addr_t const* Expected_p_peer_addr;
+  ble_gap_scan_params_t const* Expected_p_scan_params;
+  ble_gap_conn_params_t const* Expected_p_conn_params;
+  int Expected_p_peer_addr_Depth;
+  int Expected_p_scan_params_Depth;
+  int Expected_p_conn_params_Depth;
+  int ReturnThruPtr_p_peer_addr_Used;
+  ble_gap_addr_t const* ReturnThruPtr_p_peer_addr_Val;
+  int ReturnThruPtr_p_peer_addr_Size;
+  int ReturnThruPtr_p_scan_params_Used;
+  ble_gap_scan_params_t const* ReturnThruPtr_p_scan_params_Val;
+  int ReturnThruPtr_p_scan_params_Size;
+  int ReturnThruPtr_p_conn_params_Used;
+  ble_gap_conn_params_t const* ReturnThruPtr_p_conn_params_Val;
+  int ReturnThruPtr_p_conn_params_Size;
+  int IgnoreArg_p_peer_addr;
+  int IgnoreArg_p_scan_params;
+  int IgnoreArg_p_conn_params;
+
+} CMOCK_sd_ble_gap_connect_CALL_INSTANCE;
+
+typedef struct _CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE
+{
+  UNITY_LINE_TYPE LineNumber;
+  uint32_t ReturnVal;
+  int CallOrder;
+
+} CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE;
+
+static struct mock_ble_gapInstance
+{
+  int sd_ble_gap_addr_set_IgnoreBool;
+  uint32_t sd_ble_gap_addr_set_FinalReturn;
+  CMOCK_sd_ble_gap_addr_set_CALLBACK sd_ble_gap_addr_set_CallbackFunctionPointer;
+  int sd_ble_gap_addr_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_addr_set_CallInstance;
+  int sd_ble_gap_addr_get_IgnoreBool;
+  uint32_t sd_ble_gap_addr_get_FinalReturn;
+  CMOCK_sd_ble_gap_addr_get_CALLBACK sd_ble_gap_addr_get_CallbackFunctionPointer;
+  int sd_ble_gap_addr_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_addr_get_CallInstance;
+  int sd_ble_gap_whitelist_set_IgnoreBool;
+  uint32_t sd_ble_gap_whitelist_set_FinalReturn;
+  CMOCK_sd_ble_gap_whitelist_set_CALLBACK sd_ble_gap_whitelist_set_CallbackFunctionPointer;
+  int sd_ble_gap_whitelist_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_whitelist_set_CallInstance;
+  int sd_ble_gap_device_identities_set_IgnoreBool;
+  uint32_t sd_ble_gap_device_identities_set_FinalReturn;
+  CMOCK_sd_ble_gap_device_identities_set_CALLBACK sd_ble_gap_device_identities_set_CallbackFunctionPointer;
+  int sd_ble_gap_device_identities_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_device_identities_set_CallInstance;
+  int sd_ble_gap_privacy_set_IgnoreBool;
+  uint32_t sd_ble_gap_privacy_set_FinalReturn;
+  CMOCK_sd_ble_gap_privacy_set_CALLBACK sd_ble_gap_privacy_set_CallbackFunctionPointer;
+  int sd_ble_gap_privacy_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_privacy_set_CallInstance;
+  int sd_ble_gap_privacy_get_IgnoreBool;
+  uint32_t sd_ble_gap_privacy_get_FinalReturn;
+  CMOCK_sd_ble_gap_privacy_get_CALLBACK sd_ble_gap_privacy_get_CallbackFunctionPointer;
+  int sd_ble_gap_privacy_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_privacy_get_CallInstance;
+  int sd_ble_gap_adv_data_set_IgnoreBool;
+  uint32_t sd_ble_gap_adv_data_set_FinalReturn;
+  CMOCK_sd_ble_gap_adv_data_set_CALLBACK sd_ble_gap_adv_data_set_CallbackFunctionPointer;
+  int sd_ble_gap_adv_data_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_adv_data_set_CallInstance;
+  int sd_ble_gap_adv_start_IgnoreBool;
+  uint32_t sd_ble_gap_adv_start_FinalReturn;
+  CMOCK_sd_ble_gap_adv_start_CALLBACK sd_ble_gap_adv_start_CallbackFunctionPointer;
+  int sd_ble_gap_adv_start_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_adv_start_CallInstance;
+  int sd_ble_gap_adv_stop_IgnoreBool;
+  uint32_t sd_ble_gap_adv_stop_FinalReturn;
+  CMOCK_sd_ble_gap_adv_stop_CALLBACK sd_ble_gap_adv_stop_CallbackFunctionPointer;
+  int sd_ble_gap_adv_stop_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_adv_stop_CallInstance;
+  int sd_ble_gap_conn_param_update_IgnoreBool;
+  uint32_t sd_ble_gap_conn_param_update_FinalReturn;
+  CMOCK_sd_ble_gap_conn_param_update_CALLBACK sd_ble_gap_conn_param_update_CallbackFunctionPointer;
+  int sd_ble_gap_conn_param_update_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_conn_param_update_CallInstance;
+  int sd_ble_gap_disconnect_IgnoreBool;
+  uint32_t sd_ble_gap_disconnect_FinalReturn;
+  CMOCK_sd_ble_gap_disconnect_CALLBACK sd_ble_gap_disconnect_CallbackFunctionPointer;
+  int sd_ble_gap_disconnect_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_disconnect_CallInstance;
+  int sd_ble_gap_tx_power_set_IgnoreBool;
+  uint32_t sd_ble_gap_tx_power_set_FinalReturn;
+  CMOCK_sd_ble_gap_tx_power_set_CALLBACK sd_ble_gap_tx_power_set_CallbackFunctionPointer;
+  int sd_ble_gap_tx_power_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_tx_power_set_CallInstance;
+  int sd_ble_gap_appearance_set_IgnoreBool;
+  uint32_t sd_ble_gap_appearance_set_FinalReturn;
+  CMOCK_sd_ble_gap_appearance_set_CALLBACK sd_ble_gap_appearance_set_CallbackFunctionPointer;
+  int sd_ble_gap_appearance_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_appearance_set_CallInstance;
+  int sd_ble_gap_appearance_get_IgnoreBool;
+  uint32_t sd_ble_gap_appearance_get_FinalReturn;
+  CMOCK_sd_ble_gap_appearance_get_CALLBACK sd_ble_gap_appearance_get_CallbackFunctionPointer;
+  int sd_ble_gap_appearance_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_appearance_get_CallInstance;
+  int sd_ble_gap_ppcp_set_IgnoreBool;
+  uint32_t sd_ble_gap_ppcp_set_FinalReturn;
+  CMOCK_sd_ble_gap_ppcp_set_CALLBACK sd_ble_gap_ppcp_set_CallbackFunctionPointer;
+  int sd_ble_gap_ppcp_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_ppcp_set_CallInstance;
+  int sd_ble_gap_ppcp_get_IgnoreBool;
+  uint32_t sd_ble_gap_ppcp_get_FinalReturn;
+  CMOCK_sd_ble_gap_ppcp_get_CALLBACK sd_ble_gap_ppcp_get_CallbackFunctionPointer;
+  int sd_ble_gap_ppcp_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_ppcp_get_CallInstance;
+  int sd_ble_gap_device_name_set_IgnoreBool;
+  uint32_t sd_ble_gap_device_name_set_FinalReturn;
+  CMOCK_sd_ble_gap_device_name_set_CALLBACK sd_ble_gap_device_name_set_CallbackFunctionPointer;
+  int sd_ble_gap_device_name_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_device_name_set_CallInstance;
+  int sd_ble_gap_device_name_get_IgnoreBool;
+  uint32_t sd_ble_gap_device_name_get_FinalReturn;
+  CMOCK_sd_ble_gap_device_name_get_CALLBACK sd_ble_gap_device_name_get_CallbackFunctionPointer;
+  int sd_ble_gap_device_name_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_device_name_get_CallInstance;
+  int sd_ble_gap_authenticate_IgnoreBool;
+  uint32_t sd_ble_gap_authenticate_FinalReturn;
+  CMOCK_sd_ble_gap_authenticate_CALLBACK sd_ble_gap_authenticate_CallbackFunctionPointer;
+  int sd_ble_gap_authenticate_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_authenticate_CallInstance;
+  int sd_ble_gap_sec_params_reply_IgnoreBool;
+  uint32_t sd_ble_gap_sec_params_reply_FinalReturn;
+  CMOCK_sd_ble_gap_sec_params_reply_CALLBACK sd_ble_gap_sec_params_reply_CallbackFunctionPointer;
+  int sd_ble_gap_sec_params_reply_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_sec_params_reply_CallInstance;
+  int sd_ble_gap_auth_key_reply_IgnoreBool;
+  uint32_t sd_ble_gap_auth_key_reply_FinalReturn;
+  CMOCK_sd_ble_gap_auth_key_reply_CALLBACK sd_ble_gap_auth_key_reply_CallbackFunctionPointer;
+  int sd_ble_gap_auth_key_reply_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_auth_key_reply_CallInstance;
+  int sd_ble_gap_lesc_dhkey_reply_IgnoreBool;
+  uint32_t sd_ble_gap_lesc_dhkey_reply_FinalReturn;
+  CMOCK_sd_ble_gap_lesc_dhkey_reply_CALLBACK sd_ble_gap_lesc_dhkey_reply_CallbackFunctionPointer;
+  int sd_ble_gap_lesc_dhkey_reply_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_lesc_dhkey_reply_CallInstance;
+  int sd_ble_gap_keypress_notify_IgnoreBool;
+  uint32_t sd_ble_gap_keypress_notify_FinalReturn;
+  CMOCK_sd_ble_gap_keypress_notify_CALLBACK sd_ble_gap_keypress_notify_CallbackFunctionPointer;
+  int sd_ble_gap_keypress_notify_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_keypress_notify_CallInstance;
+  int sd_ble_gap_lesc_oob_data_get_IgnoreBool;
+  uint32_t sd_ble_gap_lesc_oob_data_get_FinalReturn;
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALLBACK sd_ble_gap_lesc_oob_data_get_CallbackFunctionPointer;
+  int sd_ble_gap_lesc_oob_data_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_lesc_oob_data_get_CallInstance;
+  int sd_ble_gap_lesc_oob_data_set_IgnoreBool;
+  uint32_t sd_ble_gap_lesc_oob_data_set_FinalReturn;
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALLBACK sd_ble_gap_lesc_oob_data_set_CallbackFunctionPointer;
+  int sd_ble_gap_lesc_oob_data_set_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_lesc_oob_data_set_CallInstance;
+  int sd_ble_gap_encrypt_IgnoreBool;
+  uint32_t sd_ble_gap_encrypt_FinalReturn;
+  CMOCK_sd_ble_gap_encrypt_CALLBACK sd_ble_gap_encrypt_CallbackFunctionPointer;
+  int sd_ble_gap_encrypt_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_encrypt_CallInstance;
+  int sd_ble_gap_sec_info_reply_IgnoreBool;
+  uint32_t sd_ble_gap_sec_info_reply_FinalReturn;
+  CMOCK_sd_ble_gap_sec_info_reply_CALLBACK sd_ble_gap_sec_info_reply_CallbackFunctionPointer;
+  int sd_ble_gap_sec_info_reply_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_sec_info_reply_CallInstance;
+  int sd_ble_gap_conn_sec_get_IgnoreBool;
+  uint32_t sd_ble_gap_conn_sec_get_FinalReturn;
+  CMOCK_sd_ble_gap_conn_sec_get_CALLBACK sd_ble_gap_conn_sec_get_CallbackFunctionPointer;
+  int sd_ble_gap_conn_sec_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_conn_sec_get_CallInstance;
+  int sd_ble_gap_rssi_start_IgnoreBool;
+  uint32_t sd_ble_gap_rssi_start_FinalReturn;
+  CMOCK_sd_ble_gap_rssi_start_CALLBACK sd_ble_gap_rssi_start_CallbackFunctionPointer;
+  int sd_ble_gap_rssi_start_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_rssi_start_CallInstance;
+  int sd_ble_gap_rssi_stop_IgnoreBool;
+  uint32_t sd_ble_gap_rssi_stop_FinalReturn;
+  CMOCK_sd_ble_gap_rssi_stop_CALLBACK sd_ble_gap_rssi_stop_CallbackFunctionPointer;
+  int sd_ble_gap_rssi_stop_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_rssi_stop_CallInstance;
+  int sd_ble_gap_rssi_get_IgnoreBool;
+  uint32_t sd_ble_gap_rssi_get_FinalReturn;
+  CMOCK_sd_ble_gap_rssi_get_CALLBACK sd_ble_gap_rssi_get_CallbackFunctionPointer;
+  int sd_ble_gap_rssi_get_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_rssi_get_CallInstance;
+  int sd_ble_gap_scan_start_IgnoreBool;
+  uint32_t sd_ble_gap_scan_start_FinalReturn;
+  CMOCK_sd_ble_gap_scan_start_CALLBACK sd_ble_gap_scan_start_CallbackFunctionPointer;
+  int sd_ble_gap_scan_start_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_scan_start_CallInstance;
+  int sd_ble_gap_scan_stop_IgnoreBool;
+  uint32_t sd_ble_gap_scan_stop_FinalReturn;
+  CMOCK_sd_ble_gap_scan_stop_CALLBACK sd_ble_gap_scan_stop_CallbackFunctionPointer;
+  int sd_ble_gap_scan_stop_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_scan_stop_CallInstance;
+  int sd_ble_gap_connect_IgnoreBool;
+  uint32_t sd_ble_gap_connect_FinalReturn;
+  CMOCK_sd_ble_gap_connect_CALLBACK sd_ble_gap_connect_CallbackFunctionPointer;
+  int sd_ble_gap_connect_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_connect_CallInstance;
+  int sd_ble_gap_connect_cancel_IgnoreBool;
+  uint32_t sd_ble_gap_connect_cancel_FinalReturn;
+  CMOCK_sd_ble_gap_connect_cancel_CALLBACK sd_ble_gap_connect_cancel_CallbackFunctionPointer;
+  int sd_ble_gap_connect_cancel_CallbackCalls;
+  CMOCK_MEM_INDEX_TYPE sd_ble_gap_connect_cancel_CallInstance;
+} Mock;
+
+extern jmp_buf AbortFrame;
+extern int GlobalExpectCount;
+extern int GlobalVerifyOrder;
+
+void mock_ble_gap_Verify(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_addr_set_CallInstance, cmock_line, "Function 'sd_ble_gap_addr_set' called less times than expected.");
+  if (Mock.sd_ble_gap_addr_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_addr_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_addr_get_CallInstance, cmock_line, "Function 'sd_ble_gap_addr_get' called less times than expected.");
+  if (Mock.sd_ble_gap_addr_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_addr_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_whitelist_set_CallInstance, cmock_line, "Function 'sd_ble_gap_whitelist_set' called less times than expected.");
+  if (Mock.sd_ble_gap_whitelist_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_whitelist_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_device_identities_set_CallInstance, cmock_line, "Function 'sd_ble_gap_device_identities_set' called less times than expected.");
+  if (Mock.sd_ble_gap_device_identities_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_device_identities_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_privacy_set_CallInstance, cmock_line, "Function 'sd_ble_gap_privacy_set' called less times than expected.");
+  if (Mock.sd_ble_gap_privacy_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_privacy_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_privacy_get_CallInstance, cmock_line, "Function 'sd_ble_gap_privacy_get' called less times than expected.");
+  if (Mock.sd_ble_gap_privacy_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_privacy_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_adv_data_set_CallInstance, cmock_line, "Function 'sd_ble_gap_adv_data_set' called less times than expected.");
+  if (Mock.sd_ble_gap_adv_data_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_adv_data_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_adv_start_CallInstance, cmock_line, "Function 'sd_ble_gap_adv_start' called less times than expected.");
+  if (Mock.sd_ble_gap_adv_start_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_adv_start_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_adv_stop_CallInstance, cmock_line, "Function 'sd_ble_gap_adv_stop' called less times than expected.");
+  if (Mock.sd_ble_gap_adv_stop_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_adv_stop_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_conn_param_update_CallInstance, cmock_line, "Function 'sd_ble_gap_conn_param_update' called less times than expected.");
+  if (Mock.sd_ble_gap_conn_param_update_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_conn_param_update_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_disconnect_CallInstance, cmock_line, "Function 'sd_ble_gap_disconnect' called less times than expected.");
+  if (Mock.sd_ble_gap_disconnect_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_disconnect_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_tx_power_set_CallInstance, cmock_line, "Function 'sd_ble_gap_tx_power_set' called less times than expected.");
+  if (Mock.sd_ble_gap_tx_power_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_tx_power_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_appearance_set_CallInstance, cmock_line, "Function 'sd_ble_gap_appearance_set' called less times than expected.");
+  if (Mock.sd_ble_gap_appearance_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_appearance_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_appearance_get_CallInstance, cmock_line, "Function 'sd_ble_gap_appearance_get' called less times than expected.");
+  if (Mock.sd_ble_gap_appearance_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_appearance_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_ppcp_set_CallInstance, cmock_line, "Function 'sd_ble_gap_ppcp_set' called less times than expected.");
+  if (Mock.sd_ble_gap_ppcp_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_ppcp_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_ppcp_get_CallInstance, cmock_line, "Function 'sd_ble_gap_ppcp_get' called less times than expected.");
+  if (Mock.sd_ble_gap_ppcp_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_ppcp_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_device_name_set_CallInstance, cmock_line, "Function 'sd_ble_gap_device_name_set' called less times than expected.");
+  if (Mock.sd_ble_gap_device_name_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_device_name_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_device_name_get_CallInstance, cmock_line, "Function 'sd_ble_gap_device_name_get' called less times than expected.");
+  if (Mock.sd_ble_gap_device_name_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_device_name_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_authenticate_CallInstance, cmock_line, "Function 'sd_ble_gap_authenticate' called less times than expected.");
+  if (Mock.sd_ble_gap_authenticate_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_authenticate_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_sec_params_reply_CallInstance, cmock_line, "Function 'sd_ble_gap_sec_params_reply' called less times than expected.");
+  if (Mock.sd_ble_gap_sec_params_reply_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_sec_params_reply_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_auth_key_reply_CallInstance, cmock_line, "Function 'sd_ble_gap_auth_key_reply' called less times than expected.");
+  if (Mock.sd_ble_gap_auth_key_reply_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_auth_key_reply_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance, cmock_line, "Function 'sd_ble_gap_lesc_dhkey_reply' called less times than expected.");
+  if (Mock.sd_ble_gap_lesc_dhkey_reply_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_keypress_notify_CallInstance, cmock_line, "Function 'sd_ble_gap_keypress_notify' called less times than expected.");
+  if (Mock.sd_ble_gap_keypress_notify_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_keypress_notify_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_lesc_oob_data_get_CallInstance, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called less times than expected.");
+  if (Mock.sd_ble_gap_lesc_oob_data_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_lesc_oob_data_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_lesc_oob_data_set_CallInstance, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called less times than expected.");
+  if (Mock.sd_ble_gap_lesc_oob_data_set_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_lesc_oob_data_set_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_encrypt_CallInstance, cmock_line, "Function 'sd_ble_gap_encrypt' called less times than expected.");
+  if (Mock.sd_ble_gap_encrypt_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_encrypt_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_sec_info_reply_CallInstance, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called less times than expected.");
+  if (Mock.sd_ble_gap_sec_info_reply_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_sec_info_reply_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_conn_sec_get_CallInstance, cmock_line, "Function 'sd_ble_gap_conn_sec_get' called less times than expected.");
+  if (Mock.sd_ble_gap_conn_sec_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_conn_sec_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_rssi_start_CallInstance, cmock_line, "Function 'sd_ble_gap_rssi_start' called less times than expected.");
+  if (Mock.sd_ble_gap_rssi_start_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_rssi_start_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_rssi_stop_CallInstance, cmock_line, "Function 'sd_ble_gap_rssi_stop' called less times than expected.");
+  if (Mock.sd_ble_gap_rssi_stop_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_rssi_stop_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_rssi_get_CallInstance, cmock_line, "Function 'sd_ble_gap_rssi_get' called less times than expected.");
+  if (Mock.sd_ble_gap_rssi_get_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_rssi_get_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_scan_start_CallInstance, cmock_line, "Function 'sd_ble_gap_scan_start' called less times than expected.");
+  if (Mock.sd_ble_gap_scan_start_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_scan_start_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_scan_stop_CallInstance, cmock_line, "Function 'sd_ble_gap_scan_stop' called less times than expected.");
+  if (Mock.sd_ble_gap_scan_stop_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_scan_stop_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_connect_CallInstance, cmock_line, "Function 'sd_ble_gap_connect' called less times than expected.");
+  if (Mock.sd_ble_gap_connect_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_connect_CallInstance = CMOCK_GUTS_NONE;
+  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.sd_ble_gap_connect_cancel_CallInstance, cmock_line, "Function 'sd_ble_gap_connect_cancel' called less times than expected.");
+  if (Mock.sd_ble_gap_connect_cancel_CallbackFunctionPointer != NULL)
+    Mock.sd_ble_gap_connect_cancel_CallInstance = CMOCK_GUTS_NONE;
+}
+
+void mock_ble_gap_Init(void)
+{
+  mock_ble_gap_Destroy();
+}
+
+void mock_ble_gap_Destroy(void)
+{
+  CMock_Guts_MemFreeAll();
+  memset(&Mock, 0, sizeof(Mock));
+  Mock.sd_ble_gap_addr_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_addr_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_addr_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_addr_get_CallbackCalls = 0;
+  Mock.sd_ble_gap_whitelist_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_whitelist_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_device_identities_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_device_identities_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_privacy_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_privacy_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_privacy_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_privacy_get_CallbackCalls = 0;
+  Mock.sd_ble_gap_adv_data_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_adv_data_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_adv_start_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_adv_start_CallbackCalls = 0;
+  Mock.sd_ble_gap_adv_stop_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_adv_stop_CallbackCalls = 0;
+  Mock.sd_ble_gap_conn_param_update_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_conn_param_update_CallbackCalls = 0;
+  Mock.sd_ble_gap_disconnect_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_disconnect_CallbackCalls = 0;
+  Mock.sd_ble_gap_tx_power_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_tx_power_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_appearance_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_appearance_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_appearance_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_appearance_get_CallbackCalls = 0;
+  Mock.sd_ble_gap_ppcp_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_ppcp_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_ppcp_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_ppcp_get_CallbackCalls = 0;
+  Mock.sd_ble_gap_device_name_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_device_name_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_device_name_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_device_name_get_CallbackCalls = 0;
+  Mock.sd_ble_gap_authenticate_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_authenticate_CallbackCalls = 0;
+  Mock.sd_ble_gap_sec_params_reply_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_sec_params_reply_CallbackCalls = 0;
+  Mock.sd_ble_gap_auth_key_reply_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_auth_key_reply_CallbackCalls = 0;
+  Mock.sd_ble_gap_lesc_dhkey_reply_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_lesc_dhkey_reply_CallbackCalls = 0;
+  Mock.sd_ble_gap_keypress_notify_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_keypress_notify_CallbackCalls = 0;
+  Mock.sd_ble_gap_lesc_oob_data_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_lesc_oob_data_get_CallbackCalls = 0;
+  Mock.sd_ble_gap_lesc_oob_data_set_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_lesc_oob_data_set_CallbackCalls = 0;
+  Mock.sd_ble_gap_encrypt_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_encrypt_CallbackCalls = 0;
+  Mock.sd_ble_gap_sec_info_reply_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_sec_info_reply_CallbackCalls = 0;
+  Mock.sd_ble_gap_conn_sec_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_conn_sec_get_CallbackCalls = 0;
+  Mock.sd_ble_gap_rssi_start_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_rssi_start_CallbackCalls = 0;
+  Mock.sd_ble_gap_rssi_stop_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_rssi_stop_CallbackCalls = 0;
+  Mock.sd_ble_gap_rssi_get_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_rssi_get_CallbackCalls = 0;
+  Mock.sd_ble_gap_scan_start_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_scan_start_CallbackCalls = 0;
+  Mock.sd_ble_gap_scan_stop_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_scan_stop_CallbackCalls = 0;
+  Mock.sd_ble_gap_connect_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_connect_CallbackCalls = 0;
+  Mock.sd_ble_gap_connect_cancel_CallbackFunctionPointer = NULL;
+  Mock.sd_ble_gap_connect_cancel_CallbackCalls = 0;
+  GlobalExpectCount = 0;
+  GlobalVerifyOrder = 0;
+}
+
+uint32_t sd_ble_gap_addr_set(ble_gap_addr_t const* p_addr)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_addr_set_CallInstance);
+  Mock.sd_ble_gap_addr_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_addr_set_CallInstance);
+  if (Mock.sd_ble_gap_addr_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_addr_set_FinalReturn;
+    Mock.sd_ble_gap_addr_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_addr_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_addr_set_CallbackFunctionPointer(p_addr, Mock.sd_ble_gap_addr_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_addr_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_addr_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_addr_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_addr)
+  {
+    if (cmock_call_instance->Expected_p_addr == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_addr, cmock_line, "Expected NULL. Function 'sd_ble_gap_addr_set' called with unexpected value for argument 'p_addr'."); }
+    else if (cmock_call_instance->Expected_p_addr_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_addr, p_addr, cmock_line, "Function 'sd_ble_gap_addr_set' called with unexpected value for argument 'p_addr'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_addr), (void*)(p_addr), sizeof(ble_gap_addr_t), cmock_call_instance->Expected_p_addr_Depth, cmock_line, "Function 'sd_ble_gap_addr_set' called with unexpected value for argument 'p_addr'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_addr_Used)
+  {
+    memcpy((void*)p_addr, (void*)cmock_call_instance->ReturnThruPtr_p_addr_Val,
+      cmock_call_instance->ReturnThruPtr_p_addr_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_addr_set(CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE* cmock_call_instance, ble_gap_addr_t const* p_addr, int p_addr_Depth)
+{
+  cmock_call_instance->Expected_p_addr = p_addr;
+  cmock_call_instance->Expected_p_addr_Depth = p_addr_Depth;
+  cmock_call_instance->IgnoreArg_p_addr = 0;
+  cmock_call_instance->ReturnThruPtr_p_addr_Used = 0;
+}
+
+void sd_ble_gap_addr_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_addr_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_addr_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_addr_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_addr_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_addr, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_addr_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_addr_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_addr_set(cmock_call_instance, p_addr, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_addr_set_StubWithCallback(CMOCK_sd_ble_gap_addr_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_addr_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_addr_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_addr, int p_addr_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_addr_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_addr_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_addr_set(cmock_call_instance, p_addr, p_addr_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_addr_set_CMockReturnMemThruPtr_p_addr(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_addr, int cmock_size)
+{
+  CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_addr_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_addr ReturnThruPtr called before Expect on 'sd_ble_gap_addr_set'.");
+  cmock_call_instance->ReturnThruPtr_p_addr_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_addr_Val = p_addr;
+  cmock_call_instance->ReturnThruPtr_p_addr_Size = cmock_size;
+}
+
+void sd_ble_gap_addr_set_CMockIgnoreArg_p_addr(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_addr_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_addr_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_addr IgnoreArg called before Expect on 'sd_ble_gap_addr_set'.");
+  cmock_call_instance->IgnoreArg_p_addr = 1;
+}
+
+uint32_t sd_ble_gap_addr_get(ble_gap_addr_t* p_addr)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_addr_get_CallInstance);
+  Mock.sd_ble_gap_addr_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_addr_get_CallInstance);
+  if (Mock.sd_ble_gap_addr_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_addr_get_FinalReturn;
+    Mock.sd_ble_gap_addr_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_addr_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_addr_get_CallbackFunctionPointer(p_addr, Mock.sd_ble_gap_addr_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_addr_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_addr_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_addr_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_addr)
+  {
+    if (cmock_call_instance->Expected_p_addr == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_addr, cmock_line, "Expected NULL. Function 'sd_ble_gap_addr_get' called with unexpected value for argument 'p_addr'."); }
+    else if (cmock_call_instance->Expected_p_addr_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_addr, p_addr, cmock_line, "Function 'sd_ble_gap_addr_get' called with unexpected value for argument 'p_addr'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_addr), (void*)(p_addr), sizeof(ble_gap_addr_t), cmock_call_instance->Expected_p_addr_Depth, cmock_line, "Function 'sd_ble_gap_addr_get' called with unexpected value for argument 'p_addr'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_addr_Used)
+  {
+    memcpy((void*)p_addr, (void*)cmock_call_instance->ReturnThruPtr_p_addr_Val,
+      cmock_call_instance->ReturnThruPtr_p_addr_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_addr_get(CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE* cmock_call_instance, ble_gap_addr_t* p_addr, int p_addr_Depth)
+{
+  cmock_call_instance->Expected_p_addr = p_addr;
+  cmock_call_instance->Expected_p_addr_Depth = p_addr_Depth;
+  cmock_call_instance->IgnoreArg_p_addr = 0;
+  cmock_call_instance->ReturnThruPtr_p_addr_Used = 0;
+}
+
+void sd_ble_gap_addr_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_addr_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_addr_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_addr_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_addr_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t* p_addr, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_addr_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_addr_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_addr_get(cmock_call_instance, p_addr, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_addr_get_StubWithCallback(CMOCK_sd_ble_gap_addr_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_addr_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_addr_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t* p_addr, int p_addr_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_addr_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_addr_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_addr_get(cmock_call_instance, p_addr, p_addr_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_addr_get_CMockReturnMemThruPtr_p_addr(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t* p_addr, int cmock_size)
+{
+  CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_addr_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_addr ReturnThruPtr called before Expect on 'sd_ble_gap_addr_get'.");
+  cmock_call_instance->ReturnThruPtr_p_addr_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_addr_Val = p_addr;
+  cmock_call_instance->ReturnThruPtr_p_addr_Size = cmock_size;
+}
+
+void sd_ble_gap_addr_get_CMockIgnoreArg_p_addr(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_addr_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_addr_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_addr IgnoreArg called before Expect on 'sd_ble_gap_addr_get'.");
+  cmock_call_instance->IgnoreArg_p_addr = 1;
+}
+
+uint32_t sd_ble_gap_whitelist_set(ble_gap_addr_t const* const* pp_wl_addrs, uint8_t len)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_whitelist_set_CallInstance);
+  Mock.sd_ble_gap_whitelist_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_whitelist_set_CallInstance);
+  if (Mock.sd_ble_gap_whitelist_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_whitelist_set_FinalReturn;
+    Mock.sd_ble_gap_whitelist_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_whitelist_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_whitelist_set_CallbackFunctionPointer(pp_wl_addrs, len, Mock.sd_ble_gap_whitelist_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_whitelist_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_whitelist_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_whitelist_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_pp_wl_addrs)
+  {
+    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pp_wl_addrs, pp_wl_addrs, cmock_line, "Function 'sd_ble_gap_whitelist_set' called with unexpected value for argument 'pp_wl_addrs'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_len)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_len, len, cmock_line, "Function 'sd_ble_gap_whitelist_set' called with unexpected value for argument 'len'.");
+  }
+  if (cmock_call_instance->ReturnThruPtr_pp_wl_addrs_Used)
+  {
+    memcpy((void*)pp_wl_addrs, (void*)cmock_call_instance->ReturnThruPtr_pp_wl_addrs_Val,
+      cmock_call_instance->ReturnThruPtr_pp_wl_addrs_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_whitelist_set(CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE* cmock_call_instance, ble_gap_addr_t const* const* pp_wl_addrs, int pp_wl_addrs_Depth, uint8_t len)
+{
+  cmock_call_instance->Expected_pp_wl_addrs = pp_wl_addrs;
+  cmock_call_instance->Expected_pp_wl_addrs_Depth = pp_wl_addrs_Depth;
+  cmock_call_instance->IgnoreArg_pp_wl_addrs = 0;
+  cmock_call_instance->ReturnThruPtr_pp_wl_addrs_Used = 0;
+  cmock_call_instance->Expected_len = len;
+  cmock_call_instance->IgnoreArg_len = 0;
+}
+
+void sd_ble_gap_whitelist_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_whitelist_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_whitelist_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_whitelist_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_whitelist_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* const* pp_wl_addrs, uint8_t len, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_whitelist_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_whitelist_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_whitelist_set(cmock_call_instance, pp_wl_addrs, 0, len);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_whitelist_set_StubWithCallback(CMOCK_sd_ble_gap_whitelist_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_whitelist_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_whitelist_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* const* pp_wl_addrs, int pp_wl_addrs_Depth, uint8_t len, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_whitelist_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_whitelist_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_whitelist_set(cmock_call_instance, pp_wl_addrs, pp_wl_addrs_Depth, len);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_whitelist_set_CMockReturnMemThruPtr_pp_wl_addrs(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* const* pp_wl_addrs, int cmock_size)
+{
+  CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_whitelist_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "pp_wl_addrs ReturnThruPtr called before Expect on 'sd_ble_gap_whitelist_set'.");
+  cmock_call_instance->ReturnThruPtr_pp_wl_addrs_Used = 1;
+  cmock_call_instance->ReturnThruPtr_pp_wl_addrs_Val = pp_wl_addrs;
+  cmock_call_instance->ReturnThruPtr_pp_wl_addrs_Size = cmock_size;
+}
+
+void sd_ble_gap_whitelist_set_CMockIgnoreArg_pp_wl_addrs(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_whitelist_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "pp_wl_addrs IgnoreArg called before Expect on 'sd_ble_gap_whitelist_set'.");
+  cmock_call_instance->IgnoreArg_pp_wl_addrs = 1;
+}
+
+void sd_ble_gap_whitelist_set_CMockIgnoreArg_len(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_whitelist_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_whitelist_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "len IgnoreArg called before Expect on 'sd_ble_gap_whitelist_set'.");
+  cmock_call_instance->IgnoreArg_len = 1;
+}
+
+uint32_t sd_ble_gap_device_identities_set(ble_gap_id_key_t const* const* pp_id_keys, ble_gap_irk_t const* const* pp_local_irks, uint8_t len)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_device_identities_set_CallInstance);
+  Mock.sd_ble_gap_device_identities_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_device_identities_set_CallInstance);
+  if (Mock.sd_ble_gap_device_identities_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_device_identities_set_FinalReturn;
+    Mock.sd_ble_gap_device_identities_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_device_identities_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_device_identities_set_CallbackFunctionPointer(pp_id_keys, pp_local_irks, len, Mock.sd_ble_gap_device_identities_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_device_identities_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_device_identities_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_device_identities_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_pp_id_keys)
+  {
+    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pp_id_keys, pp_id_keys, cmock_line, "Function 'sd_ble_gap_device_identities_set' called with unexpected value for argument 'pp_id_keys'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_pp_local_irks)
+  {
+    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pp_local_irks, pp_local_irks, cmock_line, "Function 'sd_ble_gap_device_identities_set' called with unexpected value for argument 'pp_local_irks'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_len)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_len, len, cmock_line, "Function 'sd_ble_gap_device_identities_set' called with unexpected value for argument 'len'.");
+  }
+  if (cmock_call_instance->ReturnThruPtr_pp_id_keys_Used)
+  {
+    memcpy((void*)pp_id_keys, (void*)cmock_call_instance->ReturnThruPtr_pp_id_keys_Val,
+      cmock_call_instance->ReturnThruPtr_pp_id_keys_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_pp_local_irks_Used)
+  {
+    memcpy((void*)pp_local_irks, (void*)cmock_call_instance->ReturnThruPtr_pp_local_irks_Val,
+      cmock_call_instance->ReturnThruPtr_pp_local_irks_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_device_identities_set(CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance, ble_gap_id_key_t const* const* pp_id_keys, int pp_id_keys_Depth, ble_gap_irk_t const* const* pp_local_irks, int pp_local_irks_Depth, uint8_t len)
+{
+  cmock_call_instance->Expected_pp_id_keys = pp_id_keys;
+  cmock_call_instance->Expected_pp_id_keys_Depth = pp_id_keys_Depth;
+  cmock_call_instance->IgnoreArg_pp_id_keys = 0;
+  cmock_call_instance->ReturnThruPtr_pp_id_keys_Used = 0;
+  cmock_call_instance->Expected_pp_local_irks = pp_local_irks;
+  cmock_call_instance->Expected_pp_local_irks_Depth = pp_local_irks_Depth;
+  cmock_call_instance->IgnoreArg_pp_local_irks = 0;
+  cmock_call_instance->ReturnThruPtr_pp_local_irks_Used = 0;
+  cmock_call_instance->Expected_len = len;
+  cmock_call_instance->IgnoreArg_len = 0;
+}
+
+void sd_ble_gap_device_identities_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_identities_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_identities_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_device_identities_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_device_identities_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_id_key_t const* const* pp_id_keys, ble_gap_irk_t const* const* pp_local_irks, uint8_t len, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_identities_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_identities_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_device_identities_set(cmock_call_instance, pp_id_keys, 0, pp_local_irks, 0, len);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_device_identities_set_StubWithCallback(CMOCK_sd_ble_gap_device_identities_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_device_identities_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_device_identities_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_id_key_t const* const* pp_id_keys, int pp_id_keys_Depth, ble_gap_irk_t const* const* pp_local_irks, int pp_local_irks_Depth, uint8_t len, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_identities_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_identities_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_device_identities_set(cmock_call_instance, pp_id_keys, pp_id_keys_Depth, pp_local_irks, pp_local_irks_Depth, len);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_id_keys(UNITY_LINE_TYPE cmock_line, ble_gap_id_key_t const* const* pp_id_keys, int cmock_size)
+{
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_identities_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "pp_id_keys ReturnThruPtr called before Expect on 'sd_ble_gap_device_identities_set'.");
+  cmock_call_instance->ReturnThruPtr_pp_id_keys_Used = 1;
+  cmock_call_instance->ReturnThruPtr_pp_id_keys_Val = pp_id_keys;
+  cmock_call_instance->ReturnThruPtr_pp_id_keys_Size = cmock_size;
+}
+
+void sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_local_irks(UNITY_LINE_TYPE cmock_line, ble_gap_irk_t const* const* pp_local_irks, int cmock_size)
+{
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_identities_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "pp_local_irks ReturnThruPtr called before Expect on 'sd_ble_gap_device_identities_set'.");
+  cmock_call_instance->ReturnThruPtr_pp_local_irks_Used = 1;
+  cmock_call_instance->ReturnThruPtr_pp_local_irks_Val = pp_local_irks;
+  cmock_call_instance->ReturnThruPtr_pp_local_irks_Size = cmock_size;
+}
+
+void sd_ble_gap_device_identities_set_CMockIgnoreArg_pp_id_keys(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_identities_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "pp_id_keys IgnoreArg called before Expect on 'sd_ble_gap_device_identities_set'.");
+  cmock_call_instance->IgnoreArg_pp_id_keys = 1;
+}
+
+void sd_ble_gap_device_identities_set_CMockIgnoreArg_pp_local_irks(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_identities_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "pp_local_irks IgnoreArg called before Expect on 'sd_ble_gap_device_identities_set'.");
+  cmock_call_instance->IgnoreArg_pp_local_irks = 1;
+}
+
+void sd_ble_gap_device_identities_set_CMockIgnoreArg_len(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_identities_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_identities_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "len IgnoreArg called before Expect on 'sd_ble_gap_device_identities_set'.");
+  cmock_call_instance->IgnoreArg_len = 1;
+}
+
+uint32_t sd_ble_gap_privacy_set(ble_gap_privacy_params_t const* p_privacy_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_privacy_set_CallInstance);
+  Mock.sd_ble_gap_privacy_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_privacy_set_CallInstance);
+  if (Mock.sd_ble_gap_privacy_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_privacy_set_FinalReturn;
+    Mock.sd_ble_gap_privacy_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_privacy_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_privacy_set_CallbackFunctionPointer(p_privacy_params, Mock.sd_ble_gap_privacy_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_privacy_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_privacy_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_privacy_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_privacy_params)
+  {
+    if (cmock_call_instance->Expected_p_privacy_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_privacy_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_privacy_set' called with unexpected value for argument 'p_privacy_params'."); }
+    else if (cmock_call_instance->Expected_p_privacy_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_privacy_params, p_privacy_params, cmock_line, "Function 'sd_ble_gap_privacy_set' called with unexpected value for argument 'p_privacy_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_privacy_params), (void*)(p_privacy_params), sizeof(ble_gap_privacy_params_t), cmock_call_instance->Expected_p_privacy_params_Depth, cmock_line, "Function 'sd_ble_gap_privacy_set' called with unexpected value for argument 'p_privacy_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_privacy_params_Used)
+  {
+    memcpy((void*)p_privacy_params, (void*)cmock_call_instance->ReturnThruPtr_p_privacy_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_privacy_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_privacy_set(CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE* cmock_call_instance, ble_gap_privacy_params_t const* p_privacy_params, int p_privacy_params_Depth)
+{
+  cmock_call_instance->Expected_p_privacy_params = p_privacy_params;
+  cmock_call_instance->Expected_p_privacy_params_Depth = p_privacy_params_Depth;
+  cmock_call_instance->IgnoreArg_p_privacy_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_privacy_params_Used = 0;
+}
+
+void sd_ble_gap_privacy_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_privacy_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_privacy_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_privacy_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_privacy_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t const* p_privacy_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_privacy_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_privacy_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_privacy_set(cmock_call_instance, p_privacy_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_privacy_set_StubWithCallback(CMOCK_sd_ble_gap_privacy_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_privacy_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_privacy_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t const* p_privacy_params, int p_privacy_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_privacy_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_privacy_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_privacy_set(cmock_call_instance, p_privacy_params, p_privacy_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_privacy_set_CMockReturnMemThruPtr_p_privacy_params(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t const* p_privacy_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_privacy_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_privacy_params ReturnThruPtr called before Expect on 'sd_ble_gap_privacy_set'.");
+  cmock_call_instance->ReturnThruPtr_p_privacy_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_privacy_params_Val = p_privacy_params;
+  cmock_call_instance->ReturnThruPtr_p_privacy_params_Size = cmock_size;
+}
+
+void sd_ble_gap_privacy_set_CMockIgnoreArg_p_privacy_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_privacy_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_privacy_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_privacy_params IgnoreArg called before Expect on 'sd_ble_gap_privacy_set'.");
+  cmock_call_instance->IgnoreArg_p_privacy_params = 1;
+}
+
+uint32_t sd_ble_gap_privacy_get(ble_gap_privacy_params_t* p_privacy_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_privacy_get_CallInstance);
+  Mock.sd_ble_gap_privacy_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_privacy_get_CallInstance);
+  if (Mock.sd_ble_gap_privacy_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_privacy_get_FinalReturn;
+    Mock.sd_ble_gap_privacy_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_privacy_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_privacy_get_CallbackFunctionPointer(p_privacy_params, Mock.sd_ble_gap_privacy_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_privacy_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_privacy_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_privacy_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_privacy_params)
+  {
+    if (cmock_call_instance->Expected_p_privacy_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_privacy_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_privacy_get' called with unexpected value for argument 'p_privacy_params'."); }
+    else if (cmock_call_instance->Expected_p_privacy_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_privacy_params, p_privacy_params, cmock_line, "Function 'sd_ble_gap_privacy_get' called with unexpected value for argument 'p_privacy_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_privacy_params), (void*)(p_privacy_params), sizeof(ble_gap_privacy_params_t), cmock_call_instance->Expected_p_privacy_params_Depth, cmock_line, "Function 'sd_ble_gap_privacy_get' called with unexpected value for argument 'p_privacy_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_privacy_params_Used)
+  {
+    memcpy((void*)p_privacy_params, (void*)cmock_call_instance->ReturnThruPtr_p_privacy_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_privacy_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_privacy_get(CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE* cmock_call_instance, ble_gap_privacy_params_t* p_privacy_params, int p_privacy_params_Depth)
+{
+  cmock_call_instance->Expected_p_privacy_params = p_privacy_params;
+  cmock_call_instance->Expected_p_privacy_params_Depth = p_privacy_params_Depth;
+  cmock_call_instance->IgnoreArg_p_privacy_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_privacy_params_Used = 0;
+}
+
+void sd_ble_gap_privacy_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_privacy_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_privacy_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_privacy_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_privacy_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t* p_privacy_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_privacy_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_privacy_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_privacy_get(cmock_call_instance, p_privacy_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_privacy_get_StubWithCallback(CMOCK_sd_ble_gap_privacy_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_privacy_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_privacy_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t* p_privacy_params, int p_privacy_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_privacy_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_privacy_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_privacy_get(cmock_call_instance, p_privacy_params, p_privacy_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_privacy_get_CMockReturnMemThruPtr_p_privacy_params(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t* p_privacy_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_privacy_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_privacy_params ReturnThruPtr called before Expect on 'sd_ble_gap_privacy_get'.");
+  cmock_call_instance->ReturnThruPtr_p_privacy_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_privacy_params_Val = p_privacy_params;
+  cmock_call_instance->ReturnThruPtr_p_privacy_params_Size = cmock_size;
+}
+
+void sd_ble_gap_privacy_get_CMockIgnoreArg_p_privacy_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_privacy_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_privacy_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_privacy_params IgnoreArg called before Expect on 'sd_ble_gap_privacy_get'.");
+  cmock_call_instance->IgnoreArg_p_privacy_params = 1;
+}
+
+uint32_t sd_ble_gap_adv_data_set(uint8_t const* p_data, uint8_t dlen, uint8_t const* p_sr_data, uint8_t srdlen)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_adv_data_set_CallInstance);
+  Mock.sd_ble_gap_adv_data_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_adv_data_set_CallInstance);
+  if (Mock.sd_ble_gap_adv_data_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_adv_data_set_FinalReturn;
+    Mock.sd_ble_gap_adv_data_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_adv_data_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_adv_data_set_CallbackFunctionPointer(p_data, dlen, p_sr_data, srdlen, Mock.sd_ble_gap_adv_data_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_adv_data_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_adv_data_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_adv_data_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_data)
+  {
+    if (cmock_call_instance->Expected_p_data == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_data, cmock_line, "Expected NULL. Function 'sd_ble_gap_adv_data_set' called with unexpected value for argument 'p_data'."); }
+    else if (cmock_call_instance->Expected_p_data_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_data, p_data, cmock_line, "Function 'sd_ble_gap_adv_data_set' called with unexpected value for argument 'p_data'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_data, p_data, cmock_call_instance->Expected_p_data_Depth, cmock_line, "Function 'sd_ble_gap_adv_data_set' called with unexpected value for argument 'p_data'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_dlen)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_dlen, dlen, cmock_line, "Function 'sd_ble_gap_adv_data_set' called with unexpected value for argument 'dlen'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_sr_data)
+  {
+    if (cmock_call_instance->Expected_p_sr_data == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_sr_data, cmock_line, "Expected NULL. Function 'sd_ble_gap_adv_data_set' called with unexpected value for argument 'p_sr_data'."); }
+    else if (cmock_call_instance->Expected_p_sr_data_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_sr_data, p_sr_data, cmock_line, "Function 'sd_ble_gap_adv_data_set' called with unexpected value for argument 'p_sr_data'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_sr_data, p_sr_data, cmock_call_instance->Expected_p_sr_data_Depth, cmock_line, "Function 'sd_ble_gap_adv_data_set' called with unexpected value for argument 'p_sr_data'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_srdlen)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_srdlen, srdlen, cmock_line, "Function 'sd_ble_gap_adv_data_set' called with unexpected value for argument 'srdlen'.");
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_data_Used)
+  {
+    memcpy((void*)p_data, (void*)cmock_call_instance->ReturnThruPtr_p_data_Val,
+      cmock_call_instance->ReturnThruPtr_p_data_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_sr_data_Used)
+  {
+    memcpy((void*)p_sr_data, (void*)cmock_call_instance->ReturnThruPtr_p_sr_data_Val,
+      cmock_call_instance->ReturnThruPtr_p_sr_data_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_adv_data_set(CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance, uint8_t const* p_data, int p_data_Depth, uint8_t dlen, uint8_t const* p_sr_data, int p_sr_data_Depth, uint8_t srdlen)
+{
+  cmock_call_instance->Expected_p_data = p_data;
+  cmock_call_instance->Expected_p_data_Depth = p_data_Depth;
+  cmock_call_instance->IgnoreArg_p_data = 0;
+  cmock_call_instance->ReturnThruPtr_p_data_Used = 0;
+  cmock_call_instance->Expected_dlen = dlen;
+  cmock_call_instance->IgnoreArg_dlen = 0;
+  cmock_call_instance->Expected_p_sr_data = p_sr_data;
+  cmock_call_instance->Expected_p_sr_data_Depth = p_sr_data_Depth;
+  cmock_call_instance->IgnoreArg_p_sr_data = 0;
+  cmock_call_instance->ReturnThruPtr_p_sr_data_Used = 0;
+  cmock_call_instance->Expected_srdlen = srdlen;
+  cmock_call_instance->IgnoreArg_srdlen = 0;
+}
+
+void sd_ble_gap_adv_data_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_adv_data_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_adv_data_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_adv_data_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_adv_data_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t const* p_data, uint8_t dlen, uint8_t const* p_sr_data, uint8_t srdlen, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_adv_data_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_adv_data_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_adv_data_set(cmock_call_instance, p_data, 0, dlen, p_sr_data, 0, srdlen);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_adv_data_set_StubWithCallback(CMOCK_sd_ble_gap_adv_data_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_adv_data_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_adv_data_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t const* p_data, int p_data_Depth, uint8_t dlen, uint8_t const* p_sr_data, int p_sr_data_Depth, uint8_t srdlen, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_adv_data_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_adv_data_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_adv_data_set(cmock_call_instance, p_data, p_data_Depth, dlen, p_sr_data, p_sr_data_Depth, srdlen);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_data(UNITY_LINE_TYPE cmock_line, uint8_t const* p_data, int cmock_size)
+{
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_adv_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_data ReturnThruPtr called before Expect on 'sd_ble_gap_adv_data_set'.");
+  cmock_call_instance->ReturnThruPtr_p_data_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_data_Val = p_data;
+  cmock_call_instance->ReturnThruPtr_p_data_Size = cmock_size;
+}
+
+void sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_sr_data(UNITY_LINE_TYPE cmock_line, uint8_t const* p_sr_data, int cmock_size)
+{
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_adv_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sr_data ReturnThruPtr called before Expect on 'sd_ble_gap_adv_data_set'.");
+  cmock_call_instance->ReturnThruPtr_p_sr_data_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_sr_data_Val = p_sr_data;
+  cmock_call_instance->ReturnThruPtr_p_sr_data_Size = cmock_size;
+}
+
+void sd_ble_gap_adv_data_set_CMockIgnoreArg_p_data(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_adv_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_data IgnoreArg called before Expect on 'sd_ble_gap_adv_data_set'.");
+  cmock_call_instance->IgnoreArg_p_data = 1;
+}
+
+void sd_ble_gap_adv_data_set_CMockIgnoreArg_dlen(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_adv_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "dlen IgnoreArg called before Expect on 'sd_ble_gap_adv_data_set'.");
+  cmock_call_instance->IgnoreArg_dlen = 1;
+}
+
+void sd_ble_gap_adv_data_set_CMockIgnoreArg_p_sr_data(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_adv_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sr_data IgnoreArg called before Expect on 'sd_ble_gap_adv_data_set'.");
+  cmock_call_instance->IgnoreArg_p_sr_data = 1;
+}
+
+void sd_ble_gap_adv_data_set_CMockIgnoreArg_srdlen(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_adv_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_adv_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "srdlen IgnoreArg called before Expect on 'sd_ble_gap_adv_data_set'.");
+  cmock_call_instance->IgnoreArg_srdlen = 1;
+}
+
+uint32_t sd_ble_gap_adv_start(ble_gap_adv_params_t const* p_adv_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_adv_start_CallInstance);
+  Mock.sd_ble_gap_adv_start_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_adv_start_CallInstance);
+  if (Mock.sd_ble_gap_adv_start_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_adv_start_FinalReturn;
+    Mock.sd_ble_gap_adv_start_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_adv_start_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_adv_start_CallbackFunctionPointer(p_adv_params, Mock.sd_ble_gap_adv_start_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_adv_start' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_adv_start' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_adv_start' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_adv_params)
+  {
+    if (cmock_call_instance->Expected_p_adv_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_adv_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_adv_start' called with unexpected value for argument 'p_adv_params'."); }
+    else if (cmock_call_instance->Expected_p_adv_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_adv_params, p_adv_params, cmock_line, "Function 'sd_ble_gap_adv_start' called with unexpected value for argument 'p_adv_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_adv_params), (void*)(p_adv_params), sizeof(ble_gap_adv_params_t), cmock_call_instance->Expected_p_adv_params_Depth, cmock_line, "Function 'sd_ble_gap_adv_start' called with unexpected value for argument 'p_adv_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_adv_params_Used)
+  {
+    memcpy((void*)p_adv_params, (void*)cmock_call_instance->ReturnThruPtr_p_adv_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_adv_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_adv_start(CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE* cmock_call_instance, ble_gap_adv_params_t const* p_adv_params, int p_adv_params_Depth)
+{
+  cmock_call_instance->Expected_p_adv_params = p_adv_params;
+  cmock_call_instance->Expected_p_adv_params_Depth = p_adv_params_Depth;
+  cmock_call_instance->IgnoreArg_p_adv_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_adv_params_Used = 0;
+}
+
+void sd_ble_gap_adv_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_adv_start_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_adv_start_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_adv_start_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_adv_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_adv_params_t const* p_adv_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_adv_start_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_adv_start_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_adv_start(cmock_call_instance, p_adv_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_adv_start_StubWithCallback(CMOCK_sd_ble_gap_adv_start_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_adv_start_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_adv_start_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_adv_params_t const* p_adv_params, int p_adv_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_adv_start_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_adv_start_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_adv_start(cmock_call_instance, p_adv_params, p_adv_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_adv_start_CMockReturnMemThruPtr_p_adv_params(UNITY_LINE_TYPE cmock_line, ble_gap_adv_params_t const* p_adv_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_adv_start_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_adv_params ReturnThruPtr called before Expect on 'sd_ble_gap_adv_start'.");
+  cmock_call_instance->ReturnThruPtr_p_adv_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_adv_params_Val = p_adv_params;
+  cmock_call_instance->ReturnThruPtr_p_adv_params_Size = cmock_size;
+}
+
+void sd_ble_gap_adv_start_CMockIgnoreArg_p_adv_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_adv_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_adv_start_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_adv_params IgnoreArg called before Expect on 'sd_ble_gap_adv_start'.");
+  cmock_call_instance->IgnoreArg_p_adv_params = 1;
+}
+
+uint32_t sd_ble_gap_adv_stop(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_adv_stop_CallInstance);
+  Mock.sd_ble_gap_adv_stop_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_adv_stop_CallInstance);
+  if (Mock.sd_ble_gap_adv_stop_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_adv_stop_FinalReturn;
+    Mock.sd_ble_gap_adv_stop_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_adv_stop_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_adv_stop_CallbackFunctionPointer(Mock.sd_ble_gap_adv_stop_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_adv_stop' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_adv_stop' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_adv_stop' called later than expected.");
+  return cmock_call_instance->ReturnVal;
+}
+
+void sd_ble_gap_adv_stop_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_adv_stop_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_adv_stop_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_adv_stop_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_adv_stop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_adv_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_adv_stop_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_adv_stop_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_adv_stop_StubWithCallback(CMOCK_sd_ble_gap_adv_stop_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_adv_stop_CallbackFunctionPointer = Callback;
+}
+
+uint32_t sd_ble_gap_conn_param_update(uint16_t conn_handle, ble_gap_conn_params_t const* p_conn_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_conn_param_update_CallInstance);
+  Mock.sd_ble_gap_conn_param_update_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_conn_param_update_CallInstance);
+  if (Mock.sd_ble_gap_conn_param_update_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_conn_param_update_FinalReturn;
+    Mock.sd_ble_gap_conn_param_update_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_conn_param_update_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_conn_param_update_CallbackFunctionPointer(conn_handle, p_conn_params, Mock.sd_ble_gap_conn_param_update_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_conn_param_update' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_conn_param_update' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_conn_param_update' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_conn_param_update' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_conn_params)
+  {
+    if (cmock_call_instance->Expected_p_conn_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_conn_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_conn_param_update' called with unexpected value for argument 'p_conn_params'."); }
+    else if (cmock_call_instance->Expected_p_conn_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_conn_params, p_conn_params, cmock_line, "Function 'sd_ble_gap_conn_param_update' called with unexpected value for argument 'p_conn_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_conn_params), (void*)(p_conn_params), sizeof(ble_gap_conn_params_t), cmock_call_instance->Expected_p_conn_params_Depth, cmock_line, "Function 'sd_ble_gap_conn_param_update' called with unexpected value for argument 'p_conn_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_conn_params_Used)
+  {
+    memcpy((void*)p_conn_params, (void*)cmock_call_instance->ReturnThruPtr_p_conn_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_conn_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_conn_param_update(CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_conn_params = p_conn_params;
+  cmock_call_instance->Expected_p_conn_params_Depth = p_conn_params_Depth;
+  cmock_call_instance->IgnoreArg_p_conn_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Used = 0;
+}
+
+void sd_ble_gap_conn_param_update_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_conn_param_update_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_conn_param_update_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_conn_param_update_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_conn_param_update_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_conn_params_t const* p_conn_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_conn_param_update_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_conn_param_update_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_conn_param_update(cmock_call_instance, conn_handle, p_conn_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_conn_param_update_StubWithCallback(CMOCK_sd_ble_gap_conn_param_update_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_conn_param_update_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_conn_param_update_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_conn_param_update_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_conn_param_update_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_conn_param_update(cmock_call_instance, conn_handle, p_conn_params, p_conn_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_conn_param_update_CMockReturnMemThruPtr_p_conn_params(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_conn_param_update_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_params ReturnThruPtr called before Expect on 'sd_ble_gap_conn_param_update'.");
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Val = p_conn_params;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Size = cmock_size;
+}
+
+void sd_ble_gap_conn_param_update_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_conn_param_update_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_conn_param_update'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_conn_param_update_CMockIgnoreArg_p_conn_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_conn_param_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_conn_param_update_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_params IgnoreArg called before Expect on 'sd_ble_gap_conn_param_update'.");
+  cmock_call_instance->IgnoreArg_p_conn_params = 1;
+}
+
+uint32_t sd_ble_gap_disconnect(uint16_t conn_handle, uint8_t hci_status_code)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_disconnect_CallInstance);
+  Mock.sd_ble_gap_disconnect_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_disconnect_CallInstance);
+  if (Mock.sd_ble_gap_disconnect_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_disconnect_FinalReturn;
+    Mock.sd_ble_gap_disconnect_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_disconnect_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_disconnect_CallbackFunctionPointer(conn_handle, hci_status_code, Mock.sd_ble_gap_disconnect_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_disconnect' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_disconnect' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_disconnect' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_disconnect' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_hci_status_code)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_hci_status_code, hci_status_code, cmock_line, "Function 'sd_ble_gap_disconnect' called with unexpected value for argument 'hci_status_code'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_disconnect(CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint8_t hci_status_code)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_hci_status_code = hci_status_code;
+  cmock_call_instance->IgnoreArg_hci_status_code = 0;
+}
+
+void sd_ble_gap_disconnect_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_disconnect_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_disconnect_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_disconnect_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_disconnect_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t hci_status_code, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_disconnect_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_disconnect_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_disconnect(cmock_call_instance, conn_handle, hci_status_code);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_disconnect_StubWithCallback(CMOCK_sd_ble_gap_disconnect_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_disconnect_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_disconnect_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_disconnect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_disconnect'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_disconnect_CMockIgnoreArg_hci_status_code(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_disconnect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_disconnect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "hci_status_code IgnoreArg called before Expect on 'sd_ble_gap_disconnect'.");
+  cmock_call_instance->IgnoreArg_hci_status_code = 1;
+}
+
+uint32_t sd_ble_gap_tx_power_set(int8_t tx_power)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_tx_power_set_CallInstance);
+  Mock.sd_ble_gap_tx_power_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_tx_power_set_CallInstance);
+  if (Mock.sd_ble_gap_tx_power_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_tx_power_set_FinalReturn;
+    Mock.sd_ble_gap_tx_power_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_tx_power_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_tx_power_set_CallbackFunctionPointer(tx_power, Mock.sd_ble_gap_tx_power_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_tx_power_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_tx_power_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_tx_power_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_tx_power)
+  {
+    UNITY_TEST_ASSERT_EQUAL_INT8(cmock_call_instance->Expected_tx_power, tx_power, cmock_line, "Function 'sd_ble_gap_tx_power_set' called with unexpected value for argument 'tx_power'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_tx_power_set(CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE* cmock_call_instance, int8_t tx_power)
+{
+  cmock_call_instance->Expected_tx_power = tx_power;
+  cmock_call_instance->IgnoreArg_tx_power = 0;
+}
+
+void sd_ble_gap_tx_power_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_tx_power_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_tx_power_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_tx_power_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_tx_power_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int8_t tx_power, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_tx_power_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_tx_power_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_tx_power_set(cmock_call_instance, tx_power);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_tx_power_set_StubWithCallback(CMOCK_sd_ble_gap_tx_power_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_tx_power_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_tx_power_set_CMockIgnoreArg_tx_power(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_tx_power_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_tx_power_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "tx_power IgnoreArg called before Expect on 'sd_ble_gap_tx_power_set'.");
+  cmock_call_instance->IgnoreArg_tx_power = 1;
+}
+
+uint32_t sd_ble_gap_appearance_set(uint16_t appearance)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_appearance_set_CallInstance);
+  Mock.sd_ble_gap_appearance_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_appearance_set_CallInstance);
+  if (Mock.sd_ble_gap_appearance_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_appearance_set_FinalReturn;
+    Mock.sd_ble_gap_appearance_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_appearance_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_appearance_set_CallbackFunctionPointer(appearance, Mock.sd_ble_gap_appearance_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_appearance_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_appearance_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_appearance_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_appearance)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_appearance, appearance, cmock_line, "Function 'sd_ble_gap_appearance_set' called with unexpected value for argument 'appearance'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_appearance_set(CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE* cmock_call_instance, uint16_t appearance)
+{
+  cmock_call_instance->Expected_appearance = appearance;
+  cmock_call_instance->IgnoreArg_appearance = 0;
+}
+
+void sd_ble_gap_appearance_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_appearance_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_appearance_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_appearance_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_appearance_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t appearance, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_appearance_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_appearance_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_appearance_set(cmock_call_instance, appearance);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_appearance_set_StubWithCallback(CMOCK_sd_ble_gap_appearance_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_appearance_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_appearance_set_CMockIgnoreArg_appearance(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_appearance_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_appearance_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "appearance IgnoreArg called before Expect on 'sd_ble_gap_appearance_set'.");
+  cmock_call_instance->IgnoreArg_appearance = 1;
+}
+
+uint32_t sd_ble_gap_appearance_get(uint16_t* p_appearance)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_appearance_get_CallInstance);
+  Mock.sd_ble_gap_appearance_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_appearance_get_CallInstance);
+  if (Mock.sd_ble_gap_appearance_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_appearance_get_FinalReturn;
+    Mock.sd_ble_gap_appearance_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_appearance_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_appearance_get_CallbackFunctionPointer(p_appearance, Mock.sd_ble_gap_appearance_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_appearance_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_appearance_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_appearance_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_appearance)
+  {
+    if (cmock_call_instance->Expected_p_appearance == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_appearance, cmock_line, "Expected NULL. Function 'sd_ble_gap_appearance_get' called with unexpected value for argument 'p_appearance'."); }
+    else if (cmock_call_instance->Expected_p_appearance_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_appearance, p_appearance, cmock_line, "Function 'sd_ble_gap_appearance_get' called with unexpected value for argument 'p_appearance'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_p_appearance, p_appearance, cmock_call_instance->Expected_p_appearance_Depth, cmock_line, "Function 'sd_ble_gap_appearance_get' called with unexpected value for argument 'p_appearance'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_appearance_Used)
+  {
+    memcpy((void*)p_appearance, (void*)cmock_call_instance->ReturnThruPtr_p_appearance_Val,
+      cmock_call_instance->ReturnThruPtr_p_appearance_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_appearance_get(CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE* cmock_call_instance, uint16_t* p_appearance, int p_appearance_Depth)
+{
+  cmock_call_instance->Expected_p_appearance = p_appearance;
+  cmock_call_instance->Expected_p_appearance_Depth = p_appearance_Depth;
+  cmock_call_instance->IgnoreArg_p_appearance = 0;
+  cmock_call_instance->ReturnThruPtr_p_appearance_Used = 0;
+}
+
+void sd_ble_gap_appearance_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_appearance_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_appearance_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_appearance_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_appearance_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t* p_appearance, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_appearance_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_appearance_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_appearance_get(cmock_call_instance, p_appearance, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_appearance_get_StubWithCallback(CMOCK_sd_ble_gap_appearance_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_appearance_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_appearance_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t* p_appearance, int p_appearance_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_appearance_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_appearance_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_appearance_get(cmock_call_instance, p_appearance, p_appearance_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_appearance_get_CMockReturnMemThruPtr_p_appearance(UNITY_LINE_TYPE cmock_line, uint16_t* p_appearance, int cmock_size)
+{
+  CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_appearance_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_appearance ReturnThruPtr called before Expect on 'sd_ble_gap_appearance_get'.");
+  cmock_call_instance->ReturnThruPtr_p_appearance_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_appearance_Val = p_appearance;
+  cmock_call_instance->ReturnThruPtr_p_appearance_Size = cmock_size;
+}
+
+void sd_ble_gap_appearance_get_CMockIgnoreArg_p_appearance(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_appearance_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_appearance_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_appearance IgnoreArg called before Expect on 'sd_ble_gap_appearance_get'.");
+  cmock_call_instance->IgnoreArg_p_appearance = 1;
+}
+
+uint32_t sd_ble_gap_ppcp_set(ble_gap_conn_params_t const* p_conn_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_ppcp_set_CallInstance);
+  Mock.sd_ble_gap_ppcp_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_ppcp_set_CallInstance);
+  if (Mock.sd_ble_gap_ppcp_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_ppcp_set_FinalReturn;
+    Mock.sd_ble_gap_ppcp_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_ppcp_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_ppcp_set_CallbackFunctionPointer(p_conn_params, Mock.sd_ble_gap_ppcp_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_ppcp_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_ppcp_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_ppcp_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_conn_params)
+  {
+    if (cmock_call_instance->Expected_p_conn_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_conn_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_ppcp_set' called with unexpected value for argument 'p_conn_params'."); }
+    else if (cmock_call_instance->Expected_p_conn_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_conn_params, p_conn_params, cmock_line, "Function 'sd_ble_gap_ppcp_set' called with unexpected value for argument 'p_conn_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_conn_params), (void*)(p_conn_params), sizeof(ble_gap_conn_params_t), cmock_call_instance->Expected_p_conn_params_Depth, cmock_line, "Function 'sd_ble_gap_ppcp_set' called with unexpected value for argument 'p_conn_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_conn_params_Used)
+  {
+    memcpy((void*)p_conn_params, (void*)cmock_call_instance->ReturnThruPtr_p_conn_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_conn_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_ppcp_set(CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE* cmock_call_instance, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth)
+{
+  cmock_call_instance->Expected_p_conn_params = p_conn_params;
+  cmock_call_instance->Expected_p_conn_params_Depth = p_conn_params_Depth;
+  cmock_call_instance->IgnoreArg_p_conn_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Used = 0;
+}
+
+void sd_ble_gap_ppcp_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_ppcp_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_ppcp_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_ppcp_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_ppcp_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_ppcp_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_ppcp_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_ppcp_set(cmock_call_instance, p_conn_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_ppcp_set_StubWithCallback(CMOCK_sd_ble_gap_ppcp_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_ppcp_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_ppcp_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_ppcp_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_ppcp_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_ppcp_set(cmock_call_instance, p_conn_params, p_conn_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_ppcp_set_CMockReturnMemThruPtr_p_conn_params(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_ppcp_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_params ReturnThruPtr called before Expect on 'sd_ble_gap_ppcp_set'.");
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Val = p_conn_params;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Size = cmock_size;
+}
+
+void sd_ble_gap_ppcp_set_CMockIgnoreArg_p_conn_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_ppcp_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_params IgnoreArg called before Expect on 'sd_ble_gap_ppcp_set'.");
+  cmock_call_instance->IgnoreArg_p_conn_params = 1;
+}
+
+uint32_t sd_ble_gap_ppcp_get(ble_gap_conn_params_t* p_conn_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_ppcp_get_CallInstance);
+  Mock.sd_ble_gap_ppcp_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_ppcp_get_CallInstance);
+  if (Mock.sd_ble_gap_ppcp_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_ppcp_get_FinalReturn;
+    Mock.sd_ble_gap_ppcp_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_ppcp_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_ppcp_get_CallbackFunctionPointer(p_conn_params, Mock.sd_ble_gap_ppcp_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_ppcp_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_ppcp_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_ppcp_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_conn_params)
+  {
+    if (cmock_call_instance->Expected_p_conn_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_conn_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_ppcp_get' called with unexpected value for argument 'p_conn_params'."); }
+    else if (cmock_call_instance->Expected_p_conn_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_conn_params, p_conn_params, cmock_line, "Function 'sd_ble_gap_ppcp_get' called with unexpected value for argument 'p_conn_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_conn_params), (void*)(p_conn_params), sizeof(ble_gap_conn_params_t), cmock_call_instance->Expected_p_conn_params_Depth, cmock_line, "Function 'sd_ble_gap_ppcp_get' called with unexpected value for argument 'p_conn_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_conn_params_Used)
+  {
+    memcpy((void*)p_conn_params, (void*)cmock_call_instance->ReturnThruPtr_p_conn_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_conn_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_ppcp_get(CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE* cmock_call_instance, ble_gap_conn_params_t* p_conn_params, int p_conn_params_Depth)
+{
+  cmock_call_instance->Expected_p_conn_params = p_conn_params;
+  cmock_call_instance->Expected_p_conn_params_Depth = p_conn_params_Depth;
+  cmock_call_instance->IgnoreArg_p_conn_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Used = 0;
+}
+
+void sd_ble_gap_ppcp_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_ppcp_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_ppcp_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_ppcp_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_ppcp_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t* p_conn_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_ppcp_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_ppcp_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_ppcp_get(cmock_call_instance, p_conn_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_ppcp_get_StubWithCallback(CMOCK_sd_ble_gap_ppcp_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_ppcp_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_ppcp_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t* p_conn_params, int p_conn_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_ppcp_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_ppcp_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_ppcp_get(cmock_call_instance, p_conn_params, p_conn_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_ppcp_get_CMockReturnMemThruPtr_p_conn_params(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t* p_conn_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_ppcp_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_params ReturnThruPtr called before Expect on 'sd_ble_gap_ppcp_get'.");
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Val = p_conn_params;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Size = cmock_size;
+}
+
+void sd_ble_gap_ppcp_get_CMockIgnoreArg_p_conn_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_ppcp_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_ppcp_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_params IgnoreArg called before Expect on 'sd_ble_gap_ppcp_get'.");
+  cmock_call_instance->IgnoreArg_p_conn_params = 1;
+}
+
+uint32_t sd_ble_gap_device_name_set(ble_gap_conn_sec_mode_t const* p_write_perm, uint8_t const* p_dev_name, uint16_t len)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_device_name_set_CallInstance);
+  Mock.sd_ble_gap_device_name_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_device_name_set_CallInstance);
+  if (Mock.sd_ble_gap_device_name_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_device_name_set_FinalReturn;
+    Mock.sd_ble_gap_device_name_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_device_name_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_device_name_set_CallbackFunctionPointer(p_write_perm, p_dev_name, len, Mock.sd_ble_gap_device_name_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_device_name_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_device_name_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_device_name_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_write_perm)
+  {
+    if (cmock_call_instance->Expected_p_write_perm == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_write_perm, cmock_line, "Expected NULL. Function 'sd_ble_gap_device_name_set' called with unexpected value for argument 'p_write_perm'."); }
+    else if (cmock_call_instance->Expected_p_write_perm_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_write_perm, p_write_perm, cmock_line, "Function 'sd_ble_gap_device_name_set' called with unexpected value for argument 'p_write_perm'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_write_perm), (void*)(p_write_perm), sizeof(ble_gap_conn_sec_mode_t), cmock_call_instance->Expected_p_write_perm_Depth, cmock_line, "Function 'sd_ble_gap_device_name_set' called with unexpected value for argument 'p_write_perm'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_dev_name)
+  {
+    if (cmock_call_instance->Expected_p_dev_name == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_dev_name, cmock_line, "Expected NULL. Function 'sd_ble_gap_device_name_set' called with unexpected value for argument 'p_dev_name'."); }
+    else if (cmock_call_instance->Expected_p_dev_name_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_dev_name, p_dev_name, cmock_line, "Function 'sd_ble_gap_device_name_set' called with unexpected value for argument 'p_dev_name'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_dev_name, p_dev_name, cmock_call_instance->Expected_p_dev_name_Depth, cmock_line, "Function 'sd_ble_gap_device_name_set' called with unexpected value for argument 'p_dev_name'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_len)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_len, len, cmock_line, "Function 'sd_ble_gap_device_name_set' called with unexpected value for argument 'len'.");
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_write_perm_Used)
+  {
+    memcpy((void*)p_write_perm, (void*)cmock_call_instance->ReturnThruPtr_p_write_perm_Val,
+      cmock_call_instance->ReturnThruPtr_p_write_perm_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_dev_name_Used)
+  {
+    memcpy((void*)p_dev_name, (void*)cmock_call_instance->ReturnThruPtr_p_dev_name_Val,
+      cmock_call_instance->ReturnThruPtr_p_dev_name_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_device_name_set(CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance, ble_gap_conn_sec_mode_t const* p_write_perm, int p_write_perm_Depth, uint8_t const* p_dev_name, int p_dev_name_Depth, uint16_t len)
+{
+  cmock_call_instance->Expected_p_write_perm = p_write_perm;
+  cmock_call_instance->Expected_p_write_perm_Depth = p_write_perm_Depth;
+  cmock_call_instance->IgnoreArg_p_write_perm = 0;
+  cmock_call_instance->ReturnThruPtr_p_write_perm_Used = 0;
+  cmock_call_instance->Expected_p_dev_name = p_dev_name;
+  cmock_call_instance->Expected_p_dev_name_Depth = p_dev_name_Depth;
+  cmock_call_instance->IgnoreArg_p_dev_name = 0;
+  cmock_call_instance->ReturnThruPtr_p_dev_name_Used = 0;
+  cmock_call_instance->Expected_len = len;
+  cmock_call_instance->IgnoreArg_len = 0;
+}
+
+void sd_ble_gap_device_name_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_name_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_name_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_device_name_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_device_name_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_sec_mode_t const* p_write_perm, uint8_t const* p_dev_name, uint16_t len, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_name_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_name_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_device_name_set(cmock_call_instance, p_write_perm, 0, p_dev_name, 0, len);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_device_name_set_StubWithCallback(CMOCK_sd_ble_gap_device_name_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_device_name_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_device_name_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_sec_mode_t const* p_write_perm, int p_write_perm_Depth, uint8_t const* p_dev_name, int p_dev_name_Depth, uint16_t len, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_name_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_name_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_device_name_set(cmock_call_instance, p_write_perm, p_write_perm_Depth, p_dev_name, p_dev_name_Depth, len);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_write_perm(UNITY_LINE_TYPE cmock_line, ble_gap_conn_sec_mode_t const* p_write_perm, int cmock_size)
+{
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_write_perm ReturnThruPtr called before Expect on 'sd_ble_gap_device_name_set'.");
+  cmock_call_instance->ReturnThruPtr_p_write_perm_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_write_perm_Val = p_write_perm;
+  cmock_call_instance->ReturnThruPtr_p_write_perm_Size = cmock_size;
+}
+
+void sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_dev_name(UNITY_LINE_TYPE cmock_line, uint8_t const* p_dev_name, int cmock_size)
+{
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_dev_name ReturnThruPtr called before Expect on 'sd_ble_gap_device_name_set'.");
+  cmock_call_instance->ReturnThruPtr_p_dev_name_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_dev_name_Val = p_dev_name;
+  cmock_call_instance->ReturnThruPtr_p_dev_name_Size = cmock_size;
+}
+
+void sd_ble_gap_device_name_set_CMockIgnoreArg_p_write_perm(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_write_perm IgnoreArg called before Expect on 'sd_ble_gap_device_name_set'.");
+  cmock_call_instance->IgnoreArg_p_write_perm = 1;
+}
+
+void sd_ble_gap_device_name_set_CMockIgnoreArg_p_dev_name(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_dev_name IgnoreArg called before Expect on 'sd_ble_gap_device_name_set'.");
+  cmock_call_instance->IgnoreArg_p_dev_name = 1;
+}
+
+void sd_ble_gap_device_name_set_CMockIgnoreArg_len(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "len IgnoreArg called before Expect on 'sd_ble_gap_device_name_set'.");
+  cmock_call_instance->IgnoreArg_len = 1;
+}
+
+uint32_t sd_ble_gap_device_name_get(uint8_t* p_dev_name, uint16_t* p_len)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_device_name_get_CallInstance);
+  Mock.sd_ble_gap_device_name_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_device_name_get_CallInstance);
+  if (Mock.sd_ble_gap_device_name_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_device_name_get_FinalReturn;
+    Mock.sd_ble_gap_device_name_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_device_name_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_device_name_get_CallbackFunctionPointer(p_dev_name, p_len, Mock.sd_ble_gap_device_name_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_device_name_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_device_name_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_device_name_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_dev_name)
+  {
+    if (cmock_call_instance->Expected_p_dev_name == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_dev_name, cmock_line, "Expected NULL. Function 'sd_ble_gap_device_name_get' called with unexpected value for argument 'p_dev_name'."); }
+    else if (cmock_call_instance->Expected_p_dev_name_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_dev_name, p_dev_name, cmock_line, "Function 'sd_ble_gap_device_name_get' called with unexpected value for argument 'p_dev_name'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_dev_name, p_dev_name, cmock_call_instance->Expected_p_dev_name_Depth, cmock_line, "Function 'sd_ble_gap_device_name_get' called with unexpected value for argument 'p_dev_name'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_len)
+  {
+    if (cmock_call_instance->Expected_p_len == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_len, cmock_line, "Expected NULL. Function 'sd_ble_gap_device_name_get' called with unexpected value for argument 'p_len'."); }
+    else if (cmock_call_instance->Expected_p_len_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_len, p_len, cmock_line, "Function 'sd_ble_gap_device_name_get' called with unexpected value for argument 'p_len'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_p_len, p_len, cmock_call_instance->Expected_p_len_Depth, cmock_line, "Function 'sd_ble_gap_device_name_get' called with unexpected value for argument 'p_len'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_dev_name_Used)
+  {
+    memcpy((void*)p_dev_name, (void*)cmock_call_instance->ReturnThruPtr_p_dev_name_Val,
+      cmock_call_instance->ReturnThruPtr_p_dev_name_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_len_Used)
+  {
+    memcpy((void*)p_len, (void*)cmock_call_instance->ReturnThruPtr_p_len_Val,
+      cmock_call_instance->ReturnThruPtr_p_len_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_device_name_get(CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance, uint8_t* p_dev_name, int p_dev_name_Depth, uint16_t* p_len, int p_len_Depth)
+{
+  cmock_call_instance->Expected_p_dev_name = p_dev_name;
+  cmock_call_instance->Expected_p_dev_name_Depth = p_dev_name_Depth;
+  cmock_call_instance->IgnoreArg_p_dev_name = 0;
+  cmock_call_instance->ReturnThruPtr_p_dev_name_Used = 0;
+  cmock_call_instance->Expected_p_len = p_len;
+  cmock_call_instance->Expected_p_len_Depth = p_len_Depth;
+  cmock_call_instance->IgnoreArg_p_len = 0;
+  cmock_call_instance->ReturnThruPtr_p_len_Used = 0;
+}
+
+void sd_ble_gap_device_name_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_name_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_name_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_device_name_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_device_name_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_dev_name, uint16_t* p_len, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_name_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_name_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_device_name_get(cmock_call_instance, p_dev_name, 0, p_len, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_device_name_get_StubWithCallback(CMOCK_sd_ble_gap_device_name_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_device_name_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_device_name_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_dev_name, int p_dev_name_Depth, uint16_t* p_len, int p_len_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_device_name_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_device_name_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_device_name_get(cmock_call_instance, p_dev_name, p_dev_name_Depth, p_len, p_len_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_dev_name(UNITY_LINE_TYPE cmock_line, uint8_t* p_dev_name, int cmock_size)
+{
+  CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_dev_name ReturnThruPtr called before Expect on 'sd_ble_gap_device_name_get'.");
+  cmock_call_instance->ReturnThruPtr_p_dev_name_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_dev_name_Val = p_dev_name;
+  cmock_call_instance->ReturnThruPtr_p_dev_name_Size = cmock_size;
+}
+
+void sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_len(UNITY_LINE_TYPE cmock_line, uint16_t* p_len, int cmock_size)
+{
+  CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_len ReturnThruPtr called before Expect on 'sd_ble_gap_device_name_get'.");
+  cmock_call_instance->ReturnThruPtr_p_len_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_len_Val = p_len;
+  cmock_call_instance->ReturnThruPtr_p_len_Size = cmock_size;
+}
+
+void sd_ble_gap_device_name_get_CMockIgnoreArg_p_dev_name(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_dev_name IgnoreArg called before Expect on 'sd_ble_gap_device_name_get'.");
+  cmock_call_instance->IgnoreArg_p_dev_name = 1;
+}
+
+void sd_ble_gap_device_name_get_CMockIgnoreArg_p_len(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_device_name_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_device_name_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_len IgnoreArg called before Expect on 'sd_ble_gap_device_name_get'.");
+  cmock_call_instance->IgnoreArg_p_len = 1;
+}
+
+uint32_t sd_ble_gap_authenticate(uint16_t conn_handle, ble_gap_sec_params_t const* p_sec_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_authenticate_CallInstance);
+  Mock.sd_ble_gap_authenticate_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_authenticate_CallInstance);
+  if (Mock.sd_ble_gap_authenticate_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_authenticate_FinalReturn;
+    Mock.sd_ble_gap_authenticate_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_authenticate_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_authenticate_CallbackFunctionPointer(conn_handle, p_sec_params, Mock.sd_ble_gap_authenticate_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_authenticate' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_authenticate' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_authenticate' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_authenticate' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_sec_params)
+  {
+    if (cmock_call_instance->Expected_p_sec_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_sec_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_authenticate' called with unexpected value for argument 'p_sec_params'."); }
+    else if (cmock_call_instance->Expected_p_sec_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_sec_params, p_sec_params, cmock_line, "Function 'sd_ble_gap_authenticate' called with unexpected value for argument 'p_sec_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_sec_params), (void*)(p_sec_params), sizeof(ble_gap_sec_params_t), cmock_call_instance->Expected_p_sec_params_Depth, cmock_line, "Function 'sd_ble_gap_authenticate' called with unexpected value for argument 'p_sec_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_sec_params_Used)
+  {
+    memcpy((void*)p_sec_params, (void*)cmock_call_instance->ReturnThruPtr_p_sec_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_sec_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_authenticate(CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gap_sec_params_t const* p_sec_params, int p_sec_params_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_sec_params = p_sec_params;
+  cmock_call_instance->Expected_p_sec_params_Depth = p_sec_params_Depth;
+  cmock_call_instance->IgnoreArg_p_sec_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_sec_params_Used = 0;
+}
+
+void sd_ble_gap_authenticate_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_authenticate_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_authenticate_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_authenticate_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_authenticate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_sec_params_t const* p_sec_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_authenticate_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_authenticate_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_authenticate(cmock_call_instance, conn_handle, p_sec_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_authenticate_StubWithCallback(CMOCK_sd_ble_gap_authenticate_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_authenticate_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_authenticate_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_sec_params_t const* p_sec_params, int p_sec_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_authenticate_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_authenticate_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_authenticate(cmock_call_instance, conn_handle, p_sec_params, p_sec_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_authenticate_CMockReturnMemThruPtr_p_sec_params(UNITY_LINE_TYPE cmock_line, ble_gap_sec_params_t const* p_sec_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_authenticate_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sec_params ReturnThruPtr called before Expect on 'sd_ble_gap_authenticate'.");
+  cmock_call_instance->ReturnThruPtr_p_sec_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_sec_params_Val = p_sec_params;
+  cmock_call_instance->ReturnThruPtr_p_sec_params_Size = cmock_size;
+}
+
+void sd_ble_gap_authenticate_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_authenticate_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_authenticate'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_authenticate_CMockIgnoreArg_p_sec_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_authenticate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_authenticate_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sec_params IgnoreArg called before Expect on 'sd_ble_gap_authenticate'.");
+  cmock_call_instance->IgnoreArg_p_sec_params = 1;
+}
+
+uint32_t sd_ble_gap_sec_params_reply(uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const* p_sec_params, ble_gap_sec_keyset_t const* p_sec_keyset)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_sec_params_reply_CallInstance);
+  Mock.sd_ble_gap_sec_params_reply_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_sec_params_reply_CallInstance);
+  if (Mock.sd_ble_gap_sec_params_reply_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_sec_params_reply_FinalReturn;
+    Mock.sd_ble_gap_sec_params_reply_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_sec_params_reply_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_sec_params_reply_CallbackFunctionPointer(conn_handle, sec_status, p_sec_params, p_sec_keyset, Mock.sd_ble_gap_sec_params_reply_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_sec_params_reply' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_sec_params_reply' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_sec_params_reply' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_sec_params_reply' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_sec_status)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_sec_status, sec_status, cmock_line, "Function 'sd_ble_gap_sec_params_reply' called with unexpected value for argument 'sec_status'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_sec_params)
+  {
+    if (cmock_call_instance->Expected_p_sec_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_sec_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_sec_params_reply' called with unexpected value for argument 'p_sec_params'."); }
+    else if (cmock_call_instance->Expected_p_sec_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_sec_params, p_sec_params, cmock_line, "Function 'sd_ble_gap_sec_params_reply' called with unexpected value for argument 'p_sec_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_sec_params), (void*)(p_sec_params), sizeof(ble_gap_sec_params_t), cmock_call_instance->Expected_p_sec_params_Depth, cmock_line, "Function 'sd_ble_gap_sec_params_reply' called with unexpected value for argument 'p_sec_params'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_sec_keyset)
+  {
+    if (cmock_call_instance->Expected_p_sec_keyset == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_sec_keyset, cmock_line, "Expected NULL. Function 'sd_ble_gap_sec_params_reply' called with unexpected value for argument 'p_sec_keyset'."); }
+    else if (cmock_call_instance->Expected_p_sec_keyset_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_sec_keyset, p_sec_keyset, cmock_line, "Function 'sd_ble_gap_sec_params_reply' called with unexpected value for argument 'p_sec_keyset'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_sec_keyset), (void*)(p_sec_keyset), sizeof(ble_gap_sec_keyset_t), cmock_call_instance->Expected_p_sec_keyset_Depth, cmock_line, "Function 'sd_ble_gap_sec_params_reply' called with unexpected value for argument 'p_sec_keyset'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_sec_params_Used)
+  {
+    memcpy((void*)p_sec_params, (void*)cmock_call_instance->ReturnThruPtr_p_sec_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_sec_params_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_sec_keyset_Used)
+  {
+    memcpy((void*)p_sec_keyset, (void*)cmock_call_instance->ReturnThruPtr_p_sec_keyset_Val,
+      cmock_call_instance->ReturnThruPtr_p_sec_keyset_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_sec_params_reply(CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const* p_sec_params, int p_sec_params_Depth, ble_gap_sec_keyset_t const* p_sec_keyset, int p_sec_keyset_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_sec_status = sec_status;
+  cmock_call_instance->IgnoreArg_sec_status = 0;
+  cmock_call_instance->Expected_p_sec_params = p_sec_params;
+  cmock_call_instance->Expected_p_sec_params_Depth = p_sec_params_Depth;
+  cmock_call_instance->IgnoreArg_p_sec_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_sec_params_Used = 0;
+  cmock_call_instance->Expected_p_sec_keyset = p_sec_keyset;
+  cmock_call_instance->Expected_p_sec_keyset_Depth = p_sec_keyset_Depth;
+  cmock_call_instance->IgnoreArg_p_sec_keyset = 0;
+  cmock_call_instance->ReturnThruPtr_p_sec_keyset_Used = 0;
+}
+
+void sd_ble_gap_sec_params_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_sec_params_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_sec_params_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_sec_params_reply_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_sec_params_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const* p_sec_params, ble_gap_sec_keyset_t const* p_sec_keyset, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_sec_params_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_sec_params_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_sec_params_reply(cmock_call_instance, conn_handle, sec_status, p_sec_params, 0, p_sec_keyset, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_sec_params_reply_StubWithCallback(CMOCK_sd_ble_gap_sec_params_reply_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_sec_params_reply_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_sec_params_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const* p_sec_params, int p_sec_params_Depth, ble_gap_sec_keyset_t const* p_sec_keyset, int p_sec_keyset_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_sec_params_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_sec_params_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_sec_params_reply(cmock_call_instance, conn_handle, sec_status, p_sec_params, p_sec_params_Depth, p_sec_keyset, p_sec_keyset_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_params(UNITY_LINE_TYPE cmock_line, ble_gap_sec_params_t const* p_sec_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_params_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sec_params ReturnThruPtr called before Expect on 'sd_ble_gap_sec_params_reply'.");
+  cmock_call_instance->ReturnThruPtr_p_sec_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_sec_params_Val = p_sec_params;
+  cmock_call_instance->ReturnThruPtr_p_sec_params_Size = cmock_size;
+}
+
+void sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_keyset(UNITY_LINE_TYPE cmock_line, ble_gap_sec_keyset_t const* p_sec_keyset, int cmock_size)
+{
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_params_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sec_keyset ReturnThruPtr called before Expect on 'sd_ble_gap_sec_params_reply'.");
+  cmock_call_instance->ReturnThruPtr_p_sec_keyset_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_sec_keyset_Val = p_sec_keyset;
+  cmock_call_instance->ReturnThruPtr_p_sec_keyset_Size = cmock_size;
+}
+
+void sd_ble_gap_sec_params_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_params_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_sec_params_reply'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_sec_params_reply_CMockIgnoreArg_sec_status(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_params_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "sec_status IgnoreArg called before Expect on 'sd_ble_gap_sec_params_reply'.");
+  cmock_call_instance->IgnoreArg_sec_status = 1;
+}
+
+void sd_ble_gap_sec_params_reply_CMockIgnoreArg_p_sec_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_params_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sec_params IgnoreArg called before Expect on 'sd_ble_gap_sec_params_reply'.");
+  cmock_call_instance->IgnoreArg_p_sec_params = 1;
+}
+
+void sd_ble_gap_sec_params_reply_CMockIgnoreArg_p_sec_keyset(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_params_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_params_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sec_keyset IgnoreArg called before Expect on 'sd_ble_gap_sec_params_reply'.");
+  cmock_call_instance->IgnoreArg_p_sec_keyset = 1;
+}
+
+uint32_t sd_ble_gap_auth_key_reply(uint16_t conn_handle, uint8_t key_type, uint8_t const* p_key)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_auth_key_reply_CallInstance);
+  Mock.sd_ble_gap_auth_key_reply_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_auth_key_reply_CallInstance);
+  if (Mock.sd_ble_gap_auth_key_reply_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_auth_key_reply_FinalReturn;
+    Mock.sd_ble_gap_auth_key_reply_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_auth_key_reply_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_auth_key_reply_CallbackFunctionPointer(conn_handle, key_type, p_key, Mock.sd_ble_gap_auth_key_reply_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_auth_key_reply' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_auth_key_reply' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_auth_key_reply' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_auth_key_reply' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_key_type)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_key_type, key_type, cmock_line, "Function 'sd_ble_gap_auth_key_reply' called with unexpected value for argument 'key_type'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_key)
+  {
+    if (cmock_call_instance->Expected_p_key == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_key, cmock_line, "Expected NULL. Function 'sd_ble_gap_auth_key_reply' called with unexpected value for argument 'p_key'."); }
+    else if (cmock_call_instance->Expected_p_key_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_key, p_key, cmock_line, "Function 'sd_ble_gap_auth_key_reply' called with unexpected value for argument 'p_key'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_p_key, p_key, cmock_call_instance->Expected_p_key_Depth, cmock_line, "Function 'sd_ble_gap_auth_key_reply' called with unexpected value for argument 'p_key'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_key_Used)
+  {
+    memcpy((void*)p_key, (void*)cmock_call_instance->ReturnThruPtr_p_key_Val,
+      cmock_call_instance->ReturnThruPtr_p_key_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_auth_key_reply(CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint8_t key_type, uint8_t const* p_key, int p_key_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_key_type = key_type;
+  cmock_call_instance->IgnoreArg_key_type = 0;
+  cmock_call_instance->Expected_p_key = p_key;
+  cmock_call_instance->Expected_p_key_Depth = p_key_Depth;
+  cmock_call_instance->IgnoreArg_p_key = 0;
+  cmock_call_instance->ReturnThruPtr_p_key_Used = 0;
+}
+
+void sd_ble_gap_auth_key_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_auth_key_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_auth_key_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_auth_key_reply_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_auth_key_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t key_type, uint8_t const* p_key, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_auth_key_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_auth_key_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_auth_key_reply(cmock_call_instance, conn_handle, key_type, p_key, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_auth_key_reply_StubWithCallback(CMOCK_sd_ble_gap_auth_key_reply_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_auth_key_reply_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_auth_key_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t key_type, uint8_t const* p_key, int p_key_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_auth_key_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_auth_key_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_auth_key_reply(cmock_call_instance, conn_handle, key_type, p_key, p_key_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_auth_key_reply_CMockReturnMemThruPtr_p_key(UNITY_LINE_TYPE cmock_line, uint8_t const* p_key, int cmock_size)
+{
+  CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_auth_key_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_key ReturnThruPtr called before Expect on 'sd_ble_gap_auth_key_reply'.");
+  cmock_call_instance->ReturnThruPtr_p_key_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_key_Val = p_key;
+  cmock_call_instance->ReturnThruPtr_p_key_Size = cmock_size;
+}
+
+void sd_ble_gap_auth_key_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_auth_key_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_auth_key_reply'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_auth_key_reply_CMockIgnoreArg_key_type(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_auth_key_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "key_type IgnoreArg called before Expect on 'sd_ble_gap_auth_key_reply'.");
+  cmock_call_instance->IgnoreArg_key_type = 1;
+}
+
+void sd_ble_gap_auth_key_reply_CMockIgnoreArg_p_key(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_auth_key_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_auth_key_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_key IgnoreArg called before Expect on 'sd_ble_gap_auth_key_reply'.");
+  cmock_call_instance->IgnoreArg_p_key = 1;
+}
+
+uint32_t sd_ble_gap_lesc_dhkey_reply(uint16_t conn_handle, ble_gap_lesc_dhkey_t const* p_dhkey)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance);
+  Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance);
+  if (Mock.sd_ble_gap_lesc_dhkey_reply_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_lesc_dhkey_reply_FinalReturn;
+    Mock.sd_ble_gap_lesc_dhkey_reply_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_lesc_dhkey_reply_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_lesc_dhkey_reply_CallbackFunctionPointer(conn_handle, p_dhkey, Mock.sd_ble_gap_lesc_dhkey_reply_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_lesc_dhkey_reply' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_lesc_dhkey_reply' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_lesc_dhkey_reply' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_lesc_dhkey_reply' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_dhkey)
+  {
+    if (cmock_call_instance->Expected_p_dhkey == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_dhkey, cmock_line, "Expected NULL. Function 'sd_ble_gap_lesc_dhkey_reply' called with unexpected value for argument 'p_dhkey'."); }
+    else if (cmock_call_instance->Expected_p_dhkey_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_dhkey, p_dhkey, cmock_line, "Function 'sd_ble_gap_lesc_dhkey_reply' called with unexpected value for argument 'p_dhkey'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_dhkey), (void*)(p_dhkey), sizeof(ble_gap_lesc_dhkey_t), cmock_call_instance->Expected_p_dhkey_Depth, cmock_line, "Function 'sd_ble_gap_lesc_dhkey_reply' called with unexpected value for argument 'p_dhkey'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_dhkey_Used)
+  {
+    memcpy((void*)p_dhkey, (void*)cmock_call_instance->ReturnThruPtr_p_dhkey_Val,
+      cmock_call_instance->ReturnThruPtr_p_dhkey_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_lesc_dhkey_reply(CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gap_lesc_dhkey_t const* p_dhkey, int p_dhkey_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_dhkey = p_dhkey;
+  cmock_call_instance->Expected_p_dhkey_Depth = p_dhkey_Depth;
+  cmock_call_instance->IgnoreArg_p_dhkey = 0;
+  cmock_call_instance->ReturnThruPtr_p_dhkey_Used = 0;
+}
+
+void sd_ble_gap_lesc_dhkey_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_lesc_dhkey_reply_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_lesc_dhkey_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_dhkey_t const* p_dhkey, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_lesc_dhkey_reply(cmock_call_instance, conn_handle, p_dhkey, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_lesc_dhkey_reply_StubWithCallback(CMOCK_sd_ble_gap_lesc_dhkey_reply_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_lesc_dhkey_reply_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_lesc_dhkey_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_dhkey_t const* p_dhkey, int p_dhkey_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_lesc_dhkey_reply(cmock_call_instance, conn_handle, p_dhkey, p_dhkey_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_lesc_dhkey_reply_CMockReturnMemThruPtr_p_dhkey(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_dhkey_t const* p_dhkey, int cmock_size)
+{
+  CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_dhkey ReturnThruPtr called before Expect on 'sd_ble_gap_lesc_dhkey_reply'.");
+  cmock_call_instance->ReturnThruPtr_p_dhkey_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_dhkey_Val = p_dhkey;
+  cmock_call_instance->ReturnThruPtr_p_dhkey_Size = cmock_size;
+}
+
+void sd_ble_gap_lesc_dhkey_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_lesc_dhkey_reply'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_lesc_dhkey_reply_CMockIgnoreArg_p_dhkey(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_dhkey_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_dhkey_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_dhkey IgnoreArg called before Expect on 'sd_ble_gap_lesc_dhkey_reply'.");
+  cmock_call_instance->IgnoreArg_p_dhkey = 1;
+}
+
+uint32_t sd_ble_gap_keypress_notify(uint16_t conn_handle, uint8_t kp_not)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_keypress_notify_CallInstance);
+  Mock.sd_ble_gap_keypress_notify_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_keypress_notify_CallInstance);
+  if (Mock.sd_ble_gap_keypress_notify_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_keypress_notify_FinalReturn;
+    Mock.sd_ble_gap_keypress_notify_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_keypress_notify_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_keypress_notify_CallbackFunctionPointer(conn_handle, kp_not, Mock.sd_ble_gap_keypress_notify_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_keypress_notify' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_keypress_notify' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_keypress_notify' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_keypress_notify' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_kp_not)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_kp_not, kp_not, cmock_line, "Function 'sd_ble_gap_keypress_notify' called with unexpected value for argument 'kp_not'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_keypress_notify(CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint8_t kp_not)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_kp_not = kp_not;
+  cmock_call_instance->IgnoreArg_kp_not = 0;
+}
+
+void sd_ble_gap_keypress_notify_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_keypress_notify_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_keypress_notify_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_keypress_notify_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_keypress_notify_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t kp_not, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_keypress_notify_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_keypress_notify_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_keypress_notify(cmock_call_instance, conn_handle, kp_not);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_keypress_notify_StubWithCallback(CMOCK_sd_ble_gap_keypress_notify_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_keypress_notify_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_keypress_notify_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_keypress_notify_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_keypress_notify'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_keypress_notify_CMockIgnoreArg_kp_not(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_keypress_notify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_keypress_notify_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "kp_not IgnoreArg called before Expect on 'sd_ble_gap_keypress_notify'.");
+  cmock_call_instance->IgnoreArg_kp_not = 1;
+}
+
+uint32_t sd_ble_gap_lesc_oob_data_get(uint16_t conn_handle, ble_gap_lesc_p256_pk_t const* p_pk_own, ble_gap_lesc_oob_data_t* p_oobd_own)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance);
+  Mock.sd_ble_gap_lesc_oob_data_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance);
+  if (Mock.sd_ble_gap_lesc_oob_data_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_lesc_oob_data_get_FinalReturn;
+    Mock.sd_ble_gap_lesc_oob_data_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_lesc_oob_data_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_lesc_oob_data_get_CallbackFunctionPointer(conn_handle, p_pk_own, p_oobd_own, Mock.sd_ble_gap_lesc_oob_data_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_pk_own)
+  {
+    if (cmock_call_instance->Expected_p_pk_own == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_pk_own, cmock_line, "Expected NULL. Function 'sd_ble_gap_lesc_oob_data_get' called with unexpected value for argument 'p_pk_own'."); }
+    else if (cmock_call_instance->Expected_p_pk_own_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_pk_own, p_pk_own, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called with unexpected value for argument 'p_pk_own'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_pk_own), (void*)(p_pk_own), sizeof(ble_gap_lesc_p256_pk_t), cmock_call_instance->Expected_p_pk_own_Depth, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called with unexpected value for argument 'p_pk_own'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_oobd_own)
+  {
+    if (cmock_call_instance->Expected_p_oobd_own == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_oobd_own, cmock_line, "Expected NULL. Function 'sd_ble_gap_lesc_oob_data_get' called with unexpected value for argument 'p_oobd_own'."); }
+    else if (cmock_call_instance->Expected_p_oobd_own_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_oobd_own, p_oobd_own, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called with unexpected value for argument 'p_oobd_own'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_oobd_own), (void*)(p_oobd_own), sizeof(ble_gap_lesc_oob_data_t), cmock_call_instance->Expected_p_oobd_own_Depth, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_get' called with unexpected value for argument 'p_oobd_own'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_pk_own_Used)
+  {
+    memcpy((void*)p_pk_own, (void*)cmock_call_instance->ReturnThruPtr_p_pk_own_Val,
+      cmock_call_instance->ReturnThruPtr_p_pk_own_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_oobd_own_Used)
+  {
+    memcpy((void*)p_oobd_own, (void*)cmock_call_instance->ReturnThruPtr_p_oobd_own_Val,
+      cmock_call_instance->ReturnThruPtr_p_oobd_own_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_lesc_oob_data_get(CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gap_lesc_p256_pk_t const* p_pk_own, int p_pk_own_Depth, ble_gap_lesc_oob_data_t* p_oobd_own, int p_oobd_own_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_pk_own = p_pk_own;
+  cmock_call_instance->Expected_p_pk_own_Depth = p_pk_own_Depth;
+  cmock_call_instance->IgnoreArg_p_pk_own = 0;
+  cmock_call_instance->ReturnThruPtr_p_pk_own_Used = 0;
+  cmock_call_instance->Expected_p_oobd_own = p_oobd_own;
+  cmock_call_instance->Expected_p_oobd_own_Depth = p_oobd_own_Depth;
+  cmock_call_instance->IgnoreArg_p_oobd_own = 0;
+  cmock_call_instance->ReturnThruPtr_p_oobd_own_Used = 0;
+}
+
+void sd_ble_gap_lesc_oob_data_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_oob_data_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_lesc_oob_data_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_lesc_oob_data_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_p256_pk_t const* p_pk_own, ble_gap_lesc_oob_data_t* p_oobd_own, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_oob_data_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_lesc_oob_data_get(cmock_call_instance, conn_handle, p_pk_own, 0, p_oobd_own, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_lesc_oob_data_get_StubWithCallback(CMOCK_sd_ble_gap_lesc_oob_data_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_lesc_oob_data_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_lesc_oob_data_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_p256_pk_t const* p_pk_own, int p_pk_own_Depth, ble_gap_lesc_oob_data_t* p_oobd_own, int p_oobd_own_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_oob_data_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_lesc_oob_data_get(cmock_call_instance, conn_handle, p_pk_own, p_pk_own_Depth, p_oobd_own, p_oobd_own_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_pk_own(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_p256_pk_t const* p_pk_own, int cmock_size)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_pk_own ReturnThruPtr called before Expect on 'sd_ble_gap_lesc_oob_data_get'.");
+  cmock_call_instance->ReturnThruPtr_p_pk_own_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_pk_own_Val = p_pk_own;
+  cmock_call_instance->ReturnThruPtr_p_pk_own_Size = cmock_size;
+}
+
+void sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_oobd_own(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_oob_data_t* p_oobd_own, int cmock_size)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_oobd_own ReturnThruPtr called before Expect on 'sd_ble_gap_lesc_oob_data_get'.");
+  cmock_call_instance->ReturnThruPtr_p_oobd_own_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_oobd_own_Val = p_oobd_own;
+  cmock_call_instance->ReturnThruPtr_p_oobd_own_Size = cmock_size;
+}
+
+void sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_lesc_oob_data_get'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_p_pk_own(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_pk_own IgnoreArg called before Expect on 'sd_ble_gap_lesc_oob_data_get'.");
+  cmock_call_instance->IgnoreArg_p_pk_own = 1;
+}
+
+void sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_p_oobd_own(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_oobd_own IgnoreArg called before Expect on 'sd_ble_gap_lesc_oob_data_get'.");
+  cmock_call_instance->IgnoreArg_p_oobd_own = 1;
+}
+
+uint32_t sd_ble_gap_lesc_oob_data_set(uint16_t conn_handle, ble_gap_lesc_oob_data_t const* p_oobd_own, ble_gap_lesc_oob_data_t const* p_oobd_peer)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance);
+  Mock.sd_ble_gap_lesc_oob_data_set_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance);
+  if (Mock.sd_ble_gap_lesc_oob_data_set_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_lesc_oob_data_set_FinalReturn;
+    Mock.sd_ble_gap_lesc_oob_data_set_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_lesc_oob_data_set_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_lesc_oob_data_set_CallbackFunctionPointer(conn_handle, p_oobd_own, p_oobd_peer, Mock.sd_ble_gap_lesc_oob_data_set_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_oobd_own)
+  {
+    if (cmock_call_instance->Expected_p_oobd_own == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_oobd_own, cmock_line, "Expected NULL. Function 'sd_ble_gap_lesc_oob_data_set' called with unexpected value for argument 'p_oobd_own'."); }
+    else if (cmock_call_instance->Expected_p_oobd_own_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_oobd_own, p_oobd_own, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called with unexpected value for argument 'p_oobd_own'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_oobd_own), (void*)(p_oobd_own), sizeof(ble_gap_lesc_oob_data_t), cmock_call_instance->Expected_p_oobd_own_Depth, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called with unexpected value for argument 'p_oobd_own'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_oobd_peer)
+  {
+    if (cmock_call_instance->Expected_p_oobd_peer == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_oobd_peer, cmock_line, "Expected NULL. Function 'sd_ble_gap_lesc_oob_data_set' called with unexpected value for argument 'p_oobd_peer'."); }
+    else if (cmock_call_instance->Expected_p_oobd_peer_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_oobd_peer, p_oobd_peer, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called with unexpected value for argument 'p_oobd_peer'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_oobd_peer), (void*)(p_oobd_peer), sizeof(ble_gap_lesc_oob_data_t), cmock_call_instance->Expected_p_oobd_peer_Depth, cmock_line, "Function 'sd_ble_gap_lesc_oob_data_set' called with unexpected value for argument 'p_oobd_peer'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_oobd_own_Used)
+  {
+    memcpy((void*)p_oobd_own, (void*)cmock_call_instance->ReturnThruPtr_p_oobd_own_Val,
+      cmock_call_instance->ReturnThruPtr_p_oobd_own_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_oobd_peer_Used)
+  {
+    memcpy((void*)p_oobd_peer, (void*)cmock_call_instance->ReturnThruPtr_p_oobd_peer_Val,
+      cmock_call_instance->ReturnThruPtr_p_oobd_peer_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_lesc_oob_data_set(CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gap_lesc_oob_data_t const* p_oobd_own, int p_oobd_own_Depth, ble_gap_lesc_oob_data_t const* p_oobd_peer, int p_oobd_peer_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_oobd_own = p_oobd_own;
+  cmock_call_instance->Expected_p_oobd_own_Depth = p_oobd_own_Depth;
+  cmock_call_instance->IgnoreArg_p_oobd_own = 0;
+  cmock_call_instance->ReturnThruPtr_p_oobd_own_Used = 0;
+  cmock_call_instance->Expected_p_oobd_peer = p_oobd_peer;
+  cmock_call_instance->Expected_p_oobd_peer_Depth = p_oobd_peer_Depth;
+  cmock_call_instance->IgnoreArg_p_oobd_peer = 0;
+  cmock_call_instance->ReturnThruPtr_p_oobd_peer_Used = 0;
+}
+
+void sd_ble_gap_lesc_oob_data_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_oob_data_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_lesc_oob_data_set_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_lesc_oob_data_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_oob_data_t const* p_oobd_own, ble_gap_lesc_oob_data_t const* p_oobd_peer, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_oob_data_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_lesc_oob_data_set(cmock_call_instance, conn_handle, p_oobd_own, 0, p_oobd_peer, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_lesc_oob_data_set_StubWithCallback(CMOCK_sd_ble_gap_lesc_oob_data_set_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_lesc_oob_data_set_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_lesc_oob_data_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_oob_data_t const* p_oobd_own, int p_oobd_own_Depth, ble_gap_lesc_oob_data_t const* p_oobd_peer, int p_oobd_peer_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_lesc_oob_data_set_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_lesc_oob_data_set(cmock_call_instance, conn_handle, p_oobd_own, p_oobd_own_Depth, p_oobd_peer, p_oobd_peer_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_own(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_oob_data_t const* p_oobd_own, int cmock_size)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_oobd_own ReturnThruPtr called before Expect on 'sd_ble_gap_lesc_oob_data_set'.");
+  cmock_call_instance->ReturnThruPtr_p_oobd_own_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_oobd_own_Val = p_oobd_own;
+  cmock_call_instance->ReturnThruPtr_p_oobd_own_Size = cmock_size;
+}
+
+void sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_peer(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_oob_data_t const* p_oobd_peer, int cmock_size)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_oobd_peer ReturnThruPtr called before Expect on 'sd_ble_gap_lesc_oob_data_set'.");
+  cmock_call_instance->ReturnThruPtr_p_oobd_peer_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_oobd_peer_Val = p_oobd_peer;
+  cmock_call_instance->ReturnThruPtr_p_oobd_peer_Size = cmock_size;
+}
+
+void sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_lesc_oob_data_set'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_p_oobd_own(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_oobd_own IgnoreArg called before Expect on 'sd_ble_gap_lesc_oob_data_set'.");
+  cmock_call_instance->IgnoreArg_p_oobd_own = 1;
+}
+
+void sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_p_oobd_peer(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_lesc_oob_data_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_lesc_oob_data_set_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_oobd_peer IgnoreArg called before Expect on 'sd_ble_gap_lesc_oob_data_set'.");
+  cmock_call_instance->IgnoreArg_p_oobd_peer = 1;
+}
+
+uint32_t sd_ble_gap_encrypt(uint16_t conn_handle, ble_gap_master_id_t const* p_master_id, ble_gap_enc_info_t const* p_enc_info)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_encrypt_CallInstance);
+  Mock.sd_ble_gap_encrypt_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_encrypt_CallInstance);
+  if (Mock.sd_ble_gap_encrypt_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_encrypt_FinalReturn;
+    Mock.sd_ble_gap_encrypt_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_encrypt_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_encrypt_CallbackFunctionPointer(conn_handle, p_master_id, p_enc_info, Mock.sd_ble_gap_encrypt_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_encrypt' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_encrypt' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_encrypt' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_encrypt' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_master_id)
+  {
+    if (cmock_call_instance->Expected_p_master_id == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_master_id, cmock_line, "Expected NULL. Function 'sd_ble_gap_encrypt' called with unexpected value for argument 'p_master_id'."); }
+    else if (cmock_call_instance->Expected_p_master_id_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_master_id, p_master_id, cmock_line, "Function 'sd_ble_gap_encrypt' called with unexpected value for argument 'p_master_id'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_master_id), (void*)(p_master_id), sizeof(ble_gap_master_id_t), cmock_call_instance->Expected_p_master_id_Depth, cmock_line, "Function 'sd_ble_gap_encrypt' called with unexpected value for argument 'p_master_id'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_enc_info)
+  {
+    if (cmock_call_instance->Expected_p_enc_info == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_enc_info, cmock_line, "Expected NULL. Function 'sd_ble_gap_encrypt' called with unexpected value for argument 'p_enc_info'."); }
+    else if (cmock_call_instance->Expected_p_enc_info_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_enc_info, p_enc_info, cmock_line, "Function 'sd_ble_gap_encrypt' called with unexpected value for argument 'p_enc_info'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_enc_info), (void*)(p_enc_info), sizeof(ble_gap_enc_info_t), cmock_call_instance->Expected_p_enc_info_Depth, cmock_line, "Function 'sd_ble_gap_encrypt' called with unexpected value for argument 'p_enc_info'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_master_id_Used)
+  {
+    memcpy((void*)p_master_id, (void*)cmock_call_instance->ReturnThruPtr_p_master_id_Val,
+      cmock_call_instance->ReturnThruPtr_p_master_id_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_enc_info_Used)
+  {
+    memcpy((void*)p_enc_info, (void*)cmock_call_instance->ReturnThruPtr_p_enc_info_Val,
+      cmock_call_instance->ReturnThruPtr_p_enc_info_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_encrypt(CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gap_master_id_t const* p_master_id, int p_master_id_Depth, ble_gap_enc_info_t const* p_enc_info, int p_enc_info_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_master_id = p_master_id;
+  cmock_call_instance->Expected_p_master_id_Depth = p_master_id_Depth;
+  cmock_call_instance->IgnoreArg_p_master_id = 0;
+  cmock_call_instance->ReturnThruPtr_p_master_id_Used = 0;
+  cmock_call_instance->Expected_p_enc_info = p_enc_info;
+  cmock_call_instance->Expected_p_enc_info_Depth = p_enc_info_Depth;
+  cmock_call_instance->IgnoreArg_p_enc_info = 0;
+  cmock_call_instance->ReturnThruPtr_p_enc_info_Used = 0;
+}
+
+void sd_ble_gap_encrypt_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_encrypt_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_encrypt_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_encrypt_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_encrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_master_id_t const* p_master_id, ble_gap_enc_info_t const* p_enc_info, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_encrypt_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_encrypt_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_encrypt(cmock_call_instance, conn_handle, p_master_id, 0, p_enc_info, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_encrypt_StubWithCallback(CMOCK_sd_ble_gap_encrypt_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_encrypt_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_encrypt_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_master_id_t const* p_master_id, int p_master_id_Depth, ble_gap_enc_info_t const* p_enc_info, int p_enc_info_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_encrypt_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_encrypt_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_encrypt(cmock_call_instance, conn_handle, p_master_id, p_master_id_Depth, p_enc_info, p_enc_info_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_master_id(UNITY_LINE_TYPE cmock_line, ble_gap_master_id_t const* p_master_id, int cmock_size)
+{
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_encrypt_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_master_id ReturnThruPtr called before Expect on 'sd_ble_gap_encrypt'.");
+  cmock_call_instance->ReturnThruPtr_p_master_id_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_master_id_Val = p_master_id;
+  cmock_call_instance->ReturnThruPtr_p_master_id_Size = cmock_size;
+}
+
+void sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_enc_info(UNITY_LINE_TYPE cmock_line, ble_gap_enc_info_t const* p_enc_info, int cmock_size)
+{
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_encrypt_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_enc_info ReturnThruPtr called before Expect on 'sd_ble_gap_encrypt'.");
+  cmock_call_instance->ReturnThruPtr_p_enc_info_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_enc_info_Val = p_enc_info;
+  cmock_call_instance->ReturnThruPtr_p_enc_info_Size = cmock_size;
+}
+
+void sd_ble_gap_encrypt_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_encrypt_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_encrypt'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_encrypt_CMockIgnoreArg_p_master_id(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_encrypt_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_master_id IgnoreArg called before Expect on 'sd_ble_gap_encrypt'.");
+  cmock_call_instance->IgnoreArg_p_master_id = 1;
+}
+
+void sd_ble_gap_encrypt_CMockIgnoreArg_p_enc_info(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_encrypt_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_enc_info IgnoreArg called before Expect on 'sd_ble_gap_encrypt'.");
+  cmock_call_instance->IgnoreArg_p_enc_info = 1;
+}
+
+uint32_t sd_ble_gap_sec_info_reply(uint16_t conn_handle, ble_gap_enc_info_t const* p_enc_info, ble_gap_irk_t const* p_id_info, ble_gap_sign_info_t const* p_sign_info)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_sec_info_reply_CallInstance);
+  Mock.sd_ble_gap_sec_info_reply_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_sec_info_reply_CallInstance);
+  if (Mock.sd_ble_gap_sec_info_reply_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_sec_info_reply_FinalReturn;
+    Mock.sd_ble_gap_sec_info_reply_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_sec_info_reply_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_sec_info_reply_CallbackFunctionPointer(conn_handle, p_enc_info, p_id_info, p_sign_info, Mock.sd_ble_gap_sec_info_reply_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_sec_info_reply' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_sec_info_reply' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_enc_info)
+  {
+    if (cmock_call_instance->Expected_p_enc_info == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_enc_info, cmock_line, "Expected NULL. Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_enc_info'."); }
+    else if (cmock_call_instance->Expected_p_enc_info_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_enc_info, p_enc_info, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_enc_info'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_enc_info), (void*)(p_enc_info), sizeof(ble_gap_enc_info_t), cmock_call_instance->Expected_p_enc_info_Depth, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_enc_info'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_id_info)
+  {
+    if (cmock_call_instance->Expected_p_id_info == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_id_info, cmock_line, "Expected NULL. Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_id_info'."); }
+    else if (cmock_call_instance->Expected_p_id_info_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_id_info, p_id_info, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_id_info'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_id_info), (void*)(p_id_info), sizeof(ble_gap_irk_t), cmock_call_instance->Expected_p_id_info_Depth, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_id_info'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_sign_info)
+  {
+    if (cmock_call_instance->Expected_p_sign_info == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_sign_info, cmock_line, "Expected NULL. Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_sign_info'."); }
+    else if (cmock_call_instance->Expected_p_sign_info_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_sign_info, p_sign_info, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_sign_info'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_sign_info), (void*)(p_sign_info), sizeof(ble_gap_sign_info_t), cmock_call_instance->Expected_p_sign_info_Depth, cmock_line, "Function 'sd_ble_gap_sec_info_reply' called with unexpected value for argument 'p_sign_info'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_enc_info_Used)
+  {
+    memcpy((void*)p_enc_info, (void*)cmock_call_instance->ReturnThruPtr_p_enc_info_Val,
+      cmock_call_instance->ReturnThruPtr_p_enc_info_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_id_info_Used)
+  {
+    memcpy((void*)p_id_info, (void*)cmock_call_instance->ReturnThruPtr_p_id_info_Val,
+      cmock_call_instance->ReturnThruPtr_p_id_info_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_sign_info_Used)
+  {
+    memcpy((void*)p_sign_info, (void*)cmock_call_instance->ReturnThruPtr_p_sign_info_Val,
+      cmock_call_instance->ReturnThruPtr_p_sign_info_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_sec_info_reply(CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gap_enc_info_t const* p_enc_info, int p_enc_info_Depth, ble_gap_irk_t const* p_id_info, int p_id_info_Depth, ble_gap_sign_info_t const* p_sign_info, int p_sign_info_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_enc_info = p_enc_info;
+  cmock_call_instance->Expected_p_enc_info_Depth = p_enc_info_Depth;
+  cmock_call_instance->IgnoreArg_p_enc_info = 0;
+  cmock_call_instance->ReturnThruPtr_p_enc_info_Used = 0;
+  cmock_call_instance->Expected_p_id_info = p_id_info;
+  cmock_call_instance->Expected_p_id_info_Depth = p_id_info_Depth;
+  cmock_call_instance->IgnoreArg_p_id_info = 0;
+  cmock_call_instance->ReturnThruPtr_p_id_info_Used = 0;
+  cmock_call_instance->Expected_p_sign_info = p_sign_info;
+  cmock_call_instance->Expected_p_sign_info_Depth = p_sign_info_Depth;
+  cmock_call_instance->IgnoreArg_p_sign_info = 0;
+  cmock_call_instance->ReturnThruPtr_p_sign_info_Used = 0;
+}
+
+void sd_ble_gap_sec_info_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_sec_info_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_sec_info_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_sec_info_reply_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_sec_info_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_enc_info_t const* p_enc_info, ble_gap_irk_t const* p_id_info, ble_gap_sign_info_t const* p_sign_info, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_sec_info_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_sec_info_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_sec_info_reply(cmock_call_instance, conn_handle, p_enc_info, 0, p_id_info, 0, p_sign_info, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_sec_info_reply_StubWithCallback(CMOCK_sd_ble_gap_sec_info_reply_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_sec_info_reply_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_sec_info_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_enc_info_t const* p_enc_info, int p_enc_info_Depth, ble_gap_irk_t const* p_id_info, int p_id_info_Depth, ble_gap_sign_info_t const* p_sign_info, int p_sign_info_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_sec_info_reply_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_sec_info_reply_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_sec_info_reply(cmock_call_instance, conn_handle, p_enc_info, p_enc_info_Depth, p_id_info, p_id_info_Depth, p_sign_info, p_sign_info_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_enc_info(UNITY_LINE_TYPE cmock_line, ble_gap_enc_info_t const* p_enc_info, int cmock_size)
+{
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_info_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_enc_info ReturnThruPtr called before Expect on 'sd_ble_gap_sec_info_reply'.");
+  cmock_call_instance->ReturnThruPtr_p_enc_info_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_enc_info_Val = p_enc_info;
+  cmock_call_instance->ReturnThruPtr_p_enc_info_Size = cmock_size;
+}
+
+void sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_id_info(UNITY_LINE_TYPE cmock_line, ble_gap_irk_t const* p_id_info, int cmock_size)
+{
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_info_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_id_info ReturnThruPtr called before Expect on 'sd_ble_gap_sec_info_reply'.");
+  cmock_call_instance->ReturnThruPtr_p_id_info_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_id_info_Val = p_id_info;
+  cmock_call_instance->ReturnThruPtr_p_id_info_Size = cmock_size;
+}
+
+void sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_sign_info(UNITY_LINE_TYPE cmock_line, ble_gap_sign_info_t const* p_sign_info, int cmock_size)
+{
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_info_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sign_info ReturnThruPtr called before Expect on 'sd_ble_gap_sec_info_reply'.");
+  cmock_call_instance->ReturnThruPtr_p_sign_info_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_sign_info_Val = p_sign_info;
+  cmock_call_instance->ReturnThruPtr_p_sign_info_Size = cmock_size;
+}
+
+void sd_ble_gap_sec_info_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_info_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_sec_info_reply'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_enc_info(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_info_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_enc_info IgnoreArg called before Expect on 'sd_ble_gap_sec_info_reply'.");
+  cmock_call_instance->IgnoreArg_p_enc_info = 1;
+}
+
+void sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_id_info(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_info_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_id_info IgnoreArg called before Expect on 'sd_ble_gap_sec_info_reply'.");
+  cmock_call_instance->IgnoreArg_p_id_info = 1;
+}
+
+void sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_sign_info(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_sec_info_reply_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_sec_info_reply_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_sign_info IgnoreArg called before Expect on 'sd_ble_gap_sec_info_reply'.");
+  cmock_call_instance->IgnoreArg_p_sign_info = 1;
+}
+
+uint32_t sd_ble_gap_conn_sec_get(uint16_t conn_handle, ble_gap_conn_sec_t* p_conn_sec)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_conn_sec_get_CallInstance);
+  Mock.sd_ble_gap_conn_sec_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_conn_sec_get_CallInstance);
+  if (Mock.sd_ble_gap_conn_sec_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_conn_sec_get_FinalReturn;
+    Mock.sd_ble_gap_conn_sec_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_conn_sec_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_conn_sec_get_CallbackFunctionPointer(conn_handle, p_conn_sec, Mock.sd_ble_gap_conn_sec_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_conn_sec_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_conn_sec_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_conn_sec_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_conn_sec_get' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_conn_sec)
+  {
+    if (cmock_call_instance->Expected_p_conn_sec == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_conn_sec, cmock_line, "Expected NULL. Function 'sd_ble_gap_conn_sec_get' called with unexpected value for argument 'p_conn_sec'."); }
+    else if (cmock_call_instance->Expected_p_conn_sec_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_conn_sec, p_conn_sec, cmock_line, "Function 'sd_ble_gap_conn_sec_get' called with unexpected value for argument 'p_conn_sec'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_conn_sec), (void*)(p_conn_sec), sizeof(ble_gap_conn_sec_t), cmock_call_instance->Expected_p_conn_sec_Depth, cmock_line, "Function 'sd_ble_gap_conn_sec_get' called with unexpected value for argument 'p_conn_sec'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_conn_sec_Used)
+  {
+    memcpy((void*)p_conn_sec, (void*)cmock_call_instance->ReturnThruPtr_p_conn_sec_Val,
+      cmock_call_instance->ReturnThruPtr_p_conn_sec_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_conn_sec_get(CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, ble_gap_conn_sec_t* p_conn_sec, int p_conn_sec_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_conn_sec = p_conn_sec;
+  cmock_call_instance->Expected_p_conn_sec_Depth = p_conn_sec_Depth;
+  cmock_call_instance->IgnoreArg_p_conn_sec = 0;
+  cmock_call_instance->ReturnThruPtr_p_conn_sec_Used = 0;
+}
+
+void sd_ble_gap_conn_sec_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_conn_sec_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_conn_sec_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_conn_sec_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_conn_sec_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_conn_sec_t* p_conn_sec, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_conn_sec_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_conn_sec_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_conn_sec_get(cmock_call_instance, conn_handle, p_conn_sec, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_conn_sec_get_StubWithCallback(CMOCK_sd_ble_gap_conn_sec_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_conn_sec_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_conn_sec_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_conn_sec_t* p_conn_sec, int p_conn_sec_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_conn_sec_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_conn_sec_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_conn_sec_get(cmock_call_instance, conn_handle, p_conn_sec, p_conn_sec_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_conn_sec_get_CMockReturnMemThruPtr_p_conn_sec(UNITY_LINE_TYPE cmock_line, ble_gap_conn_sec_t* p_conn_sec, int cmock_size)
+{
+  CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_conn_sec_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_sec ReturnThruPtr called before Expect on 'sd_ble_gap_conn_sec_get'.");
+  cmock_call_instance->ReturnThruPtr_p_conn_sec_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_conn_sec_Val = p_conn_sec;
+  cmock_call_instance->ReturnThruPtr_p_conn_sec_Size = cmock_size;
+}
+
+void sd_ble_gap_conn_sec_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_conn_sec_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_conn_sec_get'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_conn_sec_get_CMockIgnoreArg_p_conn_sec(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_conn_sec_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_conn_sec_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_sec IgnoreArg called before Expect on 'sd_ble_gap_conn_sec_get'.");
+  cmock_call_instance->IgnoreArg_p_conn_sec = 1;
+}
+
+uint32_t sd_ble_gap_rssi_start(uint16_t conn_handle, uint8_t threshold_dbm, uint8_t skip_count)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_rssi_start_CallInstance);
+  Mock.sd_ble_gap_rssi_start_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_rssi_start_CallInstance);
+  if (Mock.sd_ble_gap_rssi_start_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_rssi_start_FinalReturn;
+    Mock.sd_ble_gap_rssi_start_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_rssi_start_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_rssi_start_CallbackFunctionPointer(conn_handle, threshold_dbm, skip_count, Mock.sd_ble_gap_rssi_start_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_rssi_start' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_rssi_start' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_rssi_start' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_rssi_start' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_threshold_dbm)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_threshold_dbm, threshold_dbm, cmock_line, "Function 'sd_ble_gap_rssi_start' called with unexpected value for argument 'threshold_dbm'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_skip_count)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_skip_count, skip_count, cmock_line, "Function 'sd_ble_gap_rssi_start' called with unexpected value for argument 'skip_count'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_rssi_start(CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, uint8_t threshold_dbm, uint8_t skip_count)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_threshold_dbm = threshold_dbm;
+  cmock_call_instance->IgnoreArg_threshold_dbm = 0;
+  cmock_call_instance->Expected_skip_count = skip_count;
+  cmock_call_instance->IgnoreArg_skip_count = 0;
+}
+
+void sd_ble_gap_rssi_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_rssi_start_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_rssi_start_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_rssi_start_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_rssi_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t threshold_dbm, uint8_t skip_count, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_rssi_start_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_rssi_start_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_rssi_start(cmock_call_instance, conn_handle, threshold_dbm, skip_count);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_rssi_start_StubWithCallback(CMOCK_sd_ble_gap_rssi_start_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_rssi_start_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_rssi_start_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_rssi_start_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_rssi_start'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_rssi_start_CMockIgnoreArg_threshold_dbm(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_rssi_start_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "threshold_dbm IgnoreArg called before Expect on 'sd_ble_gap_rssi_start'.");
+  cmock_call_instance->IgnoreArg_threshold_dbm = 1;
+}
+
+void sd_ble_gap_rssi_start_CMockIgnoreArg_skip_count(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_rssi_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_rssi_start_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "skip_count IgnoreArg called before Expect on 'sd_ble_gap_rssi_start'.");
+  cmock_call_instance->IgnoreArg_skip_count = 1;
+}
+
+uint32_t sd_ble_gap_rssi_stop(uint16_t conn_handle)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_rssi_stop_CallInstance);
+  Mock.sd_ble_gap_rssi_stop_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_rssi_stop_CallInstance);
+  if (Mock.sd_ble_gap_rssi_stop_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_rssi_stop_FinalReturn;
+    Mock.sd_ble_gap_rssi_stop_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_rssi_stop_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_rssi_stop_CallbackFunctionPointer(conn_handle, Mock.sd_ble_gap_rssi_stop_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_rssi_stop' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_rssi_stop' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_rssi_stop' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_rssi_stop' called with unexpected value for argument 'conn_handle'.");
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_rssi_stop(CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+}
+
+void sd_ble_gap_rssi_stop_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_rssi_stop_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_rssi_stop_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_rssi_stop_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_rssi_stop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_rssi_stop_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_rssi_stop_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_rssi_stop(cmock_call_instance, conn_handle);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_rssi_stop_StubWithCallback(CMOCK_sd_ble_gap_rssi_stop_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_rssi_stop_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_rssi_stop_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_rssi_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_rssi_stop_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_rssi_stop'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+uint32_t sd_ble_gap_rssi_get(uint16_t conn_handle, int8_t* p_rssi)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_rssi_get_CallInstance);
+  Mock.sd_ble_gap_rssi_get_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_rssi_get_CallInstance);
+  if (Mock.sd_ble_gap_rssi_get_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_rssi_get_FinalReturn;
+    Mock.sd_ble_gap_rssi_get_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_rssi_get_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_rssi_get_CallbackFunctionPointer(conn_handle, p_rssi, Mock.sd_ble_gap_rssi_get_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_rssi_get' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_rssi_get' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_rssi_get' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_conn_handle)
+  {
+    UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_conn_handle, conn_handle, cmock_line, "Function 'sd_ble_gap_rssi_get' called with unexpected value for argument 'conn_handle'.");
+  }
+  if (!cmock_call_instance->IgnoreArg_p_rssi)
+  {
+    if (cmock_call_instance->Expected_p_rssi == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_rssi, cmock_line, "Expected NULL. Function 'sd_ble_gap_rssi_get' called with unexpected value for argument 'p_rssi'."); }
+    else if (cmock_call_instance->Expected_p_rssi_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_rssi, p_rssi, cmock_line, "Function 'sd_ble_gap_rssi_get' called with unexpected value for argument 'p_rssi'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_INT8_ARRAY(cmock_call_instance->Expected_p_rssi, p_rssi, cmock_call_instance->Expected_p_rssi_Depth, cmock_line, "Function 'sd_ble_gap_rssi_get' called with unexpected value for argument 'p_rssi'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_rssi_Used)
+  {
+    memcpy((void*)p_rssi, (void*)cmock_call_instance->ReturnThruPtr_p_rssi_Val,
+      cmock_call_instance->ReturnThruPtr_p_rssi_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_rssi_get(CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE* cmock_call_instance, uint16_t conn_handle, int8_t* p_rssi, int p_rssi_Depth)
+{
+  cmock_call_instance->Expected_conn_handle = conn_handle;
+  cmock_call_instance->IgnoreArg_conn_handle = 0;
+  cmock_call_instance->Expected_p_rssi = p_rssi;
+  cmock_call_instance->Expected_p_rssi_Depth = p_rssi_Depth;
+  cmock_call_instance->IgnoreArg_p_rssi = 0;
+  cmock_call_instance->ReturnThruPtr_p_rssi_Used = 0;
+}
+
+void sd_ble_gap_rssi_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_rssi_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_rssi_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_rssi_get_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_rssi_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, int8_t* p_rssi, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_rssi_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_rssi_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_rssi_get(cmock_call_instance, conn_handle, p_rssi, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_rssi_get_StubWithCallback(CMOCK_sd_ble_gap_rssi_get_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_rssi_get_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_rssi_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, int8_t* p_rssi, int p_rssi_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_rssi_get_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_rssi_get_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_rssi_get(cmock_call_instance, conn_handle, p_rssi, p_rssi_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_rssi_get_CMockReturnMemThruPtr_p_rssi(UNITY_LINE_TYPE cmock_line, int8_t* p_rssi, int cmock_size)
+{
+  CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_rssi_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_rssi ReturnThruPtr called before Expect on 'sd_ble_gap_rssi_get'.");
+  cmock_call_instance->ReturnThruPtr_p_rssi_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_rssi_Val = p_rssi;
+  cmock_call_instance->ReturnThruPtr_p_rssi_Size = cmock_size;
+}
+
+void sd_ble_gap_rssi_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_rssi_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "conn_handle IgnoreArg called before Expect on 'sd_ble_gap_rssi_get'.");
+  cmock_call_instance->IgnoreArg_conn_handle = 1;
+}
+
+void sd_ble_gap_rssi_get_CMockIgnoreArg_p_rssi(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_rssi_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_rssi_get_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_rssi IgnoreArg called before Expect on 'sd_ble_gap_rssi_get'.");
+  cmock_call_instance->IgnoreArg_p_rssi = 1;
+}
+
+uint32_t sd_ble_gap_scan_start(ble_gap_scan_params_t const* p_scan_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_scan_start_CallInstance);
+  Mock.sd_ble_gap_scan_start_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_scan_start_CallInstance);
+  if (Mock.sd_ble_gap_scan_start_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_scan_start_FinalReturn;
+    Mock.sd_ble_gap_scan_start_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_scan_start_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_scan_start_CallbackFunctionPointer(p_scan_params, Mock.sd_ble_gap_scan_start_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_scan_start' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_scan_start' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_scan_start' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_scan_params)
+  {
+    if (cmock_call_instance->Expected_p_scan_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_scan_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_scan_start' called with unexpected value for argument 'p_scan_params'."); }
+    else if (cmock_call_instance->Expected_p_scan_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_scan_params, p_scan_params, cmock_line, "Function 'sd_ble_gap_scan_start' called with unexpected value for argument 'p_scan_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_scan_params), (void*)(p_scan_params), sizeof(ble_gap_scan_params_t), cmock_call_instance->Expected_p_scan_params_Depth, cmock_line, "Function 'sd_ble_gap_scan_start' called with unexpected value for argument 'p_scan_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_scan_params_Used)
+  {
+    memcpy((void*)p_scan_params, (void*)cmock_call_instance->ReturnThruPtr_p_scan_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_scan_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_scan_start(CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE* cmock_call_instance, ble_gap_scan_params_t const* p_scan_params, int p_scan_params_Depth)
+{
+  cmock_call_instance->Expected_p_scan_params = p_scan_params;
+  cmock_call_instance->Expected_p_scan_params_Depth = p_scan_params_Depth;
+  cmock_call_instance->IgnoreArg_p_scan_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_scan_params_Used = 0;
+}
+
+void sd_ble_gap_scan_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_scan_start_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_scan_start_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_scan_start_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_scan_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_scan_params_t const* p_scan_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_scan_start_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_scan_start_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_scan_start(cmock_call_instance, p_scan_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_scan_start_StubWithCallback(CMOCK_sd_ble_gap_scan_start_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_scan_start_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_scan_start_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_scan_params_t const* p_scan_params, int p_scan_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_scan_start_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_scan_start_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_scan_start(cmock_call_instance, p_scan_params, p_scan_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_scan_start_CMockReturnMemThruPtr_p_scan_params(UNITY_LINE_TYPE cmock_line, ble_gap_scan_params_t const* p_scan_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_scan_start_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_scan_params ReturnThruPtr called before Expect on 'sd_ble_gap_scan_start'.");
+  cmock_call_instance->ReturnThruPtr_p_scan_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_scan_params_Val = p_scan_params;
+  cmock_call_instance->ReturnThruPtr_p_scan_params_Size = cmock_size;
+}
+
+void sd_ble_gap_scan_start_CMockIgnoreArg_p_scan_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_scan_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_scan_start_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_scan_params IgnoreArg called before Expect on 'sd_ble_gap_scan_start'.");
+  cmock_call_instance->IgnoreArg_p_scan_params = 1;
+}
+
+uint32_t sd_ble_gap_scan_stop(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_scan_stop_CallInstance);
+  Mock.sd_ble_gap_scan_stop_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_scan_stop_CallInstance);
+  if (Mock.sd_ble_gap_scan_stop_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_scan_stop_FinalReturn;
+    Mock.sd_ble_gap_scan_stop_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_scan_stop_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_scan_stop_CallbackFunctionPointer(Mock.sd_ble_gap_scan_stop_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_scan_stop' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_scan_stop' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_scan_stop' called later than expected.");
+  return cmock_call_instance->ReturnVal;
+}
+
+void sd_ble_gap_scan_stop_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_scan_stop_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_scan_stop_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_scan_stop_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_scan_stop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_scan_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_scan_stop_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_scan_stop_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_scan_stop_StubWithCallback(CMOCK_sd_ble_gap_scan_stop_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_scan_stop_CallbackFunctionPointer = Callback;
+}
+
+uint32_t sd_ble_gap_connect(ble_gap_addr_t const* p_peer_addr, ble_gap_scan_params_t const* p_scan_params, ble_gap_conn_params_t const* p_conn_params)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_connect_CallInstance);
+  Mock.sd_ble_gap_connect_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_connect_CallInstance);
+  if (Mock.sd_ble_gap_connect_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_connect_FinalReturn;
+    Mock.sd_ble_gap_connect_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_connect_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_connect_CallbackFunctionPointer(p_peer_addr, p_scan_params, p_conn_params, Mock.sd_ble_gap_connect_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_connect' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_connect' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_connect' called later than expected.");
+  if (!cmock_call_instance->IgnoreArg_p_peer_addr)
+  {
+    if (cmock_call_instance->Expected_p_peer_addr == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_peer_addr, cmock_line, "Expected NULL. Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_peer_addr'."); }
+    else if (cmock_call_instance->Expected_p_peer_addr_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_peer_addr, p_peer_addr, cmock_line, "Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_peer_addr'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_peer_addr), (void*)(p_peer_addr), sizeof(ble_gap_addr_t), cmock_call_instance->Expected_p_peer_addr_Depth, cmock_line, "Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_peer_addr'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_scan_params)
+  {
+    if (cmock_call_instance->Expected_p_scan_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_scan_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_scan_params'."); }
+    else if (cmock_call_instance->Expected_p_scan_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_scan_params, p_scan_params, cmock_line, "Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_scan_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_scan_params), (void*)(p_scan_params), sizeof(ble_gap_scan_params_t), cmock_call_instance->Expected_p_scan_params_Depth, cmock_line, "Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_scan_params'."); }
+  }
+  if (!cmock_call_instance->IgnoreArg_p_conn_params)
+  {
+    if (cmock_call_instance->Expected_p_conn_params == NULL)
+      { UNITY_TEST_ASSERT_NULL(p_conn_params, cmock_line, "Expected NULL. Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_conn_params'."); }
+    else if (cmock_call_instance->Expected_p_conn_params_Depth == 0)
+      { UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_p_conn_params, p_conn_params, cmock_line, "Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_conn_params'."); }
+    else
+      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_p_conn_params), (void*)(p_conn_params), sizeof(ble_gap_conn_params_t), cmock_call_instance->Expected_p_conn_params_Depth, cmock_line, "Function 'sd_ble_gap_connect' called with unexpected value for argument 'p_conn_params'."); }
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_peer_addr_Used)
+  {
+    memcpy((void*)p_peer_addr, (void*)cmock_call_instance->ReturnThruPtr_p_peer_addr_Val,
+      cmock_call_instance->ReturnThruPtr_p_peer_addr_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_scan_params_Used)
+  {
+    memcpy((void*)p_scan_params, (void*)cmock_call_instance->ReturnThruPtr_p_scan_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_scan_params_Size);
+  }
+  if (cmock_call_instance->ReturnThruPtr_p_conn_params_Used)
+  {
+    memcpy((void*)p_conn_params, (void*)cmock_call_instance->ReturnThruPtr_p_conn_params_Val,
+      cmock_call_instance->ReturnThruPtr_p_conn_params_Size);
+  }
+  return cmock_call_instance->ReturnVal;
+}
+
+void CMockExpectParameters_sd_ble_gap_connect(CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance, ble_gap_addr_t const* p_peer_addr, int p_peer_addr_Depth, ble_gap_scan_params_t const* p_scan_params, int p_scan_params_Depth, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth)
+{
+  cmock_call_instance->Expected_p_peer_addr = p_peer_addr;
+  cmock_call_instance->Expected_p_peer_addr_Depth = p_peer_addr_Depth;
+  cmock_call_instance->IgnoreArg_p_peer_addr = 0;
+  cmock_call_instance->ReturnThruPtr_p_peer_addr_Used = 0;
+  cmock_call_instance->Expected_p_scan_params = p_scan_params;
+  cmock_call_instance->Expected_p_scan_params_Depth = p_scan_params_Depth;
+  cmock_call_instance->IgnoreArg_p_scan_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_scan_params_Used = 0;
+  cmock_call_instance->Expected_p_conn_params = p_conn_params;
+  cmock_call_instance->Expected_p_conn_params_Depth = p_conn_params_Depth;
+  cmock_call_instance->IgnoreArg_p_conn_params = 0;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Used = 0;
+}
+
+void sd_ble_gap_connect_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_connect_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_connect_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_connect_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_connect_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_connect_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_peer_addr, ble_gap_scan_params_t const* p_scan_params, ble_gap_conn_params_t const* p_conn_params, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_connect_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_connect_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_connect_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_connect(cmock_call_instance, p_peer_addr, 0, p_scan_params, 0, p_conn_params, 0);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_connect_StubWithCallback(CMOCK_sd_ble_gap_connect_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_connect_CallbackFunctionPointer = Callback;
+}
+
+void sd_ble_gap_connect_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_peer_addr, int p_peer_addr_Depth, ble_gap_scan_params_t const* p_scan_params, int p_scan_params_Depth, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_connect_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_connect_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_connect_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  CMockExpectParameters_sd_ble_gap_connect(cmock_call_instance, p_peer_addr, p_peer_addr_Depth, p_scan_params, p_scan_params_Depth, p_conn_params, p_conn_params_Depth);
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_connect_CMockReturnMemThruPtr_p_peer_addr(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_peer_addr, int cmock_size)
+{
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_connect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_peer_addr ReturnThruPtr called before Expect on 'sd_ble_gap_connect'.");
+  cmock_call_instance->ReturnThruPtr_p_peer_addr_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_peer_addr_Val = p_peer_addr;
+  cmock_call_instance->ReturnThruPtr_p_peer_addr_Size = cmock_size;
+}
+
+void sd_ble_gap_connect_CMockReturnMemThruPtr_p_scan_params(UNITY_LINE_TYPE cmock_line, ble_gap_scan_params_t const* p_scan_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_connect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_scan_params ReturnThruPtr called before Expect on 'sd_ble_gap_connect'.");
+  cmock_call_instance->ReturnThruPtr_p_scan_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_scan_params_Val = p_scan_params;
+  cmock_call_instance->ReturnThruPtr_p_scan_params_Size = cmock_size;
+}
+
+void sd_ble_gap_connect_CMockReturnMemThruPtr_p_conn_params(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, int cmock_size)
+{
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_connect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_params ReturnThruPtr called before Expect on 'sd_ble_gap_connect'.");
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Used = 1;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Val = p_conn_params;
+  cmock_call_instance->ReturnThruPtr_p_conn_params_Size = cmock_size;
+}
+
+void sd_ble_gap_connect_CMockIgnoreArg_p_peer_addr(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_connect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_peer_addr IgnoreArg called before Expect on 'sd_ble_gap_connect'.");
+  cmock_call_instance->IgnoreArg_p_peer_addr = 1;
+}
+
+void sd_ble_gap_connect_CMockIgnoreArg_p_scan_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_connect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_scan_params IgnoreArg called before Expect on 'sd_ble_gap_connect'.");
+  cmock_call_instance->IgnoreArg_p_scan_params = 1;
+}
+
+void sd_ble_gap_connect_CMockIgnoreArg_p_conn_params(UNITY_LINE_TYPE cmock_line)
+{
+  CMOCK_sd_ble_gap_connect_CALL_INSTANCE* cmock_call_instance = cmock_call_instance = (CMOCK_sd_ble_gap_connect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.sd_ble_gap_connect_CallInstance));
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "p_conn_params IgnoreArg called before Expect on 'sd_ble_gap_connect'.");
+  cmock_call_instance->IgnoreArg_p_conn_params = 1;
+}
+
+uint32_t sd_ble_gap_connect_cancel(void)
+{
+  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
+  CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.sd_ble_gap_connect_cancel_CallInstance);
+  Mock.sd_ble_gap_connect_cancel_CallInstance = CMock_Guts_MemNext(Mock.sd_ble_gap_connect_cancel_CallInstance);
+  if (Mock.sd_ble_gap_connect_cancel_IgnoreBool)
+  {
+    if (cmock_call_instance == NULL)
+      return Mock.sd_ble_gap_connect_cancel_FinalReturn;
+    Mock.sd_ble_gap_connect_cancel_FinalReturn = cmock_call_instance->ReturnVal;
+    return cmock_call_instance->ReturnVal;
+  }
+  if (Mock.sd_ble_gap_connect_cancel_CallbackFunctionPointer != NULL)
+  {
+    return Mock.sd_ble_gap_connect_cancel_CallbackFunctionPointer(Mock.sd_ble_gap_connect_cancel_CallbackCalls++);
+  }
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'sd_ble_gap_connect_cancel' called more times than expected.");
+  cmock_line = cmock_call_instance->LineNumber;
+  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_connect_cancel' called earlier than expected.");
+  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
+    UNITY_TEST_FAIL(cmock_line, "Function 'sd_ble_gap_connect_cancel' called later than expected.");
+  return cmock_call_instance->ReturnVal;
+}
+
+void sd_ble_gap_connect_cancel_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_connect_cancel_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_connect_cancel_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+  Mock.sd_ble_gap_connect_cancel_IgnoreBool = (int)1;
+}
+
+void sd_ble_gap_connect_cancel_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
+{
+  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE));
+  CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE* cmock_call_instance = (CMOCK_sd_ble_gap_connect_cancel_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
+  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
+  Mock.sd_ble_gap_connect_cancel_CallInstance = CMock_Guts_MemChain(Mock.sd_ble_gap_connect_cancel_CallInstance, cmock_guts_index);
+  cmock_call_instance->LineNumber = cmock_line;
+  cmock_call_instance->CallOrder = ++GlobalExpectCount;
+  cmock_call_instance->ReturnVal = cmock_to_return;
+}
+
+void sd_ble_gap_connect_cancel_StubWithCallback(CMOCK_sd_ble_gap_connect_cancel_CALLBACK Callback)
+{
+  Mock.sd_ble_gap_connect_cancel_CallbackFunctionPointer = Callback;
+}
+
+/* lint -restore */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers_replacement/mocks/mock_ble_gap.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers_replacement/mocks/mock_ble_gap.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers_replacement/mocks/mock_ble_gap.h 1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers_replacement/mocks/mock_ble_gap.h  2018-04-24 08:48:29.108157100 +0200
@@ -0,0 +1,572 @@
+/* AUTOGENERATED FILE. DO NOT EDIT. */
+#ifndef _MOCK_BLE_GAP_H
+#define _MOCK_BLE_GAP_H
+
+#ifndef __STATIC_INLINE
+#define __STATIC_INLINE
+#else
+#undef __STATIC_INLINE
+#define __STATIC_INLINE
+#endif
+#define SUPPRESS_INLINE_IMPLEMENTATION
+
+#include "ble_gap.h"
+#undef SUPPRESS_INLINE_IMPLEMENTATION
+#undef __STATIC_INLINE
+#define __STATIC_INLINE __STATIC_INLINE1
+
+void mock_ble_gap_Init(void);
+void mock_ble_gap_Destroy(void);
+void mock_ble_gap_Verify(void);
+
+
+
+
+#define sd_ble_gap_addr_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_addr_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_addr_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_addr_set_ExpectAndReturn(p_addr, cmock_retval) sd_ble_gap_addr_set_CMockExpectAndReturn(__LINE__, p_addr, cmock_retval)
+void sd_ble_gap_addr_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_addr, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_addr_set_CALLBACK)(ble_gap_addr_t const* p_addr, int cmock_num_calls);
+void sd_ble_gap_addr_set_StubWithCallback(CMOCK_sd_ble_gap_addr_set_CALLBACK Callback);
+#define sd_ble_gap_addr_set_ExpectWithArrayAndReturn(p_addr, p_addr_Depth, cmock_retval) sd_ble_gap_addr_set_CMockExpectWithArrayAndReturn(__LINE__, p_addr, p_addr_Depth, cmock_retval)
+void sd_ble_gap_addr_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_addr, int p_addr_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_addr_set_ReturnThruPtr_p_addr(p_addr) sd_ble_gap_addr_set_CMockReturnMemThruPtr_p_addr(__LINE__, p_addr, sizeof(*p_addr))
+#define sd_ble_gap_addr_set_ReturnArrayThruPtr_p_addr(p_addr, cmock_len) sd_ble_gap_addr_set_CMockReturnMemThruPtr_p_addr(__LINE__, p_addr, cmock_len * sizeof(*p_addr))
+#define sd_ble_gap_addr_set_ReturnMemThruPtr_p_addr(p_addr, cmock_size) sd_ble_gap_addr_set_CMockReturnMemThruPtr_p_addr(__LINE__, p_addr, cmock_size)
+void sd_ble_gap_addr_set_CMockReturnMemThruPtr_p_addr(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_addr, int cmock_size);
+#define sd_ble_gap_addr_set_IgnoreArg_p_addr() sd_ble_gap_addr_set_CMockIgnoreArg_p_addr(__LINE__)
+void sd_ble_gap_addr_set_CMockIgnoreArg_p_addr(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_addr_get_IgnoreAndReturn(cmock_retval) sd_ble_gap_addr_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_addr_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_addr_get_ExpectAndReturn(p_addr, cmock_retval) sd_ble_gap_addr_get_CMockExpectAndReturn(__LINE__, p_addr, cmock_retval)
+void sd_ble_gap_addr_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t* p_addr, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_addr_get_CALLBACK)(ble_gap_addr_t* p_addr, int cmock_num_calls);
+void sd_ble_gap_addr_get_StubWithCallback(CMOCK_sd_ble_gap_addr_get_CALLBACK Callback);
+#define sd_ble_gap_addr_get_ExpectWithArrayAndReturn(p_addr, p_addr_Depth, cmock_retval) sd_ble_gap_addr_get_CMockExpectWithArrayAndReturn(__LINE__, p_addr, p_addr_Depth, cmock_retval)
+void sd_ble_gap_addr_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t* p_addr, int p_addr_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_addr_get_ReturnThruPtr_p_addr(p_addr) sd_ble_gap_addr_get_CMockReturnMemThruPtr_p_addr(__LINE__, p_addr, sizeof(*p_addr))
+#define sd_ble_gap_addr_get_ReturnArrayThruPtr_p_addr(p_addr, cmock_len) sd_ble_gap_addr_get_CMockReturnMemThruPtr_p_addr(__LINE__, p_addr, cmock_len * sizeof(*p_addr))
+#define sd_ble_gap_addr_get_ReturnMemThruPtr_p_addr(p_addr, cmock_size) sd_ble_gap_addr_get_CMockReturnMemThruPtr_p_addr(__LINE__, p_addr, cmock_size)
+void sd_ble_gap_addr_get_CMockReturnMemThruPtr_p_addr(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t* p_addr, int cmock_size);
+#define sd_ble_gap_addr_get_IgnoreArg_p_addr() sd_ble_gap_addr_get_CMockIgnoreArg_p_addr(__LINE__)
+void sd_ble_gap_addr_get_CMockIgnoreArg_p_addr(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_whitelist_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_whitelist_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_whitelist_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_whitelist_set_ExpectAndReturn(pp_wl_addrs, len, cmock_retval) sd_ble_gap_whitelist_set_CMockExpectAndReturn(__LINE__, pp_wl_addrs, len, cmock_retval)
+void sd_ble_gap_whitelist_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* const* pp_wl_addrs, uint8_t len, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_whitelist_set_CALLBACK)(ble_gap_addr_t const* const* pp_wl_addrs, uint8_t len, int cmock_num_calls);
+void sd_ble_gap_whitelist_set_StubWithCallback(CMOCK_sd_ble_gap_whitelist_set_CALLBACK Callback);
+#define sd_ble_gap_whitelist_set_ExpectWithArrayAndReturn(pp_wl_addrs, pp_wl_addrs_Depth, len, cmock_retval) sd_ble_gap_whitelist_set_CMockExpectWithArrayAndReturn(__LINE__, pp_wl_addrs, pp_wl_addrs_Depth, len, cmock_retval)
+void sd_ble_gap_whitelist_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* const* pp_wl_addrs, int pp_wl_addrs_Depth, uint8_t len, uint32_t cmock_to_return);
+#define sd_ble_gap_whitelist_set_ReturnThruPtr_pp_wl_addrs(pp_wl_addrs) sd_ble_gap_whitelist_set_CMockReturnMemThruPtr_pp_wl_addrs(__LINE__, pp_wl_addrs, sizeof(*pp_wl_addrs))
+#define sd_ble_gap_whitelist_set_ReturnArrayThruPtr_pp_wl_addrs(pp_wl_addrs, cmock_len) sd_ble_gap_whitelist_set_CMockReturnMemThruPtr_pp_wl_addrs(__LINE__, pp_wl_addrs, cmock_len * sizeof(*pp_wl_addrs))
+#define sd_ble_gap_whitelist_set_ReturnMemThruPtr_pp_wl_addrs(pp_wl_addrs, cmock_size) sd_ble_gap_whitelist_set_CMockReturnMemThruPtr_pp_wl_addrs(__LINE__, pp_wl_addrs, cmock_size)
+void sd_ble_gap_whitelist_set_CMockReturnMemThruPtr_pp_wl_addrs(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* const* pp_wl_addrs, int cmock_size);
+#define sd_ble_gap_whitelist_set_IgnoreArg_pp_wl_addrs() sd_ble_gap_whitelist_set_CMockIgnoreArg_pp_wl_addrs(__LINE__)
+void sd_ble_gap_whitelist_set_CMockIgnoreArg_pp_wl_addrs(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_whitelist_set_IgnoreArg_len() sd_ble_gap_whitelist_set_CMockIgnoreArg_len(__LINE__)
+void sd_ble_gap_whitelist_set_CMockIgnoreArg_len(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_device_identities_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_device_identities_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_device_identities_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_device_identities_set_ExpectAndReturn(pp_id_keys, pp_local_irks, len, cmock_retval) sd_ble_gap_device_identities_set_CMockExpectAndReturn(__LINE__, pp_id_keys, pp_local_irks, len, cmock_retval)
+void sd_ble_gap_device_identities_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_id_key_t const* const* pp_id_keys, ble_gap_irk_t const* const* pp_local_irks, uint8_t len, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_device_identities_set_CALLBACK)(ble_gap_id_key_t const* const* pp_id_keys, ble_gap_irk_t const* const* pp_local_irks, uint8_t len, int cmock_num_calls);
+void sd_ble_gap_device_identities_set_StubWithCallback(CMOCK_sd_ble_gap_device_identities_set_CALLBACK Callback);
+#define sd_ble_gap_device_identities_set_ExpectWithArrayAndReturn(pp_id_keys, pp_id_keys_Depth, pp_local_irks, pp_local_irks_Depth, len, cmock_retval) sd_ble_gap_device_identities_set_CMockExpectWithArrayAndReturn(__LINE__, pp_id_keys, pp_id_keys_Depth, pp_local_irks, pp_local_irks_Depth, len, cmock_retval)
+void sd_ble_gap_device_identities_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_id_key_t const* const* pp_id_keys, int pp_id_keys_Depth, ble_gap_irk_t const* const* pp_local_irks, int pp_local_irks_Depth, uint8_t len, uint32_t cmock_to_return);
+#define sd_ble_gap_device_identities_set_ReturnThruPtr_pp_id_keys(pp_id_keys) sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_id_keys(__LINE__, pp_id_keys, sizeof(*pp_id_keys))
+#define sd_ble_gap_device_identities_set_ReturnArrayThruPtr_pp_id_keys(pp_id_keys, cmock_len) sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_id_keys(__LINE__, pp_id_keys, cmock_len * sizeof(*pp_id_keys))
+#define sd_ble_gap_device_identities_set_ReturnMemThruPtr_pp_id_keys(pp_id_keys, cmock_size) sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_id_keys(__LINE__, pp_id_keys, cmock_size)
+void sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_id_keys(UNITY_LINE_TYPE cmock_line, ble_gap_id_key_t const* const* pp_id_keys, int cmock_size);
+#define sd_ble_gap_device_identities_set_ReturnThruPtr_pp_local_irks(pp_local_irks) sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_local_irks(__LINE__, pp_local_irks, sizeof(*pp_local_irks))
+#define sd_ble_gap_device_identities_set_ReturnArrayThruPtr_pp_local_irks(pp_local_irks, cmock_len) sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_local_irks(__LINE__, pp_local_irks, cmock_len * sizeof(*pp_local_irks))
+#define sd_ble_gap_device_identities_set_ReturnMemThruPtr_pp_local_irks(pp_local_irks, cmock_size) sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_local_irks(__LINE__, pp_local_irks, cmock_size)
+void sd_ble_gap_device_identities_set_CMockReturnMemThruPtr_pp_local_irks(UNITY_LINE_TYPE cmock_line, ble_gap_irk_t const* const* pp_local_irks, int cmock_size);
+#define sd_ble_gap_device_identities_set_IgnoreArg_pp_id_keys() sd_ble_gap_device_identities_set_CMockIgnoreArg_pp_id_keys(__LINE__)
+void sd_ble_gap_device_identities_set_CMockIgnoreArg_pp_id_keys(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_device_identities_set_IgnoreArg_pp_local_irks() sd_ble_gap_device_identities_set_CMockIgnoreArg_pp_local_irks(__LINE__)
+void sd_ble_gap_device_identities_set_CMockIgnoreArg_pp_local_irks(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_device_identities_set_IgnoreArg_len() sd_ble_gap_device_identities_set_CMockIgnoreArg_len(__LINE__)
+void sd_ble_gap_device_identities_set_CMockIgnoreArg_len(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_privacy_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_privacy_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_privacy_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_privacy_set_ExpectAndReturn(p_privacy_params, cmock_retval) sd_ble_gap_privacy_set_CMockExpectAndReturn(__LINE__, p_privacy_params, cmock_retval)
+void sd_ble_gap_privacy_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t const* p_privacy_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_privacy_set_CALLBACK)(ble_gap_privacy_params_t const* p_privacy_params, int cmock_num_calls);
+void sd_ble_gap_privacy_set_StubWithCallback(CMOCK_sd_ble_gap_privacy_set_CALLBACK Callback);
+#define sd_ble_gap_privacy_set_ExpectWithArrayAndReturn(p_privacy_params, p_privacy_params_Depth, cmock_retval) sd_ble_gap_privacy_set_CMockExpectWithArrayAndReturn(__LINE__, p_privacy_params, p_privacy_params_Depth, cmock_retval)
+void sd_ble_gap_privacy_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t const* p_privacy_params, int p_privacy_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_privacy_set_ReturnThruPtr_p_privacy_params(p_privacy_params) sd_ble_gap_privacy_set_CMockReturnMemThruPtr_p_privacy_params(__LINE__, p_privacy_params, sizeof(*p_privacy_params))
+#define sd_ble_gap_privacy_set_ReturnArrayThruPtr_p_privacy_params(p_privacy_params, cmock_len) sd_ble_gap_privacy_set_CMockReturnMemThruPtr_p_privacy_params(__LINE__, p_privacy_params, cmock_len * sizeof(*p_privacy_params))
+#define sd_ble_gap_privacy_set_ReturnMemThruPtr_p_privacy_params(p_privacy_params, cmock_size) sd_ble_gap_privacy_set_CMockReturnMemThruPtr_p_privacy_params(__LINE__, p_privacy_params, cmock_size)
+void sd_ble_gap_privacy_set_CMockReturnMemThruPtr_p_privacy_params(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t const* p_privacy_params, int cmock_size);
+#define sd_ble_gap_privacy_set_IgnoreArg_p_privacy_params() sd_ble_gap_privacy_set_CMockIgnoreArg_p_privacy_params(__LINE__)
+void sd_ble_gap_privacy_set_CMockIgnoreArg_p_privacy_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_privacy_get_IgnoreAndReturn(cmock_retval) sd_ble_gap_privacy_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_privacy_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_privacy_get_ExpectAndReturn(p_privacy_params, cmock_retval) sd_ble_gap_privacy_get_CMockExpectAndReturn(__LINE__, p_privacy_params, cmock_retval)
+void sd_ble_gap_privacy_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t* p_privacy_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_privacy_get_CALLBACK)(ble_gap_privacy_params_t* p_privacy_params, int cmock_num_calls);
+void sd_ble_gap_privacy_get_StubWithCallback(CMOCK_sd_ble_gap_privacy_get_CALLBACK Callback);
+#define sd_ble_gap_privacy_get_ExpectWithArrayAndReturn(p_privacy_params, p_privacy_params_Depth, cmock_retval) sd_ble_gap_privacy_get_CMockExpectWithArrayAndReturn(__LINE__, p_privacy_params, p_privacy_params_Depth, cmock_retval)
+void sd_ble_gap_privacy_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t* p_privacy_params, int p_privacy_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_privacy_get_ReturnThruPtr_p_privacy_params(p_privacy_params) sd_ble_gap_privacy_get_CMockReturnMemThruPtr_p_privacy_params(__LINE__, p_privacy_params, sizeof(*p_privacy_params))
+#define sd_ble_gap_privacy_get_ReturnArrayThruPtr_p_privacy_params(p_privacy_params, cmock_len) sd_ble_gap_privacy_get_CMockReturnMemThruPtr_p_privacy_params(__LINE__, p_privacy_params, cmock_len * sizeof(*p_privacy_params))
+#define sd_ble_gap_privacy_get_ReturnMemThruPtr_p_privacy_params(p_privacy_params, cmock_size) sd_ble_gap_privacy_get_CMockReturnMemThruPtr_p_privacy_params(__LINE__, p_privacy_params, cmock_size)
+void sd_ble_gap_privacy_get_CMockReturnMemThruPtr_p_privacy_params(UNITY_LINE_TYPE cmock_line, ble_gap_privacy_params_t* p_privacy_params, int cmock_size);
+#define sd_ble_gap_privacy_get_IgnoreArg_p_privacy_params() sd_ble_gap_privacy_get_CMockIgnoreArg_p_privacy_params(__LINE__)
+void sd_ble_gap_privacy_get_CMockIgnoreArg_p_privacy_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_adv_data_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_adv_data_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_adv_data_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_adv_data_set_ExpectAndReturn(p_data, dlen, p_sr_data, srdlen, cmock_retval) sd_ble_gap_adv_data_set_CMockExpectAndReturn(__LINE__, p_data, dlen, p_sr_data, srdlen, cmock_retval)
+void sd_ble_gap_adv_data_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t const* p_data, uint8_t dlen, uint8_t const* p_sr_data, uint8_t srdlen, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_adv_data_set_CALLBACK)(uint8_t const* p_data, uint8_t dlen, uint8_t const* p_sr_data, uint8_t srdlen, int cmock_num_calls);
+void sd_ble_gap_adv_data_set_StubWithCallback(CMOCK_sd_ble_gap_adv_data_set_CALLBACK Callback);
+#define sd_ble_gap_adv_data_set_ExpectWithArrayAndReturn(p_data, p_data_Depth, dlen, p_sr_data, p_sr_data_Depth, srdlen, cmock_retval) sd_ble_gap_adv_data_set_CMockExpectWithArrayAndReturn(__LINE__, p_data, p_data_Depth, dlen, p_sr_data, p_sr_data_Depth, srdlen, cmock_retval)
+void sd_ble_gap_adv_data_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t const* p_data, int p_data_Depth, uint8_t dlen, uint8_t const* p_sr_data, int p_sr_data_Depth, uint8_t srdlen, uint32_t cmock_to_return);
+#define sd_ble_gap_adv_data_set_ReturnThruPtr_p_data(p_data) sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_data(__LINE__, p_data, sizeof(*p_data))
+#define sd_ble_gap_adv_data_set_ReturnArrayThruPtr_p_data(p_data, cmock_len) sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_data(__LINE__, p_data, cmock_len * sizeof(*p_data))
+#define sd_ble_gap_adv_data_set_ReturnMemThruPtr_p_data(p_data, cmock_size) sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_data(__LINE__, p_data, cmock_size)
+void sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_data(UNITY_LINE_TYPE cmock_line, uint8_t const* p_data, int cmock_size);
+#define sd_ble_gap_adv_data_set_ReturnThruPtr_p_sr_data(p_sr_data) sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_sr_data(__LINE__, p_sr_data, sizeof(*p_sr_data))
+#define sd_ble_gap_adv_data_set_ReturnArrayThruPtr_p_sr_data(p_sr_data, cmock_len) sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_sr_data(__LINE__, p_sr_data, cmock_len * sizeof(*p_sr_data))
+#define sd_ble_gap_adv_data_set_ReturnMemThruPtr_p_sr_data(p_sr_data, cmock_size) sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_sr_data(__LINE__, p_sr_data, cmock_size)
+void sd_ble_gap_adv_data_set_CMockReturnMemThruPtr_p_sr_data(UNITY_LINE_TYPE cmock_line, uint8_t const* p_sr_data, int cmock_size);
+#define sd_ble_gap_adv_data_set_IgnoreArg_p_data() sd_ble_gap_adv_data_set_CMockIgnoreArg_p_data(__LINE__)
+void sd_ble_gap_adv_data_set_CMockIgnoreArg_p_data(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_adv_data_set_IgnoreArg_dlen() sd_ble_gap_adv_data_set_CMockIgnoreArg_dlen(__LINE__)
+void sd_ble_gap_adv_data_set_CMockIgnoreArg_dlen(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_adv_data_set_IgnoreArg_p_sr_data() sd_ble_gap_adv_data_set_CMockIgnoreArg_p_sr_data(__LINE__)
+void sd_ble_gap_adv_data_set_CMockIgnoreArg_p_sr_data(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_adv_data_set_IgnoreArg_srdlen() sd_ble_gap_adv_data_set_CMockIgnoreArg_srdlen(__LINE__)
+void sd_ble_gap_adv_data_set_CMockIgnoreArg_srdlen(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_adv_start_IgnoreAndReturn(cmock_retval) sd_ble_gap_adv_start_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_adv_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_adv_start_ExpectAndReturn(p_adv_params, cmock_retval) sd_ble_gap_adv_start_CMockExpectAndReturn(__LINE__, p_adv_params, cmock_retval)
+void sd_ble_gap_adv_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_adv_params_t const* p_adv_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_adv_start_CALLBACK)(ble_gap_adv_params_t const* p_adv_params, int cmock_num_calls);
+void sd_ble_gap_adv_start_StubWithCallback(CMOCK_sd_ble_gap_adv_start_CALLBACK Callback);
+#define sd_ble_gap_adv_start_ExpectWithArrayAndReturn(p_adv_params, p_adv_params_Depth, cmock_retval) sd_ble_gap_adv_start_CMockExpectWithArrayAndReturn(__LINE__, p_adv_params, p_adv_params_Depth, cmock_retval)
+void sd_ble_gap_adv_start_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_adv_params_t const* p_adv_params, int p_adv_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_adv_start_ReturnThruPtr_p_adv_params(p_adv_params) sd_ble_gap_adv_start_CMockReturnMemThruPtr_p_adv_params(__LINE__, p_adv_params, sizeof(*p_adv_params))
+#define sd_ble_gap_adv_start_ReturnArrayThruPtr_p_adv_params(p_adv_params, cmock_len) sd_ble_gap_adv_start_CMockReturnMemThruPtr_p_adv_params(__LINE__, p_adv_params, cmock_len * sizeof(*p_adv_params))
+#define sd_ble_gap_adv_start_ReturnMemThruPtr_p_adv_params(p_adv_params, cmock_size) sd_ble_gap_adv_start_CMockReturnMemThruPtr_p_adv_params(__LINE__, p_adv_params, cmock_size)
+void sd_ble_gap_adv_start_CMockReturnMemThruPtr_p_adv_params(UNITY_LINE_TYPE cmock_line, ble_gap_adv_params_t const* p_adv_params, int cmock_size);
+#define sd_ble_gap_adv_start_IgnoreArg_p_adv_params() sd_ble_gap_adv_start_CMockIgnoreArg_p_adv_params(__LINE__)
+void sd_ble_gap_adv_start_CMockIgnoreArg_p_adv_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_adv_stop_IgnoreAndReturn(cmock_retval) sd_ble_gap_adv_stop_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_adv_stop_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_adv_stop_ExpectAndReturn(cmock_retval) sd_ble_gap_adv_stop_CMockExpectAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_adv_stop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_adv_stop_CALLBACK)(int cmock_num_calls);
+void sd_ble_gap_adv_stop_StubWithCallback(CMOCK_sd_ble_gap_adv_stop_CALLBACK Callback);
+#define sd_ble_gap_conn_param_update_IgnoreAndReturn(cmock_retval) sd_ble_gap_conn_param_update_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_conn_param_update_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_conn_param_update_ExpectAndReturn(conn_handle, p_conn_params, cmock_retval) sd_ble_gap_conn_param_update_CMockExpectAndReturn(__LINE__, conn_handle, p_conn_params, cmock_retval)
+void sd_ble_gap_conn_param_update_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_conn_params_t const* p_conn_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_conn_param_update_CALLBACK)(uint16_t conn_handle, ble_gap_conn_params_t const* p_conn_params, int cmock_num_calls);
+void sd_ble_gap_conn_param_update_StubWithCallback(CMOCK_sd_ble_gap_conn_param_update_CALLBACK Callback);
+#define sd_ble_gap_conn_param_update_ExpectWithArrayAndReturn(conn_handle, p_conn_params, p_conn_params_Depth, cmock_retval) sd_ble_gap_conn_param_update_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_conn_params, p_conn_params_Depth, cmock_retval)
+void sd_ble_gap_conn_param_update_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_conn_param_update_ReturnThruPtr_p_conn_params(p_conn_params) sd_ble_gap_conn_param_update_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, sizeof(*p_conn_params))
+#define sd_ble_gap_conn_param_update_ReturnArrayThruPtr_p_conn_params(p_conn_params, cmock_len) sd_ble_gap_conn_param_update_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, cmock_len * sizeof(*p_conn_params))
+#define sd_ble_gap_conn_param_update_ReturnMemThruPtr_p_conn_params(p_conn_params, cmock_size) sd_ble_gap_conn_param_update_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, cmock_size)
+void sd_ble_gap_conn_param_update_CMockReturnMemThruPtr_p_conn_params(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, int cmock_size);
+#define sd_ble_gap_conn_param_update_IgnoreArg_conn_handle() sd_ble_gap_conn_param_update_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_conn_param_update_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_conn_param_update_IgnoreArg_p_conn_params() sd_ble_gap_conn_param_update_CMockIgnoreArg_p_conn_params(__LINE__)
+void sd_ble_gap_conn_param_update_CMockIgnoreArg_p_conn_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_disconnect_IgnoreAndReturn(cmock_retval) sd_ble_gap_disconnect_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_disconnect_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_disconnect_ExpectAndReturn(conn_handle, hci_status_code, cmock_retval) sd_ble_gap_disconnect_CMockExpectAndReturn(__LINE__, conn_handle, hci_status_code, cmock_retval)
+void sd_ble_gap_disconnect_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t hci_status_code, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_disconnect_CALLBACK)(uint16_t conn_handle, uint8_t hci_status_code, int cmock_num_calls);
+void sd_ble_gap_disconnect_StubWithCallback(CMOCK_sd_ble_gap_disconnect_CALLBACK Callback);
+#define sd_ble_gap_disconnect_IgnoreArg_conn_handle() sd_ble_gap_disconnect_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_disconnect_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_disconnect_IgnoreArg_hci_status_code() sd_ble_gap_disconnect_CMockIgnoreArg_hci_status_code(__LINE__)
+void sd_ble_gap_disconnect_CMockIgnoreArg_hci_status_code(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_tx_power_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_tx_power_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_tx_power_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_tx_power_set_ExpectAndReturn(tx_power, cmock_retval) sd_ble_gap_tx_power_set_CMockExpectAndReturn(__LINE__, tx_power, cmock_retval)
+void sd_ble_gap_tx_power_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int8_t tx_power, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_tx_power_set_CALLBACK)(int8_t tx_power, int cmock_num_calls);
+void sd_ble_gap_tx_power_set_StubWithCallback(CMOCK_sd_ble_gap_tx_power_set_CALLBACK Callback);
+#define sd_ble_gap_tx_power_set_IgnoreArg_tx_power() sd_ble_gap_tx_power_set_CMockIgnoreArg_tx_power(__LINE__)
+void sd_ble_gap_tx_power_set_CMockIgnoreArg_tx_power(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_appearance_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_appearance_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_appearance_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_appearance_set_ExpectAndReturn(appearance, cmock_retval) sd_ble_gap_appearance_set_CMockExpectAndReturn(__LINE__, appearance, cmock_retval)
+void sd_ble_gap_appearance_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t appearance, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_appearance_set_CALLBACK)(uint16_t appearance, int cmock_num_calls);
+void sd_ble_gap_appearance_set_StubWithCallback(CMOCK_sd_ble_gap_appearance_set_CALLBACK Callback);
+#define sd_ble_gap_appearance_set_IgnoreArg_appearance() sd_ble_gap_appearance_set_CMockIgnoreArg_appearance(__LINE__)
+void sd_ble_gap_appearance_set_CMockIgnoreArg_appearance(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_appearance_get_IgnoreAndReturn(cmock_retval) sd_ble_gap_appearance_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_appearance_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_appearance_get_ExpectAndReturn(p_appearance, cmock_retval) sd_ble_gap_appearance_get_CMockExpectAndReturn(__LINE__, p_appearance, cmock_retval)
+void sd_ble_gap_appearance_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t* p_appearance, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_appearance_get_CALLBACK)(uint16_t* p_appearance, int cmock_num_calls);
+void sd_ble_gap_appearance_get_StubWithCallback(CMOCK_sd_ble_gap_appearance_get_CALLBACK Callback);
+#define sd_ble_gap_appearance_get_ExpectWithArrayAndReturn(p_appearance, p_appearance_Depth, cmock_retval) sd_ble_gap_appearance_get_CMockExpectWithArrayAndReturn(__LINE__, p_appearance, p_appearance_Depth, cmock_retval)
+void sd_ble_gap_appearance_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t* p_appearance, int p_appearance_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_appearance_get_ReturnThruPtr_p_appearance(p_appearance) sd_ble_gap_appearance_get_CMockReturnMemThruPtr_p_appearance(__LINE__, p_appearance, sizeof(*p_appearance))
+#define sd_ble_gap_appearance_get_ReturnArrayThruPtr_p_appearance(p_appearance, cmock_len) sd_ble_gap_appearance_get_CMockReturnMemThruPtr_p_appearance(__LINE__, p_appearance, cmock_len * sizeof(*p_appearance))
+#define sd_ble_gap_appearance_get_ReturnMemThruPtr_p_appearance(p_appearance, cmock_size) sd_ble_gap_appearance_get_CMockReturnMemThruPtr_p_appearance(__LINE__, p_appearance, cmock_size)
+void sd_ble_gap_appearance_get_CMockReturnMemThruPtr_p_appearance(UNITY_LINE_TYPE cmock_line, uint16_t* p_appearance, int cmock_size);
+#define sd_ble_gap_appearance_get_IgnoreArg_p_appearance() sd_ble_gap_appearance_get_CMockIgnoreArg_p_appearance(__LINE__)
+void sd_ble_gap_appearance_get_CMockIgnoreArg_p_appearance(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_ppcp_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_ppcp_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_ppcp_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_ppcp_set_ExpectAndReturn(p_conn_params, cmock_retval) sd_ble_gap_ppcp_set_CMockExpectAndReturn(__LINE__, p_conn_params, cmock_retval)
+void sd_ble_gap_ppcp_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_ppcp_set_CALLBACK)(ble_gap_conn_params_t const* p_conn_params, int cmock_num_calls);
+void sd_ble_gap_ppcp_set_StubWithCallback(CMOCK_sd_ble_gap_ppcp_set_CALLBACK Callback);
+#define sd_ble_gap_ppcp_set_ExpectWithArrayAndReturn(p_conn_params, p_conn_params_Depth, cmock_retval) sd_ble_gap_ppcp_set_CMockExpectWithArrayAndReturn(__LINE__, p_conn_params, p_conn_params_Depth, cmock_retval)
+void sd_ble_gap_ppcp_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_ppcp_set_ReturnThruPtr_p_conn_params(p_conn_params) sd_ble_gap_ppcp_set_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, sizeof(*p_conn_params))
+#define sd_ble_gap_ppcp_set_ReturnArrayThruPtr_p_conn_params(p_conn_params, cmock_len) sd_ble_gap_ppcp_set_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, cmock_len * sizeof(*p_conn_params))
+#define sd_ble_gap_ppcp_set_ReturnMemThruPtr_p_conn_params(p_conn_params, cmock_size) sd_ble_gap_ppcp_set_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, cmock_size)
+void sd_ble_gap_ppcp_set_CMockReturnMemThruPtr_p_conn_params(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, int cmock_size);
+#define sd_ble_gap_ppcp_set_IgnoreArg_p_conn_params() sd_ble_gap_ppcp_set_CMockIgnoreArg_p_conn_params(__LINE__)
+void sd_ble_gap_ppcp_set_CMockIgnoreArg_p_conn_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_ppcp_get_IgnoreAndReturn(cmock_retval) sd_ble_gap_ppcp_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_ppcp_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_ppcp_get_ExpectAndReturn(p_conn_params, cmock_retval) sd_ble_gap_ppcp_get_CMockExpectAndReturn(__LINE__, p_conn_params, cmock_retval)
+void sd_ble_gap_ppcp_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t* p_conn_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_ppcp_get_CALLBACK)(ble_gap_conn_params_t* p_conn_params, int cmock_num_calls);
+void sd_ble_gap_ppcp_get_StubWithCallback(CMOCK_sd_ble_gap_ppcp_get_CALLBACK Callback);
+#define sd_ble_gap_ppcp_get_ExpectWithArrayAndReturn(p_conn_params, p_conn_params_Depth, cmock_retval) sd_ble_gap_ppcp_get_CMockExpectWithArrayAndReturn(__LINE__, p_conn_params, p_conn_params_Depth, cmock_retval)
+void sd_ble_gap_ppcp_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t* p_conn_params, int p_conn_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_ppcp_get_ReturnThruPtr_p_conn_params(p_conn_params) sd_ble_gap_ppcp_get_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, sizeof(*p_conn_params))
+#define sd_ble_gap_ppcp_get_ReturnArrayThruPtr_p_conn_params(p_conn_params, cmock_len) sd_ble_gap_ppcp_get_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, cmock_len * sizeof(*p_conn_params))
+#define sd_ble_gap_ppcp_get_ReturnMemThruPtr_p_conn_params(p_conn_params, cmock_size) sd_ble_gap_ppcp_get_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, cmock_size)
+void sd_ble_gap_ppcp_get_CMockReturnMemThruPtr_p_conn_params(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t* p_conn_params, int cmock_size);
+#define sd_ble_gap_ppcp_get_IgnoreArg_p_conn_params() sd_ble_gap_ppcp_get_CMockIgnoreArg_p_conn_params(__LINE__)
+void sd_ble_gap_ppcp_get_CMockIgnoreArg_p_conn_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_device_name_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_device_name_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_device_name_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_device_name_set_ExpectAndReturn(p_write_perm, p_dev_name, len, cmock_retval) sd_ble_gap_device_name_set_CMockExpectAndReturn(__LINE__, p_write_perm, p_dev_name, len, cmock_retval)
+void sd_ble_gap_device_name_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_sec_mode_t const* p_write_perm, uint8_t const* p_dev_name, uint16_t len, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_device_name_set_CALLBACK)(ble_gap_conn_sec_mode_t const* p_write_perm, uint8_t const* p_dev_name, uint16_t len, int cmock_num_calls);
+void sd_ble_gap_device_name_set_StubWithCallback(CMOCK_sd_ble_gap_device_name_set_CALLBACK Callback);
+#define sd_ble_gap_device_name_set_ExpectWithArrayAndReturn(p_write_perm, p_write_perm_Depth, p_dev_name, p_dev_name_Depth, len, cmock_retval) sd_ble_gap_device_name_set_CMockExpectWithArrayAndReturn(__LINE__, p_write_perm, p_write_perm_Depth, p_dev_name, p_dev_name_Depth, len, cmock_retval)
+void sd_ble_gap_device_name_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_conn_sec_mode_t const* p_write_perm, int p_write_perm_Depth, uint8_t const* p_dev_name, int p_dev_name_Depth, uint16_t len, uint32_t cmock_to_return);
+#define sd_ble_gap_device_name_set_ReturnThruPtr_p_write_perm(p_write_perm) sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_write_perm(__LINE__, p_write_perm, sizeof(*p_write_perm))
+#define sd_ble_gap_device_name_set_ReturnArrayThruPtr_p_write_perm(p_write_perm, cmock_len) sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_write_perm(__LINE__, p_write_perm, cmock_len * sizeof(*p_write_perm))
+#define sd_ble_gap_device_name_set_ReturnMemThruPtr_p_write_perm(p_write_perm, cmock_size) sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_write_perm(__LINE__, p_write_perm, cmock_size)
+void sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_write_perm(UNITY_LINE_TYPE cmock_line, ble_gap_conn_sec_mode_t const* p_write_perm, int cmock_size);
+#define sd_ble_gap_device_name_set_ReturnThruPtr_p_dev_name(p_dev_name) sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_dev_name(__LINE__, p_dev_name, sizeof(*p_dev_name))
+#define sd_ble_gap_device_name_set_ReturnArrayThruPtr_p_dev_name(p_dev_name, cmock_len) sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_dev_name(__LINE__, p_dev_name, cmock_len * sizeof(*p_dev_name))
+#define sd_ble_gap_device_name_set_ReturnMemThruPtr_p_dev_name(p_dev_name, cmock_size) sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_dev_name(__LINE__, p_dev_name, cmock_size)
+void sd_ble_gap_device_name_set_CMockReturnMemThruPtr_p_dev_name(UNITY_LINE_TYPE cmock_line, uint8_t const* p_dev_name, int cmock_size);
+#define sd_ble_gap_device_name_set_IgnoreArg_p_write_perm() sd_ble_gap_device_name_set_CMockIgnoreArg_p_write_perm(__LINE__)
+void sd_ble_gap_device_name_set_CMockIgnoreArg_p_write_perm(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_device_name_set_IgnoreArg_p_dev_name() sd_ble_gap_device_name_set_CMockIgnoreArg_p_dev_name(__LINE__)
+void sd_ble_gap_device_name_set_CMockIgnoreArg_p_dev_name(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_device_name_set_IgnoreArg_len() sd_ble_gap_device_name_set_CMockIgnoreArg_len(__LINE__)
+void sd_ble_gap_device_name_set_CMockIgnoreArg_len(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_device_name_get_IgnoreAndReturn(cmock_retval) sd_ble_gap_device_name_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_device_name_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_device_name_get_ExpectAndReturn(p_dev_name, p_len, cmock_retval) sd_ble_gap_device_name_get_CMockExpectAndReturn(__LINE__, p_dev_name, p_len, cmock_retval)
+void sd_ble_gap_device_name_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_dev_name, uint16_t* p_len, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_device_name_get_CALLBACK)(uint8_t* p_dev_name, uint16_t* p_len, int cmock_num_calls);
+void sd_ble_gap_device_name_get_StubWithCallback(CMOCK_sd_ble_gap_device_name_get_CALLBACK Callback);
+#define sd_ble_gap_device_name_get_ExpectWithArrayAndReturn(p_dev_name, p_dev_name_Depth, p_len, p_len_Depth, cmock_retval) sd_ble_gap_device_name_get_CMockExpectWithArrayAndReturn(__LINE__, p_dev_name, p_dev_name_Depth, p_len, p_len_Depth, cmock_retval)
+void sd_ble_gap_device_name_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* p_dev_name, int p_dev_name_Depth, uint16_t* p_len, int p_len_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_device_name_get_ReturnThruPtr_p_dev_name(p_dev_name) sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_dev_name(__LINE__, p_dev_name, sizeof(*p_dev_name))
+#define sd_ble_gap_device_name_get_ReturnArrayThruPtr_p_dev_name(p_dev_name, cmock_len) sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_dev_name(__LINE__, p_dev_name, cmock_len * sizeof(*p_dev_name))
+#define sd_ble_gap_device_name_get_ReturnMemThruPtr_p_dev_name(p_dev_name, cmock_size) sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_dev_name(__LINE__, p_dev_name, cmock_size)
+void sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_dev_name(UNITY_LINE_TYPE cmock_line, uint8_t* p_dev_name, int cmock_size);
+#define sd_ble_gap_device_name_get_ReturnThruPtr_p_len(p_len) sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_len(__LINE__, p_len, sizeof(*p_len))
+#define sd_ble_gap_device_name_get_ReturnArrayThruPtr_p_len(p_len, cmock_len) sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_len(__LINE__, p_len, cmock_len * sizeof(*p_len))
+#define sd_ble_gap_device_name_get_ReturnMemThruPtr_p_len(p_len, cmock_size) sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_len(__LINE__, p_len, cmock_size)
+void sd_ble_gap_device_name_get_CMockReturnMemThruPtr_p_len(UNITY_LINE_TYPE cmock_line, uint16_t* p_len, int cmock_size);
+#define sd_ble_gap_device_name_get_IgnoreArg_p_dev_name() sd_ble_gap_device_name_get_CMockIgnoreArg_p_dev_name(__LINE__)
+void sd_ble_gap_device_name_get_CMockIgnoreArg_p_dev_name(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_device_name_get_IgnoreArg_p_len() sd_ble_gap_device_name_get_CMockIgnoreArg_p_len(__LINE__)
+void sd_ble_gap_device_name_get_CMockIgnoreArg_p_len(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_authenticate_IgnoreAndReturn(cmock_retval) sd_ble_gap_authenticate_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_authenticate_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_authenticate_ExpectAndReturn(conn_handle, p_sec_params, cmock_retval) sd_ble_gap_authenticate_CMockExpectAndReturn(__LINE__, conn_handle, p_sec_params, cmock_retval)
+void sd_ble_gap_authenticate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_sec_params_t const* p_sec_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_authenticate_CALLBACK)(uint16_t conn_handle, ble_gap_sec_params_t const* p_sec_params, int cmock_num_calls);
+void sd_ble_gap_authenticate_StubWithCallback(CMOCK_sd_ble_gap_authenticate_CALLBACK Callback);
+#define sd_ble_gap_authenticate_ExpectWithArrayAndReturn(conn_handle, p_sec_params, p_sec_params_Depth, cmock_retval) sd_ble_gap_authenticate_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_sec_params, p_sec_params_Depth, cmock_retval)
+void sd_ble_gap_authenticate_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_sec_params_t const* p_sec_params, int p_sec_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_authenticate_ReturnThruPtr_p_sec_params(p_sec_params) sd_ble_gap_authenticate_CMockReturnMemThruPtr_p_sec_params(__LINE__, p_sec_params, sizeof(*p_sec_params))
+#define sd_ble_gap_authenticate_ReturnArrayThruPtr_p_sec_params(p_sec_params, cmock_len) sd_ble_gap_authenticate_CMockReturnMemThruPtr_p_sec_params(__LINE__, p_sec_params, cmock_len * sizeof(*p_sec_params))
+#define sd_ble_gap_authenticate_ReturnMemThruPtr_p_sec_params(p_sec_params, cmock_size) sd_ble_gap_authenticate_CMockReturnMemThruPtr_p_sec_params(__LINE__, p_sec_params, cmock_size)
+void sd_ble_gap_authenticate_CMockReturnMemThruPtr_p_sec_params(UNITY_LINE_TYPE cmock_line, ble_gap_sec_params_t const* p_sec_params, int cmock_size);
+#define sd_ble_gap_authenticate_IgnoreArg_conn_handle() sd_ble_gap_authenticate_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_authenticate_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_authenticate_IgnoreArg_p_sec_params() sd_ble_gap_authenticate_CMockIgnoreArg_p_sec_params(__LINE__)
+void sd_ble_gap_authenticate_CMockIgnoreArg_p_sec_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_sec_params_reply_IgnoreAndReturn(cmock_retval) sd_ble_gap_sec_params_reply_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_sec_params_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_sec_params_reply_ExpectAndReturn(conn_handle, sec_status, p_sec_params, p_sec_keyset, cmock_retval) sd_ble_gap_sec_params_reply_CMockExpectAndReturn(__LINE__, conn_handle, sec_status, p_sec_params, p_sec_keyset, cmock_retval)
+void sd_ble_gap_sec_params_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const* p_sec_params, ble_gap_sec_keyset_t const* p_sec_keyset, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_sec_params_reply_CALLBACK)(uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const* p_sec_params, ble_gap_sec_keyset_t const* p_sec_keyset, int cmock_num_calls);
+void sd_ble_gap_sec_params_reply_StubWithCallback(CMOCK_sd_ble_gap_sec_params_reply_CALLBACK Callback);
+#define sd_ble_gap_sec_params_reply_ExpectWithArrayAndReturn(conn_handle, sec_status, p_sec_params, p_sec_params_Depth, p_sec_keyset, p_sec_keyset_Depth, cmock_retval) sd_ble_gap_sec_params_reply_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, sec_status, p_sec_params, p_sec_params_Depth, p_sec_keyset, p_sec_keyset_Depth, cmock_retval)
+void sd_ble_gap_sec_params_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const* p_sec_params, int p_sec_params_Depth, ble_gap_sec_keyset_t const* p_sec_keyset, int p_sec_keyset_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_sec_params_reply_ReturnThruPtr_p_sec_params(p_sec_params) sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_params(__LINE__, p_sec_params, sizeof(*p_sec_params))
+#define sd_ble_gap_sec_params_reply_ReturnArrayThruPtr_p_sec_params(p_sec_params, cmock_len) sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_params(__LINE__, p_sec_params, cmock_len * sizeof(*p_sec_params))
+#define sd_ble_gap_sec_params_reply_ReturnMemThruPtr_p_sec_params(p_sec_params, cmock_size) sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_params(__LINE__, p_sec_params, cmock_size)
+void sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_params(UNITY_LINE_TYPE cmock_line, ble_gap_sec_params_t const* p_sec_params, int cmock_size);
+#define sd_ble_gap_sec_params_reply_ReturnThruPtr_p_sec_keyset(p_sec_keyset) sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_keyset(__LINE__, p_sec_keyset, sizeof(*p_sec_keyset))
+#define sd_ble_gap_sec_params_reply_ReturnArrayThruPtr_p_sec_keyset(p_sec_keyset, cmock_len) sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_keyset(__LINE__, p_sec_keyset, cmock_len * sizeof(*p_sec_keyset))
+#define sd_ble_gap_sec_params_reply_ReturnMemThruPtr_p_sec_keyset(p_sec_keyset, cmock_size) sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_keyset(__LINE__, p_sec_keyset, cmock_size)
+void sd_ble_gap_sec_params_reply_CMockReturnMemThruPtr_p_sec_keyset(UNITY_LINE_TYPE cmock_line, ble_gap_sec_keyset_t const* p_sec_keyset, int cmock_size);
+#define sd_ble_gap_sec_params_reply_IgnoreArg_conn_handle() sd_ble_gap_sec_params_reply_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_sec_params_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_sec_params_reply_IgnoreArg_sec_status() sd_ble_gap_sec_params_reply_CMockIgnoreArg_sec_status(__LINE__)
+void sd_ble_gap_sec_params_reply_CMockIgnoreArg_sec_status(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_sec_params_reply_IgnoreArg_p_sec_params() sd_ble_gap_sec_params_reply_CMockIgnoreArg_p_sec_params(__LINE__)
+void sd_ble_gap_sec_params_reply_CMockIgnoreArg_p_sec_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_sec_params_reply_IgnoreArg_p_sec_keyset() sd_ble_gap_sec_params_reply_CMockIgnoreArg_p_sec_keyset(__LINE__)
+void sd_ble_gap_sec_params_reply_CMockIgnoreArg_p_sec_keyset(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_auth_key_reply_IgnoreAndReturn(cmock_retval) sd_ble_gap_auth_key_reply_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_auth_key_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_auth_key_reply_ExpectAndReturn(conn_handle, key_type, p_key, cmock_retval) sd_ble_gap_auth_key_reply_CMockExpectAndReturn(__LINE__, conn_handle, key_type, p_key, cmock_retval)
+void sd_ble_gap_auth_key_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t key_type, uint8_t const* p_key, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_auth_key_reply_CALLBACK)(uint16_t conn_handle, uint8_t key_type, uint8_t const* p_key, int cmock_num_calls);
+void sd_ble_gap_auth_key_reply_StubWithCallback(CMOCK_sd_ble_gap_auth_key_reply_CALLBACK Callback);
+#define sd_ble_gap_auth_key_reply_ExpectWithArrayAndReturn(conn_handle, key_type, p_key, p_key_Depth, cmock_retval) sd_ble_gap_auth_key_reply_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, key_type, p_key, p_key_Depth, cmock_retval)
+void sd_ble_gap_auth_key_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t key_type, uint8_t const* p_key, int p_key_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_auth_key_reply_ReturnThruPtr_p_key(p_key) sd_ble_gap_auth_key_reply_CMockReturnMemThruPtr_p_key(__LINE__, p_key, sizeof(*p_key))
+#define sd_ble_gap_auth_key_reply_ReturnArrayThruPtr_p_key(p_key, cmock_len) sd_ble_gap_auth_key_reply_CMockReturnMemThruPtr_p_key(__LINE__, p_key, cmock_len * sizeof(*p_key))
+#define sd_ble_gap_auth_key_reply_ReturnMemThruPtr_p_key(p_key, cmock_size) sd_ble_gap_auth_key_reply_CMockReturnMemThruPtr_p_key(__LINE__, p_key, cmock_size)
+void sd_ble_gap_auth_key_reply_CMockReturnMemThruPtr_p_key(UNITY_LINE_TYPE cmock_line, uint8_t const* p_key, int cmock_size);
+#define sd_ble_gap_auth_key_reply_IgnoreArg_conn_handle() sd_ble_gap_auth_key_reply_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_auth_key_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_auth_key_reply_IgnoreArg_key_type() sd_ble_gap_auth_key_reply_CMockIgnoreArg_key_type(__LINE__)
+void sd_ble_gap_auth_key_reply_CMockIgnoreArg_key_type(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_auth_key_reply_IgnoreArg_p_key() sd_ble_gap_auth_key_reply_CMockIgnoreArg_p_key(__LINE__)
+void sd_ble_gap_auth_key_reply_CMockIgnoreArg_p_key(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_lesc_dhkey_reply_IgnoreAndReturn(cmock_retval) sd_ble_gap_lesc_dhkey_reply_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_lesc_dhkey_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_lesc_dhkey_reply_ExpectAndReturn(conn_handle, p_dhkey, cmock_retval) sd_ble_gap_lesc_dhkey_reply_CMockExpectAndReturn(__LINE__, conn_handle, p_dhkey, cmock_retval)
+void sd_ble_gap_lesc_dhkey_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_dhkey_t const* p_dhkey, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_lesc_dhkey_reply_CALLBACK)(uint16_t conn_handle, ble_gap_lesc_dhkey_t const* p_dhkey, int cmock_num_calls);
+void sd_ble_gap_lesc_dhkey_reply_StubWithCallback(CMOCK_sd_ble_gap_lesc_dhkey_reply_CALLBACK Callback);
+#define sd_ble_gap_lesc_dhkey_reply_ExpectWithArrayAndReturn(conn_handle, p_dhkey, p_dhkey_Depth, cmock_retval) sd_ble_gap_lesc_dhkey_reply_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_dhkey, p_dhkey_Depth, cmock_retval)
+void sd_ble_gap_lesc_dhkey_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_dhkey_t const* p_dhkey, int p_dhkey_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_lesc_dhkey_reply_ReturnThruPtr_p_dhkey(p_dhkey) sd_ble_gap_lesc_dhkey_reply_CMockReturnMemThruPtr_p_dhkey(__LINE__, p_dhkey, sizeof(*p_dhkey))
+#define sd_ble_gap_lesc_dhkey_reply_ReturnArrayThruPtr_p_dhkey(p_dhkey, cmock_len) sd_ble_gap_lesc_dhkey_reply_CMockReturnMemThruPtr_p_dhkey(__LINE__, p_dhkey, cmock_len * sizeof(*p_dhkey))
+#define sd_ble_gap_lesc_dhkey_reply_ReturnMemThruPtr_p_dhkey(p_dhkey, cmock_size) sd_ble_gap_lesc_dhkey_reply_CMockReturnMemThruPtr_p_dhkey(__LINE__, p_dhkey, cmock_size)
+void sd_ble_gap_lesc_dhkey_reply_CMockReturnMemThruPtr_p_dhkey(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_dhkey_t const* p_dhkey, int cmock_size);
+#define sd_ble_gap_lesc_dhkey_reply_IgnoreArg_conn_handle() sd_ble_gap_lesc_dhkey_reply_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_lesc_dhkey_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_lesc_dhkey_reply_IgnoreArg_p_dhkey() sd_ble_gap_lesc_dhkey_reply_CMockIgnoreArg_p_dhkey(__LINE__)
+void sd_ble_gap_lesc_dhkey_reply_CMockIgnoreArg_p_dhkey(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_keypress_notify_IgnoreAndReturn(cmock_retval) sd_ble_gap_keypress_notify_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_keypress_notify_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_keypress_notify_ExpectAndReturn(conn_handle, kp_not, cmock_retval) sd_ble_gap_keypress_notify_CMockExpectAndReturn(__LINE__, conn_handle, kp_not, cmock_retval)
+void sd_ble_gap_keypress_notify_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t kp_not, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_keypress_notify_CALLBACK)(uint16_t conn_handle, uint8_t kp_not, int cmock_num_calls);
+void sd_ble_gap_keypress_notify_StubWithCallback(CMOCK_sd_ble_gap_keypress_notify_CALLBACK Callback);
+#define sd_ble_gap_keypress_notify_IgnoreArg_conn_handle() sd_ble_gap_keypress_notify_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_keypress_notify_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_keypress_notify_IgnoreArg_kp_not() sd_ble_gap_keypress_notify_CMockIgnoreArg_kp_not(__LINE__)
+void sd_ble_gap_keypress_notify_CMockIgnoreArg_kp_not(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_lesc_oob_data_get_IgnoreAndReturn(cmock_retval) sd_ble_gap_lesc_oob_data_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_lesc_oob_data_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_lesc_oob_data_get_ExpectAndReturn(conn_handle, p_pk_own, p_oobd_own, cmock_retval) sd_ble_gap_lesc_oob_data_get_CMockExpectAndReturn(__LINE__, conn_handle, p_pk_own, p_oobd_own, cmock_retval)
+void sd_ble_gap_lesc_oob_data_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_p256_pk_t const* p_pk_own, ble_gap_lesc_oob_data_t* p_oobd_own, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_lesc_oob_data_get_CALLBACK)(uint16_t conn_handle, ble_gap_lesc_p256_pk_t const* p_pk_own, ble_gap_lesc_oob_data_t* p_oobd_own, int cmock_num_calls);
+void sd_ble_gap_lesc_oob_data_get_StubWithCallback(CMOCK_sd_ble_gap_lesc_oob_data_get_CALLBACK Callback);
+#define sd_ble_gap_lesc_oob_data_get_ExpectWithArrayAndReturn(conn_handle, p_pk_own, p_pk_own_Depth, p_oobd_own, p_oobd_own_Depth, cmock_retval) sd_ble_gap_lesc_oob_data_get_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_pk_own, p_pk_own_Depth, p_oobd_own, p_oobd_own_Depth, cmock_retval)
+void sd_ble_gap_lesc_oob_data_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_p256_pk_t const* p_pk_own, int p_pk_own_Depth, ble_gap_lesc_oob_data_t* p_oobd_own, int p_oobd_own_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_lesc_oob_data_get_ReturnThruPtr_p_pk_own(p_pk_own) sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_pk_own(__LINE__, p_pk_own, sizeof(*p_pk_own))
+#define sd_ble_gap_lesc_oob_data_get_ReturnArrayThruPtr_p_pk_own(p_pk_own, cmock_len) sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_pk_own(__LINE__, p_pk_own, cmock_len * sizeof(*p_pk_own))
+#define sd_ble_gap_lesc_oob_data_get_ReturnMemThruPtr_p_pk_own(p_pk_own, cmock_size) sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_pk_own(__LINE__, p_pk_own, cmock_size)
+void sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_pk_own(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_p256_pk_t const* p_pk_own, int cmock_size);
+#define sd_ble_gap_lesc_oob_data_get_ReturnThruPtr_p_oobd_own(p_oobd_own) sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_oobd_own(__LINE__, p_oobd_own, sizeof(*p_oobd_own))
+#define sd_ble_gap_lesc_oob_data_get_ReturnArrayThruPtr_p_oobd_own(p_oobd_own, cmock_len) sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_oobd_own(__LINE__, p_oobd_own, cmock_len * sizeof(*p_oobd_own))
+#define sd_ble_gap_lesc_oob_data_get_ReturnMemThruPtr_p_oobd_own(p_oobd_own, cmock_size) sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_oobd_own(__LINE__, p_oobd_own, cmock_size)
+void sd_ble_gap_lesc_oob_data_get_CMockReturnMemThruPtr_p_oobd_own(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_oob_data_t* p_oobd_own, int cmock_size);
+#define sd_ble_gap_lesc_oob_data_get_IgnoreArg_conn_handle() sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_lesc_oob_data_get_IgnoreArg_p_pk_own() sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_p_pk_own(__LINE__)
+void sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_p_pk_own(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_lesc_oob_data_get_IgnoreArg_p_oobd_own() sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_p_oobd_own(__LINE__)
+void sd_ble_gap_lesc_oob_data_get_CMockIgnoreArg_p_oobd_own(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_lesc_oob_data_set_IgnoreAndReturn(cmock_retval) sd_ble_gap_lesc_oob_data_set_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_lesc_oob_data_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_lesc_oob_data_set_ExpectAndReturn(conn_handle, p_oobd_own, p_oobd_peer, cmock_retval) sd_ble_gap_lesc_oob_data_set_CMockExpectAndReturn(__LINE__, conn_handle, p_oobd_own, p_oobd_peer, cmock_retval)
+void sd_ble_gap_lesc_oob_data_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_oob_data_t const* p_oobd_own, ble_gap_lesc_oob_data_t const* p_oobd_peer, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_lesc_oob_data_set_CALLBACK)(uint16_t conn_handle, ble_gap_lesc_oob_data_t const* p_oobd_own, ble_gap_lesc_oob_data_t const* p_oobd_peer, int cmock_num_calls);
+void sd_ble_gap_lesc_oob_data_set_StubWithCallback(CMOCK_sd_ble_gap_lesc_oob_data_set_CALLBACK Callback);
+#define sd_ble_gap_lesc_oob_data_set_ExpectWithArrayAndReturn(conn_handle, p_oobd_own, p_oobd_own_Depth, p_oobd_peer, p_oobd_peer_Depth, cmock_retval) sd_ble_gap_lesc_oob_data_set_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_oobd_own, p_oobd_own_Depth, p_oobd_peer, p_oobd_peer_Depth, cmock_retval)
+void sd_ble_gap_lesc_oob_data_set_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_lesc_oob_data_t const* p_oobd_own, int p_oobd_own_Depth, ble_gap_lesc_oob_data_t const* p_oobd_peer, int p_oobd_peer_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_lesc_oob_data_set_ReturnThruPtr_p_oobd_own(p_oobd_own) sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_own(__LINE__, p_oobd_own, sizeof(*p_oobd_own))
+#define sd_ble_gap_lesc_oob_data_set_ReturnArrayThruPtr_p_oobd_own(p_oobd_own, cmock_len) sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_own(__LINE__, p_oobd_own, cmock_len * sizeof(*p_oobd_own))
+#define sd_ble_gap_lesc_oob_data_set_ReturnMemThruPtr_p_oobd_own(p_oobd_own, cmock_size) sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_own(__LINE__, p_oobd_own, cmock_size)
+void sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_own(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_oob_data_t const* p_oobd_own, int cmock_size);
+#define sd_ble_gap_lesc_oob_data_set_ReturnThruPtr_p_oobd_peer(p_oobd_peer) sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_peer(__LINE__, p_oobd_peer, sizeof(*p_oobd_peer))
+#define sd_ble_gap_lesc_oob_data_set_ReturnArrayThruPtr_p_oobd_peer(p_oobd_peer, cmock_len) sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_peer(__LINE__, p_oobd_peer, cmock_len * sizeof(*p_oobd_peer))
+#define sd_ble_gap_lesc_oob_data_set_ReturnMemThruPtr_p_oobd_peer(p_oobd_peer, cmock_size) sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_peer(__LINE__, p_oobd_peer, cmock_size)
+void sd_ble_gap_lesc_oob_data_set_CMockReturnMemThruPtr_p_oobd_peer(UNITY_LINE_TYPE cmock_line, ble_gap_lesc_oob_data_t const* p_oobd_peer, int cmock_size);
+#define sd_ble_gap_lesc_oob_data_set_IgnoreArg_conn_handle() sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_lesc_oob_data_set_IgnoreArg_p_oobd_own() sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_p_oobd_own(__LINE__)
+void sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_p_oobd_own(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_lesc_oob_data_set_IgnoreArg_p_oobd_peer() sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_p_oobd_peer(__LINE__)
+void sd_ble_gap_lesc_oob_data_set_CMockIgnoreArg_p_oobd_peer(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_encrypt_IgnoreAndReturn(cmock_retval) sd_ble_gap_encrypt_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_encrypt_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_encrypt_ExpectAndReturn(conn_handle, p_master_id, p_enc_info, cmock_retval) sd_ble_gap_encrypt_CMockExpectAndReturn(__LINE__, conn_handle, p_master_id, p_enc_info, cmock_retval)
+void sd_ble_gap_encrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_master_id_t const* p_master_id, ble_gap_enc_info_t const* p_enc_info, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_encrypt_CALLBACK)(uint16_t conn_handle, ble_gap_master_id_t const* p_master_id, ble_gap_enc_info_t const* p_enc_info, int cmock_num_calls);
+void sd_ble_gap_encrypt_StubWithCallback(CMOCK_sd_ble_gap_encrypt_CALLBACK Callback);
+#define sd_ble_gap_encrypt_ExpectWithArrayAndReturn(conn_handle, p_master_id, p_master_id_Depth, p_enc_info, p_enc_info_Depth, cmock_retval) sd_ble_gap_encrypt_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_master_id, p_master_id_Depth, p_enc_info, p_enc_info_Depth, cmock_retval)
+void sd_ble_gap_encrypt_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_master_id_t const* p_master_id, int p_master_id_Depth, ble_gap_enc_info_t const* p_enc_info, int p_enc_info_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_encrypt_ReturnThruPtr_p_master_id(p_master_id) sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_master_id(__LINE__, p_master_id, sizeof(*p_master_id))
+#define sd_ble_gap_encrypt_ReturnArrayThruPtr_p_master_id(p_master_id, cmock_len) sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_master_id(__LINE__, p_master_id, cmock_len * sizeof(*p_master_id))
+#define sd_ble_gap_encrypt_ReturnMemThruPtr_p_master_id(p_master_id, cmock_size) sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_master_id(__LINE__, p_master_id, cmock_size)
+void sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_master_id(UNITY_LINE_TYPE cmock_line, ble_gap_master_id_t const* p_master_id, int cmock_size);
+#define sd_ble_gap_encrypt_ReturnThruPtr_p_enc_info(p_enc_info) sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_enc_info(__LINE__, p_enc_info, sizeof(*p_enc_info))
+#define sd_ble_gap_encrypt_ReturnArrayThruPtr_p_enc_info(p_enc_info, cmock_len) sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_enc_info(__LINE__, p_enc_info, cmock_len * sizeof(*p_enc_info))
+#define sd_ble_gap_encrypt_ReturnMemThruPtr_p_enc_info(p_enc_info, cmock_size) sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_enc_info(__LINE__, p_enc_info, cmock_size)
+void sd_ble_gap_encrypt_CMockReturnMemThruPtr_p_enc_info(UNITY_LINE_TYPE cmock_line, ble_gap_enc_info_t const* p_enc_info, int cmock_size);
+#define sd_ble_gap_encrypt_IgnoreArg_conn_handle() sd_ble_gap_encrypt_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_encrypt_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_encrypt_IgnoreArg_p_master_id() sd_ble_gap_encrypt_CMockIgnoreArg_p_master_id(__LINE__)
+void sd_ble_gap_encrypt_CMockIgnoreArg_p_master_id(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_encrypt_IgnoreArg_p_enc_info() sd_ble_gap_encrypt_CMockIgnoreArg_p_enc_info(__LINE__)
+void sd_ble_gap_encrypt_CMockIgnoreArg_p_enc_info(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_sec_info_reply_IgnoreAndReturn(cmock_retval) sd_ble_gap_sec_info_reply_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_sec_info_reply_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_sec_info_reply_ExpectAndReturn(conn_handle, p_enc_info, p_id_info, p_sign_info, cmock_retval) sd_ble_gap_sec_info_reply_CMockExpectAndReturn(__LINE__, conn_handle, p_enc_info, p_id_info, p_sign_info, cmock_retval)
+void sd_ble_gap_sec_info_reply_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_enc_info_t const* p_enc_info, ble_gap_irk_t const* p_id_info, ble_gap_sign_info_t const* p_sign_info, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_sec_info_reply_CALLBACK)(uint16_t conn_handle, ble_gap_enc_info_t const* p_enc_info, ble_gap_irk_t const* p_id_info, ble_gap_sign_info_t const* p_sign_info, int cmock_num_calls);
+void sd_ble_gap_sec_info_reply_StubWithCallback(CMOCK_sd_ble_gap_sec_info_reply_CALLBACK Callback);
+#define sd_ble_gap_sec_info_reply_ExpectWithArrayAndReturn(conn_handle, p_enc_info, p_enc_info_Depth, p_id_info, p_id_info_Depth, p_sign_info, p_sign_info_Depth, cmock_retval) sd_ble_gap_sec_info_reply_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_enc_info, p_enc_info_Depth, p_id_info, p_id_info_Depth, p_sign_info, p_sign_info_Depth, cmock_retval)
+void sd_ble_gap_sec_info_reply_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_enc_info_t const* p_enc_info, int p_enc_info_Depth, ble_gap_irk_t const* p_id_info, int p_id_info_Depth, ble_gap_sign_info_t const* p_sign_info, int p_sign_info_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_sec_info_reply_ReturnThruPtr_p_enc_info(p_enc_info) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_enc_info(__LINE__, p_enc_info, sizeof(*p_enc_info))
+#define sd_ble_gap_sec_info_reply_ReturnArrayThruPtr_p_enc_info(p_enc_info, cmock_len) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_enc_info(__LINE__, p_enc_info, cmock_len * sizeof(*p_enc_info))
+#define sd_ble_gap_sec_info_reply_ReturnMemThruPtr_p_enc_info(p_enc_info, cmock_size) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_enc_info(__LINE__, p_enc_info, cmock_size)
+void sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_enc_info(UNITY_LINE_TYPE cmock_line, ble_gap_enc_info_t const* p_enc_info, int cmock_size);
+#define sd_ble_gap_sec_info_reply_ReturnThruPtr_p_id_info(p_id_info) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_id_info(__LINE__, p_id_info, sizeof(*p_id_info))
+#define sd_ble_gap_sec_info_reply_ReturnArrayThruPtr_p_id_info(p_id_info, cmock_len) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_id_info(__LINE__, p_id_info, cmock_len * sizeof(*p_id_info))
+#define sd_ble_gap_sec_info_reply_ReturnMemThruPtr_p_id_info(p_id_info, cmock_size) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_id_info(__LINE__, p_id_info, cmock_size)
+void sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_id_info(UNITY_LINE_TYPE cmock_line, ble_gap_irk_t const* p_id_info, int cmock_size);
+#define sd_ble_gap_sec_info_reply_ReturnThruPtr_p_sign_info(p_sign_info) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_sign_info(__LINE__, p_sign_info, sizeof(*p_sign_info))
+#define sd_ble_gap_sec_info_reply_ReturnArrayThruPtr_p_sign_info(p_sign_info, cmock_len) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_sign_info(__LINE__, p_sign_info, cmock_len * sizeof(*p_sign_info))
+#define sd_ble_gap_sec_info_reply_ReturnMemThruPtr_p_sign_info(p_sign_info, cmock_size) sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_sign_info(__LINE__, p_sign_info, cmock_size)
+void sd_ble_gap_sec_info_reply_CMockReturnMemThruPtr_p_sign_info(UNITY_LINE_TYPE cmock_line, ble_gap_sign_info_t const* p_sign_info, int cmock_size);
+#define sd_ble_gap_sec_info_reply_IgnoreArg_conn_handle() sd_ble_gap_sec_info_reply_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_sec_info_reply_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_sec_info_reply_IgnoreArg_p_enc_info() sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_enc_info(__LINE__)
+void sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_enc_info(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_sec_info_reply_IgnoreArg_p_id_info() sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_id_info(__LINE__)
+void sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_id_info(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_sec_info_reply_IgnoreArg_p_sign_info() sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_sign_info(__LINE__)
+void sd_ble_gap_sec_info_reply_CMockIgnoreArg_p_sign_info(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_conn_sec_get_IgnoreAndReturn(cmock_retval) sd_ble_gap_conn_sec_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_conn_sec_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_conn_sec_get_ExpectAndReturn(conn_handle, p_conn_sec, cmock_retval) sd_ble_gap_conn_sec_get_CMockExpectAndReturn(__LINE__, conn_handle, p_conn_sec, cmock_retval)
+void sd_ble_gap_conn_sec_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_conn_sec_t* p_conn_sec, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_conn_sec_get_CALLBACK)(uint16_t conn_handle, ble_gap_conn_sec_t* p_conn_sec, int cmock_num_calls);
+void sd_ble_gap_conn_sec_get_StubWithCallback(CMOCK_sd_ble_gap_conn_sec_get_CALLBACK Callback);
+#define sd_ble_gap_conn_sec_get_ExpectWithArrayAndReturn(conn_handle, p_conn_sec, p_conn_sec_Depth, cmock_retval) sd_ble_gap_conn_sec_get_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_conn_sec, p_conn_sec_Depth, cmock_retval)
+void sd_ble_gap_conn_sec_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, ble_gap_conn_sec_t* p_conn_sec, int p_conn_sec_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_conn_sec_get_ReturnThruPtr_p_conn_sec(p_conn_sec) sd_ble_gap_conn_sec_get_CMockReturnMemThruPtr_p_conn_sec(__LINE__, p_conn_sec, sizeof(*p_conn_sec))
+#define sd_ble_gap_conn_sec_get_ReturnArrayThruPtr_p_conn_sec(p_conn_sec, cmock_len) sd_ble_gap_conn_sec_get_CMockReturnMemThruPtr_p_conn_sec(__LINE__, p_conn_sec, cmock_len * sizeof(*p_conn_sec))
+#define sd_ble_gap_conn_sec_get_ReturnMemThruPtr_p_conn_sec(p_conn_sec, cmock_size) sd_ble_gap_conn_sec_get_CMockReturnMemThruPtr_p_conn_sec(__LINE__, p_conn_sec, cmock_size)
+void sd_ble_gap_conn_sec_get_CMockReturnMemThruPtr_p_conn_sec(UNITY_LINE_TYPE cmock_line, ble_gap_conn_sec_t* p_conn_sec, int cmock_size);
+#define sd_ble_gap_conn_sec_get_IgnoreArg_conn_handle() sd_ble_gap_conn_sec_get_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_conn_sec_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_conn_sec_get_IgnoreArg_p_conn_sec() sd_ble_gap_conn_sec_get_CMockIgnoreArg_p_conn_sec(__LINE__)
+void sd_ble_gap_conn_sec_get_CMockIgnoreArg_p_conn_sec(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_rssi_start_IgnoreAndReturn(cmock_retval) sd_ble_gap_rssi_start_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_rssi_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_rssi_start_ExpectAndReturn(conn_handle, threshold_dbm, skip_count, cmock_retval) sd_ble_gap_rssi_start_CMockExpectAndReturn(__LINE__, conn_handle, threshold_dbm, skip_count, cmock_retval)
+void sd_ble_gap_rssi_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint8_t threshold_dbm, uint8_t skip_count, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_rssi_start_CALLBACK)(uint16_t conn_handle, uint8_t threshold_dbm, uint8_t skip_count, int cmock_num_calls);
+void sd_ble_gap_rssi_start_StubWithCallback(CMOCK_sd_ble_gap_rssi_start_CALLBACK Callback);
+#define sd_ble_gap_rssi_start_IgnoreArg_conn_handle() sd_ble_gap_rssi_start_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_rssi_start_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_rssi_start_IgnoreArg_threshold_dbm() sd_ble_gap_rssi_start_CMockIgnoreArg_threshold_dbm(__LINE__)
+void sd_ble_gap_rssi_start_CMockIgnoreArg_threshold_dbm(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_rssi_start_IgnoreArg_skip_count() sd_ble_gap_rssi_start_CMockIgnoreArg_skip_count(__LINE__)
+void sd_ble_gap_rssi_start_CMockIgnoreArg_skip_count(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_rssi_stop_IgnoreAndReturn(cmock_retval) sd_ble_gap_rssi_stop_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_rssi_stop_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_rssi_stop_ExpectAndReturn(conn_handle, cmock_retval) sd_ble_gap_rssi_stop_CMockExpectAndReturn(__LINE__, conn_handle, cmock_retval)
+void sd_ble_gap_rssi_stop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_rssi_stop_CALLBACK)(uint16_t conn_handle, int cmock_num_calls);
+void sd_ble_gap_rssi_stop_StubWithCallback(CMOCK_sd_ble_gap_rssi_stop_CALLBACK Callback);
+#define sd_ble_gap_rssi_stop_IgnoreArg_conn_handle() sd_ble_gap_rssi_stop_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_rssi_stop_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_rssi_get_IgnoreAndReturn(cmock_retval) sd_ble_gap_rssi_get_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_rssi_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_rssi_get_ExpectAndReturn(conn_handle, p_rssi, cmock_retval) sd_ble_gap_rssi_get_CMockExpectAndReturn(__LINE__, conn_handle, p_rssi, cmock_retval)
+void sd_ble_gap_rssi_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, int8_t* p_rssi, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_rssi_get_CALLBACK)(uint16_t conn_handle, int8_t* p_rssi, int cmock_num_calls);
+void sd_ble_gap_rssi_get_StubWithCallback(CMOCK_sd_ble_gap_rssi_get_CALLBACK Callback);
+#define sd_ble_gap_rssi_get_ExpectWithArrayAndReturn(conn_handle, p_rssi, p_rssi_Depth, cmock_retval) sd_ble_gap_rssi_get_CMockExpectWithArrayAndReturn(__LINE__, conn_handle, p_rssi, p_rssi_Depth, cmock_retval)
+void sd_ble_gap_rssi_get_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint16_t conn_handle, int8_t* p_rssi, int p_rssi_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_rssi_get_ReturnThruPtr_p_rssi(p_rssi) sd_ble_gap_rssi_get_CMockReturnMemThruPtr_p_rssi(__LINE__, p_rssi, sizeof(*p_rssi))
+#define sd_ble_gap_rssi_get_ReturnArrayThruPtr_p_rssi(p_rssi, cmock_len) sd_ble_gap_rssi_get_CMockReturnMemThruPtr_p_rssi(__LINE__, p_rssi, cmock_len * sizeof(*p_rssi))
+#define sd_ble_gap_rssi_get_ReturnMemThruPtr_p_rssi(p_rssi, cmock_size) sd_ble_gap_rssi_get_CMockReturnMemThruPtr_p_rssi(__LINE__, p_rssi, cmock_size)
+void sd_ble_gap_rssi_get_CMockReturnMemThruPtr_p_rssi(UNITY_LINE_TYPE cmock_line, int8_t* p_rssi, int cmock_size);
+#define sd_ble_gap_rssi_get_IgnoreArg_conn_handle() sd_ble_gap_rssi_get_CMockIgnoreArg_conn_handle(__LINE__)
+void sd_ble_gap_rssi_get_CMockIgnoreArg_conn_handle(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_rssi_get_IgnoreArg_p_rssi() sd_ble_gap_rssi_get_CMockIgnoreArg_p_rssi(__LINE__)
+void sd_ble_gap_rssi_get_CMockIgnoreArg_p_rssi(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_scan_start_IgnoreAndReturn(cmock_retval) sd_ble_gap_scan_start_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_scan_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_scan_start_ExpectAndReturn(p_scan_params, cmock_retval) sd_ble_gap_scan_start_CMockExpectAndReturn(__LINE__, p_scan_params, cmock_retval)
+void sd_ble_gap_scan_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_scan_params_t const* p_scan_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_scan_start_CALLBACK)(ble_gap_scan_params_t const* p_scan_params, int cmock_num_calls);
+void sd_ble_gap_scan_start_StubWithCallback(CMOCK_sd_ble_gap_scan_start_CALLBACK Callback);
+#define sd_ble_gap_scan_start_ExpectWithArrayAndReturn(p_scan_params, p_scan_params_Depth, cmock_retval) sd_ble_gap_scan_start_CMockExpectWithArrayAndReturn(__LINE__, p_scan_params, p_scan_params_Depth, cmock_retval)
+void sd_ble_gap_scan_start_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_scan_params_t const* p_scan_params, int p_scan_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_scan_start_ReturnThruPtr_p_scan_params(p_scan_params) sd_ble_gap_scan_start_CMockReturnMemThruPtr_p_scan_params(__LINE__, p_scan_params, sizeof(*p_scan_params))
+#define sd_ble_gap_scan_start_ReturnArrayThruPtr_p_scan_params(p_scan_params, cmock_len) sd_ble_gap_scan_start_CMockReturnMemThruPtr_p_scan_params(__LINE__, p_scan_params, cmock_len * sizeof(*p_scan_params))
+#define sd_ble_gap_scan_start_ReturnMemThruPtr_p_scan_params(p_scan_params, cmock_size) sd_ble_gap_scan_start_CMockReturnMemThruPtr_p_scan_params(__LINE__, p_scan_params, cmock_size)
+void sd_ble_gap_scan_start_CMockReturnMemThruPtr_p_scan_params(UNITY_LINE_TYPE cmock_line, ble_gap_scan_params_t const* p_scan_params, int cmock_size);
+#define sd_ble_gap_scan_start_IgnoreArg_p_scan_params() sd_ble_gap_scan_start_CMockIgnoreArg_p_scan_params(__LINE__)
+void sd_ble_gap_scan_start_CMockIgnoreArg_p_scan_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_scan_stop_IgnoreAndReturn(cmock_retval) sd_ble_gap_scan_stop_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_scan_stop_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_scan_stop_ExpectAndReturn(cmock_retval) sd_ble_gap_scan_stop_CMockExpectAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_scan_stop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_scan_stop_CALLBACK)(int cmock_num_calls);
+void sd_ble_gap_scan_stop_StubWithCallback(CMOCK_sd_ble_gap_scan_stop_CALLBACK Callback);
+#define sd_ble_gap_connect_IgnoreAndReturn(cmock_retval) sd_ble_gap_connect_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_connect_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_connect_ExpectAndReturn(p_peer_addr, p_scan_params, p_conn_params, cmock_retval) sd_ble_gap_connect_CMockExpectAndReturn(__LINE__, p_peer_addr, p_scan_params, p_conn_params, cmock_retval)
+void sd_ble_gap_connect_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_peer_addr, ble_gap_scan_params_t const* p_scan_params, ble_gap_conn_params_t const* p_conn_params, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_connect_CALLBACK)(ble_gap_addr_t const* p_peer_addr, ble_gap_scan_params_t const* p_scan_params, ble_gap_conn_params_t const* p_conn_params, int cmock_num_calls);
+void sd_ble_gap_connect_StubWithCallback(CMOCK_sd_ble_gap_connect_CALLBACK Callback);
+#define sd_ble_gap_connect_ExpectWithArrayAndReturn(p_peer_addr, p_peer_addr_Depth, p_scan_params, p_scan_params_Depth, p_conn_params, p_conn_params_Depth, cmock_retval) sd_ble_gap_connect_CMockExpectWithArrayAndReturn(__LINE__, p_peer_addr, p_peer_addr_Depth, p_scan_params, p_scan_params_Depth, p_conn_params, p_conn_params_Depth, cmock_retval)
+void sd_ble_gap_connect_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_peer_addr, int p_peer_addr_Depth, ble_gap_scan_params_t const* p_scan_params, int p_scan_params_Depth, ble_gap_conn_params_t const* p_conn_params, int p_conn_params_Depth, uint32_t cmock_to_return);
+#define sd_ble_gap_connect_ReturnThruPtr_p_peer_addr(p_peer_addr) sd_ble_gap_connect_CMockReturnMemThruPtr_p_peer_addr(__LINE__, p_peer_addr, sizeof(*p_peer_addr))
+#define sd_ble_gap_connect_ReturnArrayThruPtr_p_peer_addr(p_peer_addr, cmock_len) sd_ble_gap_connect_CMockReturnMemThruPtr_p_peer_addr(__LINE__, p_peer_addr, cmock_len * sizeof(*p_peer_addr))
+#define sd_ble_gap_connect_ReturnMemThruPtr_p_peer_addr(p_peer_addr, cmock_size) sd_ble_gap_connect_CMockReturnMemThruPtr_p_peer_addr(__LINE__, p_peer_addr, cmock_size)
+void sd_ble_gap_connect_CMockReturnMemThruPtr_p_peer_addr(UNITY_LINE_TYPE cmock_line, ble_gap_addr_t const* p_peer_addr, int cmock_size);
+#define sd_ble_gap_connect_ReturnThruPtr_p_scan_params(p_scan_params) sd_ble_gap_connect_CMockReturnMemThruPtr_p_scan_params(__LINE__, p_scan_params, sizeof(*p_scan_params))
+#define sd_ble_gap_connect_ReturnArrayThruPtr_p_scan_params(p_scan_params, cmock_len) sd_ble_gap_connect_CMockReturnMemThruPtr_p_scan_params(__LINE__, p_scan_params, cmock_len * sizeof(*p_scan_params))
+#define sd_ble_gap_connect_ReturnMemThruPtr_p_scan_params(p_scan_params, cmock_size) sd_ble_gap_connect_CMockReturnMemThruPtr_p_scan_params(__LINE__, p_scan_params, cmock_size)
+void sd_ble_gap_connect_CMockReturnMemThruPtr_p_scan_params(UNITY_LINE_TYPE cmock_line, ble_gap_scan_params_t const* p_scan_params, int cmock_size);
+#define sd_ble_gap_connect_ReturnThruPtr_p_conn_params(p_conn_params) sd_ble_gap_connect_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, sizeof(*p_conn_params))
+#define sd_ble_gap_connect_ReturnArrayThruPtr_p_conn_params(p_conn_params, cmock_len) sd_ble_gap_connect_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, cmock_len * sizeof(*p_conn_params))
+#define sd_ble_gap_connect_ReturnMemThruPtr_p_conn_params(p_conn_params, cmock_size) sd_ble_gap_connect_CMockReturnMemThruPtr_p_conn_params(__LINE__, p_conn_params, cmock_size)
+void sd_ble_gap_connect_CMockReturnMemThruPtr_p_conn_params(UNITY_LINE_TYPE cmock_line, ble_gap_conn_params_t const* p_conn_params, int cmock_size);
+#define sd_ble_gap_connect_IgnoreArg_p_peer_addr() sd_ble_gap_connect_CMockIgnoreArg_p_peer_addr(__LINE__)
+void sd_ble_gap_connect_CMockIgnoreArg_p_peer_addr(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_connect_IgnoreArg_p_scan_params() sd_ble_gap_connect_CMockIgnoreArg_p_scan_params(__LINE__)
+void sd_ble_gap_connect_CMockIgnoreArg_p_scan_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_connect_IgnoreArg_p_conn_params() sd_ble_gap_connect_CMockIgnoreArg_p_conn_params(__LINE__)
+void sd_ble_gap_connect_CMockIgnoreArg_p_conn_params(UNITY_LINE_TYPE cmock_line);
+#define sd_ble_gap_connect_cancel_IgnoreAndReturn(cmock_retval) sd_ble_gap_connect_cancel_CMockIgnoreAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_connect_cancel_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+#define sd_ble_gap_connect_cancel_ExpectAndReturn(cmock_retval) sd_ble_gap_connect_cancel_CMockExpectAndReturn(__LINE__, cmock_retval)
+void sd_ble_gap_connect_cancel_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return);
+typedef uint32_t (* CMOCK_sd_ble_gap_connect_cancel_CALLBACK)(int cmock_num_calls);
+void sd_ble_gap_connect_cancel_StubWithCallback(CMOCK_sd_ble_gap_connect_cancel_CALLBACK Callback);
+
+#endif
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers_replacement/nrf_nvic.h nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers_replacement/nrf_nvic.h
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers_replacement/nrf_nvic.h   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers_replacement/nrf_nvic.h    2018-04-24 08:48:29.118157300 +0200
@@ -0,0 +1,546 @@
+/*
+ * Copyright (c) Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
+ *   contributors to this software may be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ *   4. This software must only be used in a processor manufactured by Nordic
+ *   Semiconductor ASA, or in a processor manufactured by a third party that
+ *   is used in combination with a processor manufactured by Nordic Semiconductor.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/**
+ * @defgroup nrf_nvic_api SoftDevice NVIC API
+ * @{
+ *
+ * @note In order to use this module, the following code has to be added to a .c file:
+ *     \code
+ *     nrf_nvic_state_t nrf_nvic_state = {0};
+ *     \endcode
+ *
+ * @note Definitions and declarations starting with __ (double underscore) in this header file are
+ * not intended for direct use by the application.
+ *
+ * @brief APIs for the accessing NVIC when using a SoftDevice.
+ *
+ */
+
+#ifndef NRF_NVIC_H__
+#define NRF_NVIC_H__
+
+#include <stdint.h>
+#include "nrf.h"
+
+#include "nrf_error_soc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**@addtogroup NRF_NVIC_DEFINES Defines
+ * @{ */
+
+/**@defgroup NRF_NVIC_ISER_DEFINES SoftDevice NVIC internal definitions
+ * @{ */
+
+#define __NRF_NVIC_NVMC_IRQn (30) /**< The peripheral ID of the NVMC. IRQ numbers are used to identify peripherals, but the NVMC doesn't have an IRQ number in the MDK. */
+
+#ifdef NRF51
+  #define __NRF_NVIC_ISER_COUNT (1) /**< The number of ISER/ICER registers in the NVIC that are used. */
+
+  /**@brief Interrupts used by the SoftDevice. */
+  #define __NRF_NVIC_SD_IRQS_0 ((uint32_t)( \
+        (1U << POWER_CLOCK_IRQn) \
+      | (1U << RADIO_IRQn) \
+      | (1U << RTC0_IRQn) \
+      | (1U << TIMER0_IRQn) \
+      | (1U << RNG_IRQn) \
+      | (1U << ECB_IRQn) \
+      | (1U << CCM_AAR_IRQn) \
+      | (1U << TEMP_IRQn) \
+      | (1U << __NRF_NVIC_NVMC_IRQn) \
+      | (1U << (uint32_t)SWI4_IRQn) \
+      | (1U << (uint32_t)SWI5_IRQn) \
+    ))
+
+  /**@brief Interrupts available for to application. */
+  #define __NRF_NVIC_APP_IRQS_0 (~__NRF_NVIC_SD_IRQS_0)
+#endif
+
+#if (defined(NRF52) || defined(NRF52840_XXAA))
+  #define __NRF_NVIC_ISER_COUNT (2) /**< The number of ISER/ICER registers in the NVIC that are used. */
+
+  /**@brief Interrupts used by the SoftDevice. */
+  #define __NRF_NVIC_SD_IRQS_0 ((uint32_t)( \
+        (1U << POWER_CLOCK_IRQn) \
+      | (1U << RADIO_IRQn) \
+      | (1U << RTC0_IRQn) \
+      | (1U << TIMER0_IRQn) \
+      | (1U << RNG_IRQn) \
+      | (1U << ECB_IRQn) \
+      | (1U << CCM_AAR_IRQn) \
+      | (1U << TEMP_IRQn) \
+      | (1U << __NRF_NVIC_NVMC_IRQn) \
+      | (1U << (uint32_t)SWI4_EGU4_IRQn) \
+      | (1U << (uint32_t)SWI5_EGU5_IRQn) \
+    ))
+  #define __NRF_NVIC_SD_IRQS_1 ((uint32_t)0)
+
+  /**@brief Interrupts available for to application. */
+  #define __NRF_NVIC_APP_IRQS_0 (~__NRF_NVIC_SD_IRQS_0)
+  #define __NRF_NVIC_APP_IRQS_1 (~__NRF_NVIC_SD_IRQS_1)
+#endif
+/**@} */
+
+/**@} */
+
+/**@addtogroup NRF_NVIC_VARIABLES Variables
+ * @{ */
+
+/**@brief Type representing the state struct for the SoftDevice NVIC module. */
+typedef struct
+{
+  uint32_t volatile __irq_masks[__NRF_NVIC_ISER_COUNT]; /**< IRQs enabled by the application in the NVIC. */
+  uint32_t volatile __cr_flag;                          /**< Non-zero if already in a critical region */
+} nrf_nvic_state_t;
+
+/**@brief Variable keeping the state for the SoftDevice NVIC module. This must be declared in an
+ * application source file. */
+extern nrf_nvic_state_t nrf_nvic_state;
+
+
+/**@} */
+
+#if (__LINT__ != 1)
+
+/**@addtogroup NRF_NVIC_INTERNAL_FUNCTIONS SoftDevice NVIC internal functions
+ * @{ */
+
+/**@brief Disables IRQ interrupts globally, including the SoftDevice's interrupts.
+ *
+ * @retval  The value of PRIMASK prior to disabling the interrupts.
+ */
+__STATIC_INLINE int __sd_nvic_irq_disable(void);
+
+
+/**@brief Enables IRQ interrupts globally, including the SoftDevice's interrupts.
+ */
+__STATIC_INLINE void __sd_nvic_irq_enable(void);
+
+
+/**@brief Checks if IRQn is available to application
+ * @param[in]  IRQn  irq to check
+ *
+ * @retval  1 (true) if the irq to check is available to the application
+ */
+__STATIC_INLINE uint32_t __sd_nvic_app_accessible_irq(IRQn_Type IRQn);
+
+
+/**@brief Checks if IRQn is available to application
+ * @param[in]  priority  priority to check
+ *
+ * @retval  1 (true) if the priority to check is available to the application
+ */
+__STATIC_INLINE uint32_t __sd_nvic_is_app_accessible_priority(uint32_t priority);
+
+
+/**@} */
+
+
+/**@addtogroup NRF_NVIC_FUNCTIONS SoftDevice NVIC public functions
+ * @{ */
+
+/**@brief Enable External Interrupt.
+ * @note Corresponds to NVIC_EnableIRQ in CMSIS.
+ *
+ * @pre IRQn is valid and not reserved by the stack.
+ *
+ * @param[in] IRQn See the NVIC_EnableIRQ documentation in CMSIS.
+ *
+ * @retval ::NRF_SUCCESS The interrupt was enabled.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE The interrupt is not available for the application.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED The interrupt has a priority not available for the application.
+ */
+__STATIC_INLINE uint32_t sd_nvic_EnableIRQ(IRQn_Type IRQn);
+
+
+/**@brief  Disable External Interrupt.
+ * @note Corresponds to NVIC_DisableIRQ in CMSIS.
+ *
+ * @pre IRQn is valid and not reserved by the stack.
+ *
+ * @param[in] IRQn See the NVIC_DisableIRQ documentation in CMSIS.
+ *
+ * @retval ::NRF_SUCCESS The interrupt was disabled.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE The interrupt is not available for the application.
+ */
+__STATIC_INLINE uint32_t sd_nvic_DisableIRQ(IRQn_Type IRQn);
+
+
+/**@brief  Get Pending Interrupt.
+ * @note Corresponds to NVIC_GetPendingIRQ in CMSIS.
+ *
+ * @pre IRQn is valid and not reserved by the stack.
+ *
+ * @param[in]   IRQn          See the NVIC_GetPendingIRQ documentation in CMSIS.
+ * @param[out]  p_pending_irq Return value from NVIC_GetPendingIRQ.
+ *
+ * @retval ::NRF_SUCCESS The interrupt is available for the application.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE IRQn is not available for the application.
+ */
+__STATIC_INLINE uint32_t sd_nvic_GetPendingIRQ(IRQn_Type IRQn, uint32_t * p_pending_irq);
+
+
+/**@brief  Set Pending Interrupt.
+ * @note Corresponds to NVIC_SetPendingIRQ in CMSIS.
+ *
+ * @pre IRQn is valid and not reserved by the stack.
+ *
+ * @param[in] IRQn See the NVIC_SetPendingIRQ documentation in CMSIS.
+ *
+ * @retval ::NRF_SUCCESS The interrupt is set pending.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE IRQn is not available for the application.
+ */
+__STATIC_INLINE uint32_t sd_nvic_SetPendingIRQ(IRQn_Type IRQn);
+
+
+/**@brief  Clear Pending Interrupt.
+ * @note Corresponds to NVIC_ClearPendingIRQ in CMSIS.
+ *
+ * @pre IRQn is valid and not reserved by the stack.
+ *
+ * @param[in] IRQn See the NVIC_ClearPendingIRQ documentation in CMSIS.
+ *
+ * @retval ::NRF_SUCCESS The interrupt pending flag is cleared.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE IRQn is not available for the application.
+ */
+__STATIC_INLINE uint32_t sd_nvic_ClearPendingIRQ(IRQn_Type IRQn);
+
+
+/**@brief Set Interrupt Priority.
+ * @note Corresponds to NVIC_SetPriority in CMSIS.
+ *
+ * @pre IRQn is valid and not reserved by the stack.
+ * @pre Priority is valid and not reserved by the stack.
+ *
+ * @param[in] IRQn      See the NVIC_SetPriority documentation in CMSIS.
+ * @param[in] priority  A valid IRQ priority for use by the application.
+ *
+ * @retval ::NRF_SUCCESS The interrupt and priority level is available for the application.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE IRQn is not available for the application.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED The interrupt priority is not available for the application.
+ */
+__STATIC_INLINE uint32_t sd_nvic_SetPriority(IRQn_Type IRQn, uint32_t priority);
+
+
+/**@brief Get Interrupt Priority.
+ * @note Corresponds to NVIC_GetPriority in CMSIS.
+ *
+ * @pre IRQn is valid and not reserved by the stack.
+ *
+ * @param[in]  IRQn         See the NVIC_GetPriority documentation in CMSIS.
+ * @param[out] p_priority   Return value from NVIC_GetPriority.
+ *
+ * @retval ::NRF_SUCCESS The interrupt priority is returned in p_priority.
+ * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE - IRQn is not available for the application.
+ */
+__STATIC_INLINE uint32_t sd_nvic_GetPriority(IRQn_Type IRQn, uint32_t * p_priority);
+
+
+/**@brief System Reset.
+ * @note Corresponds to NVIC_SystemReset in CMSIS.
+ *
+ * @retval ::NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN
+ */
+__STATIC_INLINE uint32_t sd_nvic_SystemReset(void);
+
+
+/**@brief Enters critical region.
+ *
+ * @post Application interrupts will be disabled.
+ * @note sd_nvic_critical_region_enter() and ::sd_nvic_critical_region_exit() must be called in matching pairs inside each
+ * execution context
+ * @sa sd_nvic_critical_region_exit
+ *
+ * @param[out] p_is_nested_critical_region If 1, the application is now in a nested critical region.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+__STATIC_INLINE uint32_t sd_nvic_critical_region_enter(uint8_t * p_is_nested_critical_region);
+
+
+/**@brief Exit critical region.
+ *
+ * @pre Application has entered a critical region using ::sd_nvic_critical_region_enter.
+ * @post If not in a nested critical region, the application interrupts will restored to the state before ::sd_nvic_critical_region_enter was called.
+ *
+ * @param[in] is_nested_critical_region If this is set to 1, the critical region won't be exited. @sa sd_nvic_critical_region_enter.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+__STATIC_INLINE uint32_t sd_nvic_critical_region_exit(uint8_t is_nested_critical_region);
+
+#endif //#if (__LINT__ != 1)
+
+/**@} */
+
+#ifndef SUPPRESS_INLINE_IMPLEMENTATION
+
+__STATIC_INLINE int __sd_nvic_irq_disable(void)
+{
+  int pm = __get_PRIMASK();
+  __disable_irq();
+  return pm;
+}
+
+__STATIC_INLINE void __sd_nvic_irq_enable(void)
+{
+  __enable_irq();
+}
+
+
+__STATIC_INLINE uint32_t __sd_nvic_app_accessible_irq(IRQn_Type IRQn)
+{
+  if (IRQn < 32)
+  {
+    return ((1UL<<IRQn) & __NRF_NVIC_APP_IRQS_0) != 0;
+  }
+#if (defined(NRF52) || defined(NRF52840_XXAA))
+  else if (IRQn < 64)
+  {
+    return ((1UL<<(IRQn-32)) & __NRF_NVIC_APP_IRQS_1) != 0;
+  }
+#endif
+  else
+  {
+    return 1;
+  }
+}
+
+
+__STATIC_INLINE uint32_t __sd_nvic_is_app_accessible_priority(uint32_t priority)
+{
+  if (priority >= (1 << __NVIC_PRIO_BITS))
+  {
+    return 0;
+  }
+#ifdef NRF51
+  if (   priority == 0
+     || priority == 2
+     )
+  {
+    return 0;
+  }
+#endif
+#if (defined(NRF52) || defined(NRF52840_XXAA))
+  if (   priority == 0
+     || priority == 1
+     || priority == 4
+     || priority == 5
+     )
+  {
+    return 0;
+  }
+#endif
+  return 1;
+}
+
+__STATIC_INLINE uint32_t sd_nvic_EnableIRQ(IRQn_Type IRQn)
+{
+  if (!__sd_nvic_app_accessible_irq(IRQn))
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
+  }
+  if (!__sd_nvic_is_app_accessible_priority(NVIC_GetPriority(IRQn)))
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
+  }
+
+  if (nrf_nvic_state.__cr_flag)
+  {
+    nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] |= (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));
+  }
+  else
+  {
+    NVIC_EnableIRQ(IRQn);
+  }
+  return NRF_SUCCESS;
+}
+
+
+__STATIC_INLINE uint32_t sd_nvic_DisableIRQ(IRQn_Type IRQn)
+{
+  if (!__sd_nvic_app_accessible_irq(IRQn))
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
+  }
+
+  if (nrf_nvic_state.__cr_flag)
+  {
+    nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] &= ~(1UL << ((uint32_t)(IRQn) & 0x1F));
+  }
+  else
+  {
+    NVIC_DisableIRQ(IRQn);
+  }
+
+  return NRF_SUCCESS;
+}
+
+__STATIC_INLINE uint32_t sd_nvic_GetPendingIRQ(IRQn_Type IRQn, uint32_t * p_pending_irq)
+{
+  if (__sd_nvic_app_accessible_irq(IRQn))
+  {
+    *p_pending_irq = NVIC_GetPendingIRQ(IRQn);
+    return NRF_SUCCESS;
+  }
+  else
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
+  }
+}
+
+__STATIC_INLINE uint32_t sd_nvic_SetPendingIRQ(IRQn_Type IRQn)
+{
+  if (__sd_nvic_app_accessible_irq(IRQn))
+  {
+    NVIC_SetPendingIRQ(IRQn);
+    return NRF_SUCCESS;
+  }
+  else
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
+  }
+}
+
+
+__STATIC_INLINE uint32_t sd_nvic_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  if (__sd_nvic_app_accessible_irq(IRQn))
+  {
+    NVIC_ClearPendingIRQ(IRQn);
+    return NRF_SUCCESS;
+  }
+  else
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
+  }
+}
+
+__STATIC_INLINE uint32_t sd_nvic_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  if (!__sd_nvic_app_accessible_irq(IRQn))
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
+  }
+
+  if (!__sd_nvic_is_app_accessible_priority(priority))
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
+  }
+
+  NVIC_SetPriority(IRQn, (uint32_t)priority);
+  return NRF_SUCCESS;
+}
+
+
+__STATIC_INLINE uint32_t sd_nvic_GetPriority(IRQn_Type IRQn, uint32_t * p_priority)
+{
+  if (__sd_nvic_app_accessible_irq(IRQn))
+  {
+    *p_priority = (NVIC_GetPriority(IRQn) & 0xFF);
+    return NRF_SUCCESS;
+  }
+  else
+  {
+    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
+  }
+}
+
+
+__STATIC_INLINE uint32_t sd_nvic_SystemReset(void)
+{
+  NVIC_SystemReset();
+  return NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN;
+}
+
+
+__STATIC_INLINE uint32_t sd_nvic_critical_region_enter(uint8_t * p_is_nested_critical_region)
+{
+  int was_masked = __sd_nvic_irq_disable();
+  if (!nrf_nvic_state.__cr_flag)
+  {
+    nrf_nvic_state.__cr_flag = 1;
+    nrf_nvic_state.__irq_masks[0] = ( NVIC->ICER[0] & __NRF_NVIC_APP_IRQS_0 );
+    NVIC->ICER[0] = __NRF_NVIC_APP_IRQS_0;
+    #if (defined(NRF52) || defined(NRF52840_XXAA))
+    nrf_nvic_state.__irq_masks[1] = ( NVIC->ICER[1] & __NRF_NVIC_APP_IRQS_1 );
+    NVIC->ICER[1] = __NRF_NVIC_APP_IRQS_1;
+    #endif
+    *p_is_nested_critical_region = 0;
+  }
+  else
+  {
+    *p_is_nested_critical_region = 1;
+  }
+  if (!was_masked)
+  {
+    __sd_nvic_irq_enable();
+  }
+  return NRF_SUCCESS;
+}
+
+
+__STATIC_INLINE uint32_t sd_nvic_critical_region_exit(uint8_t is_nested_critical_region)
+{
+  if (nrf_nvic_state.__cr_flag && (is_nested_critical_region == 0))
+  {
+    int was_masked = __sd_nvic_irq_disable();
+    NVIC->ISER[0] = nrf_nvic_state.__irq_masks[0];
+    #if (defined(NRF52) || defined(NRF52840_XXAA))
+    NVIC->ISER[1] = nrf_nvic_state.__irq_masks[1];
+    #endif
+    nrf_nvic_state.__cr_flag = 0;
+    if (!was_masked)
+    {
+      __sd_nvic_irq_enable();
+    }
+  }
+
+  return NRF_SUCCESS;
+}
+
+#endif // #ifdef SUPPRESS_INLINE_IMPLEMENTATION
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // NRF_NVIC_H__
+
+/**@} */
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers_replacement/test.rb nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers_replacement/test.rb
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/headers_replacement/test.rb  1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/headers_replacement/test.rb   2018-04-24 08:48:29.118157300 +0200
@@ -0,0 +1,2 @@
+a = 'xxx const * const*'
+puts a.gsub('const','')
\ No newline at end of file
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/hex/s132_nrf52_3.0.0_licence-agreement.txt nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/hex/s132_nrf52_3.0.0_licence-agreement.txt
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/hex/s132_nrf52_3.0.0_licence-agreement.txt   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/hex/s132_nrf52_3.0.0_licence-agreement.txt    2018-04-24 08:48:29.128157500 +0200
@@ -0,0 +1,96 @@
+S110/S120/S130/S132 license agreement 
+
+
+NORDIC SEMICONDUCTOR ASA SOFTDEVICE LICENSE AGREEMENT 
+
+License Agreement for the Nordic Semiconductor ASA ("Nordic") S110, S120, S130 and S132 Bluetooth SoftDevice software packages 
+("SoftDevice"). 
+
+You ("You" "Licensee") must carefully and thoroughly read this License Agreement ("Agreement"), and accept to adhere to this Agreement before 
+downloading, installing and/or using any software or content in the SoftDevice provided herewith. 
+
+YOU ACCEPT THIS LICENSE AGREEMENT BY (A) CLICKING ACCEPT OR AGREE TO THIS LICENSE AGREEMENT, WHERE THIS 
+OPTION IS MADE AVAILABLE TO YOU; OR (B) BY ACTUALLY USING THE SOFTDEVICE, IN THIS CASE YOU AGREE THAT THE USE OF 
+THE SOFTDEVICE CONSTITUTES ACCEPTANCE OF THE LICENSING AGREEMENT FROM THAT POINT ONWARDS. 
+
+IF YOU DO NOT AGREE TO BE BOUND BY THE TERMS OF THIS AGREEMENT, THEN DO NOT DOWNLOAD, INSTALL/COMPLETE 
+INSTALLATION OF, OR IN ANY OTHER WAY MAKE USE OF THE SOFTDEVICE. 
+
+1. Grant of License 
+Subject to the terms in this Agreement Nordic grants Licensee a limited, non-exclusive, non-transferable, non-sub licensable, revocable license 
+("License"): (a) to use the SoftDevice solely in connection with a Nordic integrated circuit, and (b) to distribute the SoftDevice solely as integrated 
+in Licensee Product. Licensee shall not use the SoftDevice for any purpose other than specifically authorized herein. It is a material breach of this 
+agreement to use or modify the SoftDevice for use on any wireless connectivity integrated circuit other than a Nordic integrated circuit. 
+
+2. Title 
+Nordic retains full rights, title, and ownership to the SoftDevice and any and all patents, copyrights, trade secrets, trade names, trademarks, and 
+other intellectual property rights in and to the SoftDevice. 
+
+3. No Modifications or Reverse Engineering 
+Licensee shall not, modify, reverse engineer, disassemble, decompile or otherwise attempt to discover the source code of any non-source code 
+parts of the SoftDevice including, but not limited to pre-compiled hex files, binaries and object code. 
+
+4. Distribution Restrictions 
+Except as set forward in Section 1 above, the Licensee may not disclose or distribute any or all parts of the SoftDevice to any third party. 
+Licensee agrees to provide reasonable security precautions to prevent unauthorized access to or use of the SoftDevice as proscribed herein. 
+Licensee also agrees that use of and access to the SoftDevice will be strictly limited to the employees and subcontractors of the Licensee 
+necessary for the performance of development, verification and production tasks under this Agreement. The Licensee is responsible for making 
+such employees and subcontractors comply with the obligations concerning use and non-disclosure of the SoftDevice. 
+
+5. No Other Rights 
+Licensee shall use the SoftDevice only in compliance with this Agreement and shall refrain from using the SoftDevice in any way that may be 
+contrary to this Agreement. 
+
+6. Fees 
+Nordic grants the License to the Licensee free of charge provided that the Licensee undertakes the obligations in the Agreement and warrants to 
+comply with the Agreement. 
+
+7. DISCLAIMER OF WARRANTY 
+THE SOFTDEVICE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND EXPRESS OR IMPLIED AND NEITHER NORDIC, ITS 
+LICENSORS OR AFFILIATES NOR THE COPYRIGHT HOLDERS MAKE ANY REPRESENTATIONS OR WARRANTIES, EXPRESS OR 
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE OR 
+THAT THE SOFTDEVICE WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS. THERE 
+IS NO WARRANTY BY NORDIC OR BY ANY OTHER PARTY THAT THE FUNCTIONS CONTAINED IN THE SOFTDEVICE WILL MEET THE 
+REQUIREMENTS OF LICENSEE OR THAT THE OPERATION OF THE SOFTDEVICE WILL BE UNINTERRUPTED OR ERROR-FREE. 
+LICENSEE ASSUMES ALL RESPONSIBILITY AND RISK FOR THE SELECTION OF THE SOFTDEVICE TO ACHIEVE LICENSEE?S 
+INTENDED RESULTS AND FOR THE INSTALLATION, USE AND RESULTS OBTAINED FROM IT. 
+
+
+8. No Support 
+Nordic is not obligated to furnish or make available to Licensee any further information, software, technical information, know-how, show-how, 
+bug-fixes or support. Nordic reserves the right to make changes to the SoftDevice without further notice. 
+
+9. Limitation of Liability 
+In no event shall Nordic, its employees or suppliers, licensors or affiliates be liable for any lost profits, revenue, sales, data or costs of 
+procurement of substitute goods or services, property damage, personal injury, interruption of business, loss of business information or for any 
+special, direct, indirect, incidental, economic, punitive, special or consequential damages, however caused and whether arising under contract, 
+tort, negligence, or other theory of liability arising out of the use of or inability to use the SoftDevice, even if Nordic or its employees or suppliers, 
+licensors or affiliates are advised of the possibility of such damages. Because some countries/states/jurisdictions do not allow the exclusion or 
+limitation of liability, but may allow liability to be limited, in such cases, Nordic, its employees or licensors or affiliates? liability shall be limited to 
+USD 50. 
+
+10. Breach of Contract 
+Upon a breach of contract by the Licensee, Nordic and its licensor are entitled to damages in respect of any direct loss which can be reasonably 
+attributed to the breach by the Licensee. If the Licensee has acted with gross negligence or willful misconduct, the Licensee shall cover both 
+direct and indirect costs for Nordic and its licensors. 
+
+11. Indemnity 
+Licensee undertakes to indemnify, hold harmless and defend Nordic and its directors, officers, affiliates, shareholders, licensors, employees and 
+agents from and against any claims or lawsuits, including attorney's fees, that arise or result of the Licensee?s execution of the License and which 
+is not due to causes for which Nordic is responsible. 
+
+12. Governing Law 
+This Agreement shall be construed according to the laws of Norway, and hereby submits to the exclusive jurisdiction of the Oslo tingrett. 
+
+13. Assignment 
+Licensee shall not assign this Agreement or any rights or obligations hereunder without the prior written consent of Nordic. 
+
+14. Termination 
+Without prejudice to any other rights, Nordic may cancel this Agreement if Licensee does not abide by the terms and conditions of this 
+Agreement. Upon termination Licensee must promptly cease the use of the License and destroy all copies of the Licensed Technology and any 
+other material provided by Nordic or its affiliate, or produced by the Licensee in connection with the Agreement or the Licensed Technology. 
+
+15. Third party beneficiaries 
+Nordic?s licensors are intended third party beneficiaries under this Agreement. 
+
+
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/s132v3.packsc nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/s132v3.packsc
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/s132v3.packsc    1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/s132v3.packsc 2018-04-24 08:48:29.128157500 +0200
@@ -0,0 +1,411 @@
+{
+    "s132v3": {
+        "_attrs": [
+            "public"
+        ], 
+        "_class": "nRF_SoftDevice", 
+        "_defines": [
+            "S132"
+        ], 
+        "_description": "S132 softdevice", 
+        "_files": [
+            {
+                "_attrs": [
+                    "licenseAgreement"
+                ], 
+                "_value": "doc\\s132_nrf52_3.0.0_licence_agreement.txt"
+            }
+        ],
+        "_description": "S132 softdevice hex"
+    },
+    "s132v3": {
+        "_defines": [
+            "S132",
+            "NRF_SD_BLE_API_VERSION=3"
+        ],
+        "_headers": [
+            {
+                "_attrs": [
+                    "lock"
+                ],
+                "_value": "headers\\ble.h"
+            },
+            {
+                "_attrs": [
+                    "lock"
+                ], 
+                "_value": "headers\\ble_err.h"
+            },
+            {
+                "_attrs": [
+                    "lock"
+                ],
+                "_value": "headers\\ble_gatt.h"
+            },
+            {
+                "_attrs": [
+                    "lock"
+                ],
+                "_value": "headers\\ble_gatts.h"
+            },
+            {
+                "_attrs": [
+                    "lock"
+                ],
+                "_value": "headers\\ble_hci.h"
+            },
+            {
+                "_attrs": [
+                    "lock"
+                ],
+                "_value": "headers\\ble_l2cap.h"
+            },
+            {
+                "_attrs": [
+                    "lock"
+                ],
+                "_value": "headers\\ble_ranges.h"
+            }, 
+            {
+                "_attrs": [
+                    "lock"
+                ],
+                "_value": "headers\\ble_types.h"
+            },
+            {
+                "_attrs": [
+                    "lock"
+                ],
+                "_value": "headers\\nrf_error.h"
+            },
+            {
+                "_attrs": [
+                    "lock"
+                ],
+                "_value": "headers\\nrf_error_sdm.h"
+            },
+            {
+                "_attrs": [
+                    "lock"
+                ],
+                "_value": "headers\\nrf_error_soc.h"
+            },
+            {
+                "_attrs": [
+                    "lock"
+                ],
+                "_value": "headers\\nrf_sd_def.h"
+            },
+            {
+                "_attrs": [
+                    "lock"
+                ],
+                "_value": "headers\\nrf_sdm.h"
+            },
+            {
+                "_attrs": [
+                    "lock"
+                ],
+                "_value": "headers\\nrf_soc.h"
+            },
+            {
+                "_attrs": [
+                    "lock"
+                ],
+                "_value": "headers\\nrf_svc.h"
+            },
+            {
+                "_attrs": [
+                    "lock"
+                ],
+                "_value": "headers\\nrf52\\nrf_mbr.h"
+            }
+        ], 
+        "_linker": [
+            "nrf52832_xxaa"
+        ], 
+        "_links": [
+            "!s130", 
+            "!s132", 
+            "!s212", 
+            "!s332"
+        ], 
+        "_variants": [
+            {
+                "_value": "doc\\s132_nrf52_3.0.0_licence_agreement.txt",
+                "_attrs": [
+                    "public", 
+                    "softdevice"
+                ], 
+                "_includes": [
+                    "headers", 
+                    "headers\\nrf52"
+                ], 
+                "_headers": [
+                    {
+                        "_attrs": [
+                            "private"
+                        ],
+                        "_value": "headers\\ble_gap.h"
+                    },
+                    {
+                        "_attrs": [
+                            "private"
+                        ], 
+                        "_value": "headers\\nrf_nvic.h"
+                    },
+                    {
+                        "_attrs": [
+                            "private"
+                        ],
+                        "_value": "headers\\ble_gattc.h"
+                    
+                    }
+                ], 
+                "_links": [
+                    "sd_common", 
+                    "ble_common", 
+                    "ble_advdata", 
+                    "softdevice_present", 
+                    "ram_start"
+                ], 
+                "_memory": {
+                    "_ram": {
+                        "_align": [
+                            {
+                                "_size": "+0x19C0", 
+                                "_type": "left"
+                            }
+                        ]
+                    }, 
+                    "_rom": {
+                        "_align": [
+                            {
+                                "_size": "+0x1F000",
+                                "_type": "left"
+                            }
+                        ]
+                    }
+                }
+            }, 
+            {
+                "_attrs": [
+                    "public", 
+                    "softdevice"
+                ],
+                "_includes": [
+                    "headers", 
+                    "headers\\nrf52"
+                ], 
+                "_links": [
+                    "sd_common", 
+                    "softdevice_present"
+                ], 
+                "_memory": {
+                    "_ram": {
+                        "_align": [
+                            {
+                                "_size": "+0x19C0", 
+                                "_type": "left"
+                            }
+                        ]
+                    }, 
+                    "_rom": {
+                        "_align": [
+                            {
+                                "_size": "+0x1F000",
+                                "_type": "left"
+                            }
+                        ]
+                    }
+                }, 
+                "_name": "no_ble_lib"
+            }, 
+            {
+                "_attrs": [
+                    "public", 
+                    "softdevice"
+                ], 
+                "_includes": [
+                    "headers", 
+                    "headers\\nrf52"
+                ], 
+                "_headers": [
+                    {
+                        "_attrs": [
+                            "private"
+                        ],
+                        "_value": "headers\\ble_gap.h"
+                    },
+                    {
+                        "_attrs": [
+                            "private"
+                        ], 
+                        "_value": "headers\\nrf_nvic.h"
+                    },
+                    {
+                        "_attrs": [
+                            "private"
+                        ],
+                        "_value": "headers\\ble_gattc.h"
+                    
+                    }
+                ], 
+                "_links": [
+                    "softdevice_present"
+                ], 
+                "_memory": {
+                    "_ram": {
+                        "_align": [
+                            {
+                                "_size": "+0x19C0", 
+                                "_type": "left"
+                            }
+                        ]
+                    }, 
+                    "_rom": {
+                        "_align": [
+                            {
+                                "_size": "+0x1F000",
+                                "_type": "left"
+                            }
+                        ]
+                    }
+                }, 
+                "_name": "present_only"
+            }, 
+            {
+                "_attrs": [
+                    "private", 
+                    "softdevice"
+                ], 
+                "_defines": [
+                    "SVCALL_AS_NORMAL_FUNCTION", 
+                    "BLE_STACK_SUPPORT_REQD"
+                ], 
+                "_includes": [
+                    "cmock",
+                    "1|headers_replacement",
+                    "headers", 
+                    "headers\\nrf52"
+                ], 
+                "_files": [
+                    {
+                        "_value": "cmock\\mock_ble.c"
+                    },
+                    {
+                        "_attrs": [
+                            "_lint(-e18)"
+                        ],
+                        "_value": "cmock\\mock_ble_gap.c"
+                    },
+                    {
+                        "_value": "cmock\\mock_ble_gattc.c"
+                    },
+                    {
+                        "_value": "cmock\\mock_ble_gatts.c"
+                    },
+                    {
+                        "_value": "cmock\\mock_ble_l2cap.c"
+                    },
+                    {
+                        "_value": "cmock\\mock_nrf_nvic.c"
+                    },
+                    {
+                        "_value": "cmock\\mock_nrf_sd_def.c"
+                    },
+                    {
+                        "_value": "cmock\\mock_nrf_sdm.c"
+                    },
+                    {
+                        "_value": "cmock\\mock_nrf_soc.c"
+                    }
+                ], 
+                "_headers": [
+                    {
+                        "_attrs": [
+                            "_lint(-e18)"
+                        ],
+                        "_value": "headers_replacement\\ble_gap.h"
+                    },
+                    {
+                        "_attrs": [
+                            "private"
+                        ], 
+                        "_value": "headers_replacement\\nrf_nvic.h"
+                    },
+                    {
+                        "_attrs": [
+                            "private"
+                        ],
+                        "_value": "headers_replacement\\ble_gattc.h"
+                    
+                    }
+                ], 
+                "_name": "cmock"
+            }, 
+            {
+                "_attrs": [
+                    "public", 
+                    "softdevice"
+                ], 
+                "_defines": [
+                    "SVCALL_AS_NORMAL_FUNCTION"
+                ],
+                "_includes": [
+                    "headers", 
+                    "headers\\nrf52"
+                ], 
+                "_headers": [
+                    {
+                        "_attrs": [
+                            "private"
+                        ],
+                        "_value": "headers\\ble_gap.h"
+                    },
+                    {
+                        "_attrs": [
+                            "private"
+                        ], 
+                        "_value": "headers\\nrf_nvic.h"
+                    },
+                    {
+                        "_attrs": [
+                            "private"
+                        ],
+                        "_value": "headers\\ble_gattc.h"
+                    
+                    }
+                ], 
+                "_links": [
+                    "serapp_s132"
+                ], 
+                "_name": "serialized"
+            }
+        ]
+    }, 
+    "s132v3_hex": {
+        "_attrs": [
+            "public", 
+            "softdevice_hex"
+        ], 
+        "_class": "nRF_SoftDevice", 
+        "_description": "S132 softdevice hex", 
+        "_files": [
+            {
+                "_condition": "'keil5' in _toolchains", 
+                "_value": "hex/s132_nrf52_3.0.0_softdevice.hex"
+            }
+        ], 
+        "_replacements": [
+            {
+                "_condition": "'keilx' in _toolchains or 'armgcc' in _toolchains or 'ses' in _toolchains", 
+                "_value": "customHexPath:=hex"
+            }, 
+            {
+                "_condition": "'keilx' in _toolchains or 'armgcc' in _toolchains or 'ses' in _toolchains", 
+                "_value": "customHexName=s132_nrf52_3.0.0_softdevice.hex"
+            }
+        ]
+    }
+}
\ No newline at end of file
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/toolchain/armgcc/armgcc_s132v3_nrf52832_xxaa.ld nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/toolchain/armgcc/armgcc_s132v3_nrf52832_xxaa.ld
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/toolchain/armgcc/armgcc_s132v3_nrf52832_xxaa.ld  1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/toolchain/armgcc/armgcc_s132v3_nrf52832_xxaa.ld   2018-04-24 08:48:29.138157700 +0200
@@ -0,0 +1,33 @@
+/* Linker script to configure memory regions. */
+
+SEARCH_DIR(.)
+GROUP(-lgcc -lc -lnosys)
+
+MEMORY
+{
+  FLASH (rx) : ORIGIN = 0x1f000, LENGTH = 0x61000
+  RAM (rwx) :  ORIGIN = 0x200019c0, LENGTH = 0xe640
+}
+
+SECTIONS
+{
+}
+
+SECTIONS
+{
+  . = ALIGN(4);
+  .mem_section_dummy_ram :
+  {
+  }
+
+} INSERT AFTER .data;
+
+SECTIONS
+{
+  .mem_section_dummy_rom :
+  {
+  }
+
+} INSERT AFTER .text
+
+INCLUDE "nrf_common.ld"
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/toolchain/iar/iar_s132v3_nrf52832_xxaa.icf nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/toolchain/iar/iar_s132v3_nrf52832_xxaa.icf
--- nRF5_SDK_15.0.0_2e1b341_orig/components/softdevice/test/s132v3/toolchain/iar/iar_s132v3_nrf52832_xxaa.icf   1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/components/softdevice/test/s132v3/toolchain/iar/iar_s132v3_nrf52832_xxaa.icf    2018-04-24 08:48:29.138157700 +0200
@@ -0,0 +1,36 @@
+/*###ICF### Section handled by ICF editor, don't touch! ****/
+/*-Editor annotation file-*/
+/* IcfEditorFile="$TOOLKIT_DIR$\config\ide\IcfEditor\cortex_v1_0.xml" */
+/*-Specials-*/
+define symbol __ICFEDIT_intvec_start__ = 0x1f000;
+/*-Memory Regions-*/
+define symbol __ICFEDIT_region_ROM_start__   = 0x1f000;
+define symbol __ICFEDIT_region_ROM_end__     = 0x7ffff;
+define symbol __ICFEDIT_region_RAM_start__   = 0x200019c0;
+define symbol __ICFEDIT_region_RAM_end__     = 0x2000ffff;
+export symbol __ICFEDIT_region_RAM_start__;
+export symbol __ICFEDIT_region_RAM_end__;
+/*-Sizes-*/
+define symbol __ICFEDIT_size_cstack__   = ;
+define symbol __ICFEDIT_size_heap__     = ;
+/**** End of ICF editor section. ###ICF###*/
+
+define memory mem with size = 4G;
+define region ROM_region   = mem:[from __ICFEDIT_region_ROM_start__   to __ICFEDIT_region_ROM_end__];
+define region RAM_region   = mem:[from __ICFEDIT_region_RAM_start__   to __ICFEDIT_region_RAM_end__];
+
+define block CSTACK    with alignment = 8, size = __ICFEDIT_size_cstack__   { };
+define block HEAP      with alignment = 8, size = __ICFEDIT_size_heap__     { };
+define block RO_END    with alignment = 8, size = 0     { };
+
+initialize by copy { readwrite };
+do not initialize  { section .noinit };
+
+keep { section .intvec };
+place at address mem:__ICFEDIT_intvec_start__ { readonly section .intvec };
+place in ROM_region   { readonly,
+                        block RO_END };
+place in RAM_region   { readwrite,
+                        block CSTACK,
+                        block HEAP };
+
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/examples/connectivity/ble_connectivity/main.c nRF5_SDK_15.0.0_a53641a/examples/connectivity/ble_connectivity/main.c
--- nRF5_SDK_15.0.0_2e1b341_orig/examples/connectivity/ble_connectivity/main.c  2018-04-16 15:38:26.501311200 +0200
+++ nRF5_SDK_15.0.0_a53641a/examples/connectivity/ble_connectivity/main.c   2018-04-24 08:48:34.468296300 +0200
@@ -57,6 +57,7 @@
 #include "ser_conn_handlers.h"
 #include "boards.h"
 #include "nrf_drv_clock.h"
+#include "ser_config.h"
 
 #include "nrf_log.h"
 #include "nrf_log_ctrl.h"
@@ -64,6 +65,38 @@
 
 #include "ser_phy_debug_comm.h"
 
+#if defined ( __CC_ARM )
+typedef struct __attribute__((packed))
+{
+        uint32_t    magic_number;               /* Magic number to verify the presence of this structure in memory */
+        uint32_t    struct_version     : 8;     /* Version of this struct format */
+        uint32_t    rfu0               : 24;    /* Reserved for future use, shall be 0xFFFFFF */
+        uint32_t    revision_hash;              /* Unique revision identifier */
+        uint32_t    version_major      : 8;     /* Major version number */
+        uint32_t    version_minor      : 8;     /* Minor version number */
+        uint32_t    version_patch      : 8;     /* Patch version number */
+        uint32_t    rfu1               : 8;     /* Reserved for future use, shall be 0xFF */
+        uint32_t    sd_ble_api_version : 8;     /* SoftDevice BLE API version number */
+        uint32_t    transport_type     : 8;     /* Connectivity transport type, 1 = UART HCI */
+        uint32_t    rfu2               : 16;    /* Reserved for future use, shall be 0xFFFF */
+        uint32_t    baud_rate;                  /* UART transport baud rate */
+} version_info_t;
+static const version_info_t version_info __attribute__((at(0x30000))) = {
+    .magic_number       = 0x46D8A517,
+    .struct_version     = 2,
+    .rfu0               = 0xFFFFFF,
+    .revision_hash      = 0,
+    .version_major      = 2,
+    .version_minor      = 0,
+    .version_patch      = 1,
+    .rfu1               = 0xFF,
+    .sd_ble_api_version = NRF_SD_BLE_API_VERSION,
+    .transport_type     = 1,
+    .rfu2               = 0xFFFF,
+    .baud_rate          = SER_PHY_UART_BAUDRATE_VAL,
+};
+#endif
+
 #if defined(APP_USBD_ENABLED) && APP_USBD_ENABLED
 #include "app_usbd_serial_num.h"
 #ifdef BOARD_PCA10059
@@ -140,12 +173,6 @@
 
 static void on_idle(void)
 {
-    if (!NRF_LOG_PROCESS())
-    {
-        /* Sleep waiting for an application event. */
-        uint32_t err_code = sd_app_evt_wait();
-        APP_ERROR_CHECK(err_code);
-    }
 
 #if defined(APP_USBD_ENABLED) && APP_USBD_ENABLED
     while (app_usbd_event_queue_process())
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/examples/connectivity/ble_connectivity/pca10040/ser_s132_hci/config/sdk_config.h nRF5_SDK_15.0.0_a53641a/examples/connectivity/ble_connectivity/pca10040/ser_s132_hci/config/sdk_config.h
--- nRF5_SDK_15.0.0_2e1b341_orig/examples/connectivity/ble_connectivity/pca10040/ser_s132_hci/config/sdk_config.h   2018-04-16 15:38:26.756336700 +0200
+++ nRF5_SDK_15.0.0_a53641a/examples/connectivity/ble_connectivity/pca10040/ser_s132_hci/config/sdk_config.h    2018-04-24 08:48:34.478296500 +0200
@@ -48,6 +48,8 @@
 #endif
 // <h> nRF_BLE 
 
+#define NRF_SDH_BLE_GATT_MAX_MTU_SIZE 250
+
 //==========================================================
 // <q> BLE_DTM_ENABLED  - ble_dtm - Module for testing RF/PHY using DTM commands
  
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/examples/connectivity/ble_connectivity/pca10056/ser_s140_hci/config/sdk_config.h nRF5_SDK_15.0.0_a53641a/examples/connectivity/ble_connectivity/pca10056/ser_s140_hci/config/sdk_config.h
--- nRF5_SDK_15.0.0_2e1b341_orig/examples/connectivity/ble_connectivity/pca10056/ser_s140_hci/config/sdk_config.h   2018-04-16 15:38:28.964557500 +0200
+++ nRF5_SDK_15.0.0_a53641a/examples/connectivity/ble_connectivity/pca10056/ser_s140_hci/config/sdk_config.h    2018-04-24 08:48:34.559300600 +0200
@@ -48,6 +48,8 @@
 #endif
 // <h> nRF_BLE 
 
+#define NRF_SDH_BLE_GATT_MAX_MTU_SIZE 250
+
 //==========================================================
 // <q> BLE_DTM_ENABLED  - ble_dtm - Module for testing RF/PHY using DTM commands
  
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/examples/connectivity/ble_connectivity/pca10059/ser_s132v3_usb_hci/config/sdk_config.h nRF5_SDK_15.0.0_a53641a/examples/connectivity/ble_connectivity/pca10059/ser_s132v3_usb_hci/config/sdk_config.h
--- nRF5_SDK_15.0.0_2e1b341_orig/examples/connectivity/ble_connectivity/pca10059/ser_s132v3_usb_hci/config/sdk_config.h 2018-04-16 15:38:30.322693300 +0200
+++ nRF5_SDK_15.0.0_a53641a/examples/connectivity/ble_connectivity/pca10059/ser_s132v3_usb_hci/config/sdk_config.h  2018-04-24 08:48:34.756308300 +0200
@@ -133,7 +133,7 @@
 // <i> gaps. Tailor this value to adhere to this limitation.
 
 #ifndef NRF_DFU_TRIGGER_USB_INTERFACE_NUM
-#define NRF_DFU_TRIGGER_USB_INTERFACE_NUM 2
+#define NRF_DFU_TRIGGER_USB_INTERFACE_NUM 0
 #endif
 
 // </h> 
@@ -144,6 +144,8 @@
 
 // <h> nRF_BLE 
 
+#define NRF_SDH_BLE_GATT_MAX_MTU_SIZE 250
+
 //==========================================================
 // <q> BLE_DTM_ENABLED  - ble_dtm - Module for testing RF/PHY using DTM commands
  
@@ -975,7 +977,7 @@
 
 // <i> Selected Product ID
 #ifndef APP_USBD_PID
-#define APP_USBD_PID 0x521B
+#define APP_USBD_PID 0xC00A
 #endif
 
 // <o> APP_USBD_DEVICE_VER_MAJOR - Device version, major part  <0-99> 
@@ -4536,5 +4538,3 @@
 //==========================================================
 
 // <<< end of configuration section >>>
-#endif //SDK_CONFIG_H
-
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/examples/connectivity/ble_connectivity/pca10059/ser_s140_usb_hci/config/sdk_config.h nRF5_SDK_15.0.0_a53641a/examples/connectivity/ble_connectivity/pca10059/ser_s140_usb_hci/config/sdk_config.h
--- nRF5_SDK_15.0.0_2e1b341_orig/examples/connectivity/ble_connectivity/pca10059/ser_s140_usb_hci/config/sdk_config.h   2018-04-16 15:38:30.594720500 +0200
+++ nRF5_SDK_15.0.0_a53641a/examples/connectivity/ble_connectivity/pca10059/ser_s140_usb_hci/config/sdk_config.h    2018-04-24 08:48:34.806309300 +0200
@@ -133,7 +133,7 @@
 // <i> gaps. Tailor this value to adhere to this limitation.
 
 #ifndef NRF_DFU_TRIGGER_USB_INTERFACE_NUM
-#define NRF_DFU_TRIGGER_USB_INTERFACE_NUM 2
+#define NRF_DFU_TRIGGER_USB_INTERFACE_NUM 0
 #endif
 
 // </h> 
@@ -144,6 +144,8 @@
 
 // <h> nRF_BLE 
 
+#define NRF_SDH_BLE_GATT_MAX_MTU_SIZE 250
+
 //==========================================================
 // <q> BLE_DTM_ENABLED  - ble_dtm - Module for testing RF/PHY using DTM commands
  
@@ -975,7 +977,7 @@
 
 // <i> Selected Product ID
 #ifndef APP_USBD_PID
-#define APP_USBD_PID 0x521B
+#define APP_USBD_PID 0xC00A
 #endif
 
 // <o> APP_USBD_DEVICE_VER_MAJOR - Device version, major part  <0-99> 
diff -r -u -w --new-file -x '*.hex' nRF5_SDK_15.0.0_2e1b341_orig/examples/connectivity/ble_connectivity/pca10059/ser_s140_usb_hci/config/sdk_config.h.orig nRF5_SDK_15.0.0_a53641a/examples/connectivity/ble_connectivity/pca10059/ser_s140_usb_hci/config/sdk_config.h.orig
--- nRF5_SDK_15.0.0_2e1b341_orig/examples/connectivity/ble_connectivity/pca10059/ser_s140_usb_hci/config/sdk_config.h.orig  1970-01-01 01:00:00.000000000 +0100
+++ nRF5_SDK_15.0.0_a53641a/examples/connectivity/ble_connectivity/pca10059/ser_s140_usb_hci/config/sdk_config.h.orig   2018-04-24 08:48:34.816309500 +0200
@@ -0,0 +1,4540 @@
+/**
+ * Copyright (c) 2017 - 2018, Nordic Semiconductor ASA
+ * 
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ * 
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ * 
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ * 
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ */
+
+
+
+#ifndef SDK_CONFIG_H
+#define SDK_CONFIG_H
+// <<< Use Configuration Wizard in Context Menu >>>\n
+#ifdef USE_APP_CONFIG
+#include "app_config.h"
+#endif
+// <h> Application 
+
+//==========================================================
+// <h> application_info - Software Component
+
+//==========================================================
+// <s> APP_NAME - Application name
+#ifndef APP_NAME
+#define APP_NAME "ble-connectivity"
+#endif
+
+// <o> APP_ID - Application ID 
+#ifndef APP_ID
+#define APP_ID 0
+#endif
+
+// <h> APP_VERSION - Application version (semantic versioning)
+
+//==========================================================
+// <o> APP_VERSION_MAJOR - Major version  <0-1000> 
+
+
+#ifndef APP_VERSION_MAJOR
+#define APP_VERSION_MAJOR 0
+#endif
+
+// <o> APP_VERSION_MINOR - Minor version  <0-1000> 
+
+
+#ifndef APP_VERSION_MINOR
+#define APP_VERSION_MINOR 1
+#endif
+
+// <o> APP_VERSION_PATCH - Patch version  <0-1000> 
+
+
+#ifndef APP_VERSION_PATCH
+#define APP_VERSION_PATCH 0
+#endif
+
+// <s> APP_VERSION_PRERELEASE - Prerelease, eg. "-1.alpha"
+
+// <i> If not empty, this string should include the leading hyphen (-).
+// <i> This string might be normalized at run-time to not contain characters
+// <i> illegal in Semantic Versioning.
+#ifndef APP_VERSION_PRERELEASE
+#define APP_VERSION_PRERELEASE ""
+#endif
+
+// <s> APP_VERSION_METADATA - Metadata, e.g. "+some-string.01-01-2018-23-59-59"
+
+// <i> If not empty, this string should include the leading plus (+).
+// <i> This string might be normalized at run-time to not contain characters
+// <i> illegal in Semantic Versioning.
+#ifndef APP_VERSION_METADATA
+#define APP_VERSION_METADATA "+" __DATE__ " " __TIME__
+#endif
+
+// </h> 
+//==========================================================
+
+// </h> 
+//==========================================================
+
+// </h> 
+//==========================================================
+
+// <h> Board Definition 
+
+//==========================================================
+// <h> nrf_dfu_trigger_usb - USB DFU Trigger library
+
+//==========================================================
+// <q> NRF_DFU_TRIGGER_USB_USB_SHARED  - Flag indicating whether USB is used for other purposes in the application.
+ 
+
+#ifndef NRF_DFU_TRIGGER_USB_USB_SHARED
+#define NRF_DFU_TRIGGER_USB_USB_SHARED 1
+#endif
+
+// <o> NRF_DFU_TRIGGER_USB_INTERFACE_NUM - The USB interface to use for the DFU Trigger library.  <0-255> 
+
+
+// <i> According to the USB Specification, interface numbers cannot have
+// <i> gaps. Tailor this value to adhere to this limitation.
+
+#ifndef NRF_DFU_TRIGGER_USB_INTERFACE_NUM
+#define NRF_DFU_TRIGGER_USB_INTERFACE_NUM 2
+#endif
+
+// </h> 
+//==========================================================
+
+// </h> 
+//==========================================================
+
+// <h> nRF_BLE 
+
+//==========================================================
+// <q> BLE_DTM_ENABLED  - ble_dtm - Module for testing RF/PHY using DTM commands
+ 
+
+#ifndef BLE_DTM_ENABLED
+#define BLE_DTM_ENABLED 1
+#endif
+
+// </h> 
+//==========================================================
+
+// <h> nRF_Drivers 
+
+//==========================================================
+// <e> CLOCK_ENABLED - nrf_drv_clock - CLOCK peripheral driver - legacy layer
+//==========================================================
+#ifndef CLOCK_ENABLED
+#define CLOCK_ENABLED 1
+#endif
+// <o> CLOCK_CONFIG_LF_SRC  - LF Clock Source
+ 
+// <0=> RC 
+// <1=> XTAL 
+// <2=> Synth 
+
+#ifndef CLOCK_CONFIG_LF_SRC
+#define CLOCK_CONFIG_LF_SRC 1
+#endif
+
+// <o> CLOCK_CONFIG_IRQ_PRIORITY  - Interrupt priority
+ 
+
+// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
+// <0=> 0 (highest) 
+// <1=> 1 
+// <2=> 2 
+// <3=> 3 
+// <4=> 4 
+// <5=> 5 
+// <6=> 6 
+// <7=> 7 
+
+#ifndef CLOCK_CONFIG_IRQ_PRIORITY
+#define CLOCK_CONFIG_IRQ_PRIORITY 7
+#endif
+
+// </e>
+
+// <e> NRFX_CLOCK_ENABLED - nrfx_clock - CLOCK peripheral driver
+//==========================================================
+#ifndef NRFX_CLOCK_ENABLED
+#define NRFX_CLOCK_ENABLED 1
+#endif
+// <o> NRFX_CLOCK_CONFIG_LF_SRC  - LF Clock Source
+ 
+// <0=> RC 
+// <1=> XTAL 
+// <2=> Synth 
+
+#ifndef NRFX_CLOCK_CONFIG_LF_SRC
+#define NRFX_CLOCK_CONFIG_LF_SRC 1
+#endif
+
+// <o> NRFX_CLOCK_CONFIG_IRQ_PRIORITY  - Interrupt priority
+ 
+// <0=> 0 (highest) 
+// <1=> 1 
+// <2=> 2 
+// <3=> 3 
+// <4=> 4 
+// <5=> 5 
+// <6=> 6 
+// <7=> 7 
+
+#ifndef NRFX_CLOCK_CONFIG_IRQ_PRIORITY
+#define NRFX_CLOCK_CONFIG_IRQ_PRIORITY 7
+#endif
+
+// <e> NRFX_CLOCK_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRFX_CLOCK_CONFIG_LOG_ENABLED
+#define NRFX_CLOCK_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRFX_CLOCK_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRFX_CLOCK_CONFIG_LOG_LEVEL
+#define NRFX_CLOCK_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRFX_CLOCK_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRFX_CLOCK_CONFIG_INFO_COLOR
+#define NRFX_CLOCK_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRFX_CLOCK_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRFX_CLOCK_CONFIG_DEBUG_COLOR
+#define NRFX_CLOCK_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// </e>
+
+// <e> NRFX_POWER_ENABLED - nrfx_power - POWER peripheral driver
+//==========================================================
+#ifndef NRFX_POWER_ENABLED
+#define NRFX_POWER_ENABLED 1
+#endif
+// <o> NRFX_POWER_CONFIG_IRQ_PRIORITY  - Interrupt priority
+ 
+// <0=> 0 (highest) 
+// <1=> 1 
+// <2=> 2 
+// <3=> 3 
+// <4=> 4 
+// <5=> 5 
+// <6=> 6 
+// <7=> 7 
+
+#ifndef NRFX_POWER_CONFIG_IRQ_PRIORITY
+#define NRFX_POWER_CONFIG_IRQ_PRIORITY 7
+#endif
+
+// <q> NRFX_POWER_CONFIG_DEFAULT_DCDCEN  - The default configuration of main DCDC regulator
+ 
+
+// <i> This settings means only that components for DCDC regulator are installed and it can be enabled.
+
+#ifndef NRFX_POWER_CONFIG_DEFAULT_DCDCEN
+#define NRFX_POWER_CONFIG_DEFAULT_DCDCEN 0
+#endif
+
+// <q> NRFX_POWER_CONFIG_DEFAULT_DCDCENHV  - The default configuration of High Voltage DCDC regulator
+ 
+
+// <i> This settings means only that components for DCDC regulator are installed and it can be enabled.
+
+#ifndef NRFX_POWER_CONFIG_DEFAULT_DCDCENHV
+#define NRFX_POWER_CONFIG_DEFAULT_DCDCENHV 0
+#endif
+
+// </e>
+
+// <e> NRFX_PRS_ENABLED - nrfx_prs - Peripheral Resource Sharing module
+//==========================================================
+#ifndef NRFX_PRS_ENABLED
+#define NRFX_PRS_ENABLED 1
+#endif
+// <q> NRFX_PRS_BOX_0_ENABLED  - Enables box 0 in the module.
+ 
+
+#ifndef NRFX_PRS_BOX_0_ENABLED
+#define NRFX_PRS_BOX_0_ENABLED 0
+#endif
+
+// <q> NRFX_PRS_BOX_1_ENABLED  - Enables box 1 in the module.
+ 
+
+#ifndef NRFX_PRS_BOX_1_ENABLED
+#define NRFX_PRS_BOX_1_ENABLED 0
+#endif
+
+// <q> NRFX_PRS_BOX_2_ENABLED  - Enables box 2 in the module.
+ 
+
+#ifndef NRFX_PRS_BOX_2_ENABLED
+#define NRFX_PRS_BOX_2_ENABLED 0
+#endif
+
+// <q> NRFX_PRS_BOX_3_ENABLED  - Enables box 3 in the module.
+ 
+
+#ifndef NRFX_PRS_BOX_3_ENABLED
+#define NRFX_PRS_BOX_3_ENABLED 0
+#endif
+
+// <q> NRFX_PRS_BOX_4_ENABLED  - Enables box 4 in the module.
+ 
+
+#ifndef NRFX_PRS_BOX_4_ENABLED
+#define NRFX_PRS_BOX_4_ENABLED 1
+#endif
+
+// <e> NRFX_PRS_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRFX_PRS_CONFIG_LOG_ENABLED
+#define NRFX_PRS_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRFX_PRS_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRFX_PRS_CONFIG_LOG_LEVEL
+#define NRFX_PRS_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRFX_PRS_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRFX_PRS_CONFIG_INFO_COLOR
+#define NRFX_PRS_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRFX_PRS_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRFX_PRS_CONFIG_DEBUG_COLOR
+#define NRFX_PRS_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// </e>
+
+// <e> NRFX_UARTE_ENABLED - nrfx_uarte - UARTE peripheral driver
+//==========================================================
+#ifndef NRFX_UARTE_ENABLED
+#define NRFX_UARTE_ENABLED 1
+#endif
+// <o> NRFX_UARTE0_ENABLED - Enable UARTE0 instance 
+#ifndef NRFX_UARTE0_ENABLED
+#define NRFX_UARTE0_ENABLED 0
+#endif
+
+// <o> NRFX_UARTE1_ENABLED - Enable UARTE1 instance 
+#ifndef NRFX_UARTE1_ENABLED
+#define NRFX_UARTE1_ENABLED 0
+#endif
+
+// <o> NRFX_UARTE_DEFAULT_CONFIG_HWFC  - Hardware Flow Control
+ 
+// <0=> Disabled 
+// <1=> Enabled 
+
+#ifndef NRFX_UARTE_DEFAULT_CONFIG_HWFC
+#define NRFX_UARTE_DEFAULT_CONFIG_HWFC 0
+#endif
+
+// <o> NRFX_UARTE_DEFAULT_CONFIG_PARITY  - Parity
+ 
+// <0=> Excluded 
+// <14=> Included 
+
+#ifndef NRFX_UARTE_DEFAULT_CONFIG_PARITY
+#define NRFX_UARTE_DEFAULT_CONFIG_PARITY 0
+#endif
+
+// <o> NRFX_UARTE_DEFAULT_CONFIG_BAUDRATE  - Default Baudrate
+ 
+// <323584=> 1200 baud 
+// <643072=> 2400 baud 
+// <1290240=> 4800 baud 
+// <2576384=> 9600 baud 
+// <3862528=> 14400 baud 
+// <5152768=> 19200 baud 
+// <7716864=> 28800 baud 
+// <8388608=> 31250 baud 
+// <10289152=> 38400 baud 
+// <15007744=> 56000 baud 
+// <15400960=> 57600 baud 
+// <20615168=> 76800 baud 
+// <30801920=> 115200 baud 
+// <61865984=> 230400 baud 
+// <67108864=> 250000 baud 
+// <121634816=> 460800 baud 
+// <251658240=> 921600 baud 
+// <268435456=> 1000000 baud 
+
+#ifndef NRFX_UARTE_DEFAULT_CONFIG_BAUDRATE
+#define NRFX_UARTE_DEFAULT_CONFIG_BAUDRATE 30801920
+#endif
+
+// <o> NRFX_UARTE_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
+ 
+// <0=> 0 (highest) 
+// <1=> 1 
+// <2=> 2 
+// <3=> 3 
+// <4=> 4 
+// <5=> 5 
+// <6=> 6 
+// <7=> 7 
+
+#ifndef NRFX_UARTE_DEFAULT_CONFIG_IRQ_PRIORITY
+#define NRFX_UARTE_DEFAULT_CONFIG_IRQ_PRIORITY 7
+#endif
+
+// <e> NRFX_UARTE_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRFX_UARTE_CONFIG_LOG_ENABLED
+#define NRFX_UARTE_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRFX_UARTE_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRFX_UARTE_CONFIG_LOG_LEVEL
+#define NRFX_UARTE_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRFX_UARTE_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRFX_UARTE_CONFIG_INFO_COLOR
+#define NRFX_UARTE_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRFX_UARTE_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRFX_UARTE_CONFIG_DEBUG_COLOR
+#define NRFX_UARTE_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// </e>
+
+// <e> NRFX_UART_ENABLED - nrfx_uart - UART peripheral driver
+//==========================================================
+#ifndef NRFX_UART_ENABLED
+#define NRFX_UART_ENABLED 1
+#endif
+// <o> NRFX_UART0_ENABLED - Enable UART0 instance 
+#ifndef NRFX_UART0_ENABLED
+#define NRFX_UART0_ENABLED 0
+#endif
+
+// <o> NRFX_UART_DEFAULT_CONFIG_HWFC  - Hardware Flow Control
+ 
+// <0=> Disabled 
+// <1=> Enabled 
+
+#ifndef NRFX_UART_DEFAULT_CONFIG_HWFC
+#define NRFX_UART_DEFAULT_CONFIG_HWFC 0
+#endif
+
+// <o> NRFX_UART_DEFAULT_CONFIG_PARITY  - Parity
+ 
+// <0=> Excluded 
+// <14=> Included 
+
+#ifndef NRFX_UART_DEFAULT_CONFIG_PARITY
+#define NRFX_UART_DEFAULT_CONFIG_PARITY 0
+#endif
+
+// <o> NRFX_UART_DEFAULT_CONFIG_BAUDRATE  - Default Baudrate
+ 
+// <323584=> 1200 baud 
+// <643072=> 2400 baud 
+// <1290240=> 4800 baud 
+// <2576384=> 9600 baud 
+// <3866624=> 14400 baud 
+// <5152768=> 19200 baud 
+// <7729152=> 28800 baud 
+// <8388608=> 31250 baud 
+// <10309632=> 38400 baud 
+// <15007744=> 56000 baud 
+// <15462400=> 57600 baud 
+// <20615168=> 76800 baud 
+// <30924800=> 115200 baud 
+// <61845504=> 230400 baud 
+// <67108864=> 250000 baud 
+// <123695104=> 460800 baud 
+// <247386112=> 921600 baud 
+// <268435456=> 1000000 baud 
+
+#ifndef NRFX_UART_DEFAULT_CONFIG_BAUDRATE
+#define NRFX_UART_DEFAULT_CONFIG_BAUDRATE 30924800
+#endif
+
+// <o> NRFX_UART_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
+ 
+// <0=> 0 (highest) 
+// <1=> 1 
+// <2=> 2 
+// <3=> 3 
+// <4=> 4 
+// <5=> 5 
+// <6=> 6 
+// <7=> 7 
+
+#ifndef NRFX_UART_DEFAULT_CONFIG_IRQ_PRIORITY
+#define NRFX_UART_DEFAULT_CONFIG_IRQ_PRIORITY 7
+#endif
+
+// <e> NRFX_UART_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRFX_UART_CONFIG_LOG_ENABLED
+#define NRFX_UART_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRFX_UART_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRFX_UART_CONFIG_LOG_LEVEL
+#define NRFX_UART_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRFX_UART_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRFX_UART_CONFIG_INFO_COLOR
+#define NRFX_UART_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRFX_UART_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRFX_UART_CONFIG_DEBUG_COLOR
+#define NRFX_UART_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// </e>
+
+// <e> POWER_ENABLED - nrf_drv_power - POWER peripheral driver - legacy layer
+//==========================================================
+#ifndef POWER_ENABLED
+#define POWER_ENABLED 1
+#endif
+// <o> POWER_CONFIG_IRQ_PRIORITY  - Interrupt priority
+ 
+
+// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
+// <0=> 0 (highest) 
+// <1=> 1 
+// <2=> 2 
+// <3=> 3 
+// <4=> 4 
+// <5=> 5 
+// <6=> 6 
+// <7=> 7 
+
+#ifndef POWER_CONFIG_IRQ_PRIORITY
+#define POWER_CONFIG_IRQ_PRIORITY 7
+#endif
+
+// <q> POWER_CONFIG_DEFAULT_DCDCEN  - The default configuration of main DCDC regulator
+ 
+
+// <i> This settings means only that components for DCDC regulator are installed and it can be enabled.
+
+#ifndef POWER_CONFIG_DEFAULT_DCDCEN
+#define POWER_CONFIG_DEFAULT_DCDCEN 0
+#endif
+
+// <q> POWER_CONFIG_DEFAULT_DCDCENHV  - The default configuration of High Voltage DCDC regulator
+ 
+
+// <i> This settings means only that components for DCDC regulator are installed and it can be enabled.
+
+#ifndef POWER_CONFIG_DEFAULT_DCDCENHV
+#define POWER_CONFIG_DEFAULT_DCDCENHV 0
+#endif
+
+// </e>
+
+// <e> UART_ENABLED - nrf_drv_uart - UART/UARTE peripheral driver - legacy layer
+//==========================================================
+#ifndef UART_ENABLED
+#define UART_ENABLED 1
+#endif
+// <o> UART_DEFAULT_CONFIG_HWFC  - Hardware Flow Control
+ 
+// <0=> Disabled 
+// <1=> Enabled 
+
+#ifndef UART_DEFAULT_CONFIG_HWFC
+#define UART_DEFAULT_CONFIG_HWFC 0
+#endif
+
+// <o> UART_DEFAULT_CONFIG_PARITY  - Parity
+ 
+// <0=> Excluded 
+// <14=> Included 
+
+#ifndef UART_DEFAULT_CONFIG_PARITY
+#define UART_DEFAULT_CONFIG_PARITY 0
+#endif
+
+// <o> UART_DEFAULT_CONFIG_BAUDRATE  - Default Baudrate
+ 
+// <323584=> 1200 baud 
+// <643072=> 2400 baud 
+// <1290240=> 4800 baud 
+// <2576384=> 9600 baud 
+// <3862528=> 14400 baud 
+// <5152768=> 19200 baud 
+// <7716864=> 28800 baud 
+// <10289152=> 38400 baud 
+// <15400960=> 57600 baud 
+// <20615168=> 76800 baud 
+// <30801920=> 115200 baud 
+// <61865984=> 230400 baud 
+// <67108864=> 250000 baud 
+// <121634816=> 460800 baud 
+// <251658240=> 921600 baud 
+// <268435456=> 1000000 baud 
+
+#ifndef UART_DEFAULT_CONFIG_BAUDRATE
+#define UART_DEFAULT_CONFIG_BAUDRATE 30801920
+#endif
+
+// <o> UART_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
+ 
+
+// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
+// <0=> 0 (highest) 
+// <1=> 1 
+// <2=> 2 
+// <3=> 3 
+// <4=> 4 
+// <5=> 5 
+// <6=> 6 
+// <7=> 7 
+
+#ifndef UART_DEFAULT_CONFIG_IRQ_PRIORITY
+#define UART_DEFAULT_CONFIG_IRQ_PRIORITY 7
+#endif
+
+// <q> UART_EASY_DMA_SUPPORT  - Driver supporting EasyDMA
+ 
+
+#ifndef UART_EASY_DMA_SUPPORT
+#define UART_EASY_DMA_SUPPORT 1
+#endif
+
+// <q> UART_LEGACY_SUPPORT  - Driver supporting Legacy mode
+ 
+
+#ifndef UART_LEGACY_SUPPORT
+#define UART_LEGACY_SUPPORT 1
+#endif
+
+// <e> UART0_ENABLED - Enable UART0 instance
+//==========================================================
+#ifndef UART0_ENABLED
+#define UART0_ENABLED 1
+#endif
+// <q> UART0_CONFIG_USE_EASY_DMA  - Default setting for using EasyDMA
+ 
+
+#ifndef UART0_CONFIG_USE_EASY_DMA
+#define UART0_CONFIG_USE_EASY_DMA 1
+#endif
+
+// </e>
+
+// <e> UART1_ENABLED - Enable UART1 instance
+//==========================================================
+#ifndef UART1_ENABLED
+#define UART1_ENABLED 0
+#endif
+// </e>
+
+// </e>
+
+// <e> USBD_ENABLED - nrf_drv_usbd - USB driver
+//==========================================================
+#ifndef USBD_ENABLED
+#define USBD_ENABLED 1
+#endif
+// <o> USBD_CONFIG_IRQ_PRIORITY  - Interrupt priority
+ 
+
+// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
+// <0=> 0 (highest) 
+// <1=> 1 
+// <2=> 2 
+// <3=> 3 
+// <4=> 4 
+// <5=> 5 
+// <6=> 6 
+// <7=> 7 
+
+#ifndef USBD_CONFIG_IRQ_PRIORITY
+#define USBD_CONFIG_IRQ_PRIORITY 7
+#endif
+
+// <o> USBD_CONFIG_DMASCHEDULER_MODE  - USBD SMA scheduler working scheme
+ 
+// <0=> Prioritized access 
+// <1=> Round Robin 
+
+#ifndef USBD_CONFIG_DMASCHEDULER_MODE
+#define USBD_CONFIG_DMASCHEDULER_MODE 0
+#endif
+
+// </e>
+
+// </h> 
+//==========================================================
+
+// <h> nRF_Libraries 
+
+//==========================================================
+// <e> APP_SCHEDULER_ENABLED - app_scheduler - Events scheduler
+//==========================================================
+#ifndef APP_SCHEDULER_ENABLED
+#define APP_SCHEDULER_ENABLED 1
+#endif
+// <q> APP_SCHEDULER_WITH_PAUSE  - Enabling pause feature
+ 
+
+#ifndef APP_SCHEDULER_WITH_PAUSE
+#define APP_SCHEDULER_WITH_PAUSE 1
+#endif
+
+// <q> APP_SCHEDULER_WITH_PROFILER  - Enabling scheduler profiling
+ 
+
+#ifndef APP_SCHEDULER_WITH_PROFILER
+#define APP_SCHEDULER_WITH_PROFILER 1
+#endif
+
+// </e>
+
+// <e> APP_TIMER_ENABLED - app_timer - Application timer functionality
+//==========================================================
+#ifndef APP_TIMER_ENABLED
+#define APP_TIMER_ENABLED 1
+#endif
+// <o> APP_TIMER_CONFIG_RTC_FREQUENCY  - Configure RTC prescaler.
+ 
+// <0=> 32768 Hz 
+// <1=> 16384 Hz 
+// <3=> 8192 Hz 
+// <7=> 4096 Hz 
+// <15=> 2048 Hz 
+// <31=> 1024 Hz 
+
+#ifndef APP_TIMER_CONFIG_RTC_FREQUENCY
+#define APP_TIMER_CONFIG_RTC_FREQUENCY 0
+#endif
+
+// <o> APP_TIMER_CONFIG_IRQ_PRIORITY  - Interrupt priority
+ 
+
+// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
+// <0=> 0 (highest) 
+// <1=> 1 
+// <2=> 2 
+// <3=> 3 
+// <4=> 4 
+// <5=> 5 
+// <6=> 6 
+// <7=> 7 
+
+#ifndef APP_TIMER_CONFIG_IRQ_PRIORITY
+#define APP_TIMER_CONFIG_IRQ_PRIORITY 7
+#endif
+
+// <o> APP_TIMER_CONFIG_OP_QUEUE_SIZE - Capacity of timer requests queue. 
+// <i> Size of the queue depends on how many timers are used
+// <i> in the system, how often timers are started and overall
+// <i> system latency. If queue size is too small app_timer calls
+// <i> will fail.
+
+#ifndef APP_TIMER_CONFIG_OP_QUEUE_SIZE
+#define APP_TIMER_CONFIG_OP_QUEUE_SIZE 10
+#endif
+
+// <q> APP_TIMER_CONFIG_USE_SCHEDULER  - Enable scheduling app_timer events to app_scheduler
+ 
+
+#ifndef APP_TIMER_CONFIG_USE_SCHEDULER
+#define APP_TIMER_CONFIG_USE_SCHEDULER 0
+#endif
+
+// <q> APP_TIMER_KEEPS_RTC_ACTIVE  - Enable RTC always on
+ 
+
+// <i> If option is enabled RTC is kept running even if there is no active timers.
+// <i> This option can be used when app_timer is used for timestamping.
+
+#ifndef APP_TIMER_KEEPS_RTC_ACTIVE
+#define APP_TIMER_KEEPS_RTC_ACTIVE 0
+#endif
+
+// <o> APP_TIMER_SAFE_WINDOW_MS - Maximum possible latency (in milliseconds) of handling app_timer event. 
+// <i> Maximum possible timeout that can be set is reduced by safe window.
+// <i> Example: RTC frequency 16384 Hz, maximum possible timeout 1024 seconds - APP_TIMER_SAFE_WINDOW_MS.
+// <i> Since RTC is not stopped when processor is halted in debugging session, this value
+// <i> must cover it if debugging is needed. It is possible to halt processor for APP_TIMER_SAFE_WINDOW_MS
+// <i> without corrupting app_timer behavior.
+
+#ifndef APP_TIMER_SAFE_WINDOW_MS
+#define APP_TIMER_SAFE_WINDOW_MS 300000
+#endif
+
+// <h> App Timer Legacy configuration - Legacy configuration.
+
+//==========================================================
+// <q> APP_TIMER_WITH_PROFILER  - Enable app_timer profiling
+ 
+
+#ifndef APP_TIMER_WITH_PROFILER
+#define APP_TIMER_WITH_PROFILER 0
+#endif
+
+// <q> APP_TIMER_CONFIG_SWI_NUMBER  - Configure SWI instance used.
+ 
+
+#ifndef APP_TIMER_CONFIG_SWI_NUMBER
+#define APP_TIMER_CONFIG_SWI_NUMBER 0
+#endif
+
+// </h> 
+//==========================================================
+
+// </e>
+
+// <q> APP_USBD_CDC_ACM_ENABLED  - app_usbd_cdc_acm - USB CDC ACM class
+ 
+
+#ifndef APP_USBD_CDC_ACM_ENABLED
+#define APP_USBD_CDC_ACM_ENABLED 1
+#endif
+
+// <e> APP_USBD_ENABLED - app_usbd - USB Device library
+//==========================================================
+#ifndef APP_USBD_ENABLED
+#define APP_USBD_ENABLED 1
+#endif
+// <s> APP_USBD_VID - Vendor ID
+
+// <i> Vendor ID ordered from USB IF: http://www.usb.org/developers/vendor/
+#ifndef APP_USBD_VID
+#define APP_USBD_VID 0x1915
+#endif
+
+// <s> APP_USBD_PID - Product ID
+
+// <i> Selected Product ID
+#ifndef APP_USBD_PID
+#define APP_USBD_PID 0x521B
+#endif
+
+// <o> APP_USBD_DEVICE_VER_MAJOR - Device version, major part  <0-99> 
+
+
+// <i> Device version, will be converted automatically to BCD notation. Use just decimal values.
+
+#ifndef APP_USBD_DEVICE_VER_MAJOR
+#define APP_USBD_DEVICE_VER_MAJOR 1
+#endif
+
+// <o> APP_USBD_DEVICE_VER_MINOR - Device version, minor part  <0-99> 
+
+
+// <i> Device version, will be converted automatically to BCD notation. Use just decimal values.
+
+#ifndef APP_USBD_DEVICE_VER_MINOR
+#define APP_USBD_DEVICE_VER_MINOR 0
+#endif
+
+// <q> APP_USBD_CONFIG_SELF_POWERED  - Self powered 
+ 
+
+#ifndef APP_USBD_CONFIG_SELF_POWERED
+#define APP_USBD_CONFIG_SELF_POWERED 1
+#endif
+
+// <o> APP_USBD_CONFIG_MAX_POWER - MaxPower field in configuration descriptor in milliamps  <0-500> 
+
+
+#ifndef APP_USBD_CONFIG_MAX_POWER
+#define APP_USBD_CONFIG_MAX_POWER 500
+#endif
+
+// <q> APP_USBD_CONFIG_POWER_EVENTS_PROCESS  - Process power events
+ 
+
+// <i> Enable processing power events in USB event handler.
+
+#ifndef APP_USBD_CONFIG_POWER_EVENTS_PROCESS
+#define APP_USBD_CONFIG_POWER_EVENTS_PROCESS 1
+#endif
+
+// <e> APP_USBD_CONFIG_EVENT_QUEUE_ENABLE - Enable event queue
+
+// <i> This is the default configuration when all the events are placed into internal queue.
+// <i> Disable it when external queue is used like app_scheduler or if you wish to process all events inside interrupts.
+// <i> Processing all events from the interrupt level adds requirement not to call any functions that modifies the USBD library state from the context higher than USB interrupt context.
+// <i> Functions that modify USBD state are functions for sleep, wakeup, start, stop, enable and disable.
+//==========================================================
+#ifndef APP_USBD_CONFIG_EVENT_QUEUE_ENABLE
+#define APP_USBD_CONFIG_EVENT_QUEUE_ENABLE 1
+#endif
+// <o> APP_USBD_CONFIG_EVENT_QUEUE_SIZE - The size of event queue  <16-64> 
+
+
+// <i> The size of the queue for the events that would be processed in the main loop.
+
+#ifndef APP_USBD_CONFIG_EVENT_QUEUE_SIZE
+#define APP_USBD_CONFIG_EVENT_QUEUE_SIZE 32
+#endif
+
+// <o> APP_USBD_CONFIG_SOF_HANDLING_MODE  - Change SOF events handling mode.
+ 
+
+// <i> Normal queue   - SOF events are pushed normally into event queue.
+// <i> Compress queue - SOF events are counted and binded with other events or executed when queue is empty.
+// <i>                  This prevents queue from filling with SOF events.
+// <i> Interrupt      - SOF events are processed in interrupt.
+// <0=> Normal queue 
+// <1=> Compress queue 
+// <2=> Interrupt 
+
+#ifndef APP_USBD_CONFIG_SOF_HANDLING_MODE
+#define APP_USBD_CONFIG_SOF_HANDLING_MODE 1
+#endif
+
+// </e>
+
+// <q> APP_USBD_CONFIG_SOF_TIMESTAMP_PROVIDE  - Provide a function that generates timestamps for logs based on the current SOF
+ 
+
+// <i> The function app_usbd_sof_timestamp_get will be implemented if the logger is enabled. 
+// <i> Use it when initializing the logger. 
+// <i> SOF processing will be always enabled when this configuration parameter is active. 
+// <i> Notice that this option is configured outside of APP_USBD_CONFIG_LOG_ENABLED. 
+// <i> This means that it will work even if the logging in this very module is disabled. 
+
+#ifndef APP_USBD_CONFIG_SOF_TIMESTAMP_PROVIDE
+#define APP_USBD_CONFIG_SOF_TIMESTAMP_PROVIDE 0
+#endif
+
+// </e>
+
+// <q> APP_USBD_NRF_DFU_TRIGGER_ENABLED  - app_usbd_nrf_dfu_trigger - USBD Nordic DFU Trigger class
+ 
+
+#ifndef APP_USBD_NRF_DFU_TRIGGER_ENABLED
+#define APP_USBD_NRF_DFU_TRIGGER_ENABLED 1
+#endif
+
+// <q> CRC16_ENABLED  - crc16 - CRC16 calculation routines
+ 
+
+#ifndef CRC16_ENABLED
+#define CRC16_ENABLED 1
+#endif
+
+// <e> NRF_BALLOC_ENABLED - nrf_balloc - Block allocator module
+//==========================================================
+#ifndef NRF_BALLOC_ENABLED
+#define NRF_BALLOC_ENABLED 1
+#endif
+// <e> NRF_BALLOC_CONFIG_DEBUG_ENABLED - Enables debug mode in the module.
+//==========================================================
+#ifndef NRF_BALLOC_CONFIG_DEBUG_ENABLED
+#define NRF_BALLOC_CONFIG_DEBUG_ENABLED 0
+#endif
+// <o> NRF_BALLOC_CONFIG_HEAD_GUARD_WORDS - Number of words used as head guard.  <0-255> 
+
+
+#ifndef NRF_BALLOC_CONFIG_HEAD_GUARD_WORDS
+#define NRF_BALLOC_CONFIG_HEAD_GUARD_WORDS 1
+#endif
+
+// <o> NRF_BALLOC_CONFIG_TAIL_GUARD_WORDS - Number of words used as tail guard.  <0-255> 
+
+
+#ifndef NRF_BALLOC_CONFIG_TAIL_GUARD_WORDS
+#define NRF_BALLOC_CONFIG_TAIL_GUARD_WORDS 1
+#endif
+
+// <q> NRF_BALLOC_CONFIG_BASIC_CHECKS_ENABLED  - Enables basic checks in this module.
+ 
+
+#ifndef NRF_BALLOC_CONFIG_BASIC_CHECKS_ENABLED
+#define NRF_BALLOC_CONFIG_BASIC_CHECKS_ENABLED 0
+#endif
+
+// <q> NRF_BALLOC_CONFIG_DOUBLE_FREE_CHECK_ENABLED  - Enables double memory free check in this module.
+ 
+
+#ifndef NRF_BALLOC_CONFIG_DOUBLE_FREE_CHECK_ENABLED
+#define NRF_BALLOC_CONFIG_DOUBLE_FREE_CHECK_ENABLED 0
+#endif
+
+// <q> NRF_BALLOC_CONFIG_DATA_TRASHING_CHECK_ENABLED  - Enables free memory corruption check in this module.
+ 
+
+#ifndef NRF_BALLOC_CONFIG_DATA_TRASHING_CHECK_ENABLED
+#define NRF_BALLOC_CONFIG_DATA_TRASHING_CHECK_ENABLED 0
+#endif
+
+// <q> NRF_BALLOC_CLI_CMDS  - Enable CLI commands specific to the module
+ 
+
+#ifndef NRF_BALLOC_CLI_CMDS
+#define NRF_BALLOC_CLI_CMDS 0
+#endif
+
+// </e>
+
+// </e>
+
+// <q> NRF_FPRINTF_ENABLED  - nrf_fprintf - fprintf function.
+ 
+
+#ifndef NRF_FPRINTF_ENABLED
+#define NRF_FPRINTF_ENABLED 1
+#endif
+
+// <q> NRF_MEMOBJ_ENABLED  - nrf_memobj - Linked memory allocator module
+ 
+
+#ifndef NRF_MEMOBJ_ENABLED
+#define NRF_MEMOBJ_ENABLED 1
+#endif
+
+// <e> NRF_QUEUE_ENABLED - nrf_queue - Queue module
+//==========================================================
+#ifndef NRF_QUEUE_ENABLED
+#define NRF_QUEUE_ENABLED 1
+#endif
+// <q> NRF_QUEUE_CLI_CMDS  - Enable CLI commands specific to the module
+ 
+
+#ifndef NRF_QUEUE_CLI_CMDS
+#define NRF_QUEUE_CLI_CMDS 0
+#endif
+
+// </e>
+
+// <q> NRF_SECTION_ITER_ENABLED  - nrf_section_iter - Section iterator
+ 
+
+#ifndef NRF_SECTION_ITER_ENABLED
+#define NRF_SECTION_ITER_ENABLED 1
+#endif
+
+// <q> NRF_STRERROR_ENABLED  - nrf_strerror - Library for converting error code to string.
+ 
+
+#ifndef NRF_STRERROR_ENABLED
+#define NRF_STRERROR_ENABLED 1
+#endif
+
+// </h> 
+//==========================================================
+
+// <h> nRF_Log 
+
+//==========================================================
+// <e> NRF_LOG_BACKEND_RTT_ENABLED - nrf_log_backend_rtt - Log RTT backend
+//==========================================================
+#ifndef NRF_LOG_BACKEND_RTT_ENABLED
+#define NRF_LOG_BACKEND_RTT_ENABLED 0
+#endif
+// <o> NRF_LOG_BACKEND_RTT_TEMP_BUFFER_SIZE - Size of buffer for partially processed strings. 
+// <i> Size of the buffer is a trade-off between RAM usage and processing.
+// <i> if buffer is smaller then strings will often be fragmented.
+// <i> It is recommended to use size which will fit typical log and only the
+// <i> longer one will be fragmented.
+
+#ifndef NRF_LOG_BACKEND_RTT_TEMP_BUFFER_SIZE
+#define NRF_LOG_BACKEND_RTT_TEMP_BUFFER_SIZE 64
+#endif
+
+// <o> NRF_LOG_BACKEND_RTT_TX_RETRY_DELAY_MS - Period before retrying writing to RTT 
+#ifndef NRF_LOG_BACKEND_RTT_TX_RETRY_DELAY_MS
+#define NRF_LOG_BACKEND_RTT_TX_RETRY_DELAY_MS 1
+#endif
+
+// <o> NRF_LOG_BACKEND_RTT_TX_RETRY_CNT - Writing to RTT retries. 
+// <i> If RTT fails to accept any new data after retries
+// <i> module assumes that host is not active and on next
+// <i> request it will perform only one write attempt.
+// <i> On successful writing, module assumes that host is active
+// <i> and scheme with retry is applied again.
+
+#ifndef NRF_LOG_BACKEND_RTT_TX_RETRY_CNT
+#define NRF_LOG_BACKEND_RTT_TX_RETRY_CNT 3
+#endif
+
+// </e>
+
+// <q> NRF_LOG_STR_FORMATTER_TIMESTAMP_FORMAT_ENABLED  - nrf_log_str_formatter - Log string formatter
+ 
+
+#ifndef NRF_LOG_STR_FORMATTER_TIMESTAMP_FORMAT_ENABLED
+#define NRF_LOG_STR_FORMATTER_TIMESTAMP_FORMAT_ENABLED 1
+#endif
+
+// <h> nrf_log - Logger
+
+//==========================================================
+// <e> NRF_LOG_ENABLED - Logging module for nRF5 SDK
+//==========================================================
+#ifndef NRF_LOG_ENABLED
+#define NRF_LOG_ENABLED 0
+#endif
+// <e> NRF_LOG_USES_COLORS - If enabled then ANSI escape code for colors is prefixed to every string
+//==========================================================
+#ifndef NRF_LOG_USES_COLORS
+#define NRF_LOG_USES_COLORS 0
+#endif
+// <o> NRF_LOG_COLOR_DEFAULT  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_LOG_COLOR_DEFAULT
+#define NRF_LOG_COLOR_DEFAULT 0
+#endif
+
+// <o> NRF_LOG_ERROR_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_LOG_ERROR_COLOR
+#define NRF_LOG_ERROR_COLOR 2
+#endif
+
+// <o> NRF_LOG_WARNING_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_LOG_WARNING_COLOR
+#define NRF_LOG_WARNING_COLOR 4
+#endif
+
+// </e>
+
+// <o> NRF_LOG_DEFAULT_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_LOG_DEFAULT_LEVEL
+#define NRF_LOG_DEFAULT_LEVEL 3
+#endif
+
+// <q> NRF_LOG_DEFERRED  - Enable deffered logger.
+ 
+
+// <i> Log data is buffered and can be processed in idle.
+
+#ifndef NRF_LOG_DEFERRED
+#define NRF_LOG_DEFERRED 1
+#endif
+
+// <o> NRF_LOG_BUFSIZE  - Size of the buffer for storing logs (in bytes).
+ 
+
+// <i> Must be power of 2 and multiple of 4.
+// <i> If NRF_LOG_DEFERRED = 0 then buffer size can be reduced to minimum.
+// <128=> 128 
+// <256=> 256 
+// <512=> 512 
+// <1024=> 1024 
+// <2048=> 2048 
+// <4096=> 4096 
+// <8192=> 8192 
+// <16384=> 16384 
+
+#ifndef NRF_LOG_BUFSIZE
+#define NRF_LOG_BUFSIZE 1024
+#endif
+
+// <q> NRF_LOG_ALLOW_OVERFLOW  - Configures behavior when circular buffer is full.
+ 
+
+// <i> If set then oldest logs are overwritten. Otherwise a 
+// <i> marker is injected informing about overflow.
+
+#ifndef NRF_LOG_ALLOW_OVERFLOW
+#define NRF_LOG_ALLOW_OVERFLOW 1
+#endif
+
+// <e> NRF_LOG_USES_TIMESTAMP - Enable timestamping
+
+// <i> Function for getting the timestamp is provided by the user
+//==========================================================
+#ifndef NRF_LOG_USES_TIMESTAMP
+#define NRF_LOG_USES_TIMESTAMP 0
+#endif
+// <o> NRF_LOG_TIMESTAMP_DEFAULT_FREQUENCY - Default frequency of the timestamp (in Hz) or 0 to use app_timer frequency. 
+#ifndef NRF_LOG_TIMESTAMP_DEFAULT_FREQUENCY
+#define NRF_LOG_TIMESTAMP_DEFAULT_FREQUENCY 0
+#endif
+
+// </e>
+
+// <q> NRF_LOG_FILTERS_ENABLED  - Enable dynamic filtering of logs.
+ 
+
+#ifndef NRF_LOG_FILTERS_ENABLED
+#define NRF_LOG_FILTERS_ENABLED 0
+#endif
+
+// <q> NRF_LOG_CLI_CMDS  - Enable CLI commands for the module.
+ 
+
+#ifndef NRF_LOG_CLI_CMDS
+#define NRF_LOG_CLI_CMDS 0
+#endif
+
+// <h> Log message pool - Configuration of log message pool
+
+//==========================================================
+// <o> NRF_LOG_MSGPOOL_ELEMENT_SIZE - Size of a single element in the pool of memory objects. 
+// <i> If a small value is set, then performance of logs processing
+// <i> is degraded because data is fragmented. Bigger value impacts
+// <i> RAM memory utilization. The size is set to fit a message with
+// <i> a timestamp and up to 2 arguments in a single memory object.
+
+#ifndef NRF_LOG_MSGPOOL_ELEMENT_SIZE
+#define NRF_LOG_MSGPOOL_ELEMENT_SIZE 20
+#endif
+
+// <o> NRF_LOG_MSGPOOL_ELEMENT_COUNT - Number of elements in the pool of memory objects 
+// <i> If a small value is set, then it may lead to a deadlock
+// <i> in certain cases if backend has high latency and holds
+// <i> multiple messages for long time. Bigger value impacts
+// <i> RAM memory usage.
+
+#ifndef NRF_LOG_MSGPOOL_ELEMENT_COUNT
+#define NRF_LOG_MSGPOOL_ELEMENT_COUNT 8
+#endif
+
+// </h> 
+//==========================================================
+
+// </e>
+
+// <h> nrf_log module configuration 
+
+//==========================================================
+// <h> nrf_log in nRF_Core 
+
+//==========================================================
+// <e> NRF_MPU_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRF_MPU_CONFIG_LOG_ENABLED
+#define NRF_MPU_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRF_MPU_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_MPU_CONFIG_LOG_LEVEL
+#define NRF_MPU_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRF_MPU_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_MPU_CONFIG_INFO_COLOR
+#define NRF_MPU_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRF_MPU_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_MPU_CONFIG_DEBUG_COLOR
+#define NRF_MPU_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> NRF_STACK_GUARD_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRF_STACK_GUARD_CONFIG_LOG_ENABLED
+#define NRF_STACK_GUARD_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRF_STACK_GUARD_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_STACK_GUARD_CONFIG_LOG_LEVEL
+#define NRF_STACK_GUARD_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRF_STACK_GUARD_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_STACK_GUARD_CONFIG_INFO_COLOR
+#define NRF_STACK_GUARD_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRF_STACK_GUARD_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_STACK_GUARD_CONFIG_DEBUG_COLOR
+#define NRF_STACK_GUARD_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> TASK_MANAGER_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef TASK_MANAGER_CONFIG_LOG_ENABLED
+#define TASK_MANAGER_CONFIG_LOG_ENABLED 0
+#endif
+// <o> TASK_MANAGER_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef TASK_MANAGER_CONFIG_LOG_LEVEL
+#define TASK_MANAGER_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> TASK_MANAGER_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef TASK_MANAGER_CONFIG_INFO_COLOR
+#define TASK_MANAGER_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> TASK_MANAGER_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef TASK_MANAGER_CONFIG_DEBUG_COLOR
+#define TASK_MANAGER_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// </h> 
+//==========================================================
+
+// <h> nrf_log in nRF_Drivers 
+
+//==========================================================
+// <e> CLOCK_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef CLOCK_CONFIG_LOG_ENABLED
+#define CLOCK_CONFIG_LOG_ENABLED 0
+#endif
+// <o> CLOCK_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef CLOCK_CONFIG_LOG_LEVEL
+#define CLOCK_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> CLOCK_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef CLOCK_CONFIG_INFO_COLOR
+#define CLOCK_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> CLOCK_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef CLOCK_CONFIG_DEBUG_COLOR
+#define CLOCK_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> COMP_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef COMP_CONFIG_LOG_ENABLED
+#define COMP_CONFIG_LOG_ENABLED 0
+#endif
+// <o> COMP_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef COMP_CONFIG_LOG_LEVEL
+#define COMP_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> COMP_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef COMP_CONFIG_INFO_COLOR
+#define COMP_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> COMP_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef COMP_CONFIG_DEBUG_COLOR
+#define COMP_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> GPIOTE_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef GPIOTE_CONFIG_LOG_ENABLED
+#define GPIOTE_CONFIG_LOG_ENABLED 0
+#endif
+// <o> GPIOTE_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef GPIOTE_CONFIG_LOG_LEVEL
+#define GPIOTE_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> GPIOTE_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef GPIOTE_CONFIG_INFO_COLOR
+#define GPIOTE_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> GPIOTE_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef GPIOTE_CONFIG_DEBUG_COLOR
+#define GPIOTE_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> LPCOMP_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef LPCOMP_CONFIG_LOG_ENABLED
+#define LPCOMP_CONFIG_LOG_ENABLED 0
+#endif
+// <o> LPCOMP_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef LPCOMP_CONFIG_LOG_LEVEL
+#define LPCOMP_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> LPCOMP_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef LPCOMP_CONFIG_INFO_COLOR
+#define LPCOMP_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> LPCOMP_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef LPCOMP_CONFIG_DEBUG_COLOR
+#define LPCOMP_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> PDM_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef PDM_CONFIG_LOG_ENABLED
+#define PDM_CONFIG_LOG_ENABLED 0
+#endif
+// <o> PDM_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef PDM_CONFIG_LOG_LEVEL
+#define PDM_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> PDM_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef PDM_CONFIG_INFO_COLOR
+#define PDM_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> PDM_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef PDM_CONFIG_DEBUG_COLOR
+#define PDM_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> PPI_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef PPI_CONFIG_LOG_ENABLED
+#define PPI_CONFIG_LOG_ENABLED 0
+#endif
+// <o> PPI_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef PPI_CONFIG_LOG_LEVEL
+#define PPI_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> PPI_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef PPI_CONFIG_INFO_COLOR
+#define PPI_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> PPI_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef PPI_CONFIG_DEBUG_COLOR
+#define PPI_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> PWM_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef PWM_CONFIG_LOG_ENABLED
+#define PWM_CONFIG_LOG_ENABLED 0
+#endif
+// <o> PWM_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef PWM_CONFIG_LOG_LEVEL
+#define PWM_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> PWM_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef PWM_CONFIG_INFO_COLOR
+#define PWM_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> PWM_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef PWM_CONFIG_DEBUG_COLOR
+#define PWM_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> QDEC_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef QDEC_CONFIG_LOG_ENABLED
+#define QDEC_CONFIG_LOG_ENABLED 0
+#endif
+// <o> QDEC_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef QDEC_CONFIG_LOG_LEVEL
+#define QDEC_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> QDEC_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef QDEC_CONFIG_INFO_COLOR
+#define QDEC_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> QDEC_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef QDEC_CONFIG_DEBUG_COLOR
+#define QDEC_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> RNG_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef RNG_CONFIG_LOG_ENABLED
+#define RNG_CONFIG_LOG_ENABLED 0
+#endif
+// <o> RNG_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef RNG_CONFIG_LOG_LEVEL
+#define RNG_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> RNG_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef RNG_CONFIG_INFO_COLOR
+#define RNG_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> RNG_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef RNG_CONFIG_DEBUG_COLOR
+#define RNG_CONFIG_DEBUG_COLOR 0
+#endif
+
+// <q> RNG_CONFIG_RANDOM_NUMBER_LOG_ENABLED  - Enables logging of random numbers.
+ 
+
+#ifndef RNG_CONFIG_RANDOM_NUMBER_LOG_ENABLED
+#define RNG_CONFIG_RANDOM_NUMBER_LOG_ENABLED 0
+#endif
+
+// </e>
+
+// <e> RTC_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef RTC_CONFIG_LOG_ENABLED
+#define RTC_CONFIG_LOG_ENABLED 0
+#endif
+// <o> RTC_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef RTC_CONFIG_LOG_LEVEL
+#define RTC_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> RTC_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef RTC_CONFIG_INFO_COLOR
+#define RTC_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> RTC_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef RTC_CONFIG_DEBUG_COLOR
+#define RTC_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> SAADC_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef SAADC_CONFIG_LOG_ENABLED
+#define SAADC_CONFIG_LOG_ENABLED 0
+#endif
+// <o> SAADC_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef SAADC_CONFIG_LOG_LEVEL
+#define SAADC_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> SAADC_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef SAADC_CONFIG_INFO_COLOR
+#define SAADC_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> SAADC_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef SAADC_CONFIG_DEBUG_COLOR
+#define SAADC_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> SPIS_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef SPIS_CONFIG_LOG_ENABLED
+#define SPIS_CONFIG_LOG_ENABLED 0
+#endif
+// <o> SPIS_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef SPIS_CONFIG_LOG_LEVEL
+#define SPIS_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> SPIS_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef SPIS_CONFIG_INFO_COLOR
+#define SPIS_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> SPIS_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef SPIS_CONFIG_DEBUG_COLOR
+#define SPIS_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> SPI_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef SPI_CONFIG_LOG_ENABLED
+#define SPI_CONFIG_LOG_ENABLED 0
+#endif
+// <o> SPI_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef SPI_CONFIG_LOG_LEVEL
+#define SPI_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> SPI_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef SPI_CONFIG_INFO_COLOR
+#define SPI_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> SPI_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef SPI_CONFIG_DEBUG_COLOR
+#define SPI_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> TIMER_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef TIMER_CONFIG_LOG_ENABLED
+#define TIMER_CONFIG_LOG_ENABLED 0
+#endif
+// <o> TIMER_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef TIMER_CONFIG_LOG_LEVEL
+#define TIMER_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> TIMER_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef TIMER_CONFIG_INFO_COLOR
+#define TIMER_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> TIMER_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef TIMER_CONFIG_DEBUG_COLOR
+#define TIMER_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> TWIS_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef TWIS_CONFIG_LOG_ENABLED
+#define TWIS_CONFIG_LOG_ENABLED 0
+#endif
+// <o> TWIS_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef TWIS_CONFIG_LOG_LEVEL
+#define TWIS_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> TWIS_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef TWIS_CONFIG_INFO_COLOR
+#define TWIS_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> TWIS_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef TWIS_CONFIG_DEBUG_COLOR
+#define TWIS_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> TWI_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef TWI_CONFIG_LOG_ENABLED
+#define TWI_CONFIG_LOG_ENABLED 0
+#endif
+// <o> TWI_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef TWI_CONFIG_LOG_LEVEL
+#define TWI_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> TWI_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef TWI_CONFIG_INFO_COLOR
+#define TWI_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> TWI_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef TWI_CONFIG_DEBUG_COLOR
+#define TWI_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> UART_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef UART_CONFIG_LOG_ENABLED
+#define UART_CONFIG_LOG_ENABLED 0
+#endif
+// <o> UART_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef UART_CONFIG_LOG_LEVEL
+#define UART_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> UART_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef UART_CONFIG_INFO_COLOR
+#define UART_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> UART_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef UART_CONFIG_DEBUG_COLOR
+#define UART_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> USBD_CONFIG_LOG_ENABLED - Enable logging in the module
+//==========================================================
+#ifndef USBD_CONFIG_LOG_ENABLED
+#define USBD_CONFIG_LOG_ENABLED 0
+#endif
+// <o> USBD_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef USBD_CONFIG_LOG_LEVEL
+#define USBD_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> USBD_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef USBD_CONFIG_INFO_COLOR
+#define USBD_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> USBD_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef USBD_CONFIG_DEBUG_COLOR
+#define USBD_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> WDT_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef WDT_CONFIG_LOG_ENABLED
+#define WDT_CONFIG_LOG_ENABLED 0
+#endif
+// <o> WDT_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef WDT_CONFIG_LOG_LEVEL
+#define WDT_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> WDT_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef WDT_CONFIG_INFO_COLOR
+#define WDT_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> WDT_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef WDT_CONFIG_DEBUG_COLOR
+#define WDT_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// </h> 
+//==========================================================
+
+// <h> nrf_log in nRF_Libraries 
+
+//==========================================================
+// <e> APP_TIMER_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef APP_TIMER_CONFIG_LOG_ENABLED
+#define APP_TIMER_CONFIG_LOG_ENABLED 0
+#endif
+// <o> APP_TIMER_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef APP_TIMER_CONFIG_LOG_LEVEL
+#define APP_TIMER_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> APP_TIMER_CONFIG_INITIAL_LOG_LEVEL  - Initial severity level if dynamic filtering is enabled.
+ 
+
+// <i> If module generates a lot of logs, initial log level can
+// <i> be decreased to prevent flooding. Severity level can be
+// <i> increased on instance basis.
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef APP_TIMER_CONFIG_INITIAL_LOG_LEVEL
+#define APP_TIMER_CONFIG_INITIAL_LOG_LEVEL 3
+#endif
+
+// <o> APP_TIMER_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef APP_TIMER_CONFIG_INFO_COLOR
+#define APP_TIMER_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> APP_TIMER_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef APP_TIMER_CONFIG_DEBUG_COLOR
+#define APP_TIMER_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> APP_USBD_CDC_ACM_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef APP_USBD_CDC_ACM_CONFIG_LOG_ENABLED
+#define APP_USBD_CDC_ACM_CONFIG_LOG_ENABLED 0
+#endif
+// <o> APP_USBD_CDC_ACM_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef APP_USBD_CDC_ACM_CONFIG_LOG_LEVEL
+#define APP_USBD_CDC_ACM_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> APP_USBD_CDC_ACM_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef APP_USBD_CDC_ACM_CONFIG_INFO_COLOR
+#define APP_USBD_CDC_ACM_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> APP_USBD_CDC_ACM_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef APP_USBD_CDC_ACM_CONFIG_DEBUG_COLOR
+#define APP_USBD_CDC_ACM_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> APP_USBD_CONFIG_LOG_ENABLED - Enable logging in the module
+//==========================================================
+#ifndef APP_USBD_CONFIG_LOG_ENABLED
+#define APP_USBD_CONFIG_LOG_ENABLED 0
+#endif
+// <o> APP_USBD_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef APP_USBD_CONFIG_LOG_LEVEL
+#define APP_USBD_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> APP_USBD_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef APP_USBD_CONFIG_INFO_COLOR
+#define APP_USBD_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> APP_USBD_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef APP_USBD_CONFIG_DEBUG_COLOR
+#define APP_USBD_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> APP_USBD_DUMMY_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef APP_USBD_DUMMY_CONFIG_LOG_ENABLED
+#define APP_USBD_DUMMY_CONFIG_LOG_ENABLED 0
+#endif
+// <o> APP_USBD_DUMMY_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef APP_USBD_DUMMY_CONFIG_LOG_LEVEL
+#define APP_USBD_DUMMY_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> APP_USBD_DUMMY_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef APP_USBD_DUMMY_CONFIG_INFO_COLOR
+#define APP_USBD_DUMMY_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> APP_USBD_DUMMY_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef APP_USBD_DUMMY_CONFIG_DEBUG_COLOR
+#define APP_USBD_DUMMY_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> APP_USBD_MSC_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef APP_USBD_MSC_CONFIG_LOG_ENABLED
+#define APP_USBD_MSC_CONFIG_LOG_ENABLED 0
+#endif
+// <o> APP_USBD_MSC_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef APP_USBD_MSC_CONFIG_LOG_LEVEL
+#define APP_USBD_MSC_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> APP_USBD_MSC_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef APP_USBD_MSC_CONFIG_INFO_COLOR
+#define APP_USBD_MSC_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> APP_USBD_MSC_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef APP_USBD_MSC_CONFIG_DEBUG_COLOR
+#define APP_USBD_MSC_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> APP_USBD_NRF_DFU_TRIGGER_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef APP_USBD_NRF_DFU_TRIGGER_CONFIG_LOG_ENABLED
+#define APP_USBD_NRF_DFU_TRIGGER_CONFIG_LOG_ENABLED 0
+#endif
+// <o> APP_USBD_NRF_DFU_TRIGGER_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef APP_USBD_NRF_DFU_TRIGGER_CONFIG_LOG_LEVEL
+#define APP_USBD_NRF_DFU_TRIGGER_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> APP_USBD_NRF_DFU_TRIGGER_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef APP_USBD_NRF_DFU_TRIGGER_CONFIG_INFO_COLOR
+#define APP_USBD_NRF_DFU_TRIGGER_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> APP_USBD_NRF_DFU_TRIGGER_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef APP_USBD_NRF_DFU_TRIGGER_CONFIG_DEBUG_COLOR
+#define APP_USBD_NRF_DFU_TRIGGER_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> NRF_ATFIFO_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRF_ATFIFO_CONFIG_LOG_ENABLED
+#define NRF_ATFIFO_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRF_ATFIFO_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_ATFIFO_CONFIG_LOG_LEVEL
+#define NRF_ATFIFO_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRF_ATFIFO_CONFIG_LOG_INIT_FILTER_LEVEL  - Initial severity level if dynamic filtering is enabled
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_ATFIFO_CONFIG_LOG_INIT_FILTER_LEVEL
+#define NRF_ATFIFO_CONFIG_LOG_INIT_FILTER_LEVEL 3
+#endif
+
+// <o> NRF_ATFIFO_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_ATFIFO_CONFIG_INFO_COLOR
+#define NRF_ATFIFO_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRF_ATFIFO_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_ATFIFO_CONFIG_DEBUG_COLOR
+#define NRF_ATFIFO_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> NRF_BALLOC_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRF_BALLOC_CONFIG_LOG_ENABLED
+#define NRF_BALLOC_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRF_BALLOC_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_BALLOC_CONFIG_LOG_LEVEL
+#define NRF_BALLOC_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRF_BALLOC_CONFIG_INITIAL_LOG_LEVEL  - Initial severity level if dynamic filtering is enabled.
+ 
+
+// <i> If module generates a lot of logs, initial log level can
+// <i> be decreased to prevent flooding. Severity level can be
+// <i> increased on instance basis.
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_BALLOC_CONFIG_INITIAL_LOG_LEVEL
+#define NRF_BALLOC_CONFIG_INITIAL_LOG_LEVEL 3
+#endif
+
+// <o> NRF_BALLOC_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_BALLOC_CONFIG_INFO_COLOR
+#define NRF_BALLOC_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRF_BALLOC_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_BALLOC_CONFIG_DEBUG_COLOR
+#define NRF_BALLOC_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> NRF_CLI_BLE_UART_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRF_CLI_BLE_UART_CONFIG_LOG_ENABLED
+#define NRF_CLI_BLE_UART_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRF_CLI_BLE_UART_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_CLI_BLE_UART_CONFIG_LOG_LEVEL
+#define NRF_CLI_BLE_UART_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRF_CLI_BLE_UART_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_CLI_BLE_UART_CONFIG_INFO_COLOR
+#define NRF_CLI_BLE_UART_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRF_CLI_BLE_UART_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_CLI_BLE_UART_CONFIG_DEBUG_COLOR
+#define NRF_CLI_BLE_UART_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> NRF_CLI_LIBUARTE_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRF_CLI_LIBUARTE_CONFIG_LOG_ENABLED
+#define NRF_CLI_LIBUARTE_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRF_CLI_LIBUARTE_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_CLI_LIBUARTE_CONFIG_LOG_LEVEL
+#define NRF_CLI_LIBUARTE_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRF_CLI_LIBUARTE_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_CLI_LIBUARTE_CONFIG_INFO_COLOR
+#define NRF_CLI_LIBUARTE_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRF_CLI_LIBUARTE_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_CLI_LIBUARTE_CONFIG_DEBUG_COLOR
+#define NRF_CLI_LIBUARTE_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> NRF_CLI_UART_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRF_CLI_UART_CONFIG_LOG_ENABLED
+#define NRF_CLI_UART_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRF_CLI_UART_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_CLI_UART_CONFIG_LOG_LEVEL
+#define NRF_CLI_UART_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRF_CLI_UART_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_CLI_UART_CONFIG_INFO_COLOR
+#define NRF_CLI_UART_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRF_CLI_UART_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_CLI_UART_CONFIG_DEBUG_COLOR
+#define NRF_CLI_UART_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> NRF_LIBUARTE_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRF_LIBUARTE_CONFIG_LOG_ENABLED
+#define NRF_LIBUARTE_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRF_LIBUARTE_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_LIBUARTE_CONFIG_LOG_LEVEL
+#define NRF_LIBUARTE_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRF_LIBUARTE_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_LIBUARTE_CONFIG_INFO_COLOR
+#define NRF_LIBUARTE_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRF_LIBUARTE_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_LIBUARTE_CONFIG_DEBUG_COLOR
+#define NRF_LIBUARTE_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> NRF_MEMOBJ_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRF_MEMOBJ_CONFIG_LOG_ENABLED
+#define NRF_MEMOBJ_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRF_MEMOBJ_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_MEMOBJ_CONFIG_LOG_LEVEL
+#define NRF_MEMOBJ_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRF_MEMOBJ_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_MEMOBJ_CONFIG_INFO_COLOR
+#define NRF_MEMOBJ_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRF_MEMOBJ_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_MEMOBJ_CONFIG_DEBUG_COLOR
+#define NRF_MEMOBJ_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> NRF_PWR_MGMT_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRF_PWR_MGMT_CONFIG_LOG_ENABLED
+#define NRF_PWR_MGMT_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRF_PWR_MGMT_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_PWR_MGMT_CONFIG_LOG_LEVEL
+#define NRF_PWR_MGMT_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRF_PWR_MGMT_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_PWR_MGMT_CONFIG_INFO_COLOR
+#define NRF_PWR_MGMT_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRF_PWR_MGMT_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_PWR_MGMT_CONFIG_DEBUG_COLOR
+#define NRF_PWR_MGMT_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> NRF_QUEUE_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRF_QUEUE_CONFIG_LOG_ENABLED
+#define NRF_QUEUE_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRF_QUEUE_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_QUEUE_CONFIG_LOG_LEVEL
+#define NRF_QUEUE_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRF_QUEUE_CONFIG_LOG_INIT_FILTER_LEVEL  - Initial severity level if dynamic filtering is enabled
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_QUEUE_CONFIG_LOG_INIT_FILTER_LEVEL
+#define NRF_QUEUE_CONFIG_LOG_INIT_FILTER_LEVEL 3
+#endif
+
+// <o> NRF_QUEUE_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_QUEUE_CONFIG_INFO_COLOR
+#define NRF_QUEUE_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRF_QUEUE_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_QUEUE_CONFIG_DEBUG_COLOR
+#define NRF_QUEUE_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> NRF_SDH_ANT_LOG_ENABLED - Enable logging in SoftDevice handler (ANT) module.
+//==========================================================
+#ifndef NRF_SDH_ANT_LOG_ENABLED
+#define NRF_SDH_ANT_LOG_ENABLED 0
+#endif
+// <o> NRF_SDH_ANT_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_SDH_ANT_LOG_LEVEL
+#define NRF_SDH_ANT_LOG_LEVEL 3
+#endif
+
+// <o> NRF_SDH_ANT_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_SDH_ANT_INFO_COLOR
+#define NRF_SDH_ANT_INFO_COLOR 0
+#endif
+
+// <o> NRF_SDH_ANT_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_SDH_ANT_DEBUG_COLOR
+#define NRF_SDH_ANT_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> NRF_SDH_BLE_LOG_ENABLED - Enable logging in SoftDevice handler (BLE) module.
+//==========================================================
+#ifndef NRF_SDH_BLE_LOG_ENABLED
+#define NRF_SDH_BLE_LOG_ENABLED 1
+#endif
+// <o> NRF_SDH_BLE_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_SDH_BLE_LOG_LEVEL
+#define NRF_SDH_BLE_LOG_LEVEL 3
+#endif
+
+// <o> NRF_SDH_BLE_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_SDH_BLE_INFO_COLOR
+#define NRF_SDH_BLE_INFO_COLOR 0
+#endif
+
+// <o> NRF_SDH_BLE_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_SDH_BLE_DEBUG_COLOR
+#define NRF_SDH_BLE_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> NRF_SDH_LOG_ENABLED - Enable logging in SoftDevice handler module.
+//==========================================================
+#ifndef NRF_SDH_LOG_ENABLED
+#define NRF_SDH_LOG_ENABLED 1
+#endif
+// <o> NRF_SDH_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_SDH_LOG_LEVEL
+#define NRF_SDH_LOG_LEVEL 3
+#endif
+
+// <o> NRF_SDH_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_SDH_INFO_COLOR
+#define NRF_SDH_INFO_COLOR 0
+#endif
+
+// <o> NRF_SDH_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_SDH_DEBUG_COLOR
+#define NRF_SDH_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> NRF_SDH_SOC_LOG_ENABLED - Enable logging in SoftDevice handler (SoC) module.
+//==========================================================
+#ifndef NRF_SDH_SOC_LOG_ENABLED
+#define NRF_SDH_SOC_LOG_ENABLED 1
+#endif
+// <o> NRF_SDH_SOC_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_SDH_SOC_LOG_LEVEL
+#define NRF_SDH_SOC_LOG_LEVEL 3
+#endif
+
+// <o> NRF_SDH_SOC_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_SDH_SOC_INFO_COLOR
+#define NRF_SDH_SOC_INFO_COLOR 0
+#endif
+
+// <o> NRF_SDH_SOC_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_SDH_SOC_DEBUG_COLOR
+#define NRF_SDH_SOC_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> NRF_SORTLIST_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRF_SORTLIST_CONFIG_LOG_ENABLED
+#define NRF_SORTLIST_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRF_SORTLIST_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_SORTLIST_CONFIG_LOG_LEVEL
+#define NRF_SORTLIST_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRF_SORTLIST_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_SORTLIST_CONFIG_INFO_COLOR
+#define NRF_SORTLIST_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRF_SORTLIST_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_SORTLIST_CONFIG_DEBUG_COLOR
+#define NRF_SORTLIST_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// <e> NRF_TWI_SENSOR_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef NRF_TWI_SENSOR_CONFIG_LOG_ENABLED
+#define NRF_TWI_SENSOR_CONFIG_LOG_ENABLED 0
+#endif
+// <o> NRF_TWI_SENSOR_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef NRF_TWI_SENSOR_CONFIG_LOG_LEVEL
+#define NRF_TWI_SENSOR_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> NRF_TWI_SENSOR_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_TWI_SENSOR_CONFIG_INFO_COLOR
+#define NRF_TWI_SENSOR_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> NRF_TWI_SENSOR_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef NRF_TWI_SENSOR_CONFIG_DEBUG_COLOR
+#define NRF_TWI_SENSOR_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// </h> 
+//==========================================================
+
+// <h> nrf_log in nRF_Serialization 
+
+//==========================================================
+// <e> SER_HAL_TRANSPORT_CONFIG_LOG_ENABLED - Enables logging in the module.
+//==========================================================
+#ifndef SER_HAL_TRANSPORT_CONFIG_LOG_ENABLED
+#define SER_HAL_TRANSPORT_CONFIG_LOG_ENABLED 0
+#endif
+// <o> SER_HAL_TRANSPORT_CONFIG_LOG_LEVEL  - Default Severity level
+ 
+// <0=> Off 
+// <1=> Error 
+// <2=> Warning 
+// <3=> Info 
+// <4=> Debug 
+
+#ifndef SER_HAL_TRANSPORT_CONFIG_LOG_LEVEL
+#define SER_HAL_TRANSPORT_CONFIG_LOG_LEVEL 3
+#endif
+
+// <o> SER_HAL_TRANSPORT_CONFIG_INFO_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef SER_HAL_TRANSPORT_CONFIG_INFO_COLOR
+#define SER_HAL_TRANSPORT_CONFIG_INFO_COLOR 0
+#endif
+
+// <o> SER_HAL_TRANSPORT_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
+ 
+// <0=> Default 
+// <1=> Black 
+// <2=> Red 
+// <3=> Green 
+// <4=> Yellow 
+// <5=> Blue 
+// <6=> Magenta 
+// <7=> Cyan 
+// <8=> White 
+
+#ifndef SER_HAL_TRANSPORT_CONFIG_DEBUG_COLOR
+#define SER_HAL_TRANSPORT_CONFIG_DEBUG_COLOR 0
+#endif
+
+// </e>
+
+// </h> 
+//==========================================================
+
+// </h> 
+//==========================================================
+
+// </h> 
+//==========================================================
+
+// </h> 
+//==========================================================
+
+// <h> nRF_Segger_RTT 
+
+//==========================================================
+// <h> segger_rtt - SEGGER RTT
+
+//==========================================================
+// <o> SEGGER_RTT_CONFIG_BUFFER_SIZE_UP - Size of upstream buffer. 
+// <i> Note that either @ref NRF_LOG_BACKEND_RTT_OUTPUT_BUFFER_SIZE
+// <i> or this value is actually used. It depends on which one is bigger.
+
+#ifndef SEGGER_RTT_CONFIG_BUFFER_SIZE_UP
+#define SEGGER_RTT_CONFIG_BUFFER_SIZE_UP 512
+#endif
+
+// <o> SEGGER_RTT_CONFIG_MAX_NUM_UP_BUFFERS - Size of upstream buffer. 
+#ifndef SEGGER_RTT_CONFIG_MAX_NUM_UP_BUFFERS
+#define SEGGER_RTT_CONFIG_MAX_NUM_UP_BUFFERS 2
+#endif
+
+// <o> SEGGER_RTT_CONFIG_BUFFER_SIZE_DOWN - Size of upstream buffer. 
+#ifndef SEGGER_RTT_CONFIG_BUFFER_SIZE_DOWN
+#define SEGGER_RTT_CONFIG_BUFFER_SIZE_DOWN 16
+#endif
+
+// <o> SEGGER_RTT_CONFIG_MAX_NUM_DOWN_BUFFERS - Size of upstream buffer. 
+#ifndef SEGGER_RTT_CONFIG_MAX_NUM_DOWN_BUFFERS
+#define SEGGER_RTT_CONFIG_MAX_NUM_DOWN_BUFFERS 2
+#endif
+
+// <o> SEGGER_RTT_CONFIG_DEFAULT_MODE  - RTT behavior if the buffer is full.
+ 
+
+// <i> The following modes are supported:
+// <i> - SKIP  - Do not block, output nothing.
+// <i> - TRIM  - Do not block, output as much as fits.
+// <i> - BLOCK - Wait until there is space in the buffer.
+// <0=> SKIP 
+// <1=> TRIM 
+// <2=> BLOCK_IF_FIFO_FULL 
+
+#ifndef SEGGER_RTT_CONFIG_DEFAULT_MODE
+#define SEGGER_RTT_CONFIG_DEFAULT_MODE 0
+#endif
+
+// </h> 
+//==========================================================
+
+// </h> 
+//==========================================================
+
+// <h> nRF_SoftDevice 
+
+//==========================================================
+// <e> NRF_SDH_BLE_ENABLED - nrf_sdh_ble - SoftDevice BLE event handler
+//==========================================================
+#ifndef NRF_SDH_BLE_ENABLED
+#define NRF_SDH_BLE_ENABLED 1
+#endif
+// <h> BLE Stack configuration - Stack configuration parameters
+
+// <i> The SoftDevice handler will configure the stack with these parameters when calling @ref nrf_sdh_ble_default_cfg_set.
+// <i> Other libraries might depend on these values; keep them up-to-date even if you are not explicitely calling @ref nrf_sdh_ble_default_cfg_set.
+//==========================================================
+// <o> NRF_SDH_BLE_GAP_DATA_LENGTH   <27-251> 
+
+
+// <i> Requested BLE GAP data length to be negotiated.
+
+#ifndef NRF_SDH_BLE_GAP_DATA_LENGTH
+#define NRF_SDH_BLE_GAP_DATA_LENGTH 27
+#endif
+
+// <o> NRF_SDH_BLE_PERIPHERAL_LINK_COUNT - Maximum number of peripheral links. 
+#ifndef NRF_SDH_BLE_PERIPHERAL_LINK_COUNT
+#define NRF_SDH_BLE_PERIPHERAL_LINK_COUNT 0
+#endif
+
+// <o> NRF_SDH_BLE_CENTRAL_LINK_COUNT - Maximum number of central links. 
+#ifndef NRF_SDH_BLE_CENTRAL_LINK_COUNT
+#define NRF_SDH_BLE_CENTRAL_LINK_COUNT 0
+#endif
+
+// <o> NRF_SDH_BLE_TOTAL_LINK_COUNT - Total link count. 
+// <i> Maximum number of total concurrent connections using the default configuration.
+
+#ifndef NRF_SDH_BLE_TOTAL_LINK_COUNT
+#define NRF_SDH_BLE_TOTAL_LINK_COUNT 1
+#endif
+
+// <o> NRF_SDH_BLE_GAP_EVENT_LENGTH - GAP event length. 
+// <i> The time set aside for this connection on every connection interval in 1.25 ms units.
+
+#ifndef NRF_SDH_BLE_GAP_EVENT_LENGTH
+#define NRF_SDH_BLE_GAP_EVENT_LENGTH 6
+#endif
+
+// <o> NRF_SDH_BLE_GATT_MAX_MTU_SIZE - Static maximum MTU size. 
+#ifndef NRF_SDH_BLE_GATT_MAX_MTU_SIZE
+#define NRF_SDH_BLE_GATT_MAX_MTU_SIZE 250
+#endif
+
+// <o> NRF_SDH_BLE_GATTS_ATTR_TAB_SIZE - Attribute Table size in bytes. The size must be a multiple of 4. 
+#ifndef NRF_SDH_BLE_GATTS_ATTR_TAB_SIZE
+#define NRF_SDH_BLE_GATTS_ATTR_TAB_SIZE 1408
+#endif
+
+// <o> NRF_SDH_BLE_VS_UUID_COUNT - The number of vendor-specific UUIDs. 
+#ifndef NRF_SDH_BLE_VS_UUID_COUNT
+#define NRF_SDH_BLE_VS_UUID_COUNT 0
+#endif
+
+// <q> NRF_SDH_BLE_SERVICE_CHANGED  - Include the Service Changed characteristic in the Attribute Table.
+ 
+
+#ifndef NRF_SDH_BLE_SERVICE_CHANGED
+#define NRF_SDH_BLE_SERVICE_CHANGED 0
+#endif
+
+// </h> 
+//==========================================================
+
+// <h> BLE Observers - Observers and priority levels
+
+//==========================================================
+// <o> NRF_SDH_BLE_OBSERVER_PRIO_LEVELS - Total number of priority levels for BLE observers. 
+// <i> This setting configures the number of priority levels available for BLE event handlers.
+// <i> The priority level of a handler determines the order in which it receives events, with respect to other handlers.
+
+#ifndef NRF_SDH_BLE_OBSERVER_PRIO_LEVELS
+#define NRF_SDH_BLE_OBSERVER_PRIO_LEVELS 4
+#endif
+
+// <h> BLE Observers priorities - Invididual priorities
+
+//==========================================================
+// <o> BLE_ADV_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Advertising module.
+
+#ifndef BLE_ADV_BLE_OBSERVER_PRIO
+#define BLE_ADV_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> BLE_ANCS_C_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Apple Notification Service Client.
+
+#ifndef BLE_ANCS_C_BLE_OBSERVER_PRIO
+#define BLE_ANCS_C_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_ANS_C_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Alert Notification Service Client.
+
+#ifndef BLE_ANS_C_BLE_OBSERVER_PRIO
+#define BLE_ANS_C_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_BAS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Battery Service.
+
+#ifndef BLE_BAS_BLE_OBSERVER_PRIO
+#define BLE_BAS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_BAS_C_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Battery Service Client.
+
+#ifndef BLE_BAS_C_BLE_OBSERVER_PRIO
+#define BLE_BAS_C_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_BPS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Blood Pressure Service.
+
+#ifndef BLE_BPS_BLE_OBSERVER_PRIO
+#define BLE_BPS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_CONN_PARAMS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Connection parameters module.
+
+#ifndef BLE_CONN_PARAMS_BLE_OBSERVER_PRIO
+#define BLE_CONN_PARAMS_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> BLE_CONN_STATE_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Connection State module.
+
+#ifndef BLE_CONN_STATE_BLE_OBSERVER_PRIO
+#define BLE_CONN_STATE_BLE_OBSERVER_PRIO 0
+#endif
+
+// <o> BLE_CSCS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Cycling Speed and Cadence Service.
+
+#ifndef BLE_CSCS_BLE_OBSERVER_PRIO
+#define BLE_CSCS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_CTS_C_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Current Time Service Client.
+
+#ifndef BLE_CTS_C_BLE_OBSERVER_PRIO
+#define BLE_CTS_C_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_DB_DISC_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Database Discovery module.
+
+#ifndef BLE_DB_DISC_BLE_OBSERVER_PRIO
+#define BLE_DB_DISC_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> BLE_DFU_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the DFU Service.
+
+#ifndef BLE_DFU_BLE_OBSERVER_PRIO
+#define BLE_DFU_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_DIS_C_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Device Information Client.
+
+#ifndef BLE_DIS_C_BLE_OBSERVER_PRIO
+#define BLE_DIS_C_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_GLS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Glucose Service.
+
+#ifndef BLE_GLS_BLE_OBSERVER_PRIO
+#define BLE_GLS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_HIDS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Human Interface Device Service.
+
+#ifndef BLE_HIDS_BLE_OBSERVER_PRIO
+#define BLE_HIDS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_HRS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Heart Rate Service.
+
+#ifndef BLE_HRS_BLE_OBSERVER_PRIO
+#define BLE_HRS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_HRS_C_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Heart Rate Service Client.
+
+#ifndef BLE_HRS_C_BLE_OBSERVER_PRIO
+#define BLE_HRS_C_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_HTS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Health Thermometer Service.
+
+#ifndef BLE_HTS_BLE_OBSERVER_PRIO
+#define BLE_HTS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_IAS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Immediate Alert Service.
+
+#ifndef BLE_IAS_BLE_OBSERVER_PRIO
+#define BLE_IAS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_IAS_C_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Immediate Alert Service Client.
+
+#ifndef BLE_IAS_C_BLE_OBSERVER_PRIO
+#define BLE_IAS_C_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_LBS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the LED Button Service.
+
+#ifndef BLE_LBS_BLE_OBSERVER_PRIO
+#define BLE_LBS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_LBS_C_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the LED Button Service Client.
+
+#ifndef BLE_LBS_C_BLE_OBSERVER_PRIO
+#define BLE_LBS_C_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_LESC_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the BLE LESC module.
+
+#ifndef BLE_LESC_OBSERVER_PRIO
+#define BLE_LESC_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_LLS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Link Loss Service.
+
+#ifndef BLE_LLS_BLE_OBSERVER_PRIO
+#define BLE_LLS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_LNS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Location Navigation Service.
+
+#ifndef BLE_LNS_BLE_OBSERVER_PRIO
+#define BLE_LNS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_NUS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the UART Service.
+
+#ifndef BLE_NUS_BLE_OBSERVER_PRIO
+#define BLE_NUS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_NUS_C_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the UART Central Service.
+
+#ifndef BLE_NUS_C_BLE_OBSERVER_PRIO
+#define BLE_NUS_C_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_OTS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Object transfer service.
+
+#ifndef BLE_OTS_BLE_OBSERVER_PRIO
+#define BLE_OTS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_OTS_C_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Object transfer service client.
+
+#ifndef BLE_OTS_C_BLE_OBSERVER_PRIO
+#define BLE_OTS_C_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_RSCS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Running Speed and Cadence Service.
+
+#ifndef BLE_RSCS_BLE_OBSERVER_PRIO
+#define BLE_RSCS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_RSCS_C_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Running Speed and Cadence Client.
+
+#ifndef BLE_RSCS_C_BLE_OBSERVER_PRIO
+#define BLE_RSCS_C_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BLE_TPS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the TX Power Service.
+
+#ifndef BLE_TPS_BLE_OBSERVER_PRIO
+#define BLE_TPS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> BSP_BTN_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Button Control module.
+
+#ifndef BSP_BTN_BLE_OBSERVER_PRIO
+#define BSP_BTN_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the NFC pairing library.
+
+#ifndef NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO
+#define NFC_BLE_PAIR_LIB_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NRF_BLE_BMS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Bond Management Service.
+
+#ifndef NRF_BLE_BMS_BLE_OBSERVER_PRIO
+#define NRF_BLE_BMS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> NRF_BLE_CGMS_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Contiuon Glucose Monitoring Service.
+
+#ifndef NRF_BLE_CGMS_BLE_OBSERVER_PRIO
+#define NRF_BLE_CGMS_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> NRF_BLE_ES_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Eddystone module.
+
+#ifndef NRF_BLE_ES_BLE_OBSERVER_PRIO
+#define NRF_BLE_ES_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> NRF_BLE_GATTS_C_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the GATT Service Client.
+
+#ifndef NRF_BLE_GATTS_C_BLE_OBSERVER_PRIO
+#define NRF_BLE_GATTS_C_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> NRF_BLE_GATT_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the GATT module.
+
+#ifndef NRF_BLE_GATT_BLE_OBSERVER_PRIO
+#define NRF_BLE_GATT_BLE_OBSERVER_PRIO 1
+#endif
+
+// <o> NRF_BLE_QWR_BLE_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the Queued writes module.
+
+#ifndef NRF_BLE_QWR_BLE_OBSERVER_PRIO
+#define NRF_BLE_QWR_BLE_OBSERVER_PRIO 2
+#endif
+
+// <o> PM_BLE_OBSERVER_PRIO - Priority with which BLE events are dispatched to the Peer Manager module. 
+#ifndef PM_BLE_OBSERVER_PRIO
+#define PM_BLE_OBSERVER_PRIO 1
+#endif
+
+// </h> 
+//==========================================================
+
+// </h> 
+//==========================================================
+
+
+// </e>
+
+// <e> NRF_SDH_ENABLED - nrf_sdh - SoftDevice handler
+//==========================================================
+#ifndef NRF_SDH_ENABLED
+#define NRF_SDH_ENABLED 1
+#endif
+// <h> Dispatch model 
+
+// <i> This setting configures how Stack events are dispatched to the application.
+//==========================================================
+// <o> NRF_SDH_DISPATCH_MODEL
+ 
+
+// <i> NRF_SDH_DISPATCH_MODEL_INTERRUPT: SoftDevice events are passed to the application from the interrupt context.
+// <i> NRF_SDH_DISPATCH_MODEL_APPSH: SoftDevice events are scheduled using @ref app_scheduler.
+// <i> NRF_SDH_DISPATCH_MODEL_POLLING: SoftDevice events are to be fetched manually.
+// <0=> NRF_SDH_DISPATCH_MODEL_INTERRUPT 
+// <1=> NRF_SDH_DISPATCH_MODEL_APPSH 
+// <2=> NRF_SDH_DISPATCH_MODEL_POLLING 
+
+#ifndef NRF_SDH_DISPATCH_MODEL
+#define NRF_SDH_DISPATCH_MODEL 0
+#endif
+
+// </h> 
+//==========================================================
+
+// <h> Clock - SoftDevice clock configuration
+
+//==========================================================
+// <o> NRF_SDH_CLOCK_LF_SRC  - SoftDevice clock source.
+ 
+// <0=> NRF_CLOCK_LF_SRC_RC 
+// <1=> NRF_CLOCK_LF_SRC_XTAL 
+// <2=> NRF_CLOCK_LF_SRC_SYNTH 
+
+#ifndef NRF_SDH_CLOCK_LF_SRC
+#define NRF_SDH_CLOCK_LF_SRC 1
+#endif
+
+// <o> NRF_SDH_CLOCK_LF_RC_CTIV - SoftDevice calibration timer interval. 
+#ifndef NRF_SDH_CLOCK_LF_RC_CTIV
+#define NRF_SDH_CLOCK_LF_RC_CTIV 0
+#endif
+
+// <o> NRF_SDH_CLOCK_LF_RC_TEMP_CTIV - SoftDevice calibration timer interval under constant temperature. 
+// <i> How often (in number of calibration intervals) the RC oscillator shall be calibrated
+// <i>  if the temperature has not changed.
+
+#ifndef NRF_SDH_CLOCK_LF_RC_TEMP_CTIV
+#define NRF_SDH_CLOCK_LF_RC_TEMP_CTIV 0
+#endif
+
+// <o> NRF_SDH_CLOCK_LF_ACCURACY  - External clock accuracy used in the LL to compute timing.
+ 
+// <0=> NRF_CLOCK_LF_ACCURACY_250_PPM 
+// <1=> NRF_CLOCK_LF_ACCURACY_500_PPM 
+// <2=> NRF_CLOCK_LF_ACCURACY_150_PPM 
+// <3=> NRF_CLOCK_LF_ACCURACY_100_PPM 
+// <4=> NRF_CLOCK_LF_ACCURACY_75_PPM 
+// <5=> NRF_CLOCK_LF_ACCURACY_50_PPM 
+// <6=> NRF_CLOCK_LF_ACCURACY_30_PPM 
+// <7=> NRF_CLOCK_LF_ACCURACY_20_PPM 
+// <8=> NRF_CLOCK_LF_ACCURACY_10_PPM 
+// <9=> NRF_CLOCK_LF_ACCURACY_5_PPM 
+// <10=> NRF_CLOCK_LF_ACCURACY_2_PPM 
+// <11=> NRF_CLOCK_LF_ACCURACY_1_PPM 
+
+#ifndef NRF_SDH_CLOCK_LF_ACCURACY
+#define NRF_SDH_CLOCK_LF_ACCURACY 7
+#endif
+
+// </h> 
+//==========================================================
+
+// <h> SDH Observers - Observers and priority levels
+
+//==========================================================
+// <o> NRF_SDH_REQ_OBSERVER_PRIO_LEVELS - Total number of priority levels for request observers. 
+// <i> This setting configures the number of priority levels available for the SoftDevice request event handlers.
+// <i> The priority level of a handler determines the order in which it receives events, with respect to other handlers.
+
+#ifndef NRF_SDH_REQ_OBSERVER_PRIO_LEVELS
+#define NRF_SDH_REQ_OBSERVER_PRIO_LEVELS 2
+#endif
+
+// <o> NRF_SDH_STATE_OBSERVER_PRIO_LEVELS - Total number of priority levels for state observers. 
+// <i> This setting configures the number of priority levels available for the SoftDevice state event handlers.
+// <i> The priority level of a handler determines the order in which it receives events, with respect to other handlers.
+
+#ifndef NRF_SDH_STATE_OBSERVER_PRIO_LEVELS
+#define NRF_SDH_STATE_OBSERVER_PRIO_LEVELS 2
+#endif
+
+// <o> NRF_SDH_STACK_OBSERVER_PRIO_LEVELS - Total number of priority levels for stack event observers. 
+// <i> This setting configures the number of priority levels available for the SoftDevice stack event handlers (ANT, BLE, SoC).
+// <i> The priority level of a handler determines the order in which it receives events, with respect to other handlers.
+
+#ifndef NRF_SDH_STACK_OBSERVER_PRIO_LEVELS
+#define NRF_SDH_STACK_OBSERVER_PRIO_LEVELS 2
+#endif
+
+
+// <h> State Observers priorities - Invididual priorities
+
+//==========================================================
+// <o> CLOCK_CONFIG_STATE_OBSERVER_PRIO  
+// <i> Priority with which state events are dispatched to the Clock driver.
+
+#ifndef CLOCK_CONFIG_STATE_OBSERVER_PRIO
+#define CLOCK_CONFIG_STATE_OBSERVER_PRIO 0
+#endif
+
+// <o> POWER_CONFIG_STATE_OBSERVER_PRIO  
+// <i> Priority with which state events are dispatched to the Power driver.
+
+#ifndef POWER_CONFIG_STATE_OBSERVER_PRIO
+#define POWER_CONFIG_STATE_OBSERVER_PRIO 0
+#endif
+
+// <o> RNG_CONFIG_STATE_OBSERVER_PRIO  
+// <i> Priority with which state events are dispatched to this module.
+
+#ifndef RNG_CONFIG_STATE_OBSERVER_PRIO
+#define RNG_CONFIG_STATE_OBSERVER_PRIO 0
+#endif
+
+// </h> 
+//==========================================================
+
+// <h> Stack Event Observers priorities - Invididual priorities
+
+//==========================================================
+// <o> NRF_SDH_ANT_STACK_OBSERVER_PRIO  
+// <i> This setting configures the priority with which ANT events are processed with respect to other events coming from the stack.
+// <i> Modify this setting if you need to have ANT events dispatched before or after other stack events, such as BLE or SoC.
+// <i> Zero is the highest priority.
+
+#ifndef NRF_SDH_ANT_STACK_OBSERVER_PRIO
+#define NRF_SDH_ANT_STACK_OBSERVER_PRIO 0
+#endif
+
+// <o> NRF_SDH_BLE_STACK_OBSERVER_PRIO  
+// <i> This setting configures the priority with which BLE events are processed with respect to other events coming from the stack.
+// <i> Modify this setting if you need to have BLE events dispatched before or after other stack events, such as ANT or SoC.
+// <i> Zero is the highest priority.
+
+#ifndef NRF_SDH_BLE_STACK_OBSERVER_PRIO
+#define NRF_SDH_BLE_STACK_OBSERVER_PRIO 0
+#endif
+
+// <o> NRF_SDH_SOC_STACK_OBSERVER_PRIO  
+// <i> This setting configures the priority with which SoC events are processed with respect to other events coming from the stack.
+// <i> Modify this setting if you need to have SoC events dispatched before or after other stack events, such as ANT or BLE.
+// <i> Zero is the highest priority.
+
+#ifndef NRF_SDH_SOC_STACK_OBSERVER_PRIO
+#define NRF_SDH_SOC_STACK_OBSERVER_PRIO 0
+#endif
+
+// </h> 
+//==========================================================
+
+// </h> 
+//==========================================================
+
+
+// </e>
+
+// <e> NRF_SDH_SOC_ENABLED - nrf_sdh_soc - SoftDevice SoC event handler
+//==========================================================
+#ifndef NRF_SDH_SOC_ENABLED
+#define NRF_SDH_SOC_ENABLED 1
+#endif
+// <h> SoC Observers - Observers and priority levels
+
+//==========================================================
+// <o> NRF_SDH_SOC_OBSERVER_PRIO_LEVELS - Total number of priority levels for SoC observers. 
+// <i> This setting configures the number of priority levels available for the SoC event handlers.
+// <i> The priority level of a handler determines the order in which it receives events, with respect to other handlers.
+
+#ifndef NRF_SDH_SOC_OBSERVER_PRIO_LEVELS
+#define NRF_SDH_SOC_OBSERVER_PRIO_LEVELS 2
+#endif
+
+// <h> SoC Observers priorities - Invididual priorities
+
+//==========================================================
+// <o> BLE_ADV_SOC_OBSERVER_PRIO  
+// <i> Priority with which SoC events are dispatched to the Advertising module.
+
+#ifndef BLE_ADV_SOC_OBSERVER_PRIO
+#define BLE_ADV_SOC_OBSERVER_PRIO 1
+#endif
+
+// <o> BLE_DFU_SOC_OBSERVER_PRIO  
+// <i> Priority with which BLE events are dispatched to the DFU Service.
+
+#ifndef BLE_DFU_SOC_OBSERVER_PRIO
+#define BLE_DFU_SOC_OBSERVER_PRIO 1
+#endif
+
+// <o> CLOCK_CONFIG_SOC_OBSERVER_PRIO  
+// <i> Priority with which SoC events are dispatched to the Clock driver.
+
+#ifndef CLOCK_CONFIG_SOC_OBSERVER_PRIO
+#define CLOCK_CONFIG_SOC_OBSERVER_PRIO 0
+#endif
+
+// <o> POWER_CONFIG_SOC_OBSERVER_PRIO  
+// <i> Priority with which SoC events are dispatched to the Power driver.
+
+#ifndef POWER_CONFIG_SOC_OBSERVER_PRIO
+#define POWER_CONFIG_SOC_OBSERVER_PRIO 0
+#endif
+
+// </h> 
+//==========================================================
+
+// </h> 
+//==========================================================
+
+
+// </e>
+
+// </h> 
+//==========================================================
+
+// <<< end of configuration section >>>
+#endif //SDK_CONFIG_H
+
